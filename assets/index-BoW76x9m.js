function _mergeNamespaces(s, e) {
  for (var o = 0; o < e.length; o++) {
    const a = e[o];
    if (typeof a != "string" && !Array.isArray(a)) {
      for (const c in a)
        if (c !== "default" && !(c in s)) {
          const d = Object.getOwnPropertyDescriptor(a, c);
          d &&
            Object.defineProperty(
              s,
              c,
              d.get ? d : { enumerable: !0, get: () => a[c] }
            );
        }
    }
  }
  return Object.freeze(
    Object.defineProperty(s, Symbol.toStringTag, { value: "Module" })
  );
}
(function () {
  const e = document.createElement("link").relList;
  if (e && e.supports && e.supports("modulepreload")) return;
  for (const c of document.querySelectorAll('link[rel="modulepreload"]')) a(c);
  new MutationObserver((c) => {
    for (const d of c)
      if (d.type === "childList")
        for (const g of d.addedNodes)
          g.tagName === "LINK" && g.rel === "modulepreload" && a(g);
  }).observe(document, { childList: !0, subtree: !0 });
  function o(c) {
    const d = {};
    return (
      c.integrity && (d.integrity = c.integrity),
      c.referrerPolicy && (d.referrerPolicy = c.referrerPolicy),
      c.crossOrigin === "use-credentials"
        ? (d.credentials = "include")
        : c.crossOrigin === "anonymous"
        ? (d.credentials = "omit")
        : (d.credentials = "same-origin"),
      d
    );
  }
  function a(c) {
    if (c.ep) return;
    c.ep = !0;
    const d = o(c);
    fetch(c.href, d);
  }
})();
var commonjsGlobal =
  typeof globalThis < "u"
    ? globalThis
    : typeof window < "u"
    ? window
    : typeof global < "u"
    ? global
    : typeof self < "u"
    ? self
    : {};
function getDefaultExportFromCjs(s) {
  return s && s.__esModule && Object.prototype.hasOwnProperty.call(s, "default")
    ? s.default
    : s;
}
var jsxRuntime = { exports: {} },
  reactJsxRuntime_production_min = {},
  react$1 = { exports: {} },
  react_production_min = {};
/**
 * @license React
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var l$1 = Symbol.for("react.element"),
  n$1 = Symbol.for("react.portal"),
  p$3 = Symbol.for("react.fragment"),
  q$1 = Symbol.for("react.strict_mode"),
  r = Symbol.for("react.profiler"),
  t = Symbol.for("react.provider"),
  u = Symbol.for("react.context"),
  v$8 = Symbol.for("react.forward_ref"),
  w$8 = Symbol.for("react.suspense"),
  x = Symbol.for("react.memo"),
  y = Symbol.for("react.lazy"),
  z$1 = Symbol.iterator;
function A$1(s) {
  return s === null || typeof s != "object"
    ? null
    : ((s = (z$1 && s[z$1]) || s["@@iterator"]),
      typeof s == "function" ? s : null);
}
var B$1 = {
    isMounted: function () {
      return !1;
    },
    enqueueForceUpdate: function () {},
    enqueueReplaceState: function () {},
    enqueueSetState: function () {},
  },
  C$1 = Object.assign,
  D$1 = {};
function E$1(s, e, o) {
  (this.props = s),
    (this.context = e),
    (this.refs = D$1),
    (this.updater = o || B$1);
}
E$1.prototype.isReactComponent = {};
E$1.prototype.setState = function (s, e) {
  if (typeof s != "object" && typeof s != "function" && s != null)
    throw Error(
      "setState(...): takes an object of state variables to update or a function which returns an object of state variables."
    );
  this.updater.enqueueSetState(this, s, e, "setState");
};
E$1.prototype.forceUpdate = function (s) {
  this.updater.enqueueForceUpdate(this, s, "forceUpdate");
};
function F() {}
F.prototype = E$1.prototype;
function G$1(s, e, o) {
  (this.props = s),
    (this.context = e),
    (this.refs = D$1),
    (this.updater = o || B$1);
}
var H$1 = (G$1.prototype = new F());
H$1.constructor = G$1;
C$1(H$1, E$1.prototype);
H$1.isPureReactComponent = !0;
var I$1 = Array.isArray,
  J = Object.prototype.hasOwnProperty,
  K$1 = { current: null },
  L$1 = { key: !0, ref: !0, __self: !0, __source: !0 };
function M$1(s, e, o) {
  var a,
    c = {},
    d = null,
    g = null;
  if (e != null)
    for (a in (e.ref !== void 0 && (g = e.ref),
    e.key !== void 0 && (d = "" + e.key),
    e))
      J.call(e, a) && !L$1.hasOwnProperty(a) && (c[a] = e[a]);
  var _ = arguments.length - 2;
  if (_ === 1) c.children = o;
  else if (1 < _) {
    for (var b = Array(_), j = 0; j < _; j++) b[j] = arguments[j + 2];
    c.children = b;
  }
  if (s && s.defaultProps)
    for (a in ((_ = s.defaultProps), _)) c[a] === void 0 && (c[a] = _[a]);
  return {
    $$typeof: l$1,
    type: s,
    key: d,
    ref: g,
    props: c,
    _owner: K$1.current,
  };
}
function N$1(s, e) {
  return {
    $$typeof: l$1,
    type: s.type,
    key: e,
    ref: s.ref,
    props: s.props,
    _owner: s._owner,
  };
}
function O$1(s) {
  return typeof s == "object" && s !== null && s.$$typeof === l$1;
}
function escape$1(s) {
  var e = { "=": "=0", ":": "=2" };
  return (
    "$" +
    s.replace(/[=:]/g, function (o) {
      return e[o];
    })
  );
}
var P$1 = /\/+/g;
function Q$1(s, e) {
  return typeof s == "object" && s !== null && s.key != null
    ? escape$1("" + s.key)
    : e.toString(36);
}
function R$1(s, e, o, a, c) {
  var d = typeof s;
  (d === "undefined" || d === "boolean") && (s = null);
  var g = !1;
  if (s === null) g = !0;
  else
    switch (d) {
      case "string":
      case "number":
        g = !0;
        break;
      case "object":
        switch (s.$$typeof) {
          case l$1:
          case n$1:
            g = !0;
        }
    }
  if (g)
    return (
      (g = s),
      (c = c(g)),
      (s = a === "" ? "." + Q$1(g, 0) : a),
      I$1(c)
        ? ((o = ""),
          s != null && (o = s.replace(P$1, "$&/") + "/"),
          R$1(c, e, o, "", function (j) {
            return j;
          }))
        : c != null &&
          (O$1(c) &&
            (c = N$1(
              c,
              o +
                (!c.key || (g && g.key === c.key)
                  ? ""
                  : ("" + c.key).replace(P$1, "$&/") + "/") +
                s
            )),
          e.push(c)),
      1
    );
  if (((g = 0), (a = a === "" ? "." : a + ":"), I$1(s)))
    for (var _ = 0; _ < s.length; _++) {
      d = s[_];
      var b = a + Q$1(d, _);
      g += R$1(d, e, o, b, c);
    }
  else if (((b = A$1(s)), typeof b == "function"))
    for (s = b.call(s), _ = 0; !(d = s.next()).done; )
      (d = d.value), (b = a + Q$1(d, _++)), (g += R$1(d, e, o, b, c));
  else if (d === "object")
    throw (
      ((e = String(s)),
      Error(
        "Objects are not valid as a React child (found: " +
          (e === "[object Object]"
            ? "object with keys {" + Object.keys(s).join(", ") + "}"
            : e) +
          "). If you meant to render a collection of children, use an array instead."
      ))
    );
  return g;
}
function S$1(s, e, o) {
  if (s == null) return s;
  var a = [],
    c = 0;
  return (
    R$1(s, a, "", "", function (d) {
      return e.call(o, d, c++);
    }),
    a
  );
}
function T$1(s) {
  if (s._status === -1) {
    var e = s._result;
    (e = e()),
      e.then(
        function (o) {
          (s._status === 0 || s._status === -1) &&
            ((s._status = 1), (s._result = o));
        },
        function (o) {
          (s._status === 0 || s._status === -1) &&
            ((s._status = 2), (s._result = o));
        }
      ),
      s._status === -1 && ((s._status = 0), (s._result = e));
  }
  if (s._status === 1) return s._result.default;
  throw s._result;
}
var U$1 = { current: null },
  V$1 = { transition: null },
  W$1 = {
    ReactCurrentDispatcher: U$1,
    ReactCurrentBatchConfig: V$1,
    ReactCurrentOwner: K$1,
  };
function X$1() {
  throw Error("act(...) is not supported in production builds of React.");
}
react_production_min.Children = {
  map: S$1,
  forEach: function (s, e, o) {
    S$1(
      s,
      function () {
        e.apply(this, arguments);
      },
      o
    );
  },
  count: function (s) {
    var e = 0;
    return (
      S$1(s, function () {
        e++;
      }),
      e
    );
  },
  toArray: function (s) {
    return (
      S$1(s, function (e) {
        return e;
      }) || []
    );
  },
  only: function (s) {
    if (!O$1(s))
      throw Error(
        "React.Children.only expected to receive a single React element child."
      );
    return s;
  },
};
react_production_min.Component = E$1;
react_production_min.Fragment = p$3;
react_production_min.Profiler = r;
react_production_min.PureComponent = G$1;
react_production_min.StrictMode = q$1;
react_production_min.Suspense = w$8;
react_production_min.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = W$1;
react_production_min.act = X$1;
react_production_min.cloneElement = function (s, e, o) {
  if (s == null)
    throw Error(
      "React.cloneElement(...): The argument must be a React element, but you passed " +
        s +
        "."
    );
  var a = C$1({}, s.props),
    c = s.key,
    d = s.ref,
    g = s._owner;
  if (e != null) {
    if (
      (e.ref !== void 0 && ((d = e.ref), (g = K$1.current)),
      e.key !== void 0 && (c = "" + e.key),
      s.type && s.type.defaultProps)
    )
      var _ = s.type.defaultProps;
    for (b in e)
      J.call(e, b) &&
        !L$1.hasOwnProperty(b) &&
        (a[b] = e[b] === void 0 && _ !== void 0 ? _[b] : e[b]);
  }
  var b = arguments.length - 2;
  if (b === 1) a.children = o;
  else if (1 < b) {
    _ = Array(b);
    for (var j = 0; j < b; j++) _[j] = arguments[j + 2];
    a.children = _;
  }
  return { $$typeof: l$1, type: s.type, key: c, ref: d, props: a, _owner: g };
};
react_production_min.createContext = function (s) {
  return (
    (s = {
      $$typeof: u,
      _currentValue: s,
      _currentValue2: s,
      _threadCount: 0,
      Provider: null,
      Consumer: null,
      _defaultValue: null,
      _globalName: null,
    }),
    (s.Provider = { $$typeof: t, _context: s }),
    (s.Consumer = s)
  );
};
react_production_min.createElement = M$1;
react_production_min.createFactory = function (s) {
  var e = M$1.bind(null, s);
  return (e.type = s), e;
};
react_production_min.createRef = function () {
  return { current: null };
};
react_production_min.forwardRef = function (s) {
  return { $$typeof: v$8, render: s };
};
react_production_min.isValidElement = O$1;
react_production_min.lazy = function (s) {
  return { $$typeof: y, _payload: { _status: -1, _result: s }, _init: T$1 };
};
react_production_min.memo = function (s, e) {
  return { $$typeof: x, type: s, compare: e === void 0 ? null : e };
};
react_production_min.startTransition = function (s) {
  var e = V$1.transition;
  V$1.transition = {};
  try {
    s();
  } finally {
    V$1.transition = e;
  }
};
react_production_min.unstable_act = X$1;
react_production_min.useCallback = function (s, e) {
  return U$1.current.useCallback(s, e);
};
react_production_min.useContext = function (s) {
  return U$1.current.useContext(s);
};
react_production_min.useDebugValue = function () {};
react_production_min.useDeferredValue = function (s) {
  return U$1.current.useDeferredValue(s);
};
react_production_min.useEffect = function (s, e) {
  return U$1.current.useEffect(s, e);
};
react_production_min.useId = function () {
  return U$1.current.useId();
};
react_production_min.useImperativeHandle = function (s, e, o) {
  return U$1.current.useImperativeHandle(s, e, o);
};
react_production_min.useInsertionEffect = function (s, e) {
  return U$1.current.useInsertionEffect(s, e);
};
react_production_min.useLayoutEffect = function (s, e) {
  return U$1.current.useLayoutEffect(s, e);
};
react_production_min.useMemo = function (s, e) {
  return U$1.current.useMemo(s, e);
};
react_production_min.useReducer = function (s, e, o) {
  return U$1.current.useReducer(s, e, o);
};
react_production_min.useRef = function (s) {
  return U$1.current.useRef(s);
};
react_production_min.useState = function (s) {
  return U$1.current.useState(s);
};
react_production_min.useSyncExternalStore = function (s, e, o) {
  return U$1.current.useSyncExternalStore(s, e, o);
};
react_production_min.useTransition = function () {
  return U$1.current.useTransition();
};
react_production_min.version = "18.3.1";
react$1.exports = react_production_min;
var reactExports$1 = react$1.exports;
const React = getDefaultExportFromCjs(reactExports$1),
  React$1 = _mergeNamespaces({ __proto__: null, default: React }, [
    reactExports$1,
  ]);
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var f = reactExports$1,
  k = Symbol.for("react.element"),
  l = Symbol.for("react.fragment"),
  m$2 = Object.prototype.hasOwnProperty,
  n = f.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner,
  p$2 = { key: !0, ref: !0, __self: !0, __source: !0 };
function q(s, e, o) {
  var a,
    c = {},
    d = null,
    g = null;
  o !== void 0 && (d = "" + o),
    e.key !== void 0 && (d = "" + e.key),
    e.ref !== void 0 && (g = e.ref);
  for (a in e) m$2.call(e, a) && !p$2.hasOwnProperty(a) && (c[a] = e[a]);
  if (s && s.defaultProps)
    for (a in ((e = s.defaultProps), e)) c[a] === void 0 && (c[a] = e[a]);
  return { $$typeof: k, type: s, key: d, ref: g, props: c, _owner: n.current };
}
reactJsxRuntime_production_min.Fragment = l;
reactJsxRuntime_production_min.jsx = q;
reactJsxRuntime_production_min.jsxs = q;
jsxRuntime.exports = reactJsxRuntime_production_min;
var jsxRuntimeExports = jsxRuntime.exports,
  client = {},
  reactDom = { exports: {} },
  reactDom_production_min = {},
  scheduler$2 = { exports: {} },
  scheduler_production_min$2 = {};
/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ (function (s) {
  function e(mt, vt) {
    var Ct = mt.length;
    mt.push(vt);
    e: for (; 0 < Ct; ) {
      var Tt = (Ct - 1) >>> 1,
        Dt = mt[Tt];
      if (0 < c(Dt, vt)) (mt[Tt] = vt), (mt[Ct] = Dt), (Ct = Tt);
      else break e;
    }
  }
  function o(mt) {
    return mt.length === 0 ? null : mt[0];
  }
  function a(mt) {
    if (mt.length === 0) return null;
    var vt = mt[0],
      Ct = mt.pop();
    if (Ct !== vt) {
      mt[0] = Ct;
      e: for (var Tt = 0, Dt = mt.length, Wt = Dt >>> 1; Tt < Wt; ) {
        var Pt = 2 * (Tt + 1) - 1,
          Jt = mt[Pt],
          Gt = Pt + 1,
          en = mt[Gt];
        if (0 > c(Jt, Ct))
          Gt < Dt && 0 > c(en, Jt)
            ? ((mt[Tt] = en), (mt[Gt] = Ct), (Tt = Gt))
            : ((mt[Tt] = Jt), (mt[Pt] = Ct), (Tt = Pt));
        else if (Gt < Dt && 0 > c(en, Ct))
          (mt[Tt] = en), (mt[Gt] = Ct), (Tt = Gt);
        else break e;
      }
    }
    return vt;
  }
  function c(mt, vt) {
    var Ct = mt.sortIndex - vt.sortIndex;
    return Ct !== 0 ? Ct : mt.id - vt.id;
  }
  if (typeof performance == "object" && typeof performance.now == "function") {
    var d = performance;
    s.unstable_now = function () {
      return d.now();
    };
  } else {
    var g = Date,
      _ = g.now();
    s.unstable_now = function () {
      return g.now() - _;
    };
  }
  var b = [],
    j = [],
    $ = 1,
    _e = null,
    et = 3,
    rt = !1,
    st = !1,
    at = !1,
    ct = typeof setTimeout == "function" ? setTimeout : null,
    it = typeof clearTimeout == "function" ? clearTimeout : null,
    lt = typeof setImmediate < "u" ? setImmediate : null;
  typeof navigator < "u" &&
    navigator.scheduling !== void 0 &&
    navigator.scheduling.isInputPending !== void 0 &&
    navigator.scheduling.isInputPending.bind(navigator.scheduling);
  function ot(mt) {
    for (var vt = o(j); vt !== null; ) {
      if (vt.callback === null) a(j);
      else if (vt.startTime <= mt)
        a(j), (vt.sortIndex = vt.expirationTime), e(b, vt);
      else break;
      vt = o(j);
    }
  }
  function ut(mt) {
    if (((at = !1), ot(mt), !st))
      if (o(b) !== null) (st = !0), Et(pt);
      else {
        var vt = o(j);
        vt !== null && bt(ut, vt.startTime - mt);
      }
  }
  function pt(mt, vt) {
    (st = !1), at && ((at = !1), it(xt), (xt = -1)), (rt = !0);
    var Ct = et;
    try {
      for (
        ot(vt), _e = o(b);
        _e !== null && (!(_e.expirationTime > vt) || (mt && !Mt()));

      ) {
        var Tt = _e.callback;
        if (typeof Tt == "function") {
          (_e.callback = null), (et = _e.priorityLevel);
          var Dt = Tt(_e.expirationTime <= vt);
          (vt = s.unstable_now()),
            typeof Dt == "function" ? (_e.callback = Dt) : _e === o(b) && a(b),
            ot(vt);
        } else a(b);
        _e = o(b);
      }
      if (_e !== null) var Wt = !0;
      else {
        var Pt = o(j);
        Pt !== null && bt(ut, Pt.startTime - vt), (Wt = !1);
      }
      return Wt;
    } finally {
      (_e = null), (et = Ct), (rt = !1);
    }
  }
  var ft = !1,
    gt = null,
    xt = -1,
    _t = 5,
    St = -1;
  function Mt() {
    return !(s.unstable_now() - St < _t);
  }
  function Rt() {
    if (gt !== null) {
      var mt = s.unstable_now();
      St = mt;
      var vt = !0;
      try {
        vt = gt(!0, mt);
      } finally {
        vt ? Ft() : ((ft = !1), (gt = null));
      }
    } else ft = !1;
  }
  var Ft;
  if (typeof lt == "function")
    Ft = function () {
      lt(Rt);
    };
  else if (typeof MessageChannel < "u") {
    var Ot = new MessageChannel(),
      Lt = Ot.port2;
    (Ot.port1.onmessage = Rt),
      (Ft = function () {
        Lt.postMessage(null);
      });
  } else
    Ft = function () {
      ct(Rt, 0);
    };
  function Et(mt) {
    (gt = mt), ft || ((ft = !0), Ft());
  }
  function bt(mt, vt) {
    xt = ct(function () {
      mt(s.unstable_now());
    }, vt);
  }
  (s.unstable_IdlePriority = 5),
    (s.unstable_ImmediatePriority = 1),
    (s.unstable_LowPriority = 4),
    (s.unstable_NormalPriority = 3),
    (s.unstable_Profiling = null),
    (s.unstable_UserBlockingPriority = 2),
    (s.unstable_cancelCallback = function (mt) {
      mt.callback = null;
    }),
    (s.unstable_continueExecution = function () {
      st || rt || ((st = !0), Et(pt));
    }),
    (s.unstable_forceFrameRate = function (mt) {
      0 > mt || 125 < mt
        ? console.error(
            "forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"
          )
        : (_t = 0 < mt ? Math.floor(1e3 / mt) : 5);
    }),
    (s.unstable_getCurrentPriorityLevel = function () {
      return et;
    }),
    (s.unstable_getFirstCallbackNode = function () {
      return o(b);
    }),
    (s.unstable_next = function (mt) {
      switch (et) {
        case 1:
        case 2:
        case 3:
          var vt = 3;
          break;
        default:
          vt = et;
      }
      var Ct = et;
      et = vt;
      try {
        return mt();
      } finally {
        et = Ct;
      }
    }),
    (s.unstable_pauseExecution = function () {}),
    (s.unstable_requestPaint = function () {}),
    (s.unstable_runWithPriority = function (mt, vt) {
      switch (mt) {
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
          break;
        default:
          mt = 3;
      }
      var Ct = et;
      et = mt;
      try {
        return vt();
      } finally {
        et = Ct;
      }
    }),
    (s.unstable_scheduleCallback = function (mt, vt, Ct) {
      var Tt = s.unstable_now();
      switch (
        (typeof Ct == "object" && Ct !== null
          ? ((Ct = Ct.delay),
            (Ct = typeof Ct == "number" && 0 < Ct ? Tt + Ct : Tt))
          : (Ct = Tt),
        mt)
      ) {
        case 1:
          var Dt = -1;
          break;
        case 2:
          Dt = 250;
          break;
        case 5:
          Dt = 1073741823;
          break;
        case 4:
          Dt = 1e4;
          break;
        default:
          Dt = 5e3;
      }
      return (
        (Dt = Ct + Dt),
        (mt = {
          id: $++,
          callback: vt,
          priorityLevel: mt,
          startTime: Ct,
          expirationTime: Dt,
          sortIndex: -1,
        }),
        Ct > Tt
          ? ((mt.sortIndex = Ct),
            e(j, mt),
            o(b) === null &&
              mt === o(j) &&
              (at ? (it(xt), (xt = -1)) : (at = !0), bt(ut, Ct - Tt)))
          : ((mt.sortIndex = Dt), e(b, mt), st || rt || ((st = !0), Et(pt))),
        mt
      );
    }),
    (s.unstable_shouldYield = Mt),
    (s.unstable_wrapCallback = function (mt) {
      var vt = et;
      return function () {
        var Ct = et;
        et = vt;
        try {
          return mt.apply(this, arguments);
        } finally {
          et = Ct;
        }
      };
    });
})(scheduler_production_min$2);
scheduler$2.exports = scheduler_production_min$2;
var schedulerExports$1 = scheduler$2.exports;
/**
 * @license React
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var aa = reactExports$1,
  ca = schedulerExports$1;
function p$1(s) {
  for (
    var e = "https://reactjs.org/docs/error-decoder.html?invariant=" + s, o = 1;
    o < arguments.length;
    o++
  )
    e += "&args[]=" + encodeURIComponent(arguments[o]);
  return (
    "Minified React error #" +
    s +
    "; visit " +
    e +
    " for the full message or use the non-minified dev environment for full errors and additional helpful warnings."
  );
}
var da = new Set(),
  ea = {};
function fa(s, e) {
  ha(s, e), ha(s + "Capture", e);
}
function ha(s, e) {
  for (ea[s] = e, s = 0; s < e.length; s++) da.add(e[s]);
}
var ia = !(
    typeof window > "u" ||
    typeof window.document > "u" ||
    typeof window.document.createElement > "u"
  ),
  ja = Object.prototype.hasOwnProperty,
  ka =
    /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,
  la = {},
  ma = {};
function oa(s) {
  return ja.call(ma, s)
    ? !0
    : ja.call(la, s)
    ? !1
    : ka.test(s)
    ? (ma[s] = !0)
    : ((la[s] = !0), !1);
}
function pa(s, e, o, a) {
  if (o !== null && o.type === 0) return !1;
  switch (typeof e) {
    case "function":
    case "symbol":
      return !0;
    case "boolean":
      return a
        ? !1
        : o !== null
        ? !o.acceptsBooleans
        : ((s = s.toLowerCase().slice(0, 5)), s !== "data-" && s !== "aria-");
    default:
      return !1;
  }
}
function qa(s, e, o, a) {
  if (e === null || typeof e > "u" || pa(s, e, o, a)) return !0;
  if (a) return !1;
  if (o !== null)
    switch (o.type) {
      case 3:
        return !e;
      case 4:
        return e === !1;
      case 5:
        return isNaN(e);
      case 6:
        return isNaN(e) || 1 > e;
    }
  return !1;
}
function v$7(s, e, o, a, c, d, g) {
  (this.acceptsBooleans = e === 2 || e === 3 || e === 4),
    (this.attributeName = a),
    (this.attributeNamespace = c),
    (this.mustUseProperty = o),
    (this.propertyName = s),
    (this.type = e),
    (this.sanitizeURL = d),
    (this.removeEmptyString = g);
}
var z = {};
"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style"
  .split(" ")
  .forEach(function (s) {
    z[s] = new v$7(s, 0, !1, s, null, !1, !1);
  });
[
  ["acceptCharset", "accept-charset"],
  ["className", "class"],
  ["htmlFor", "for"],
  ["httpEquiv", "http-equiv"],
].forEach(function (s) {
  var e = s[0];
  z[e] = new v$7(e, 1, !1, s[1], null, !1, !1);
});
["contentEditable", "draggable", "spellCheck", "value"].forEach(function (s) {
  z[s] = new v$7(s, 2, !1, s.toLowerCase(), null, !1, !1);
});
[
  "autoReverse",
  "externalResourcesRequired",
  "focusable",
  "preserveAlpha",
].forEach(function (s) {
  z[s] = new v$7(s, 2, !1, s, null, !1, !1);
});
"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope"
  .split(" ")
  .forEach(function (s) {
    z[s] = new v$7(s, 3, !1, s.toLowerCase(), null, !1, !1);
  });
["checked", "multiple", "muted", "selected"].forEach(function (s) {
  z[s] = new v$7(s, 3, !0, s, null, !1, !1);
});
["capture", "download"].forEach(function (s) {
  z[s] = new v$7(s, 4, !1, s, null, !1, !1);
});
["cols", "rows", "size", "span"].forEach(function (s) {
  z[s] = new v$7(s, 6, !1, s, null, !1, !1);
});
["rowSpan", "start"].forEach(function (s) {
  z[s] = new v$7(s, 5, !1, s.toLowerCase(), null, !1, !1);
});
var ra = /[\-:]([a-z])/g;
function sa(s) {
  return s[1].toUpperCase();
}
"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height"
  .split(" ")
  .forEach(function (s) {
    var e = s.replace(ra, sa);
    z[e] = new v$7(e, 1, !1, s, null, !1, !1);
  });
"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type"
  .split(" ")
  .forEach(function (s) {
    var e = s.replace(ra, sa);
    z[e] = new v$7(e, 1, !1, s, "http://www.w3.org/1999/xlink", !1, !1);
  });
["xml:base", "xml:lang", "xml:space"].forEach(function (s) {
  var e = s.replace(ra, sa);
  z[e] = new v$7(e, 1, !1, s, "http://www.w3.org/XML/1998/namespace", !1, !1);
});
["tabIndex", "crossOrigin"].forEach(function (s) {
  z[s] = new v$7(s, 1, !1, s.toLowerCase(), null, !1, !1);
});
z.xlinkHref = new v$7(
  "xlinkHref",
  1,
  !1,
  "xlink:href",
  "http://www.w3.org/1999/xlink",
  !0,
  !1
);
["src", "href", "action", "formAction"].forEach(function (s) {
  z[s] = new v$7(s, 1, !1, s.toLowerCase(), null, !0, !0);
});
function ta(s, e, o, a) {
  var c = z.hasOwnProperty(e) ? z[e] : null;
  (c !== null
    ? c.type !== 0
    : a ||
      !(2 < e.length) ||
      (e[0] !== "o" && e[0] !== "O") ||
      (e[1] !== "n" && e[1] !== "N")) &&
    (qa(e, o, c, a) && (o = null),
    a || c === null
      ? oa(e) && (o === null ? s.removeAttribute(e) : s.setAttribute(e, "" + o))
      : c.mustUseProperty
      ? (s[c.propertyName] = o === null ? (c.type === 3 ? !1 : "") : o)
      : ((e = c.attributeName),
        (a = c.attributeNamespace),
        o === null
          ? s.removeAttribute(e)
          : ((c = c.type),
            (o = c === 3 || (c === 4 && o === !0) ? "" : "" + o),
            a ? s.setAttributeNS(a, e, o) : s.setAttribute(e, o))));
}
var ua = aa.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,
  va = Symbol.for("react.element"),
  wa$1 = Symbol.for("react.portal"),
  ya = Symbol.for("react.fragment"),
  za = Symbol.for("react.strict_mode"),
  Aa = Symbol.for("react.profiler"),
  Ba = Symbol.for("react.provider"),
  Ca = Symbol.for("react.context"),
  Da = Symbol.for("react.forward_ref"),
  Ea = Symbol.for("react.suspense"),
  Fa = Symbol.for("react.suspense_list"),
  Ga = Symbol.for("react.memo"),
  Ha = Symbol.for("react.lazy"),
  Ia = Symbol.for("react.offscreen"),
  Ja = Symbol.iterator;
function Ka(s) {
  return s === null || typeof s != "object"
    ? null
    : ((s = (Ja && s[Ja]) || s["@@iterator"]),
      typeof s == "function" ? s : null);
}
var A = Object.assign,
  La;
function Ma(s) {
  if (La === void 0)
    try {
      throw Error();
    } catch (o) {
      var e = o.stack.trim().match(/\n( *(at )?)/);
      La = (e && e[1]) || "";
    }
  return (
    `
` +
    La +
    s
  );
}
var Na = !1;
function Oa(s, e) {
  if (!s || Na) return "";
  Na = !0;
  var o = Error.prepareStackTrace;
  Error.prepareStackTrace = void 0;
  try {
    if (e)
      if (
        ((e = function () {
          throw Error();
        }),
        Object.defineProperty(e.prototype, "props", {
          set: function () {
            throw Error();
          },
        }),
        typeof Reflect == "object" && Reflect.construct)
      ) {
        try {
          Reflect.construct(e, []);
        } catch (j) {
          var a = j;
        }
        Reflect.construct(s, [], e);
      } else {
        try {
          e.call();
        } catch (j) {
          a = j;
        }
        s.call(e.prototype);
      }
    else {
      try {
        throw Error();
      } catch (j) {
        a = j;
      }
      s();
    }
  } catch (j) {
    if (j && a && typeof j.stack == "string") {
      for (
        var c = j.stack.split(`
`),
          d = a.stack.split(`
`),
          g = c.length - 1,
          _ = d.length - 1;
        1 <= g && 0 <= _ && c[g] !== d[_];

      )
        _--;
      for (; 1 <= g && 0 <= _; g--, _--)
        if (c[g] !== d[_]) {
          if (g !== 1 || _ !== 1)
            do
              if ((g--, _--, 0 > _ || c[g] !== d[_])) {
                var b =
                  `
` + c[g].replace(" at new ", " at ");
                return (
                  s.displayName &&
                    b.includes("<anonymous>") &&
                    (b = b.replace("<anonymous>", s.displayName)),
                  b
                );
              }
            while (1 <= g && 0 <= _);
          break;
        }
    }
  } finally {
    (Na = !1), (Error.prepareStackTrace = o);
  }
  return (s = s ? s.displayName || s.name : "") ? Ma(s) : "";
}
function Pa(s) {
  switch (s.tag) {
    case 5:
      return Ma(s.type);
    case 16:
      return Ma("Lazy");
    case 13:
      return Ma("Suspense");
    case 19:
      return Ma("SuspenseList");
    case 0:
    case 2:
    case 15:
      return (s = Oa(s.type, !1)), s;
    case 11:
      return (s = Oa(s.type.render, !1)), s;
    case 1:
      return (s = Oa(s.type, !0)), s;
    default:
      return "";
  }
}
function Qa(s) {
  if (s == null) return null;
  if (typeof s == "function") return s.displayName || s.name || null;
  if (typeof s == "string") return s;
  switch (s) {
    case ya:
      return "Fragment";
    case wa$1:
      return "Portal";
    case Aa:
      return "Profiler";
    case za:
      return "StrictMode";
    case Ea:
      return "Suspense";
    case Fa:
      return "SuspenseList";
  }
  if (typeof s == "object")
    switch (s.$$typeof) {
      case Ca:
        return (s.displayName || "Context") + ".Consumer";
      case Ba:
        return (s._context.displayName || "Context") + ".Provider";
      case Da:
        var e = s.render;
        return (
          (s = s.displayName),
          s ||
            ((s = e.displayName || e.name || ""),
            (s = s !== "" ? "ForwardRef(" + s + ")" : "ForwardRef")),
          s
        );
      case Ga:
        return (
          (e = s.displayName || null), e !== null ? e : Qa(s.type) || "Memo"
        );
      case Ha:
        (e = s._payload), (s = s._init);
        try {
          return Qa(s(e));
        } catch {}
    }
  return null;
}
function Ra(s) {
  var e = s.type;
  switch (s.tag) {
    case 24:
      return "Cache";
    case 9:
      return (e.displayName || "Context") + ".Consumer";
    case 10:
      return (e._context.displayName || "Context") + ".Provider";
    case 18:
      return "DehydratedFragment";
    case 11:
      return (
        (s = e.render),
        (s = s.displayName || s.name || ""),
        e.displayName || (s !== "" ? "ForwardRef(" + s + ")" : "ForwardRef")
      );
    case 7:
      return "Fragment";
    case 5:
      return e;
    case 4:
      return "Portal";
    case 3:
      return "Root";
    case 6:
      return "Text";
    case 16:
      return Qa(e);
    case 8:
      return e === za ? "StrictMode" : "Mode";
    case 22:
      return "Offscreen";
    case 12:
      return "Profiler";
    case 21:
      return "Scope";
    case 13:
      return "Suspense";
    case 19:
      return "SuspenseList";
    case 25:
      return "TracingMarker";
    case 1:
    case 0:
    case 17:
    case 2:
    case 14:
    case 15:
      if (typeof e == "function") return e.displayName || e.name || null;
      if (typeof e == "string") return e;
  }
  return null;
}
function Sa(s) {
  switch (typeof s) {
    case "boolean":
    case "number":
    case "string":
    case "undefined":
      return s;
    case "object":
      return s;
    default:
      return "";
  }
}
function Ta(s) {
  var e = s.type;
  return (
    (s = s.nodeName) &&
    s.toLowerCase() === "input" &&
    (e === "checkbox" || e === "radio")
  );
}
function Ua(s) {
  var e = Ta(s) ? "checked" : "value",
    o = Object.getOwnPropertyDescriptor(s.constructor.prototype, e),
    a = "" + s[e];
  if (
    !s.hasOwnProperty(e) &&
    typeof o < "u" &&
    typeof o.get == "function" &&
    typeof o.set == "function"
  ) {
    var c = o.get,
      d = o.set;
    return (
      Object.defineProperty(s, e, {
        configurable: !0,
        get: function () {
          return c.call(this);
        },
        set: function (g) {
          (a = "" + g), d.call(this, g);
        },
      }),
      Object.defineProperty(s, e, { enumerable: o.enumerable }),
      {
        getValue: function () {
          return a;
        },
        setValue: function (g) {
          a = "" + g;
        },
        stopTracking: function () {
          (s._valueTracker = null), delete s[e];
        },
      }
    );
  }
}
function Va(s) {
  s._valueTracker || (s._valueTracker = Ua(s));
}
function Wa(s) {
  if (!s) return !1;
  var e = s._valueTracker;
  if (!e) return !0;
  var o = e.getValue(),
    a = "";
  return (
    s && (a = Ta(s) ? (s.checked ? "true" : "false") : s.value),
    (s = a),
    s !== o ? (e.setValue(s), !0) : !1
  );
}
function Xa(s) {
  if (((s = s || (typeof document < "u" ? document : void 0)), typeof s > "u"))
    return null;
  try {
    return s.activeElement || s.body;
  } catch {
    return s.body;
  }
}
function Ya(s, e) {
  var o = e.checked;
  return A({}, e, {
    defaultChecked: void 0,
    defaultValue: void 0,
    value: void 0,
    checked: o ?? s._wrapperState.initialChecked,
  });
}
function Za(s, e) {
  var o = e.defaultValue == null ? "" : e.defaultValue,
    a = e.checked != null ? e.checked : e.defaultChecked;
  (o = Sa(e.value != null ? e.value : o)),
    (s._wrapperState = {
      initialChecked: a,
      initialValue: o,
      controlled:
        e.type === "checkbox" || e.type === "radio"
          ? e.checked != null
          : e.value != null,
    });
}
function ab(s, e) {
  (e = e.checked), e != null && ta(s, "checked", e, !1);
}
function bb(s, e) {
  ab(s, e);
  var o = Sa(e.value),
    a = e.type;
  if (o != null)
    a === "number"
      ? ((o === 0 && s.value === "") || s.value != o) && (s.value = "" + o)
      : s.value !== "" + o && (s.value = "" + o);
  else if (a === "submit" || a === "reset") {
    s.removeAttribute("value");
    return;
  }
  e.hasOwnProperty("value")
    ? cb(s, e.type, o)
    : e.hasOwnProperty("defaultValue") && cb(s, e.type, Sa(e.defaultValue)),
    e.checked == null &&
      e.defaultChecked != null &&
      (s.defaultChecked = !!e.defaultChecked);
}
function db(s, e, o) {
  if (e.hasOwnProperty("value") || e.hasOwnProperty("defaultValue")) {
    var a = e.type;
    if (
      !(
        (a !== "submit" && a !== "reset") ||
        (e.value !== void 0 && e.value !== null)
      )
    )
      return;
    (e = "" + s._wrapperState.initialValue),
      o || e === s.value || (s.value = e),
      (s.defaultValue = e);
  }
  (o = s.name),
    o !== "" && (s.name = ""),
    (s.defaultChecked = !!s._wrapperState.initialChecked),
    o !== "" && (s.name = o);
}
function cb(s, e, o) {
  (e !== "number" || Xa(s.ownerDocument) !== s) &&
    (o == null
      ? (s.defaultValue = "" + s._wrapperState.initialValue)
      : s.defaultValue !== "" + o && (s.defaultValue = "" + o));
}
var eb = Array.isArray;
function fb$1(s, e, o, a) {
  if (((s = s.options), e)) {
    e = {};
    for (var c = 0; c < o.length; c++) e["$" + o[c]] = !0;
    for (o = 0; o < s.length; o++)
      (c = e.hasOwnProperty("$" + s[o].value)),
        s[o].selected !== c && (s[o].selected = c),
        c && a && (s[o].defaultSelected = !0);
  } else {
    for (o = "" + Sa(o), e = null, c = 0; c < s.length; c++) {
      if (s[c].value === o) {
        (s[c].selected = !0), a && (s[c].defaultSelected = !0);
        return;
      }
      e !== null || s[c].disabled || (e = s[c]);
    }
    e !== null && (e.selected = !0);
  }
}
function gb(s, e) {
  if (e.dangerouslySetInnerHTML != null) throw Error(p$1(91));
  return A({}, e, {
    value: void 0,
    defaultValue: void 0,
    children: "" + s._wrapperState.initialValue,
  });
}
function hb(s, e) {
  var o = e.value;
  if (o == null) {
    if (((o = e.children), (e = e.defaultValue), o != null)) {
      if (e != null) throw Error(p$1(92));
      if (eb(o)) {
        if (1 < o.length) throw Error(p$1(93));
        o = o[0];
      }
      e = o;
    }
    e == null && (e = ""), (o = e);
  }
  s._wrapperState = { initialValue: Sa(o) };
}
function ib(s, e) {
  var o = Sa(e.value),
    a = Sa(e.defaultValue);
  o != null &&
    ((o = "" + o),
    o !== s.value && (s.value = o),
    e.defaultValue == null && s.defaultValue !== o && (s.defaultValue = o)),
    a != null && (s.defaultValue = "" + a);
}
function jb(s) {
  var e = s.textContent;
  e === s._wrapperState.initialValue && e !== "" && e !== null && (s.value = e);
}
function kb(s) {
  switch (s) {
    case "svg":
      return "http://www.w3.org/2000/svg";
    case "math":
      return "http://www.w3.org/1998/Math/MathML";
    default:
      return "http://www.w3.org/1999/xhtml";
  }
}
function lb(s, e) {
  return s == null || s === "http://www.w3.org/1999/xhtml"
    ? kb(e)
    : s === "http://www.w3.org/2000/svg" && e === "foreignObject"
    ? "http://www.w3.org/1999/xhtml"
    : s;
}
var mb,
  nb = (function (s) {
    return typeof MSApp < "u" && MSApp.execUnsafeLocalFunction
      ? function (e, o, a, c) {
          MSApp.execUnsafeLocalFunction(function () {
            return s(e, o, a, c);
          });
        }
      : s;
  })(function (s, e) {
    if (s.namespaceURI !== "http://www.w3.org/2000/svg" || "innerHTML" in s)
      s.innerHTML = e;
    else {
      for (
        mb = mb || document.createElement("div"),
          mb.innerHTML = "<svg>" + e.valueOf().toString() + "</svg>",
          e = mb.firstChild;
        s.firstChild;

      )
        s.removeChild(s.firstChild);
      for (; e.firstChild; ) s.appendChild(e.firstChild);
    }
  });
function ob(s, e) {
  if (e) {
    var o = s.firstChild;
    if (o && o === s.lastChild && o.nodeType === 3) {
      o.nodeValue = e;
      return;
    }
  }
  s.textContent = e;
}
var pb = {
    animationIterationCount: !0,
    aspectRatio: !0,
    borderImageOutset: !0,
    borderImageSlice: !0,
    borderImageWidth: !0,
    boxFlex: !0,
    boxFlexGroup: !0,
    boxOrdinalGroup: !0,
    columnCount: !0,
    columns: !0,
    flex: !0,
    flexGrow: !0,
    flexPositive: !0,
    flexShrink: !0,
    flexNegative: !0,
    flexOrder: !0,
    gridArea: !0,
    gridRow: !0,
    gridRowEnd: !0,
    gridRowSpan: !0,
    gridRowStart: !0,
    gridColumn: !0,
    gridColumnEnd: !0,
    gridColumnSpan: !0,
    gridColumnStart: !0,
    fontWeight: !0,
    lineClamp: !0,
    lineHeight: !0,
    opacity: !0,
    order: !0,
    orphans: !0,
    tabSize: !0,
    widows: !0,
    zIndex: !0,
    zoom: !0,
    fillOpacity: !0,
    floodOpacity: !0,
    stopOpacity: !0,
    strokeDasharray: !0,
    strokeDashoffset: !0,
    strokeMiterlimit: !0,
    strokeOpacity: !0,
    strokeWidth: !0,
  },
  qb = ["Webkit", "ms", "Moz", "O"];
Object.keys(pb).forEach(function (s) {
  qb.forEach(function (e) {
    (e = e + s.charAt(0).toUpperCase() + s.substring(1)), (pb[e] = pb[s]);
  });
});
function rb(s, e, o) {
  return e == null || typeof e == "boolean" || e === ""
    ? ""
    : o || typeof e != "number" || e === 0 || (pb.hasOwnProperty(s) && pb[s])
    ? ("" + e).trim()
    : e + "px";
}
function sb(s, e) {
  s = s.style;
  for (var o in e)
    if (e.hasOwnProperty(o)) {
      var a = o.indexOf("--") === 0,
        c = rb(o, e[o], a);
      o === "float" && (o = "cssFloat"), a ? s.setProperty(o, c) : (s[o] = c);
    }
}
var tb = A(
  { menuitem: !0 },
  {
    area: !0,
    base: !0,
    br: !0,
    col: !0,
    embed: !0,
    hr: !0,
    img: !0,
    input: !0,
    keygen: !0,
    link: !0,
    meta: !0,
    param: !0,
    source: !0,
    track: !0,
    wbr: !0,
  }
);
function ub(s, e) {
  if (e) {
    if (tb[s] && (e.children != null || e.dangerouslySetInnerHTML != null))
      throw Error(p$1(137, s));
    if (e.dangerouslySetInnerHTML != null) {
      if (e.children != null) throw Error(p$1(60));
      if (
        typeof e.dangerouslySetInnerHTML != "object" ||
        !("__html" in e.dangerouslySetInnerHTML)
      )
        throw Error(p$1(61));
    }
    if (e.style != null && typeof e.style != "object") throw Error(p$1(62));
  }
}
function vb(s, e) {
  if (s.indexOf("-") === -1) return typeof e.is == "string";
  switch (s) {
    case "annotation-xml":
    case "color-profile":
    case "font-face":
    case "font-face-src":
    case "font-face-uri":
    case "font-face-format":
    case "font-face-name":
    case "missing-glyph":
      return !1;
    default:
      return !0;
  }
}
var wb = null;
function xb(s) {
  return (
    (s = s.target || s.srcElement || window),
    s.correspondingUseElement && (s = s.correspondingUseElement),
    s.nodeType === 3 ? s.parentNode : s
  );
}
var yb = null,
  zb = null,
  Ab = null;
function Bb(s) {
  if ((s = Cb(s))) {
    if (typeof yb != "function") throw Error(p$1(280));
    var e = s.stateNode;
    e && ((e = Db(e)), yb(s.stateNode, s.type, e));
  }
}
function Eb(s) {
  zb ? (Ab ? Ab.push(s) : (Ab = [s])) : (zb = s);
}
function Fb() {
  if (zb) {
    var s = zb,
      e = Ab;
    if (((Ab = zb = null), Bb(s), e)) for (s = 0; s < e.length; s++) Bb(e[s]);
  }
}
function Gb(s, e) {
  return s(e);
}
function Hb() {}
var Ib = !1;
function Jb(s, e, o) {
  if (Ib) return s(e, o);
  Ib = !0;
  try {
    return Gb(s, e, o);
  } finally {
    (Ib = !1), (zb !== null || Ab !== null) && (Hb(), Fb());
  }
}
function Kb(s, e) {
  var o = s.stateNode;
  if (o === null) return null;
  var a = Db(o);
  if (a === null) return null;
  o = a[e];
  e: switch (e) {
    case "onClick":
    case "onClickCapture":
    case "onDoubleClick":
    case "onDoubleClickCapture":
    case "onMouseDown":
    case "onMouseDownCapture":
    case "onMouseMove":
    case "onMouseMoveCapture":
    case "onMouseUp":
    case "onMouseUpCapture":
    case "onMouseEnter":
      (a = !a.disabled) ||
        ((s = s.type),
        (a = !(
          s === "button" ||
          s === "input" ||
          s === "select" ||
          s === "textarea"
        ))),
        (s = !a);
      break e;
    default:
      s = !1;
  }
  if (s) return null;
  if (o && typeof o != "function") throw Error(p$1(231, e, typeof o));
  return o;
}
var Lb = !1;
if (ia)
  try {
    var Mb = {};
    Object.defineProperty(Mb, "passive", {
      get: function () {
        Lb = !0;
      },
    }),
      window.addEventListener("test", Mb, Mb),
      window.removeEventListener("test", Mb, Mb);
  } catch {
    Lb = !1;
  }
function Nb(s, e, o, a, c, d, g, _, b) {
  var j = Array.prototype.slice.call(arguments, 3);
  try {
    e.apply(o, j);
  } catch ($) {
    this.onError($);
  }
}
var Ob = !1,
  Pb = null,
  Qb = !1,
  Rb = null,
  Sb = {
    onError: function (s) {
      (Ob = !0), (Pb = s);
    },
  };
function Tb(s, e, o, a, c, d, g, _, b) {
  (Ob = !1), (Pb = null), Nb.apply(Sb, arguments);
}
function Ub(s, e, o, a, c, d, g, _, b) {
  if ((Tb.apply(this, arguments), Ob)) {
    if (Ob) {
      var j = Pb;
      (Ob = !1), (Pb = null);
    } else throw Error(p$1(198));
    Qb || ((Qb = !0), (Rb = j));
  }
}
function Vb(s) {
  var e = s,
    o = s;
  if (s.alternate) for (; e.return; ) e = e.return;
  else {
    s = e;
    do (e = s), e.flags & 4098 && (o = e.return), (s = e.return);
    while (s);
  }
  return e.tag === 3 ? o : null;
}
function Wb(s) {
  if (s.tag === 13) {
    var e = s.memoizedState;
    if (
      (e === null && ((s = s.alternate), s !== null && (e = s.memoizedState)),
      e !== null)
    )
      return e.dehydrated;
  }
  return null;
}
function Xb(s) {
  if (Vb(s) !== s) throw Error(p$1(188));
}
function Yb(s) {
  var e = s.alternate;
  if (!e) {
    if (((e = Vb(s)), e === null)) throw Error(p$1(188));
    return e !== s ? null : s;
  }
  for (var o = s, a = e; ; ) {
    var c = o.return;
    if (c === null) break;
    var d = c.alternate;
    if (d === null) {
      if (((a = c.return), a !== null)) {
        o = a;
        continue;
      }
      break;
    }
    if (c.child === d.child) {
      for (d = c.child; d; ) {
        if (d === o) return Xb(c), s;
        if (d === a) return Xb(c), e;
        d = d.sibling;
      }
      throw Error(p$1(188));
    }
    if (o.return !== a.return) (o = c), (a = d);
    else {
      for (var g = !1, _ = c.child; _; ) {
        if (_ === o) {
          (g = !0), (o = c), (a = d);
          break;
        }
        if (_ === a) {
          (g = !0), (a = c), (o = d);
          break;
        }
        _ = _.sibling;
      }
      if (!g) {
        for (_ = d.child; _; ) {
          if (_ === o) {
            (g = !0), (o = d), (a = c);
            break;
          }
          if (_ === a) {
            (g = !0), (a = d), (o = c);
            break;
          }
          _ = _.sibling;
        }
        if (!g) throw Error(p$1(189));
      }
    }
    if (o.alternate !== a) throw Error(p$1(190));
  }
  if (o.tag !== 3) throw Error(p$1(188));
  return o.stateNode.current === o ? s : e;
}
function Zb(s) {
  return (s = Yb(s)), s !== null ? $b(s) : null;
}
function $b(s) {
  if (s.tag === 5 || s.tag === 6) return s;
  for (s = s.child; s !== null; ) {
    var e = $b(s);
    if (e !== null) return e;
    s = s.sibling;
  }
  return null;
}
var ac = ca.unstable_scheduleCallback,
  bc = ca.unstable_cancelCallback,
  cc = ca.unstable_shouldYield,
  dc = ca.unstable_requestPaint,
  B = ca.unstable_now,
  ec = ca.unstable_getCurrentPriorityLevel,
  fc = ca.unstable_ImmediatePriority,
  gc = ca.unstable_UserBlockingPriority,
  hc = ca.unstable_NormalPriority,
  ic = ca.unstable_LowPriority,
  jc = ca.unstable_IdlePriority,
  kc = null,
  lc = null;
function mc(s) {
  if (lc && typeof lc.onCommitFiberRoot == "function")
    try {
      lc.onCommitFiberRoot(kc, s, void 0, (s.current.flags & 128) === 128);
    } catch {}
}
var oc = Math.clz32 ? Math.clz32 : nc,
  pc = Math.log,
  qc = Math.LN2;
function nc(s) {
  return (s >>>= 0), s === 0 ? 32 : (31 - ((pc(s) / qc) | 0)) | 0;
}
var rc = 64,
  sc = 4194304;
function tc(s) {
  switch (s & -s) {
    case 1:
      return 1;
    case 2:
      return 2;
    case 4:
      return 4;
    case 8:
      return 8;
    case 16:
      return 16;
    case 32:
      return 32;
    case 64:
    case 128:
    case 256:
    case 512:
    case 1024:
    case 2048:
    case 4096:
    case 8192:
    case 16384:
    case 32768:
    case 65536:
    case 131072:
    case 262144:
    case 524288:
    case 1048576:
    case 2097152:
      return s & 4194240;
    case 4194304:
    case 8388608:
    case 16777216:
    case 33554432:
    case 67108864:
      return s & 130023424;
    case 134217728:
      return 134217728;
    case 268435456:
      return 268435456;
    case 536870912:
      return 536870912;
    case 1073741824:
      return 1073741824;
    default:
      return s;
  }
}
function uc(s, e) {
  var o = s.pendingLanes;
  if (o === 0) return 0;
  var a = 0,
    c = s.suspendedLanes,
    d = s.pingedLanes,
    g = o & 268435455;
  if (g !== 0) {
    var _ = g & ~c;
    _ !== 0 ? (a = tc(_)) : ((d &= g), d !== 0 && (a = tc(d)));
  } else (g = o & ~c), g !== 0 ? (a = tc(g)) : d !== 0 && (a = tc(d));
  if (a === 0) return 0;
  if (
    e !== 0 &&
    e !== a &&
    !(e & c) &&
    ((c = a & -a), (d = e & -e), c >= d || (c === 16 && (d & 4194240) !== 0))
  )
    return e;
  if ((a & 4 && (a |= o & 16), (e = s.entangledLanes), e !== 0))
    for (s = s.entanglements, e &= a; 0 < e; )
      (o = 31 - oc(e)), (c = 1 << o), (a |= s[o]), (e &= ~c);
  return a;
}
function vc(s, e) {
  switch (s) {
    case 1:
    case 2:
    case 4:
      return e + 250;
    case 8:
    case 16:
    case 32:
    case 64:
    case 128:
    case 256:
    case 512:
    case 1024:
    case 2048:
    case 4096:
    case 8192:
    case 16384:
    case 32768:
    case 65536:
    case 131072:
    case 262144:
    case 524288:
    case 1048576:
    case 2097152:
      return e + 5e3;
    case 4194304:
    case 8388608:
    case 16777216:
    case 33554432:
    case 67108864:
      return -1;
    case 134217728:
    case 268435456:
    case 536870912:
    case 1073741824:
      return -1;
    default:
      return -1;
  }
}
function wc(s, e) {
  for (
    var o = s.suspendedLanes,
      a = s.pingedLanes,
      c = s.expirationTimes,
      d = s.pendingLanes;
    0 < d;

  ) {
    var g = 31 - oc(d),
      _ = 1 << g,
      b = c[g];
    b === -1
      ? (!(_ & o) || _ & a) && (c[g] = vc(_, e))
      : b <= e && (s.expiredLanes |= _),
      (d &= ~_);
  }
}
function xc(s) {
  return (
    (s = s.pendingLanes & -1073741825),
    s !== 0 ? s : s & 1073741824 ? 1073741824 : 0
  );
}
function yc() {
  var s = rc;
  return (rc <<= 1), !(rc & 4194240) && (rc = 64), s;
}
function zc(s) {
  for (var e = [], o = 0; 31 > o; o++) e.push(s);
  return e;
}
function Ac(s, e, o) {
  (s.pendingLanes |= e),
    e !== 536870912 && ((s.suspendedLanes = 0), (s.pingedLanes = 0)),
    (s = s.eventTimes),
    (e = 31 - oc(e)),
    (s[e] = o);
}
function Bc(s, e) {
  var o = s.pendingLanes & ~e;
  (s.pendingLanes = e),
    (s.suspendedLanes = 0),
    (s.pingedLanes = 0),
    (s.expiredLanes &= e),
    (s.mutableReadLanes &= e),
    (s.entangledLanes &= e),
    (e = s.entanglements);
  var a = s.eventTimes;
  for (s = s.expirationTimes; 0 < o; ) {
    var c = 31 - oc(o),
      d = 1 << c;
    (e[c] = 0), (a[c] = -1), (s[c] = -1), (o &= ~d);
  }
}
function Cc(s, e) {
  var o = (s.entangledLanes |= e);
  for (s = s.entanglements; o; ) {
    var a = 31 - oc(o),
      c = 1 << a;
    (c & e) | (s[a] & e) && (s[a] |= e), (o &= ~c);
  }
}
var C = 0;
function Dc(s) {
  return (s &= -s), 1 < s ? (4 < s ? (s & 268435455 ? 16 : 536870912) : 4) : 1;
}
var Ec,
  Fc,
  Gc,
  Hc,
  Ic,
  Jc = !1,
  Kc = [],
  Lc = null,
  Mc = null,
  Nc = null,
  Oc = new Map(),
  Pc = new Map(),
  Qc = [],
  Rc =
    "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(
      " "
    );
function Sc(s, e) {
  switch (s) {
    case "focusin":
    case "focusout":
      Lc = null;
      break;
    case "dragenter":
    case "dragleave":
      Mc = null;
      break;
    case "mouseover":
    case "mouseout":
      Nc = null;
      break;
    case "pointerover":
    case "pointerout":
      Oc.delete(e.pointerId);
      break;
    case "gotpointercapture":
    case "lostpointercapture":
      Pc.delete(e.pointerId);
  }
}
function Tc(s, e, o, a, c, d) {
  return s === null || s.nativeEvent !== d
    ? ((s = {
        blockedOn: e,
        domEventName: o,
        eventSystemFlags: a,
        nativeEvent: d,
        targetContainers: [c],
      }),
      e !== null && ((e = Cb(e)), e !== null && Fc(e)),
      s)
    : ((s.eventSystemFlags |= a),
      (e = s.targetContainers),
      c !== null && e.indexOf(c) === -1 && e.push(c),
      s);
}
function Uc(s, e, o, a, c) {
  switch (e) {
    case "focusin":
      return (Lc = Tc(Lc, s, e, o, a, c)), !0;
    case "dragenter":
      return (Mc = Tc(Mc, s, e, o, a, c)), !0;
    case "mouseover":
      return (Nc = Tc(Nc, s, e, o, a, c)), !0;
    case "pointerover":
      var d = c.pointerId;
      return Oc.set(d, Tc(Oc.get(d) || null, s, e, o, a, c)), !0;
    case "gotpointercapture":
      return (
        (d = c.pointerId), Pc.set(d, Tc(Pc.get(d) || null, s, e, o, a, c)), !0
      );
  }
  return !1;
}
function Vc(s) {
  var e = Wc(s.target);
  if (e !== null) {
    var o = Vb(e);
    if (o !== null) {
      if (((e = o.tag), e === 13)) {
        if (((e = Wb(o)), e !== null)) {
          (s.blockedOn = e),
            Ic(s.priority, function () {
              Gc(o);
            });
          return;
        }
      } else if (e === 3 && o.stateNode.current.memoizedState.isDehydrated) {
        s.blockedOn = o.tag === 3 ? o.stateNode.containerInfo : null;
        return;
      }
    }
  }
  s.blockedOn = null;
}
function Xc(s) {
  if (s.blockedOn !== null) return !1;
  for (var e = s.targetContainers; 0 < e.length; ) {
    var o = Yc(s.domEventName, s.eventSystemFlags, e[0], s.nativeEvent);
    if (o === null) {
      o = s.nativeEvent;
      var a = new o.constructor(o.type, o);
      (wb = a), o.target.dispatchEvent(a), (wb = null);
    } else return (e = Cb(o)), e !== null && Fc(e), (s.blockedOn = o), !1;
    e.shift();
  }
  return !0;
}
function Zc(s, e, o) {
  Xc(s) && o.delete(e);
}
function $c() {
  (Jc = !1),
    Lc !== null && Xc(Lc) && (Lc = null),
    Mc !== null && Xc(Mc) && (Mc = null),
    Nc !== null && Xc(Nc) && (Nc = null),
    Oc.forEach(Zc),
    Pc.forEach(Zc);
}
function ad$1(s, e) {
  s.blockedOn === e &&
    ((s.blockedOn = null),
    Jc ||
      ((Jc = !0),
      ca.unstable_scheduleCallback(ca.unstable_NormalPriority, $c)));
}
function bd(s) {
  function e(c) {
    return ad$1(c, s);
  }
  if (0 < Kc.length) {
    ad$1(Kc[0], s);
    for (var o = 1; o < Kc.length; o++) {
      var a = Kc[o];
      a.blockedOn === s && (a.blockedOn = null);
    }
  }
  for (
    Lc !== null && ad$1(Lc, s),
      Mc !== null && ad$1(Mc, s),
      Nc !== null && ad$1(Nc, s),
      Oc.forEach(e),
      Pc.forEach(e),
      o = 0;
    o < Qc.length;
    o++
  )
    (a = Qc[o]), a.blockedOn === s && (a.blockedOn = null);
  for (; 0 < Qc.length && ((o = Qc[0]), o.blockedOn === null); )
    Vc(o), o.blockedOn === null && Qc.shift();
}
var cd = ua.ReactCurrentBatchConfig,
  dd = !0;
function ed(s, e, o, a) {
  var c = C,
    d = cd.transition;
  cd.transition = null;
  try {
    (C = 1), fd(s, e, o, a);
  } finally {
    (C = c), (cd.transition = d);
  }
}
function gd(s, e, o, a) {
  var c = C,
    d = cd.transition;
  cd.transition = null;
  try {
    (C = 4), fd(s, e, o, a);
  } finally {
    (C = c), (cd.transition = d);
  }
}
function fd(s, e, o, a) {
  if (dd) {
    var c = Yc(s, e, o, a);
    if (c === null) hd(s, e, a, id$2, o), Sc(s, a);
    else if (Uc(c, s, e, o, a)) a.stopPropagation();
    else if ((Sc(s, a), e & 4 && -1 < Rc.indexOf(s))) {
      for (; c !== null; ) {
        var d = Cb(c);
        if (
          (d !== null && Ec(d),
          (d = Yc(s, e, o, a)),
          d === null && hd(s, e, a, id$2, o),
          d === c)
        )
          break;
        c = d;
      }
      c !== null && a.stopPropagation();
    } else hd(s, e, a, null, o);
  }
}
var id$2 = null;
function Yc(s, e, o, a) {
  if (((id$2 = null), (s = xb(a)), (s = Wc(s)), s !== null))
    if (((e = Vb(s)), e === null)) s = null;
    else if (((o = e.tag), o === 13)) {
      if (((s = Wb(e)), s !== null)) return s;
      s = null;
    } else if (o === 3) {
      if (e.stateNode.current.memoizedState.isDehydrated)
        return e.tag === 3 ? e.stateNode.containerInfo : null;
      s = null;
    } else e !== s && (s = null);
  return (id$2 = s), null;
}
function jd(s) {
  switch (s) {
    case "cancel":
    case "click":
    case "close":
    case "contextmenu":
    case "copy":
    case "cut":
    case "auxclick":
    case "dblclick":
    case "dragend":
    case "dragstart":
    case "drop":
    case "focusin":
    case "focusout":
    case "input":
    case "invalid":
    case "keydown":
    case "keypress":
    case "keyup":
    case "mousedown":
    case "mouseup":
    case "paste":
    case "pause":
    case "play":
    case "pointercancel":
    case "pointerdown":
    case "pointerup":
    case "ratechange":
    case "reset":
    case "resize":
    case "seeked":
    case "submit":
    case "touchcancel":
    case "touchend":
    case "touchstart":
    case "volumechange":
    case "change":
    case "selectionchange":
    case "textInput":
    case "compositionstart":
    case "compositionend":
    case "compositionupdate":
    case "beforeblur":
    case "afterblur":
    case "beforeinput":
    case "blur":
    case "fullscreenchange":
    case "focus":
    case "hashchange":
    case "popstate":
    case "select":
    case "selectstart":
      return 1;
    case "drag":
    case "dragenter":
    case "dragexit":
    case "dragleave":
    case "dragover":
    case "mousemove":
    case "mouseout":
    case "mouseover":
    case "pointermove":
    case "pointerout":
    case "pointerover":
    case "scroll":
    case "toggle":
    case "touchmove":
    case "wheel":
    case "mouseenter":
    case "mouseleave":
    case "pointerenter":
    case "pointerleave":
      return 4;
    case "message":
      switch (ec()) {
        case fc:
          return 1;
        case gc:
          return 4;
        case hc:
        case ic:
          return 16;
        case jc:
          return 536870912;
        default:
          return 16;
      }
    default:
      return 16;
  }
}
var kd = null,
  ld = null,
  md = null;
function nd() {
  if (md) return md;
  var s,
    e = ld,
    o = e.length,
    a,
    c = "value" in kd ? kd.value : kd.textContent,
    d = c.length;
  for (s = 0; s < o && e[s] === c[s]; s++);
  var g = o - s;
  for (a = 1; a <= g && e[o - a] === c[d - a]; a++);
  return (md = c.slice(s, 1 < a ? 1 - a : void 0));
}
function od(s) {
  var e = s.keyCode;
  return (
    "charCode" in s
      ? ((s = s.charCode), s === 0 && e === 13 && (s = 13))
      : (s = e),
    s === 10 && (s = 13),
    32 <= s || s === 13 ? s : 0
  );
}
function pd() {
  return !0;
}
function qd() {
  return !1;
}
function rd(s) {
  function e(o, a, c, d, g) {
    (this._reactName = o),
      (this._targetInst = c),
      (this.type = a),
      (this.nativeEvent = d),
      (this.target = g),
      (this.currentTarget = null);
    for (var _ in s)
      s.hasOwnProperty(_) && ((o = s[_]), (this[_] = o ? o(d) : d[_]));
    return (
      (this.isDefaultPrevented = (
        d.defaultPrevented != null ? d.defaultPrevented : d.returnValue === !1
      )
        ? pd
        : qd),
      (this.isPropagationStopped = qd),
      this
    );
  }
  return (
    A(e.prototype, {
      preventDefault: function () {
        this.defaultPrevented = !0;
        var o = this.nativeEvent;
        o &&
          (o.preventDefault
            ? o.preventDefault()
            : typeof o.returnValue != "unknown" && (o.returnValue = !1),
          (this.isDefaultPrevented = pd));
      },
      stopPropagation: function () {
        var o = this.nativeEvent;
        o &&
          (o.stopPropagation
            ? o.stopPropagation()
            : typeof o.cancelBubble != "unknown" && (o.cancelBubble = !0),
          (this.isPropagationStopped = pd));
      },
      persist: function () {},
      isPersistent: pd,
    }),
    e
  );
}
var sd = {
    eventPhase: 0,
    bubbles: 0,
    cancelable: 0,
    timeStamp: function (s) {
      return s.timeStamp || Date.now();
    },
    defaultPrevented: 0,
    isTrusted: 0,
  },
  td$1 = rd(sd),
  ud = A({}, sd, { view: 0, detail: 0 }),
  vd = rd(ud),
  wd,
  xd,
  yd,
  Ad = A({}, ud, {
    screenX: 0,
    screenY: 0,
    clientX: 0,
    clientY: 0,
    pageX: 0,
    pageY: 0,
    ctrlKey: 0,
    shiftKey: 0,
    altKey: 0,
    metaKey: 0,
    getModifierState: zd,
    button: 0,
    buttons: 0,
    relatedTarget: function (s) {
      return s.relatedTarget === void 0
        ? s.fromElement === s.srcElement
          ? s.toElement
          : s.fromElement
        : s.relatedTarget;
    },
    movementX: function (s) {
      return "movementX" in s
        ? s.movementX
        : (s !== yd &&
            (yd && s.type === "mousemove"
              ? ((wd = s.screenX - yd.screenX), (xd = s.screenY - yd.screenY))
              : (xd = wd = 0),
            (yd = s)),
          wd);
    },
    movementY: function (s) {
      return "movementY" in s ? s.movementY : xd;
    },
  }),
  Bd = rd(Ad),
  Cd = A({}, Ad, { dataTransfer: 0 }),
  Dd = rd(Cd),
  Ed = A({}, ud, { relatedTarget: 0 }),
  Fd = rd(Ed),
  Gd = A({}, sd, { animationName: 0, elapsedTime: 0, pseudoElement: 0 }),
  Hd = rd(Gd),
  Id = A({}, sd, {
    clipboardData: function (s) {
      return "clipboardData" in s ? s.clipboardData : window.clipboardData;
    },
  }),
  Jd = rd(Id),
  Kd = A({}, sd, { data: 0 }),
  Ld = rd(Kd),
  Md = {
    Esc: "Escape",
    Spacebar: " ",
    Left: "ArrowLeft",
    Up: "ArrowUp",
    Right: "ArrowRight",
    Down: "ArrowDown",
    Del: "Delete",
    Win: "OS",
    Menu: "ContextMenu",
    Apps: "ContextMenu",
    Scroll: "ScrollLock",
    MozPrintableKey: "Unidentified",
  },
  Nd = {
    8: "Backspace",
    9: "Tab",
    12: "Clear",
    13: "Enter",
    16: "Shift",
    17: "Control",
    18: "Alt",
    19: "Pause",
    20: "CapsLock",
    27: "Escape",
    32: " ",
    33: "PageUp",
    34: "PageDown",
    35: "End",
    36: "Home",
    37: "ArrowLeft",
    38: "ArrowUp",
    39: "ArrowRight",
    40: "ArrowDown",
    45: "Insert",
    46: "Delete",
    112: "F1",
    113: "F2",
    114: "F3",
    115: "F4",
    116: "F5",
    117: "F6",
    118: "F7",
    119: "F8",
    120: "F9",
    121: "F10",
    122: "F11",
    123: "F12",
    144: "NumLock",
    145: "ScrollLock",
    224: "Meta",
  },
  Od = {
    Alt: "altKey",
    Control: "ctrlKey",
    Meta: "metaKey",
    Shift: "shiftKey",
  };
function Pd(s) {
  var e = this.nativeEvent;
  return e.getModifierState ? e.getModifierState(s) : (s = Od[s]) ? !!e[s] : !1;
}
function zd() {
  return Pd;
}
var Qd = A({}, ud, {
    key: function (s) {
      if (s.key) {
        var e = Md[s.key] || s.key;
        if (e !== "Unidentified") return e;
      }
      return s.type === "keypress"
        ? ((s = od(s)), s === 13 ? "Enter" : String.fromCharCode(s))
        : s.type === "keydown" || s.type === "keyup"
        ? Nd[s.keyCode] || "Unidentified"
        : "";
    },
    code: 0,
    location: 0,
    ctrlKey: 0,
    shiftKey: 0,
    altKey: 0,
    metaKey: 0,
    repeat: 0,
    locale: 0,
    getModifierState: zd,
    charCode: function (s) {
      return s.type === "keypress" ? od(s) : 0;
    },
    keyCode: function (s) {
      return s.type === "keydown" || s.type === "keyup" ? s.keyCode : 0;
    },
    which: function (s) {
      return s.type === "keypress"
        ? od(s)
        : s.type === "keydown" || s.type === "keyup"
        ? s.keyCode
        : 0;
    },
  }),
  Rd = rd(Qd),
  Sd = A({}, Ad, {
    pointerId: 0,
    width: 0,
    height: 0,
    pressure: 0,
    tangentialPressure: 0,
    tiltX: 0,
    tiltY: 0,
    twist: 0,
    pointerType: 0,
    isPrimary: 0,
  }),
  Td = rd(Sd),
  Ud = A({}, ud, {
    touches: 0,
    targetTouches: 0,
    changedTouches: 0,
    altKey: 0,
    metaKey: 0,
    ctrlKey: 0,
    shiftKey: 0,
    getModifierState: zd,
  }),
  Vd = rd(Ud),
  Wd = A({}, sd, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 }),
  Xd = rd(Wd),
  Yd = A({}, Ad, {
    deltaX: function (s) {
      return "deltaX" in s ? s.deltaX : "wheelDeltaX" in s ? -s.wheelDeltaX : 0;
    },
    deltaY: function (s) {
      return "deltaY" in s
        ? s.deltaY
        : "wheelDeltaY" in s
        ? -s.wheelDeltaY
        : "wheelDelta" in s
        ? -s.wheelDelta
        : 0;
    },
    deltaZ: 0,
    deltaMode: 0,
  }),
  Zd = rd(Yd),
  $d = [9, 13, 27, 32],
  ae = ia && "CompositionEvent" in window,
  be = null;
ia && "documentMode" in document && (be = document.documentMode);
var ce = ia && "TextEvent" in window && !be,
  de = ia && (!ae || (be && 8 < be && 11 >= be)),
  ee = " ",
  fe = !1;
function ge(s, e) {
  switch (s) {
    case "keyup":
      return $d.indexOf(e.keyCode) !== -1;
    case "keydown":
      return e.keyCode !== 229;
    case "keypress":
    case "mousedown":
    case "focusout":
      return !0;
    default:
      return !1;
  }
}
function he(s) {
  return (s = s.detail), typeof s == "object" && "data" in s ? s.data : null;
}
var ie = !1;
function je(s, e) {
  switch (s) {
    case "compositionend":
      return he(e);
    case "keypress":
      return e.which !== 32 ? null : ((fe = !0), ee);
    case "textInput":
      return (s = e.data), s === ee && fe ? null : s;
    default:
      return null;
  }
}
function ke(s, e) {
  if (ie)
    return s === "compositionend" || (!ae && ge(s, e))
      ? ((s = nd()), (md = ld = kd = null), (ie = !1), s)
      : null;
  switch (s) {
    case "paste":
      return null;
    case "keypress":
      if (!(e.ctrlKey || e.altKey || e.metaKey) || (e.ctrlKey && e.altKey)) {
        if (e.char && 1 < e.char.length) return e.char;
        if (e.which) return String.fromCharCode(e.which);
      }
      return null;
    case "compositionend":
      return de && e.locale !== "ko" ? null : e.data;
    default:
      return null;
  }
}
var le = {
  color: !0,
  date: !0,
  datetime: !0,
  "datetime-local": !0,
  email: !0,
  month: !0,
  number: !0,
  password: !0,
  range: !0,
  search: !0,
  tel: !0,
  text: !0,
  time: !0,
  url: !0,
  week: !0,
};
function me(s) {
  var e = s && s.nodeName && s.nodeName.toLowerCase();
  return e === "input" ? !!le[s.type] : e === "textarea";
}
function ne(s, e, o, a) {
  Eb(a),
    (e = oe(e, "onChange")),
    0 < e.length &&
      ((o = new td$1("onChange", "change", null, o, a)),
      s.push({ event: o, listeners: e }));
}
var pe = null,
  qe = null;
function re(s) {
  se(s, 0);
}
function te(s) {
  var e = ue(s);
  if (Wa(e)) return s;
}
function ve(s, e) {
  if (s === "change") return e;
}
var we = !1;
if (ia) {
  var xe;
  if (ia) {
    var ye = "oninput" in document;
    if (!ye) {
      var ze = document.createElement("div");
      ze.setAttribute("oninput", "return;"),
        (ye = typeof ze.oninput == "function");
    }
    xe = ye;
  } else xe = !1;
  we = xe && (!document.documentMode || 9 < document.documentMode);
}
function Ae() {
  pe && (pe.detachEvent("onpropertychange", Be), (qe = pe = null));
}
function Be(s) {
  if (s.propertyName === "value" && te(qe)) {
    var e = [];
    ne(e, qe, s, xb(s)), Jb(re, e);
  }
}
function Ce(s, e, o) {
  s === "focusin"
    ? (Ae(), (pe = e), (qe = o), pe.attachEvent("onpropertychange", Be))
    : s === "focusout" && Ae();
}
function De(s) {
  if (s === "selectionchange" || s === "keyup" || s === "keydown")
    return te(qe);
}
function Ee(s, e) {
  if (s === "click") return te(e);
}
function Fe(s, e) {
  if (s === "input" || s === "change") return te(e);
}
function Ge(s, e) {
  return (s === e && (s !== 0 || 1 / s === 1 / e)) || (s !== s && e !== e);
}
var He = typeof Object.is == "function" ? Object.is : Ge;
function Ie(s, e) {
  if (He(s, e)) return !0;
  if (typeof s != "object" || s === null || typeof e != "object" || e === null)
    return !1;
  var o = Object.keys(s),
    a = Object.keys(e);
  if (o.length !== a.length) return !1;
  for (a = 0; a < o.length; a++) {
    var c = o[a];
    if (!ja.call(e, c) || !He(s[c], e[c])) return !1;
  }
  return !0;
}
function Je(s) {
  for (; s && s.firstChild; ) s = s.firstChild;
  return s;
}
function Ke(s, e) {
  var o = Je(s);
  s = 0;
  for (var a; o; ) {
    if (o.nodeType === 3) {
      if (((a = s + o.textContent.length), s <= e && a >= e))
        return { node: o, offset: e - s };
      s = a;
    }
    e: {
      for (; o; ) {
        if (o.nextSibling) {
          o = o.nextSibling;
          break e;
        }
        o = o.parentNode;
      }
      o = void 0;
    }
    o = Je(o);
  }
}
function Le(s, e) {
  return s && e
    ? s === e
      ? !0
      : s && s.nodeType === 3
      ? !1
      : e && e.nodeType === 3
      ? Le(s, e.parentNode)
      : "contains" in s
      ? s.contains(e)
      : s.compareDocumentPosition
      ? !!(s.compareDocumentPosition(e) & 16)
      : !1
    : !1;
}
function Me() {
  for (var s = window, e = Xa(); e instanceof s.HTMLIFrameElement; ) {
    try {
      var o = typeof e.contentWindow.location.href == "string";
    } catch {
      o = !1;
    }
    if (o) s = e.contentWindow;
    else break;
    e = Xa(s.document);
  }
  return e;
}
function Ne(s) {
  var e = s && s.nodeName && s.nodeName.toLowerCase();
  return (
    e &&
    ((e === "input" &&
      (s.type === "text" ||
        s.type === "search" ||
        s.type === "tel" ||
        s.type === "url" ||
        s.type === "password")) ||
      e === "textarea" ||
      s.contentEditable === "true")
  );
}
function Oe(s) {
  var e = Me(),
    o = s.focusedElem,
    a = s.selectionRange;
  if (
    e !== o &&
    o &&
    o.ownerDocument &&
    Le(o.ownerDocument.documentElement, o)
  ) {
    if (a !== null && Ne(o)) {
      if (
        ((e = a.start),
        (s = a.end),
        s === void 0 && (s = e),
        "selectionStart" in o)
      )
        (o.selectionStart = e), (o.selectionEnd = Math.min(s, o.value.length));
      else if (
        ((s = ((e = o.ownerDocument || document) && e.defaultView) || window),
        s.getSelection)
      ) {
        s = s.getSelection();
        var c = o.textContent.length,
          d = Math.min(a.start, c);
        (a = a.end === void 0 ? d : Math.min(a.end, c)),
          !s.extend && d > a && ((c = a), (a = d), (d = c)),
          (c = Ke(o, d));
        var g = Ke(o, a);
        c &&
          g &&
          (s.rangeCount !== 1 ||
            s.anchorNode !== c.node ||
            s.anchorOffset !== c.offset ||
            s.focusNode !== g.node ||
            s.focusOffset !== g.offset) &&
          ((e = e.createRange()),
          e.setStart(c.node, c.offset),
          s.removeAllRanges(),
          d > a
            ? (s.addRange(e), s.extend(g.node, g.offset))
            : (e.setEnd(g.node, g.offset), s.addRange(e)));
      }
    }
    for (e = [], s = o; (s = s.parentNode); )
      s.nodeType === 1 &&
        e.push({ element: s, left: s.scrollLeft, top: s.scrollTop });
    for (typeof o.focus == "function" && o.focus(), o = 0; o < e.length; o++)
      (s = e[o]),
        (s.element.scrollLeft = s.left),
        (s.element.scrollTop = s.top);
  }
}
var Pe = ia && "documentMode" in document && 11 >= document.documentMode,
  Qe = null,
  Re = null,
  Se = null,
  Te = !1;
function Ue(s, e, o) {
  var a = o.window === o ? o.document : o.nodeType === 9 ? o : o.ownerDocument;
  Te ||
    Qe == null ||
    Qe !== Xa(a) ||
    ((a = Qe),
    "selectionStart" in a && Ne(a)
      ? (a = { start: a.selectionStart, end: a.selectionEnd })
      : ((a = (
          (a.ownerDocument && a.ownerDocument.defaultView) ||
          window
        ).getSelection()),
        (a = {
          anchorNode: a.anchorNode,
          anchorOffset: a.anchorOffset,
          focusNode: a.focusNode,
          focusOffset: a.focusOffset,
        })),
    (Se && Ie(Se, a)) ||
      ((Se = a),
      (a = oe(Re, "onSelect")),
      0 < a.length &&
        ((e = new td$1("onSelect", "select", null, e, o)),
        s.push({ event: e, listeners: a }),
        (e.target = Qe))));
}
function Ve(s, e) {
  var o = {};
  return (
    (o[s.toLowerCase()] = e.toLowerCase()),
    (o["Webkit" + s] = "webkit" + e),
    (o["Moz" + s] = "moz" + e),
    o
  );
}
var We = {
    animationend: Ve("Animation", "AnimationEnd"),
    animationiteration: Ve("Animation", "AnimationIteration"),
    animationstart: Ve("Animation", "AnimationStart"),
    transitionend: Ve("Transition", "TransitionEnd"),
  },
  Xe = {},
  Ye = {};
ia &&
  ((Ye = document.createElement("div").style),
  "AnimationEvent" in window ||
    (delete We.animationend.animation,
    delete We.animationiteration.animation,
    delete We.animationstart.animation),
  "TransitionEvent" in window || delete We.transitionend.transition);
function Ze(s) {
  if (Xe[s]) return Xe[s];
  if (!We[s]) return s;
  var e = We[s],
    o;
  for (o in e) if (e.hasOwnProperty(o) && o in Ye) return (Xe[s] = e[o]);
  return s;
}
var $e = Ze("animationend"),
  af = Ze("animationiteration"),
  bf = Ze("animationstart"),
  cf = Ze("transitionend"),
  df = new Map(),
  ef =
    "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(
      " "
    );
function ff(s, e) {
  df.set(s, e), fa(e, [s]);
}
for (var gf = 0; gf < ef.length; gf++) {
  var hf = ef[gf],
    jf = hf.toLowerCase(),
    kf = hf[0].toUpperCase() + hf.slice(1);
  ff(jf, "on" + kf);
}
ff($e, "onAnimationEnd");
ff(af, "onAnimationIteration");
ff(bf, "onAnimationStart");
ff("dblclick", "onDoubleClick");
ff("focusin", "onFocus");
ff("focusout", "onBlur");
ff(cf, "onTransitionEnd");
ha("onMouseEnter", ["mouseout", "mouseover"]);
ha("onMouseLeave", ["mouseout", "mouseover"]);
ha("onPointerEnter", ["pointerout", "pointerover"]);
ha("onPointerLeave", ["pointerout", "pointerover"]);
fa(
  "onChange",
  "change click focusin focusout input keydown keyup selectionchange".split(" ")
);
fa(
  "onSelect",
  "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(
    " "
  )
);
fa("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]);
fa(
  "onCompositionEnd",
  "compositionend focusout keydown keypress keyup mousedown".split(" ")
);
fa(
  "onCompositionStart",
  "compositionstart focusout keydown keypress keyup mousedown".split(" ")
);
fa(
  "onCompositionUpdate",
  "compositionupdate focusout keydown keypress keyup mousedown".split(" ")
);
var lf =
    "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(
      " "
    ),
  mf = new Set("cancel close invalid load scroll toggle".split(" ").concat(lf));
function nf(s, e, o) {
  var a = s.type || "unknown-event";
  (s.currentTarget = o), Ub(a, e, void 0, s), (s.currentTarget = null);
}
function se(s, e) {
  e = (e & 4) !== 0;
  for (var o = 0; o < s.length; o++) {
    var a = s[o],
      c = a.event;
    a = a.listeners;
    e: {
      var d = void 0;
      if (e)
        for (var g = a.length - 1; 0 <= g; g--) {
          var _ = a[g],
            b = _.instance,
            j = _.currentTarget;
          if (((_ = _.listener), b !== d && c.isPropagationStopped())) break e;
          nf(c, _, j), (d = b);
        }
      else
        for (g = 0; g < a.length; g++) {
          if (
            ((_ = a[g]),
            (b = _.instance),
            (j = _.currentTarget),
            (_ = _.listener),
            b !== d && c.isPropagationStopped())
          )
            break e;
          nf(c, _, j), (d = b);
        }
    }
  }
  if (Qb) throw ((s = Rb), (Qb = !1), (Rb = null), s);
}
function D(s, e) {
  var o = e[of];
  o === void 0 && (o = e[of] = new Set());
  var a = s + "__bubble";
  o.has(a) || (pf(e, s, 2, !1), o.add(a));
}
function qf(s, e, o) {
  var a = 0;
  e && (a |= 4), pf(o, s, a, e);
}
var rf = "_reactListening" + Math.random().toString(36).slice(2);
function sf(s) {
  if (!s[rf]) {
    (s[rf] = !0),
      da.forEach(function (o) {
        o !== "selectionchange" && (mf.has(o) || qf(o, !1, s), qf(o, !0, s));
      });
    var e = s.nodeType === 9 ? s : s.ownerDocument;
    e === null || e[rf] || ((e[rf] = !0), qf("selectionchange", !1, e));
  }
}
function pf(s, e, o, a) {
  switch (jd(e)) {
    case 1:
      var c = ed;
      break;
    case 4:
      c = gd;
      break;
    default:
      c = fd;
  }
  (o = c.bind(null, e, o, s)),
    (c = void 0),
    !Lb ||
      (e !== "touchstart" && e !== "touchmove" && e !== "wheel") ||
      (c = !0),
    a
      ? c !== void 0
        ? s.addEventListener(e, o, { capture: !0, passive: c })
        : s.addEventListener(e, o, !0)
      : c !== void 0
      ? s.addEventListener(e, o, { passive: c })
      : s.addEventListener(e, o, !1);
}
function hd(s, e, o, a, c) {
  var d = a;
  if (!(e & 1) && !(e & 2) && a !== null)
    e: for (;;) {
      if (a === null) return;
      var g = a.tag;
      if (g === 3 || g === 4) {
        var _ = a.stateNode.containerInfo;
        if (_ === c || (_.nodeType === 8 && _.parentNode === c)) break;
        if (g === 4)
          for (g = a.return; g !== null; ) {
            var b = g.tag;
            if (
              (b === 3 || b === 4) &&
              ((b = g.stateNode.containerInfo),
              b === c || (b.nodeType === 8 && b.parentNode === c))
            )
              return;
            g = g.return;
          }
        for (; _ !== null; ) {
          if (((g = Wc(_)), g === null)) return;
          if (((b = g.tag), b === 5 || b === 6)) {
            a = d = g;
            continue e;
          }
          _ = _.parentNode;
        }
      }
      a = a.return;
    }
  Jb(function () {
    var j = d,
      $ = xb(o),
      _e = [];
    e: {
      var et = df.get(s);
      if (et !== void 0) {
        var rt = td$1,
          st = s;
        switch (s) {
          case "keypress":
            if (od(o) === 0) break e;
          case "keydown":
          case "keyup":
            rt = Rd;
            break;
          case "focusin":
            (st = "focus"), (rt = Fd);
            break;
          case "focusout":
            (st = "blur"), (rt = Fd);
            break;
          case "beforeblur":
          case "afterblur":
            rt = Fd;
            break;
          case "click":
            if (o.button === 2) break e;
          case "auxclick":
          case "dblclick":
          case "mousedown":
          case "mousemove":
          case "mouseup":
          case "mouseout":
          case "mouseover":
          case "contextmenu":
            rt = Bd;
            break;
          case "drag":
          case "dragend":
          case "dragenter":
          case "dragexit":
          case "dragleave":
          case "dragover":
          case "dragstart":
          case "drop":
            rt = Dd;
            break;
          case "touchcancel":
          case "touchend":
          case "touchmove":
          case "touchstart":
            rt = Vd;
            break;
          case $e:
          case af:
          case bf:
            rt = Hd;
            break;
          case cf:
            rt = Xd;
            break;
          case "scroll":
            rt = vd;
            break;
          case "wheel":
            rt = Zd;
            break;
          case "copy":
          case "cut":
          case "paste":
            rt = Jd;
            break;
          case "gotpointercapture":
          case "lostpointercapture":
          case "pointercancel":
          case "pointerdown":
          case "pointermove":
          case "pointerout":
          case "pointerover":
          case "pointerup":
            rt = Td;
        }
        var at = (e & 4) !== 0,
          ct = !at && s === "scroll",
          it = at ? (et !== null ? et + "Capture" : null) : et;
        at = [];
        for (var lt = j, ot; lt !== null; ) {
          ot = lt;
          var ut = ot.stateNode;
          if (
            (ot.tag === 5 &&
              ut !== null &&
              ((ot = ut),
              it !== null &&
                ((ut = Kb(lt, it)), ut != null && at.push(tf(lt, ut, ot)))),
            ct)
          )
            break;
          lt = lt.return;
        }
        0 < at.length &&
          ((et = new rt(et, st, null, o, $)),
          _e.push({ event: et, listeners: at }));
      }
    }
    if (!(e & 7)) {
      e: {
        if (
          ((et = s === "mouseover" || s === "pointerover"),
          (rt = s === "mouseout" || s === "pointerout"),
          et &&
            o !== wb &&
            (st = o.relatedTarget || o.fromElement) &&
            (Wc(st) || st[uf]))
        )
          break e;
        if (
          (rt || et) &&
          ((et =
            $.window === $
              ? $
              : (et = $.ownerDocument)
              ? et.defaultView || et.parentWindow
              : window),
          rt
            ? ((st = o.relatedTarget || o.toElement),
              (rt = j),
              (st = st ? Wc(st) : null),
              st !== null &&
                ((ct = Vb(st)), st !== ct || (st.tag !== 5 && st.tag !== 6)) &&
                (st = null))
            : ((rt = null), (st = j)),
          rt !== st)
        ) {
          if (
            ((at = Bd),
            (ut = "onMouseLeave"),
            (it = "onMouseEnter"),
            (lt = "mouse"),
            (s === "pointerout" || s === "pointerover") &&
              ((at = Td),
              (ut = "onPointerLeave"),
              (it = "onPointerEnter"),
              (lt = "pointer")),
            (ct = rt == null ? et : ue(rt)),
            (ot = st == null ? et : ue(st)),
            (et = new at(ut, lt + "leave", rt, o, $)),
            (et.target = ct),
            (et.relatedTarget = ot),
            (ut = null),
            Wc($) === j &&
              ((at = new at(it, lt + "enter", st, o, $)),
              (at.target = ot),
              (at.relatedTarget = ct),
              (ut = at)),
            (ct = ut),
            rt && st)
          )
            t: {
              for (at = rt, it = st, lt = 0, ot = at; ot; ot = vf(ot)) lt++;
              for (ot = 0, ut = it; ut; ut = vf(ut)) ot++;
              for (; 0 < lt - ot; ) (at = vf(at)), lt--;
              for (; 0 < ot - lt; ) (it = vf(it)), ot--;
              for (; lt--; ) {
                if (at === it || (it !== null && at === it.alternate)) break t;
                (at = vf(at)), (it = vf(it));
              }
              at = null;
            }
          else at = null;
          rt !== null && wf(_e, et, rt, at, !1),
            st !== null && ct !== null && wf(_e, ct, st, at, !0);
        }
      }
      e: {
        if (
          ((et = j ? ue(j) : window),
          (rt = et.nodeName && et.nodeName.toLowerCase()),
          rt === "select" || (rt === "input" && et.type === "file"))
        )
          var pt = ve;
        else if (me(et))
          if (we) pt = Fe;
          else {
            pt = De;
            var ft = Ce;
          }
        else
          (rt = et.nodeName) &&
            rt.toLowerCase() === "input" &&
            (et.type === "checkbox" || et.type === "radio") &&
            (pt = Ee);
        if (pt && (pt = pt(s, j))) {
          ne(_e, pt, o, $);
          break e;
        }
        ft && ft(s, et, j),
          s === "focusout" &&
            (ft = et._wrapperState) &&
            ft.controlled &&
            et.type === "number" &&
            cb(et, "number", et.value);
      }
      switch (((ft = j ? ue(j) : window), s)) {
        case "focusin":
          (me(ft) || ft.contentEditable === "true") &&
            ((Qe = ft), (Re = j), (Se = null));
          break;
        case "focusout":
          Se = Re = Qe = null;
          break;
        case "mousedown":
          Te = !0;
          break;
        case "contextmenu":
        case "mouseup":
        case "dragend":
          (Te = !1), Ue(_e, o, $);
          break;
        case "selectionchange":
          if (Pe) break;
        case "keydown":
        case "keyup":
          Ue(_e, o, $);
      }
      var gt;
      if (ae)
        e: {
          switch (s) {
            case "compositionstart":
              var xt = "onCompositionStart";
              break e;
            case "compositionend":
              xt = "onCompositionEnd";
              break e;
            case "compositionupdate":
              xt = "onCompositionUpdate";
              break e;
          }
          xt = void 0;
        }
      else
        ie
          ? ge(s, o) && (xt = "onCompositionEnd")
          : s === "keydown" && o.keyCode === 229 && (xt = "onCompositionStart");
      xt &&
        (de &&
          o.locale !== "ko" &&
          (ie || xt !== "onCompositionStart"
            ? xt === "onCompositionEnd" && ie && (gt = nd())
            : ((kd = $),
              (ld = "value" in kd ? kd.value : kd.textContent),
              (ie = !0))),
        (ft = oe(j, xt)),
        0 < ft.length &&
          ((xt = new Ld(xt, s, null, o, $)),
          _e.push({ event: xt, listeners: ft }),
          gt ? (xt.data = gt) : ((gt = he(o)), gt !== null && (xt.data = gt)))),
        (gt = ce ? je(s, o) : ke(s, o)) &&
          ((j = oe(j, "onBeforeInput")),
          0 < j.length &&
            (($ = new Ld("onBeforeInput", "beforeinput", null, o, $)),
            _e.push({ event: $, listeners: j }),
            ($.data = gt)));
    }
    se(_e, e);
  });
}
function tf(s, e, o) {
  return { instance: s, listener: e, currentTarget: o };
}
function oe(s, e) {
  for (var o = e + "Capture", a = []; s !== null; ) {
    var c = s,
      d = c.stateNode;
    c.tag === 5 &&
      d !== null &&
      ((c = d),
      (d = Kb(s, o)),
      d != null && a.unshift(tf(s, d, c)),
      (d = Kb(s, e)),
      d != null && a.push(tf(s, d, c))),
      (s = s.return);
  }
  return a;
}
function vf(s) {
  if (s === null) return null;
  do s = s.return;
  while (s && s.tag !== 5);
  return s || null;
}
function wf(s, e, o, a, c) {
  for (var d = e._reactName, g = []; o !== null && o !== a; ) {
    var _ = o,
      b = _.alternate,
      j = _.stateNode;
    if (b !== null && b === a) break;
    _.tag === 5 &&
      j !== null &&
      ((_ = j),
      c
        ? ((b = Kb(o, d)), b != null && g.unshift(tf(o, b, _)))
        : c || ((b = Kb(o, d)), b != null && g.push(tf(o, b, _)))),
      (o = o.return);
  }
  g.length !== 0 && s.push({ event: e, listeners: g });
}
var xf = /\r\n?/g,
  yf = /\u0000|\uFFFD/g;
function zf(s) {
  return (typeof s == "string" ? s : "" + s)
    .replace(
      xf,
      `
`
    )
    .replace(yf, "");
}
function Af(s, e, o) {
  if (((e = zf(e)), zf(s) !== e && o)) throw Error(p$1(425));
}
function Bf() {}
var Cf = null,
  Df = null;
function Ef(s, e) {
  return (
    s === "textarea" ||
    s === "noscript" ||
    typeof e.children == "string" ||
    typeof e.children == "number" ||
    (typeof e.dangerouslySetInnerHTML == "object" &&
      e.dangerouslySetInnerHTML !== null &&
      e.dangerouslySetInnerHTML.__html != null)
  );
}
var Ff = typeof setTimeout == "function" ? setTimeout : void 0,
  Gf = typeof clearTimeout == "function" ? clearTimeout : void 0,
  Hf = typeof Promise == "function" ? Promise : void 0,
  Jf =
    typeof queueMicrotask == "function"
      ? queueMicrotask
      : typeof Hf < "u"
      ? function (s) {
          return Hf.resolve(null).then(s).catch(If);
        }
      : Ff;
function If(s) {
  setTimeout(function () {
    throw s;
  });
}
function Kf(s, e) {
  var o = e,
    a = 0;
  do {
    var c = o.nextSibling;
    if ((s.removeChild(o), c && c.nodeType === 8))
      if (((o = c.data), o === "/$")) {
        if (a === 0) {
          s.removeChild(c), bd(e);
          return;
        }
        a--;
      } else (o !== "$" && o !== "$?" && o !== "$!") || a++;
    o = c;
  } while (o);
  bd(e);
}
function Lf(s) {
  for (; s != null; s = s.nextSibling) {
    var e = s.nodeType;
    if (e === 1 || e === 3) break;
    if (e === 8) {
      if (((e = s.data), e === "$" || e === "$!" || e === "$?")) break;
      if (e === "/$") return null;
    }
  }
  return s;
}
function Mf(s) {
  s = s.previousSibling;
  for (var e = 0; s; ) {
    if (s.nodeType === 8) {
      var o = s.data;
      if (o === "$" || o === "$!" || o === "$?") {
        if (e === 0) return s;
        e--;
      } else o === "/$" && e++;
    }
    s = s.previousSibling;
  }
  return null;
}
var Nf = Math.random().toString(36).slice(2),
  Of = "__reactFiber$" + Nf,
  Pf = "__reactProps$" + Nf,
  uf = "__reactContainer$" + Nf,
  of = "__reactEvents$" + Nf,
  Qf = "__reactListeners$" + Nf,
  Rf = "__reactHandles$" + Nf;
function Wc(s) {
  var e = s[Of];
  if (e) return e;
  for (var o = s.parentNode; o; ) {
    if ((e = o[uf] || o[Of])) {
      if (
        ((o = e.alternate),
        e.child !== null || (o !== null && o.child !== null))
      )
        for (s = Mf(s); s !== null; ) {
          if ((o = s[Of])) return o;
          s = Mf(s);
        }
      return e;
    }
    (s = o), (o = s.parentNode);
  }
  return null;
}
function Cb(s) {
  return (
    (s = s[Of] || s[uf]),
    !s || (s.tag !== 5 && s.tag !== 6 && s.tag !== 13 && s.tag !== 3) ? null : s
  );
}
function ue(s) {
  if (s.tag === 5 || s.tag === 6) return s.stateNode;
  throw Error(p$1(33));
}
function Db(s) {
  return s[Pf] || null;
}
var Sf = [],
  Tf = -1;
function Uf(s) {
  return { current: s };
}
function E(s) {
  0 > Tf || ((s.current = Sf[Tf]), (Sf[Tf] = null), Tf--);
}
function G(s, e) {
  Tf++, (Sf[Tf] = s.current), (s.current = e);
}
var Vf = {},
  H = Uf(Vf),
  Wf = Uf(!1),
  Xf = Vf;
function Yf(s, e) {
  var o = s.type.contextTypes;
  if (!o) return Vf;
  var a = s.stateNode;
  if (a && a.__reactInternalMemoizedUnmaskedChildContext === e)
    return a.__reactInternalMemoizedMaskedChildContext;
  var c = {},
    d;
  for (d in o) c[d] = e[d];
  return (
    a &&
      ((s = s.stateNode),
      (s.__reactInternalMemoizedUnmaskedChildContext = e),
      (s.__reactInternalMemoizedMaskedChildContext = c)),
    c
  );
}
function Zf(s) {
  return (s = s.childContextTypes), s != null;
}
function $f() {
  E(Wf), E(H);
}
function ag(s, e, o) {
  if (H.current !== Vf) throw Error(p$1(168));
  G(H, e), G(Wf, o);
}
function bg$1(s, e, o) {
  var a = s.stateNode;
  if (((e = e.childContextTypes), typeof a.getChildContext != "function"))
    return o;
  a = a.getChildContext();
  for (var c in a) if (!(c in e)) throw Error(p$1(108, Ra(s) || "Unknown", c));
  return A({}, o, a);
}
function cg(s) {
  return (
    (s =
      ((s = s.stateNode) && s.__reactInternalMemoizedMergedChildContext) || Vf),
    (Xf = H.current),
    G(H, s),
    G(Wf, Wf.current),
    !0
  );
}
function dg(s, e, o) {
  var a = s.stateNode;
  if (!a) throw Error(p$1(169));
  o
    ? ((s = bg$1(s, e, Xf)),
      (a.__reactInternalMemoizedMergedChildContext = s),
      E(Wf),
      E(H),
      G(H, s))
    : E(Wf),
    G(Wf, o);
}
var eg = null,
  fg = !1,
  gg = !1;
function hg(s) {
  eg === null ? (eg = [s]) : eg.push(s);
}
function ig(s) {
  (fg = !0), hg(s);
}
function jg() {
  if (!gg && eg !== null) {
    gg = !0;
    var s = 0,
      e = C;
    try {
      var o = eg;
      for (C = 1; s < o.length; s++) {
        var a = o[s];
        do a = a(!0);
        while (a !== null);
      }
      (eg = null), (fg = !1);
    } catch (c) {
      throw (eg !== null && (eg = eg.slice(s + 1)), ac(fc, jg), c);
    } finally {
      (C = e), (gg = !1);
    }
  }
  return null;
}
var kg = [],
  lg = 0,
  mg = null,
  ng = 0,
  og = [],
  pg = 0,
  qg = null,
  rg = 1,
  sg = "";
function tg(s, e) {
  (kg[lg++] = ng), (kg[lg++] = mg), (mg = s), (ng = e);
}
function ug(s, e, o) {
  (og[pg++] = rg), (og[pg++] = sg), (og[pg++] = qg), (qg = s);
  var a = rg;
  s = sg;
  var c = 32 - oc(a) - 1;
  (a &= ~(1 << c)), (o += 1);
  var d = 32 - oc(e) + c;
  if (30 < d) {
    var g = c - (c % 5);
    (d = (a & ((1 << g) - 1)).toString(32)),
      (a >>= g),
      (c -= g),
      (rg = (1 << (32 - oc(e) + c)) | (o << c) | a),
      (sg = d + s);
  } else (rg = (1 << d) | (o << c) | a), (sg = s);
}
function vg(s) {
  s.return !== null && (tg(s, 1), ug(s, 1, 0));
}
function wg(s) {
  for (; s === mg; )
    (mg = kg[--lg]), (kg[lg] = null), (ng = kg[--lg]), (kg[lg] = null);
  for (; s === qg; )
    (qg = og[--pg]),
      (og[pg] = null),
      (sg = og[--pg]),
      (og[pg] = null),
      (rg = og[--pg]),
      (og[pg] = null);
}
var xg = null,
  yg = null,
  I = !1,
  zg = null;
function Ag(s, e) {
  var o = Bg(5, null, null, 0);
  (o.elementType = "DELETED"),
    (o.stateNode = e),
    (o.return = s),
    (e = s.deletions),
    e === null ? ((s.deletions = [o]), (s.flags |= 16)) : e.push(o);
}
function Cg(s, e) {
  switch (s.tag) {
    case 5:
      var o = s.type;
      return (
        (e =
          e.nodeType !== 1 || o.toLowerCase() !== e.nodeName.toLowerCase()
            ? null
            : e),
        e !== null
          ? ((s.stateNode = e), (xg = s), (yg = Lf(e.firstChild)), !0)
          : !1
      );
    case 6:
      return (
        (e = s.pendingProps === "" || e.nodeType !== 3 ? null : e),
        e !== null ? ((s.stateNode = e), (xg = s), (yg = null), !0) : !1
      );
    case 13:
      return (
        (e = e.nodeType !== 8 ? null : e),
        e !== null
          ? ((o = qg !== null ? { id: rg, overflow: sg } : null),
            (s.memoizedState = {
              dehydrated: e,
              treeContext: o,
              retryLane: 1073741824,
            }),
            (o = Bg(18, null, null, 0)),
            (o.stateNode = e),
            (o.return = s),
            (s.child = o),
            (xg = s),
            (yg = null),
            !0)
          : !1
      );
    default:
      return !1;
  }
}
function Dg(s) {
  return (s.mode & 1) !== 0 && (s.flags & 128) === 0;
}
function Eg(s) {
  if (I) {
    var e = yg;
    if (e) {
      var o = e;
      if (!Cg(s, e)) {
        if (Dg(s)) throw Error(p$1(418));
        e = Lf(o.nextSibling);
        var a = xg;
        e && Cg(s, e)
          ? Ag(a, o)
          : ((s.flags = (s.flags & -4097) | 2), (I = !1), (xg = s));
      }
    } else {
      if (Dg(s)) throw Error(p$1(418));
      (s.flags = (s.flags & -4097) | 2), (I = !1), (xg = s);
    }
  }
}
function Fg(s) {
  for (s = s.return; s !== null && s.tag !== 5 && s.tag !== 3 && s.tag !== 13; )
    s = s.return;
  xg = s;
}
function Gg(s) {
  if (s !== xg) return !1;
  if (!I) return Fg(s), (I = !0), !1;
  var e;
  if (
    ((e = s.tag !== 3) &&
      !(e = s.tag !== 5) &&
      ((e = s.type),
      (e = e !== "head" && e !== "body" && !Ef(s.type, s.memoizedProps))),
    e && (e = yg))
  ) {
    if (Dg(s)) throw (Hg(), Error(p$1(418)));
    for (; e; ) Ag(s, e), (e = Lf(e.nextSibling));
  }
  if ((Fg(s), s.tag === 13)) {
    if (((s = s.memoizedState), (s = s !== null ? s.dehydrated : null), !s))
      throw Error(p$1(317));
    e: {
      for (s = s.nextSibling, e = 0; s; ) {
        if (s.nodeType === 8) {
          var o = s.data;
          if (o === "/$") {
            if (e === 0) {
              yg = Lf(s.nextSibling);
              break e;
            }
            e--;
          } else (o !== "$" && o !== "$!" && o !== "$?") || e++;
        }
        s = s.nextSibling;
      }
      yg = null;
    }
  } else yg = xg ? Lf(s.stateNode.nextSibling) : null;
  return !0;
}
function Hg() {
  for (var s = yg; s; ) s = Lf(s.nextSibling);
}
function Ig() {
  (yg = xg = null), (I = !1);
}
function Jg(s) {
  zg === null ? (zg = [s]) : zg.push(s);
}
var Kg = ua.ReactCurrentBatchConfig;
function Lg(s, e, o) {
  if (
    ((s = o.ref), s !== null && typeof s != "function" && typeof s != "object")
  ) {
    if (o._owner) {
      if (((o = o._owner), o)) {
        if (o.tag !== 1) throw Error(p$1(309));
        var a = o.stateNode;
      }
      if (!a) throw Error(p$1(147, s));
      var c = a,
        d = "" + s;
      return e !== null &&
        e.ref !== null &&
        typeof e.ref == "function" &&
        e.ref._stringRef === d
        ? e.ref
        : ((e = function (g) {
            var _ = c.refs;
            g === null ? delete _[d] : (_[d] = g);
          }),
          (e._stringRef = d),
          e);
    }
    if (typeof s != "string") throw Error(p$1(284));
    if (!o._owner) throw Error(p$1(290, s));
  }
  return s;
}
function Mg(s, e) {
  throw (
    ((s = Object.prototype.toString.call(e)),
    Error(
      p$1(
        31,
        s === "[object Object]"
          ? "object with keys {" + Object.keys(e).join(", ") + "}"
          : s
      )
    ))
  );
}
function Ng(s) {
  var e = s._init;
  return e(s._payload);
}
function Og(s) {
  function e(it, lt) {
    if (s) {
      var ot = it.deletions;
      ot === null ? ((it.deletions = [lt]), (it.flags |= 16)) : ot.push(lt);
    }
  }
  function o(it, lt) {
    if (!s) return null;
    for (; lt !== null; ) e(it, lt), (lt = lt.sibling);
    return null;
  }
  function a(it, lt) {
    for (it = new Map(); lt !== null; )
      lt.key !== null ? it.set(lt.key, lt) : it.set(lt.index, lt),
        (lt = lt.sibling);
    return it;
  }
  function c(it, lt) {
    return (it = Pg(it, lt)), (it.index = 0), (it.sibling = null), it;
  }
  function d(it, lt, ot) {
    return (
      (it.index = ot),
      s
        ? ((ot = it.alternate),
          ot !== null
            ? ((ot = ot.index), ot < lt ? ((it.flags |= 2), lt) : ot)
            : ((it.flags |= 2), lt))
        : ((it.flags |= 1048576), lt)
    );
  }
  function g(it) {
    return s && it.alternate === null && (it.flags |= 2), it;
  }
  function _(it, lt, ot, ut) {
    return lt === null || lt.tag !== 6
      ? ((lt = Qg(ot, it.mode, ut)), (lt.return = it), lt)
      : ((lt = c(lt, ot)), (lt.return = it), lt);
  }
  function b(it, lt, ot, ut) {
    var pt = ot.type;
    return pt === ya
      ? $(it, lt, ot.props.children, ut, ot.key)
      : lt !== null &&
        (lt.elementType === pt ||
          (typeof pt == "object" &&
            pt !== null &&
            pt.$$typeof === Ha &&
            Ng(pt) === lt.type))
      ? ((ut = c(lt, ot.props)),
        (ut.ref = Lg(it, lt, ot)),
        (ut.return = it),
        ut)
      : ((ut = Rg(ot.type, ot.key, ot.props, null, it.mode, ut)),
        (ut.ref = Lg(it, lt, ot)),
        (ut.return = it),
        ut);
  }
  function j(it, lt, ot, ut) {
    return lt === null ||
      lt.tag !== 4 ||
      lt.stateNode.containerInfo !== ot.containerInfo ||
      lt.stateNode.implementation !== ot.implementation
      ? ((lt = Sg(ot, it.mode, ut)), (lt.return = it), lt)
      : ((lt = c(lt, ot.children || [])), (lt.return = it), lt);
  }
  function $(it, lt, ot, ut, pt) {
    return lt === null || lt.tag !== 7
      ? ((lt = Tg(ot, it.mode, ut, pt)), (lt.return = it), lt)
      : ((lt = c(lt, ot)), (lt.return = it), lt);
  }
  function _e(it, lt, ot) {
    if ((typeof lt == "string" && lt !== "") || typeof lt == "number")
      return (lt = Qg("" + lt, it.mode, ot)), (lt.return = it), lt;
    if (typeof lt == "object" && lt !== null) {
      switch (lt.$$typeof) {
        case va:
          return (
            (ot = Rg(lt.type, lt.key, lt.props, null, it.mode, ot)),
            (ot.ref = Lg(it, null, lt)),
            (ot.return = it),
            ot
          );
        case wa$1:
          return (lt = Sg(lt, it.mode, ot)), (lt.return = it), lt;
        case Ha:
          var ut = lt._init;
          return _e(it, ut(lt._payload), ot);
      }
      if (eb(lt) || Ka(lt))
        return (lt = Tg(lt, it.mode, ot, null)), (lt.return = it), lt;
      Mg(it, lt);
    }
    return null;
  }
  function et(it, lt, ot, ut) {
    var pt = lt !== null ? lt.key : null;
    if ((typeof ot == "string" && ot !== "") || typeof ot == "number")
      return pt !== null ? null : _(it, lt, "" + ot, ut);
    if (typeof ot == "object" && ot !== null) {
      switch (ot.$$typeof) {
        case va:
          return ot.key === pt ? b(it, lt, ot, ut) : null;
        case wa$1:
          return ot.key === pt ? j(it, lt, ot, ut) : null;
        case Ha:
          return (pt = ot._init), et(it, lt, pt(ot._payload), ut);
      }
      if (eb(ot) || Ka(ot)) return pt !== null ? null : $(it, lt, ot, ut, null);
      Mg(it, ot);
    }
    return null;
  }
  function rt(it, lt, ot, ut, pt) {
    if ((typeof ut == "string" && ut !== "") || typeof ut == "number")
      return (it = it.get(ot) || null), _(lt, it, "" + ut, pt);
    if (typeof ut == "object" && ut !== null) {
      switch (ut.$$typeof) {
        case va:
          return (
            (it = it.get(ut.key === null ? ot : ut.key) || null),
            b(lt, it, ut, pt)
          );
        case wa$1:
          return (
            (it = it.get(ut.key === null ? ot : ut.key) || null),
            j(lt, it, ut, pt)
          );
        case Ha:
          var ft = ut._init;
          return rt(it, lt, ot, ft(ut._payload), pt);
      }
      if (eb(ut) || Ka(ut))
        return (it = it.get(ot) || null), $(lt, it, ut, pt, null);
      Mg(lt, ut);
    }
    return null;
  }
  function st(it, lt, ot, ut) {
    for (
      var pt = null, ft = null, gt = lt, xt = (lt = 0), _t = null;
      gt !== null && xt < ot.length;
      xt++
    ) {
      gt.index > xt ? ((_t = gt), (gt = null)) : (_t = gt.sibling);
      var St = et(it, gt, ot[xt], ut);
      if (St === null) {
        gt === null && (gt = _t);
        break;
      }
      s && gt && St.alternate === null && e(it, gt),
        (lt = d(St, lt, xt)),
        ft === null ? (pt = St) : (ft.sibling = St),
        (ft = St),
        (gt = _t);
    }
    if (xt === ot.length) return o(it, gt), I && tg(it, xt), pt;
    if (gt === null) {
      for (; xt < ot.length; xt++)
        (gt = _e(it, ot[xt], ut)),
          gt !== null &&
            ((lt = d(gt, lt, xt)),
            ft === null ? (pt = gt) : (ft.sibling = gt),
            (ft = gt));
      return I && tg(it, xt), pt;
    }
    for (gt = a(it, gt); xt < ot.length; xt++)
      (_t = rt(gt, it, xt, ot[xt], ut)),
        _t !== null &&
          (s &&
            _t.alternate !== null &&
            gt.delete(_t.key === null ? xt : _t.key),
          (lt = d(_t, lt, xt)),
          ft === null ? (pt = _t) : (ft.sibling = _t),
          (ft = _t));
    return (
      s &&
        gt.forEach(function (Mt) {
          return e(it, Mt);
        }),
      I && tg(it, xt),
      pt
    );
  }
  function at(it, lt, ot, ut) {
    var pt = Ka(ot);
    if (typeof pt != "function") throw Error(p$1(150));
    if (((ot = pt.call(ot)), ot == null)) throw Error(p$1(151));
    for (
      var ft = (pt = null), gt = lt, xt = (lt = 0), _t = null, St = ot.next();
      gt !== null && !St.done;
      xt++, St = ot.next()
    ) {
      gt.index > xt ? ((_t = gt), (gt = null)) : (_t = gt.sibling);
      var Mt = et(it, gt, St.value, ut);
      if (Mt === null) {
        gt === null && (gt = _t);
        break;
      }
      s && gt && Mt.alternate === null && e(it, gt),
        (lt = d(Mt, lt, xt)),
        ft === null ? (pt = Mt) : (ft.sibling = Mt),
        (ft = Mt),
        (gt = _t);
    }
    if (St.done) return o(it, gt), I && tg(it, xt), pt;
    if (gt === null) {
      for (; !St.done; xt++, St = ot.next())
        (St = _e(it, St.value, ut)),
          St !== null &&
            ((lt = d(St, lt, xt)),
            ft === null ? (pt = St) : (ft.sibling = St),
            (ft = St));
      return I && tg(it, xt), pt;
    }
    for (gt = a(it, gt); !St.done; xt++, St = ot.next())
      (St = rt(gt, it, xt, St.value, ut)),
        St !== null &&
          (s &&
            St.alternate !== null &&
            gt.delete(St.key === null ? xt : St.key),
          (lt = d(St, lt, xt)),
          ft === null ? (pt = St) : (ft.sibling = St),
          (ft = St));
    return (
      s &&
        gt.forEach(function (Rt) {
          return e(it, Rt);
        }),
      I && tg(it, xt),
      pt
    );
  }
  function ct(it, lt, ot, ut) {
    if (
      (typeof ot == "object" &&
        ot !== null &&
        ot.type === ya &&
        ot.key === null &&
        (ot = ot.props.children),
      typeof ot == "object" && ot !== null)
    ) {
      switch (ot.$$typeof) {
        case va:
          e: {
            for (var pt = ot.key, ft = lt; ft !== null; ) {
              if (ft.key === pt) {
                if (((pt = ot.type), pt === ya)) {
                  if (ft.tag === 7) {
                    o(it, ft.sibling),
                      (lt = c(ft, ot.props.children)),
                      (lt.return = it),
                      (it = lt);
                    break e;
                  }
                } else if (
                  ft.elementType === pt ||
                  (typeof pt == "object" &&
                    pt !== null &&
                    pt.$$typeof === Ha &&
                    Ng(pt) === ft.type)
                ) {
                  o(it, ft.sibling),
                    (lt = c(ft, ot.props)),
                    (lt.ref = Lg(it, ft, ot)),
                    (lt.return = it),
                    (it = lt);
                  break e;
                }
                o(it, ft);
                break;
              } else e(it, ft);
              ft = ft.sibling;
            }
            ot.type === ya
              ? ((lt = Tg(ot.props.children, it.mode, ut, ot.key)),
                (lt.return = it),
                (it = lt))
              : ((ut = Rg(ot.type, ot.key, ot.props, null, it.mode, ut)),
                (ut.ref = Lg(it, lt, ot)),
                (ut.return = it),
                (it = ut));
          }
          return g(it);
        case wa$1:
          e: {
            for (ft = ot.key; lt !== null; ) {
              if (lt.key === ft)
                if (
                  lt.tag === 4 &&
                  lt.stateNode.containerInfo === ot.containerInfo &&
                  lt.stateNode.implementation === ot.implementation
                ) {
                  o(it, lt.sibling),
                    (lt = c(lt, ot.children || [])),
                    (lt.return = it),
                    (it = lt);
                  break e;
                } else {
                  o(it, lt);
                  break;
                }
              else e(it, lt);
              lt = lt.sibling;
            }
            (lt = Sg(ot, it.mode, ut)), (lt.return = it), (it = lt);
          }
          return g(it);
        case Ha:
          return (ft = ot._init), ct(it, lt, ft(ot._payload), ut);
      }
      if (eb(ot)) return st(it, lt, ot, ut);
      if (Ka(ot)) return at(it, lt, ot, ut);
      Mg(it, ot);
    }
    return (typeof ot == "string" && ot !== "") || typeof ot == "number"
      ? ((ot = "" + ot),
        lt !== null && lt.tag === 6
          ? (o(it, lt.sibling), (lt = c(lt, ot)), (lt.return = it), (it = lt))
          : (o(it, lt),
            (lt = Qg(ot, it.mode, ut)),
            (lt.return = it),
            (it = lt)),
        g(it))
      : o(it, lt);
  }
  return ct;
}
var Ug = Og(!0),
  Vg = Og(!1),
  Wg = Uf(null),
  Xg = null,
  Yg = null,
  Zg = null;
function $g() {
  Zg = Yg = Xg = null;
}
function ah(s) {
  var e = Wg.current;
  E(Wg), (s._currentValue = e);
}
function bh(s, e, o) {
  for (; s !== null; ) {
    var a = s.alternate;
    if (
      ((s.childLanes & e) !== e
        ? ((s.childLanes |= e), a !== null && (a.childLanes |= e))
        : a !== null && (a.childLanes & e) !== e && (a.childLanes |= e),
      s === o)
    )
      break;
    s = s.return;
  }
}
function ch$1(s, e) {
  (Xg = s),
    (Zg = Yg = null),
    (s = s.dependencies),
    s !== null &&
      s.firstContext !== null &&
      (s.lanes & e && (dh = !0), (s.firstContext = null));
}
function eh(s) {
  var e = s._currentValue;
  if (Zg !== s)
    if (((s = { context: s, memoizedValue: e, next: null }), Yg === null)) {
      if (Xg === null) throw Error(p$1(308));
      (Yg = s), (Xg.dependencies = { lanes: 0, firstContext: s });
    } else Yg = Yg.next = s;
  return e;
}
var fh = null;
function gh(s) {
  fh === null ? (fh = [s]) : fh.push(s);
}
function hh(s, e, o, a) {
  var c = e.interleaved;
  return (
    c === null ? ((o.next = o), gh(e)) : ((o.next = c.next), (c.next = o)),
    (e.interleaved = o),
    ih(s, a)
  );
}
function ih(s, e) {
  s.lanes |= e;
  var o = s.alternate;
  for (o !== null && (o.lanes |= e), o = s, s = s.return; s !== null; )
    (s.childLanes |= e),
      (o = s.alternate),
      o !== null && (o.childLanes |= e),
      (o = s),
      (s = s.return);
  return o.tag === 3 ? o.stateNode : null;
}
var jh = !1;
function kh(s) {
  s.updateQueue = {
    baseState: s.memoizedState,
    firstBaseUpdate: null,
    lastBaseUpdate: null,
    shared: { pending: null, interleaved: null, lanes: 0 },
    effects: null,
  };
}
function lh(s, e) {
  (s = s.updateQueue),
    e.updateQueue === s &&
      (e.updateQueue = {
        baseState: s.baseState,
        firstBaseUpdate: s.firstBaseUpdate,
        lastBaseUpdate: s.lastBaseUpdate,
        shared: s.shared,
        effects: s.effects,
      });
}
function mh(s, e) {
  return {
    eventTime: s,
    lane: e,
    tag: 0,
    payload: null,
    callback: null,
    next: null,
  };
}
function nh(s, e, o) {
  var a = s.updateQueue;
  if (a === null) return null;
  if (((a = a.shared), K & 2)) {
    var c = a.pending;
    return (
      c === null ? (e.next = e) : ((e.next = c.next), (c.next = e)),
      (a.pending = e),
      ih(s, o)
    );
  }
  return (
    (c = a.interleaved),
    c === null ? ((e.next = e), gh(a)) : ((e.next = c.next), (c.next = e)),
    (a.interleaved = e),
    ih(s, o)
  );
}
function oh(s, e, o) {
  if (
    ((e = e.updateQueue), e !== null && ((e = e.shared), (o & 4194240) !== 0))
  ) {
    var a = e.lanes;
    (a &= s.pendingLanes), (o |= a), (e.lanes = o), Cc(s, o);
  }
}
function ph(s, e) {
  var o = s.updateQueue,
    a = s.alternate;
  if (a !== null && ((a = a.updateQueue), o === a)) {
    var c = null,
      d = null;
    if (((o = o.firstBaseUpdate), o !== null)) {
      do {
        var g = {
          eventTime: o.eventTime,
          lane: o.lane,
          tag: o.tag,
          payload: o.payload,
          callback: o.callback,
          next: null,
        };
        d === null ? (c = d = g) : (d = d.next = g), (o = o.next);
      } while (o !== null);
      d === null ? (c = d = e) : (d = d.next = e);
    } else c = d = e;
    (o = {
      baseState: a.baseState,
      firstBaseUpdate: c,
      lastBaseUpdate: d,
      shared: a.shared,
      effects: a.effects,
    }),
      (s.updateQueue = o);
    return;
  }
  (s = o.lastBaseUpdate),
    s === null ? (o.firstBaseUpdate = e) : (s.next = e),
    (o.lastBaseUpdate = e);
}
function qh(s, e, o, a) {
  var c = s.updateQueue;
  jh = !1;
  var d = c.firstBaseUpdate,
    g = c.lastBaseUpdate,
    _ = c.shared.pending;
  if (_ !== null) {
    c.shared.pending = null;
    var b = _,
      j = b.next;
    (b.next = null), g === null ? (d = j) : (g.next = j), (g = b);
    var $ = s.alternate;
    $ !== null &&
      (($ = $.updateQueue),
      (_ = $.lastBaseUpdate),
      _ !== g &&
        (_ === null ? ($.firstBaseUpdate = j) : (_.next = j),
        ($.lastBaseUpdate = b)));
  }
  if (d !== null) {
    var _e = c.baseState;
    (g = 0), ($ = j = b = null), (_ = d);
    do {
      var et = _.lane,
        rt = _.eventTime;
      if ((a & et) === et) {
        $ !== null &&
          ($ = $.next =
            {
              eventTime: rt,
              lane: 0,
              tag: _.tag,
              payload: _.payload,
              callback: _.callback,
              next: null,
            });
        e: {
          var st = s,
            at = _;
          switch (((et = e), (rt = o), at.tag)) {
            case 1:
              if (((st = at.payload), typeof st == "function")) {
                _e = st.call(rt, _e, et);
                break e;
              }
              _e = st;
              break e;
            case 3:
              st.flags = (st.flags & -65537) | 128;
            case 0:
              if (
                ((st = at.payload),
                (et = typeof st == "function" ? st.call(rt, _e, et) : st),
                et == null)
              )
                break e;
              _e = A({}, _e, et);
              break e;
            case 2:
              jh = !0;
          }
        }
        _.callback !== null &&
          _.lane !== 0 &&
          ((s.flags |= 64),
          (et = c.effects),
          et === null ? (c.effects = [_]) : et.push(_));
      } else
        (rt = {
          eventTime: rt,
          lane: et,
          tag: _.tag,
          payload: _.payload,
          callback: _.callback,
          next: null,
        }),
          $ === null ? ((j = $ = rt), (b = _e)) : ($ = $.next = rt),
          (g |= et);
      if (((_ = _.next), _ === null)) {
        if (((_ = c.shared.pending), _ === null)) break;
        (et = _),
          (_ = et.next),
          (et.next = null),
          (c.lastBaseUpdate = et),
          (c.shared.pending = null);
      }
    } while (!0);
    if (
      ($ === null && (b = _e),
      (c.baseState = b),
      (c.firstBaseUpdate = j),
      (c.lastBaseUpdate = $),
      (e = c.shared.interleaved),
      e !== null)
    ) {
      c = e;
      do (g |= c.lane), (c = c.next);
      while (c !== e);
    } else d === null && (c.shared.lanes = 0);
    (rh |= g), (s.lanes = g), (s.memoizedState = _e);
  }
}
function sh(s, e, o) {
  if (((s = e.effects), (e.effects = null), s !== null))
    for (e = 0; e < s.length; e++) {
      var a = s[e],
        c = a.callback;
      if (c !== null) {
        if (((a.callback = null), (a = o), typeof c != "function"))
          throw Error(p$1(191, c));
        c.call(a);
      }
    }
}
var th = {},
  uh = Uf(th),
  vh$1 = Uf(th),
  wh = Uf(th);
function xh(s) {
  if (s === th) throw Error(p$1(174));
  return s;
}
function yh(s, e) {
  switch ((G(wh, e), G(vh$1, s), G(uh, th), (s = e.nodeType), s)) {
    case 9:
    case 11:
      e = (e = e.documentElement) ? e.namespaceURI : lb(null, "");
      break;
    default:
      (s = s === 8 ? e.parentNode : e),
        (e = s.namespaceURI || null),
        (s = s.tagName),
        (e = lb(e, s));
  }
  E(uh), G(uh, e);
}
function zh() {
  E(uh), E(vh$1), E(wh);
}
function Ah(s) {
  xh(wh.current);
  var e = xh(uh.current),
    o = lb(e, s.type);
  e !== o && (G(vh$1, s), G(uh, o));
}
function Bh(s) {
  vh$1.current === s && (E(uh), E(vh$1));
}
var L = Uf(0);
function Ch(s) {
  for (var e = s; e !== null; ) {
    if (e.tag === 13) {
      var o = e.memoizedState;
      if (
        o !== null &&
        ((o = o.dehydrated), o === null || o.data === "$?" || o.data === "$!")
      )
        return e;
    } else if (e.tag === 19 && e.memoizedProps.revealOrder !== void 0) {
      if (e.flags & 128) return e;
    } else if (e.child !== null) {
      (e.child.return = e), (e = e.child);
      continue;
    }
    if (e === s) break;
    for (; e.sibling === null; ) {
      if (e.return === null || e.return === s) return null;
      e = e.return;
    }
    (e.sibling.return = e.return), (e = e.sibling);
  }
  return null;
}
var Dh = [];
function Eh() {
  for (var s = 0; s < Dh.length; s++)
    Dh[s]._workInProgressVersionPrimary = null;
  Dh.length = 0;
}
var Fh = ua.ReactCurrentDispatcher,
  Gh = ua.ReactCurrentBatchConfig,
  Hh = 0,
  M = null,
  N = null,
  O = null,
  Ih = !1,
  Jh = !1,
  Kh = 0,
  Lh = 0;
function P() {
  throw Error(p$1(321));
}
function Mh(s, e) {
  if (e === null) return !1;
  for (var o = 0; o < e.length && o < s.length; o++)
    if (!He(s[o], e[o])) return !1;
  return !0;
}
function Nh(s, e, o, a, c, d) {
  if (
    ((Hh = d),
    (M = e),
    (e.memoizedState = null),
    (e.updateQueue = null),
    (e.lanes = 0),
    (Fh.current = s === null || s.memoizedState === null ? Oh : Ph),
    (s = o(a, c)),
    Jh)
  ) {
    d = 0;
    do {
      if (((Jh = !1), (Kh = 0), 25 <= d)) throw Error(p$1(301));
      (d += 1),
        (O = N = null),
        (e.updateQueue = null),
        (Fh.current = Qh),
        (s = o(a, c));
    } while (Jh);
  }
  if (
    ((Fh.current = Rh),
    (e = N !== null && N.next !== null),
    (Hh = 0),
    (O = N = M = null),
    (Ih = !1),
    e)
  )
    throw Error(p$1(300));
  return s;
}
function Sh() {
  var s = Kh !== 0;
  return (Kh = 0), s;
}
function Th() {
  var s = {
    memoizedState: null,
    baseState: null,
    baseQueue: null,
    queue: null,
    next: null,
  };
  return O === null ? (M.memoizedState = O = s) : (O = O.next = s), O;
}
function Uh() {
  if (N === null) {
    var s = M.alternate;
    s = s !== null ? s.memoizedState : null;
  } else s = N.next;
  var e = O === null ? M.memoizedState : O.next;
  if (e !== null) (O = e), (N = s);
  else {
    if (s === null) throw Error(p$1(310));
    (N = s),
      (s = {
        memoizedState: N.memoizedState,
        baseState: N.baseState,
        baseQueue: N.baseQueue,
        queue: N.queue,
        next: null,
      }),
      O === null ? (M.memoizedState = O = s) : (O = O.next = s);
  }
  return O;
}
function Vh(s, e) {
  return typeof e == "function" ? e(s) : e;
}
function Wh(s) {
  var e = Uh(),
    o = e.queue;
  if (o === null) throw Error(p$1(311));
  o.lastRenderedReducer = s;
  var a = N,
    c = a.baseQueue,
    d = o.pending;
  if (d !== null) {
    if (c !== null) {
      var g = c.next;
      (c.next = d.next), (d.next = g);
    }
    (a.baseQueue = c = d), (o.pending = null);
  }
  if (c !== null) {
    (d = c.next), (a = a.baseState);
    var _ = (g = null),
      b = null,
      j = d;
    do {
      var $ = j.lane;
      if ((Hh & $) === $)
        b !== null &&
          (b = b.next =
            {
              lane: 0,
              action: j.action,
              hasEagerState: j.hasEagerState,
              eagerState: j.eagerState,
              next: null,
            }),
          (a = j.hasEagerState ? j.eagerState : s(a, j.action));
      else {
        var _e = {
          lane: $,
          action: j.action,
          hasEagerState: j.hasEagerState,
          eagerState: j.eagerState,
          next: null,
        };
        b === null ? ((_ = b = _e), (g = a)) : (b = b.next = _e),
          (M.lanes |= $),
          (rh |= $);
      }
      j = j.next;
    } while (j !== null && j !== d);
    b === null ? (g = a) : (b.next = _),
      He(a, e.memoizedState) || (dh = !0),
      (e.memoizedState = a),
      (e.baseState = g),
      (e.baseQueue = b),
      (o.lastRenderedState = a);
  }
  if (((s = o.interleaved), s !== null)) {
    c = s;
    do (d = c.lane), (M.lanes |= d), (rh |= d), (c = c.next);
    while (c !== s);
  } else c === null && (o.lanes = 0);
  return [e.memoizedState, o.dispatch];
}
function Xh(s) {
  var e = Uh(),
    o = e.queue;
  if (o === null) throw Error(p$1(311));
  o.lastRenderedReducer = s;
  var a = o.dispatch,
    c = o.pending,
    d = e.memoizedState;
  if (c !== null) {
    o.pending = null;
    var g = (c = c.next);
    do (d = s(d, g.action)), (g = g.next);
    while (g !== c);
    He(d, e.memoizedState) || (dh = !0),
      (e.memoizedState = d),
      e.baseQueue === null && (e.baseState = d),
      (o.lastRenderedState = d);
  }
  return [d, a];
}
function Yh() {}
function Zh(s, e) {
  var o = M,
    a = Uh(),
    c = e(),
    d = !He(a.memoizedState, c);
  if (
    (d && ((a.memoizedState = c), (dh = !0)),
    (a = a.queue),
    $h(ai.bind(null, o, a, s), [s]),
    a.getSnapshot !== e || d || (O !== null && O.memoizedState.tag & 1))
  ) {
    if (
      ((o.flags |= 2048),
      bi(9, ci.bind(null, o, a, c, e), void 0, null),
      Q === null)
    )
      throw Error(p$1(349));
    Hh & 30 || di(o, e, c);
  }
  return c;
}
function di(s, e, o) {
  (s.flags |= 16384),
    (s = { getSnapshot: e, value: o }),
    (e = M.updateQueue),
    e === null
      ? ((e = { lastEffect: null, stores: null }),
        (M.updateQueue = e),
        (e.stores = [s]))
      : ((o = e.stores), o === null ? (e.stores = [s]) : o.push(s));
}
function ci(s, e, o, a) {
  (e.value = o), (e.getSnapshot = a), ei(e) && fi(s);
}
function ai(s, e, o) {
  return o(function () {
    ei(e) && fi(s);
  });
}
function ei(s) {
  var e = s.getSnapshot;
  s = s.value;
  try {
    var o = e();
    return !He(s, o);
  } catch {
    return !0;
  }
}
function fi(s) {
  var e = ih(s, 1);
  e !== null && gi(e, s, 1, -1);
}
function hi(s) {
  var e = Th();
  return (
    typeof s == "function" && (s = s()),
    (e.memoizedState = e.baseState = s),
    (s = {
      pending: null,
      interleaved: null,
      lanes: 0,
      dispatch: null,
      lastRenderedReducer: Vh,
      lastRenderedState: s,
    }),
    (e.queue = s),
    (s = s.dispatch = ii.bind(null, M, s)),
    [e.memoizedState, s]
  );
}
function bi(s, e, o, a) {
  return (
    (s = { tag: s, create: e, destroy: o, deps: a, next: null }),
    (e = M.updateQueue),
    e === null
      ? ((e = { lastEffect: null, stores: null }),
        (M.updateQueue = e),
        (e.lastEffect = s.next = s))
      : ((o = e.lastEffect),
        o === null
          ? (e.lastEffect = s.next = s)
          : ((a = o.next), (o.next = s), (s.next = a), (e.lastEffect = s))),
    s
  );
}
function ji() {
  return Uh().memoizedState;
}
function ki(s, e, o, a) {
  var c = Th();
  (M.flags |= s),
    (c.memoizedState = bi(1 | e, o, void 0, a === void 0 ? null : a));
}
function li(s, e, o, a) {
  var c = Uh();
  a = a === void 0 ? null : a;
  var d = void 0;
  if (N !== null) {
    var g = N.memoizedState;
    if (((d = g.destroy), a !== null && Mh(a, g.deps))) {
      c.memoizedState = bi(e, o, d, a);
      return;
    }
  }
  (M.flags |= s), (c.memoizedState = bi(1 | e, o, d, a));
}
function mi(s, e) {
  return ki(8390656, 8, s, e);
}
function $h(s, e) {
  return li(2048, 8, s, e);
}
function ni(s, e) {
  return li(4, 2, s, e);
}
function oi(s, e) {
  return li(4, 4, s, e);
}
function pi(s, e) {
  if (typeof e == "function")
    return (
      (s = s()),
      e(s),
      function () {
        e(null);
      }
    );
  if (e != null)
    return (
      (s = s()),
      (e.current = s),
      function () {
        e.current = null;
      }
    );
}
function qi(s, e, o) {
  return (
    (o = o != null ? o.concat([s]) : null), li(4, 4, pi.bind(null, e, s), o)
  );
}
function ri() {}
function si(s, e) {
  var o = Uh();
  e = e === void 0 ? null : e;
  var a = o.memoizedState;
  return a !== null && e !== null && Mh(e, a[1])
    ? a[0]
    : ((o.memoizedState = [s, e]), s);
}
function ti(s, e) {
  var o = Uh();
  e = e === void 0 ? null : e;
  var a = o.memoizedState;
  return a !== null && e !== null && Mh(e, a[1])
    ? a[0]
    : ((s = s()), (o.memoizedState = [s, e]), s);
}
function ui(s, e, o) {
  return Hh & 21
    ? (He(o, e) || ((o = yc()), (M.lanes |= o), (rh |= o), (s.baseState = !0)),
      e)
    : (s.baseState && ((s.baseState = !1), (dh = !0)), (s.memoizedState = o));
}
function vi(s, e) {
  var o = C;
  (C = o !== 0 && 4 > o ? o : 4), s(!0);
  var a = Gh.transition;
  Gh.transition = {};
  try {
    s(!1), e();
  } finally {
    (C = o), (Gh.transition = a);
  }
}
function wi() {
  return Uh().memoizedState;
}
function xi(s, e, o) {
  var a = yi(s);
  if (
    ((o = {
      lane: a,
      action: o,
      hasEagerState: !1,
      eagerState: null,
      next: null,
    }),
    zi(s))
  )
    Ai(e, o);
  else if (((o = hh(s, e, o, a)), o !== null)) {
    var c = R();
    gi(o, s, a, c), Bi(o, e, a);
  }
}
function ii(s, e, o) {
  var a = yi(s),
    c = { lane: a, action: o, hasEagerState: !1, eagerState: null, next: null };
  if (zi(s)) Ai(e, c);
  else {
    var d = s.alternate;
    if (
      s.lanes === 0 &&
      (d === null || d.lanes === 0) &&
      ((d = e.lastRenderedReducer), d !== null)
    )
      try {
        var g = e.lastRenderedState,
          _ = d(g, o);
        if (((c.hasEagerState = !0), (c.eagerState = _), He(_, g))) {
          var b = e.interleaved;
          b === null
            ? ((c.next = c), gh(e))
            : ((c.next = b.next), (b.next = c)),
            (e.interleaved = c);
          return;
        }
      } catch {
      } finally {
      }
    (o = hh(s, e, c, a)),
      o !== null && ((c = R()), gi(o, s, a, c), Bi(o, e, a));
  }
}
function zi(s) {
  var e = s.alternate;
  return s === M || (e !== null && e === M);
}
function Ai(s, e) {
  Jh = Ih = !0;
  var o = s.pending;
  o === null ? (e.next = e) : ((e.next = o.next), (o.next = e)),
    (s.pending = e);
}
function Bi(s, e, o) {
  if (o & 4194240) {
    var a = e.lanes;
    (a &= s.pendingLanes), (o |= a), (e.lanes = o), Cc(s, o);
  }
}
var Rh = {
    readContext: eh,
    useCallback: P,
    useContext: P,
    useEffect: P,
    useImperativeHandle: P,
    useInsertionEffect: P,
    useLayoutEffect: P,
    useMemo: P,
    useReducer: P,
    useRef: P,
    useState: P,
    useDebugValue: P,
    useDeferredValue: P,
    useTransition: P,
    useMutableSource: P,
    useSyncExternalStore: P,
    useId: P,
    unstable_isNewReconciler: !1,
  },
  Oh = {
    readContext: eh,
    useCallback: function (s, e) {
      return (Th().memoizedState = [s, e === void 0 ? null : e]), s;
    },
    useContext: eh,
    useEffect: mi,
    useImperativeHandle: function (s, e, o) {
      return (
        (o = o != null ? o.concat([s]) : null),
        ki(4194308, 4, pi.bind(null, e, s), o)
      );
    },
    useLayoutEffect: function (s, e) {
      return ki(4194308, 4, s, e);
    },
    useInsertionEffect: function (s, e) {
      return ki(4, 2, s, e);
    },
    useMemo: function (s, e) {
      var o = Th();
      return (
        (e = e === void 0 ? null : e), (s = s()), (o.memoizedState = [s, e]), s
      );
    },
    useReducer: function (s, e, o) {
      var a = Th();
      return (
        (e = o !== void 0 ? o(e) : e),
        (a.memoizedState = a.baseState = e),
        (s = {
          pending: null,
          interleaved: null,
          lanes: 0,
          dispatch: null,
          lastRenderedReducer: s,
          lastRenderedState: e,
        }),
        (a.queue = s),
        (s = s.dispatch = xi.bind(null, M, s)),
        [a.memoizedState, s]
      );
    },
    useRef: function (s) {
      var e = Th();
      return (s = { current: s }), (e.memoizedState = s);
    },
    useState: hi,
    useDebugValue: ri,
    useDeferredValue: function (s) {
      return (Th().memoizedState = s);
    },
    useTransition: function () {
      var s = hi(!1),
        e = s[0];
      return (s = vi.bind(null, s[1])), (Th().memoizedState = s), [e, s];
    },
    useMutableSource: function () {},
    useSyncExternalStore: function (s, e, o) {
      var a = M,
        c = Th();
      if (I) {
        if (o === void 0) throw Error(p$1(407));
        o = o();
      } else {
        if (((o = e()), Q === null)) throw Error(p$1(349));
        Hh & 30 || di(a, e, o);
      }
      c.memoizedState = o;
      var d = { value: o, getSnapshot: e };
      return (
        (c.queue = d),
        mi(ai.bind(null, a, d, s), [s]),
        (a.flags |= 2048),
        bi(9, ci.bind(null, a, d, o, e), void 0, null),
        o
      );
    },
    useId: function () {
      var s = Th(),
        e = Q.identifierPrefix;
      if (I) {
        var o = sg,
          a = rg;
        (o = (a & ~(1 << (32 - oc(a) - 1))).toString(32) + o),
          (e = ":" + e + "R" + o),
          (o = Kh++),
          0 < o && (e += "H" + o.toString(32)),
          (e += ":");
      } else (o = Lh++), (e = ":" + e + "r" + o.toString(32) + ":");
      return (s.memoizedState = e);
    },
    unstable_isNewReconciler: !1,
  },
  Ph = {
    readContext: eh,
    useCallback: si,
    useContext: eh,
    useEffect: $h,
    useImperativeHandle: qi,
    useInsertionEffect: ni,
    useLayoutEffect: oi,
    useMemo: ti,
    useReducer: Wh,
    useRef: ji,
    useState: function () {
      return Wh(Vh);
    },
    useDebugValue: ri,
    useDeferredValue: function (s) {
      var e = Uh();
      return ui(e, N.memoizedState, s);
    },
    useTransition: function () {
      var s = Wh(Vh)[0],
        e = Uh().memoizedState;
      return [s, e];
    },
    useMutableSource: Yh,
    useSyncExternalStore: Zh,
    useId: wi,
    unstable_isNewReconciler: !1,
  },
  Qh = {
    readContext: eh,
    useCallback: si,
    useContext: eh,
    useEffect: $h,
    useImperativeHandle: qi,
    useInsertionEffect: ni,
    useLayoutEffect: oi,
    useMemo: ti,
    useReducer: Xh,
    useRef: ji,
    useState: function () {
      return Xh(Vh);
    },
    useDebugValue: ri,
    useDeferredValue: function (s) {
      var e = Uh();
      return N === null ? (e.memoizedState = s) : ui(e, N.memoizedState, s);
    },
    useTransition: function () {
      var s = Xh(Vh)[0],
        e = Uh().memoizedState;
      return [s, e];
    },
    useMutableSource: Yh,
    useSyncExternalStore: Zh,
    useId: wi,
    unstable_isNewReconciler: !1,
  };
function Ci(s, e) {
  if (s && s.defaultProps) {
    (e = A({}, e)), (s = s.defaultProps);
    for (var o in s) e[o] === void 0 && (e[o] = s[o]);
    return e;
  }
  return e;
}
function Di(s, e, o, a) {
  (e = s.memoizedState),
    (o = o(a, e)),
    (o = o == null ? e : A({}, e, o)),
    (s.memoizedState = o),
    s.lanes === 0 && (s.updateQueue.baseState = o);
}
var Ei = {
  isMounted: function (s) {
    return (s = s._reactInternals) ? Vb(s) === s : !1;
  },
  enqueueSetState: function (s, e, o) {
    s = s._reactInternals;
    var a = R(),
      c = yi(s),
      d = mh(a, c);
    (d.payload = e),
      o != null && (d.callback = o),
      (e = nh(s, d, c)),
      e !== null && (gi(e, s, c, a), oh(e, s, c));
  },
  enqueueReplaceState: function (s, e, o) {
    s = s._reactInternals;
    var a = R(),
      c = yi(s),
      d = mh(a, c);
    (d.tag = 1),
      (d.payload = e),
      o != null && (d.callback = o),
      (e = nh(s, d, c)),
      e !== null && (gi(e, s, c, a), oh(e, s, c));
  },
  enqueueForceUpdate: function (s, e) {
    s = s._reactInternals;
    var o = R(),
      a = yi(s),
      c = mh(o, a);
    (c.tag = 2),
      e != null && (c.callback = e),
      (e = nh(s, c, a)),
      e !== null && (gi(e, s, a, o), oh(e, s, a));
  },
};
function Fi(s, e, o, a, c, d, g) {
  return (
    (s = s.stateNode),
    typeof s.shouldComponentUpdate == "function"
      ? s.shouldComponentUpdate(a, d, g)
      : e.prototype && e.prototype.isPureReactComponent
      ? !Ie(o, a) || !Ie(c, d)
      : !0
  );
}
function Gi(s, e, o) {
  var a = !1,
    c = Vf,
    d = e.contextType;
  return (
    typeof d == "object" && d !== null
      ? (d = eh(d))
      : ((c = Zf(e) ? Xf : H.current),
        (a = e.contextTypes),
        (d = (a = a != null) ? Yf(s, c) : Vf)),
    (e = new e(o, d)),
    (s.memoizedState = e.state !== null && e.state !== void 0 ? e.state : null),
    (e.updater = Ei),
    (s.stateNode = e),
    (e._reactInternals = s),
    a &&
      ((s = s.stateNode),
      (s.__reactInternalMemoizedUnmaskedChildContext = c),
      (s.__reactInternalMemoizedMaskedChildContext = d)),
    e
  );
}
function Hi(s, e, o, a) {
  (s = e.state),
    typeof e.componentWillReceiveProps == "function" &&
      e.componentWillReceiveProps(o, a),
    typeof e.UNSAFE_componentWillReceiveProps == "function" &&
      e.UNSAFE_componentWillReceiveProps(o, a),
    e.state !== s && Ei.enqueueReplaceState(e, e.state, null);
}
function Ii(s, e, o, a) {
  var c = s.stateNode;
  (c.props = o), (c.state = s.memoizedState), (c.refs = {}), kh(s);
  var d = e.contextType;
  typeof d == "object" && d !== null
    ? (c.context = eh(d))
    : ((d = Zf(e) ? Xf : H.current), (c.context = Yf(s, d))),
    (c.state = s.memoizedState),
    (d = e.getDerivedStateFromProps),
    typeof d == "function" && (Di(s, e, d, o), (c.state = s.memoizedState)),
    typeof e.getDerivedStateFromProps == "function" ||
      typeof c.getSnapshotBeforeUpdate == "function" ||
      (typeof c.UNSAFE_componentWillMount != "function" &&
        typeof c.componentWillMount != "function") ||
      ((e = c.state),
      typeof c.componentWillMount == "function" && c.componentWillMount(),
      typeof c.UNSAFE_componentWillMount == "function" &&
        c.UNSAFE_componentWillMount(),
      e !== c.state && Ei.enqueueReplaceState(c, c.state, null),
      qh(s, o, c, a),
      (c.state = s.memoizedState)),
    typeof c.componentDidMount == "function" && (s.flags |= 4194308);
}
function Ji(s, e) {
  try {
    var o = "",
      a = e;
    do (o += Pa(a)), (a = a.return);
    while (a);
    var c = o;
  } catch (d) {
    c =
      `
Error generating stack: ` +
      d.message +
      `
` +
      d.stack;
  }
  return { value: s, source: e, stack: c, digest: null };
}
function Ki(s, e, o) {
  return { value: s, source: null, stack: o ?? null, digest: e ?? null };
}
function Li(s, e) {
  try {
    console.error(e.value);
  } catch (o) {
    setTimeout(function () {
      throw o;
    });
  }
}
var Mi = typeof WeakMap == "function" ? WeakMap : Map;
function Ni(s, e, o) {
  (o = mh(-1, o)), (o.tag = 3), (o.payload = { element: null });
  var a = e.value;
  return (
    (o.callback = function () {
      Oi || ((Oi = !0), (Pi = a)), Li(s, e);
    }),
    o
  );
}
function Qi(s, e, o) {
  (o = mh(-1, o)), (o.tag = 3);
  var a = s.type.getDerivedStateFromError;
  if (typeof a == "function") {
    var c = e.value;
    (o.payload = function () {
      return a(c);
    }),
      (o.callback = function () {
        Li(s, e);
      });
  }
  var d = s.stateNode;
  return (
    d !== null &&
      typeof d.componentDidCatch == "function" &&
      (o.callback = function () {
        Li(s, e),
          typeof a != "function" &&
            (Ri === null ? (Ri = new Set([this])) : Ri.add(this));
        var g = e.stack;
        this.componentDidCatch(e.value, {
          componentStack: g !== null ? g : "",
        });
      }),
    o
  );
}
function Si(s, e, o) {
  var a = s.pingCache;
  if (a === null) {
    a = s.pingCache = new Mi();
    var c = new Set();
    a.set(e, c);
  } else (c = a.get(e)), c === void 0 && ((c = new Set()), a.set(e, c));
  c.has(o) || (c.add(o), (s = Ti.bind(null, s, e, o)), e.then(s, s));
}
function Ui(s) {
  do {
    var e;
    if (
      ((e = s.tag === 13) &&
        ((e = s.memoizedState), (e = e !== null ? e.dehydrated !== null : !0)),
      e)
    )
      return s;
    s = s.return;
  } while (s !== null);
  return null;
}
function Vi(s, e, o, a, c) {
  return s.mode & 1
    ? ((s.flags |= 65536), (s.lanes = c), s)
    : (s === e
        ? (s.flags |= 65536)
        : ((s.flags |= 128),
          (o.flags |= 131072),
          (o.flags &= -52805),
          o.tag === 1 &&
            (o.alternate === null
              ? (o.tag = 17)
              : ((e = mh(-1, 1)), (e.tag = 2), nh(o, e, 1))),
          (o.lanes |= 1)),
      s);
}
var Wi = ua.ReactCurrentOwner,
  dh = !1;
function Xi(s, e, o, a) {
  e.child = s === null ? Vg(e, null, o, a) : Ug(e, s.child, o, a);
}
function Yi(s, e, o, a, c) {
  o = o.render;
  var d = e.ref;
  return (
    ch$1(e, c),
    (a = Nh(s, e, o, a, d, c)),
    (o = Sh()),
    s !== null && !dh
      ? ((e.updateQueue = s.updateQueue),
        (e.flags &= -2053),
        (s.lanes &= ~c),
        Zi(s, e, c))
      : (I && o && vg(e), (e.flags |= 1), Xi(s, e, a, c), e.child)
  );
}
function $i(s, e, o, a, c) {
  if (s === null) {
    var d = o.type;
    return typeof d == "function" &&
      !aj(d) &&
      d.defaultProps === void 0 &&
      o.compare === null &&
      o.defaultProps === void 0
      ? ((e.tag = 15), (e.type = d), bj(s, e, d, a, c))
      : ((s = Rg(o.type, null, a, e, e.mode, c)),
        (s.ref = e.ref),
        (s.return = e),
        (e.child = s));
  }
  if (((d = s.child), !(s.lanes & c))) {
    var g = d.memoizedProps;
    if (
      ((o = o.compare), (o = o !== null ? o : Ie), o(g, a) && s.ref === e.ref)
    )
      return Zi(s, e, c);
  }
  return (
    (e.flags |= 1),
    (s = Pg(d, a)),
    (s.ref = e.ref),
    (s.return = e),
    (e.child = s)
  );
}
function bj(s, e, o, a, c) {
  if (s !== null) {
    var d = s.memoizedProps;
    if (Ie(d, a) && s.ref === e.ref)
      if (((dh = !1), (e.pendingProps = a = d), (s.lanes & c) !== 0))
        s.flags & 131072 && (dh = !0);
      else return (e.lanes = s.lanes), Zi(s, e, c);
  }
  return cj(s, e, o, a, c);
}
function dj(s, e, o) {
  var a = e.pendingProps,
    c = a.children,
    d = s !== null ? s.memoizedState : null;
  if (a.mode === "hidden")
    if (!(e.mode & 1))
      (e.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }),
        G(ej, fj),
        (fj |= o);
    else {
      if (!(o & 1073741824))
        return (
          (s = d !== null ? d.baseLanes | o : o),
          (e.lanes = e.childLanes = 1073741824),
          (e.memoizedState = {
            baseLanes: s,
            cachePool: null,
            transitions: null,
          }),
          (e.updateQueue = null),
          G(ej, fj),
          (fj |= s),
          null
        );
      (e.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }),
        (a = d !== null ? d.baseLanes : o),
        G(ej, fj),
        (fj |= a);
    }
  else
    d !== null ? ((a = d.baseLanes | o), (e.memoizedState = null)) : (a = o),
      G(ej, fj),
      (fj |= a);
  return Xi(s, e, c, o), e.child;
}
function gj(s, e) {
  var o = e.ref;
  ((s === null && o !== null) || (s !== null && s.ref !== o)) &&
    ((e.flags |= 512), (e.flags |= 2097152));
}
function cj(s, e, o, a, c) {
  var d = Zf(o) ? Xf : H.current;
  return (
    (d = Yf(e, d)),
    ch$1(e, c),
    (o = Nh(s, e, o, a, d, c)),
    (a = Sh()),
    s !== null && !dh
      ? ((e.updateQueue = s.updateQueue),
        (e.flags &= -2053),
        (s.lanes &= ~c),
        Zi(s, e, c))
      : (I && a && vg(e), (e.flags |= 1), Xi(s, e, o, c), e.child)
  );
}
function hj(s, e, o, a, c) {
  if (Zf(o)) {
    var d = !0;
    cg(e);
  } else d = !1;
  if ((ch$1(e, c), e.stateNode === null))
    ij(s, e), Gi(e, o, a), Ii(e, o, a, c), (a = !0);
  else if (s === null) {
    var g = e.stateNode,
      _ = e.memoizedProps;
    g.props = _;
    var b = g.context,
      j = o.contextType;
    typeof j == "object" && j !== null
      ? (j = eh(j))
      : ((j = Zf(o) ? Xf : H.current), (j = Yf(e, j)));
    var $ = o.getDerivedStateFromProps,
      _e =
        typeof $ == "function" ||
        typeof g.getSnapshotBeforeUpdate == "function";
    _e ||
      (typeof g.UNSAFE_componentWillReceiveProps != "function" &&
        typeof g.componentWillReceiveProps != "function") ||
      ((_ !== a || b !== j) && Hi(e, g, a, j)),
      (jh = !1);
    var et = e.memoizedState;
    (g.state = et),
      qh(e, a, g, c),
      (b = e.memoizedState),
      _ !== a || et !== b || Wf.current || jh
        ? (typeof $ == "function" && (Di(e, o, $, a), (b = e.memoizedState)),
          (_ = jh || Fi(e, o, _, a, et, b, j))
            ? (_e ||
                (typeof g.UNSAFE_componentWillMount != "function" &&
                  typeof g.componentWillMount != "function") ||
                (typeof g.componentWillMount == "function" &&
                  g.componentWillMount(),
                typeof g.UNSAFE_componentWillMount == "function" &&
                  g.UNSAFE_componentWillMount()),
              typeof g.componentDidMount == "function" && (e.flags |= 4194308))
            : (typeof g.componentDidMount == "function" && (e.flags |= 4194308),
              (e.memoizedProps = a),
              (e.memoizedState = b)),
          (g.props = a),
          (g.state = b),
          (g.context = j),
          (a = _))
        : (typeof g.componentDidMount == "function" && (e.flags |= 4194308),
          (a = !1));
  } else {
    (g = e.stateNode),
      lh(s, e),
      (_ = e.memoizedProps),
      (j = e.type === e.elementType ? _ : Ci(e.type, _)),
      (g.props = j),
      (_e = e.pendingProps),
      (et = g.context),
      (b = o.contextType),
      typeof b == "object" && b !== null
        ? (b = eh(b))
        : ((b = Zf(o) ? Xf : H.current), (b = Yf(e, b)));
    var rt = o.getDerivedStateFromProps;
    ($ =
      typeof rt == "function" ||
      typeof g.getSnapshotBeforeUpdate == "function") ||
      (typeof g.UNSAFE_componentWillReceiveProps != "function" &&
        typeof g.componentWillReceiveProps != "function") ||
      ((_ !== _e || et !== b) && Hi(e, g, a, b)),
      (jh = !1),
      (et = e.memoizedState),
      (g.state = et),
      qh(e, a, g, c);
    var st = e.memoizedState;
    _ !== _e || et !== st || Wf.current || jh
      ? (typeof rt == "function" && (Di(e, o, rt, a), (st = e.memoizedState)),
        (j = jh || Fi(e, o, j, a, et, st, b) || !1)
          ? ($ ||
              (typeof g.UNSAFE_componentWillUpdate != "function" &&
                typeof g.componentWillUpdate != "function") ||
              (typeof g.componentWillUpdate == "function" &&
                g.componentWillUpdate(a, st, b),
              typeof g.UNSAFE_componentWillUpdate == "function" &&
                g.UNSAFE_componentWillUpdate(a, st, b)),
            typeof g.componentDidUpdate == "function" && (e.flags |= 4),
            typeof g.getSnapshotBeforeUpdate == "function" && (e.flags |= 1024))
          : (typeof g.componentDidUpdate != "function" ||
              (_ === s.memoizedProps && et === s.memoizedState) ||
              (e.flags |= 4),
            typeof g.getSnapshotBeforeUpdate != "function" ||
              (_ === s.memoizedProps && et === s.memoizedState) ||
              (e.flags |= 1024),
            (e.memoizedProps = a),
            (e.memoizedState = st)),
        (g.props = a),
        (g.state = st),
        (g.context = b),
        (a = j))
      : (typeof g.componentDidUpdate != "function" ||
          (_ === s.memoizedProps && et === s.memoizedState) ||
          (e.flags |= 4),
        typeof g.getSnapshotBeforeUpdate != "function" ||
          (_ === s.memoizedProps && et === s.memoizedState) ||
          (e.flags |= 1024),
        (a = !1));
  }
  return jj(s, e, o, a, d, c);
}
function jj(s, e, o, a, c, d) {
  gj(s, e);
  var g = (e.flags & 128) !== 0;
  if (!a && !g) return c && dg(e, o, !1), Zi(s, e, d);
  (a = e.stateNode), (Wi.current = e);
  var _ =
    g && typeof o.getDerivedStateFromError != "function" ? null : a.render();
  return (
    (e.flags |= 1),
    s !== null && g
      ? ((e.child = Ug(e, s.child, null, d)), (e.child = Ug(e, null, _, d)))
      : Xi(s, e, _, d),
    (e.memoizedState = a.state),
    c && dg(e, o, !0),
    e.child
  );
}
function kj(s) {
  var e = s.stateNode;
  e.pendingContext
    ? ag(s, e.pendingContext, e.pendingContext !== e.context)
    : e.context && ag(s, e.context, !1),
    yh(s, e.containerInfo);
}
function lj(s, e, o, a, c) {
  return Ig(), Jg(c), (e.flags |= 256), Xi(s, e, o, a), e.child;
}
var mj = { dehydrated: null, treeContext: null, retryLane: 0 };
function nj(s) {
  return { baseLanes: s, cachePool: null, transitions: null };
}
function oj(s, e, o) {
  var a = e.pendingProps,
    c = L.current,
    d = !1,
    g = (e.flags & 128) !== 0,
    _;
  if (
    ((_ = g) ||
      (_ = s !== null && s.memoizedState === null ? !1 : (c & 2) !== 0),
    _
      ? ((d = !0), (e.flags &= -129))
      : (s === null || s.memoizedState !== null) && (c |= 1),
    G(L, c & 1),
    s === null)
  )
    return (
      Eg(e),
      (s = e.memoizedState),
      s !== null && ((s = s.dehydrated), s !== null)
        ? (e.mode & 1
            ? s.data === "$!"
              ? (e.lanes = 8)
              : (e.lanes = 1073741824)
            : (e.lanes = 1),
          null)
        : ((g = a.children),
          (s = a.fallback),
          d
            ? ((a = e.mode),
              (d = e.child),
              (g = { mode: "hidden", children: g }),
              !(a & 1) && d !== null
                ? ((d.childLanes = 0), (d.pendingProps = g))
                : (d = pj(g, a, 0, null)),
              (s = Tg(s, a, o, null)),
              (d.return = e),
              (s.return = e),
              (d.sibling = s),
              (e.child = d),
              (e.child.memoizedState = nj(o)),
              (e.memoizedState = mj),
              s)
            : qj(e, g))
    );
  if (((c = s.memoizedState), c !== null && ((_ = c.dehydrated), _ !== null)))
    return rj(s, e, g, a, _, c, o);
  if (d) {
    (d = a.fallback), (g = e.mode), (c = s.child), (_ = c.sibling);
    var b = { mode: "hidden", children: a.children };
    return (
      !(g & 1) && e.child !== c
        ? ((a = e.child),
          (a.childLanes = 0),
          (a.pendingProps = b),
          (e.deletions = null))
        : ((a = Pg(c, b)), (a.subtreeFlags = c.subtreeFlags & 14680064)),
      _ !== null ? (d = Pg(_, d)) : ((d = Tg(d, g, o, null)), (d.flags |= 2)),
      (d.return = e),
      (a.return = e),
      (a.sibling = d),
      (e.child = a),
      (a = d),
      (d = e.child),
      (g = s.child.memoizedState),
      (g =
        g === null
          ? nj(o)
          : {
              baseLanes: g.baseLanes | o,
              cachePool: null,
              transitions: g.transitions,
            }),
      (d.memoizedState = g),
      (d.childLanes = s.childLanes & ~o),
      (e.memoizedState = mj),
      a
    );
  }
  return (
    (d = s.child),
    (s = d.sibling),
    (a = Pg(d, { mode: "visible", children: a.children })),
    !(e.mode & 1) && (a.lanes = o),
    (a.return = e),
    (a.sibling = null),
    s !== null &&
      ((o = e.deletions),
      o === null ? ((e.deletions = [s]), (e.flags |= 16)) : o.push(s)),
    (e.child = a),
    (e.memoizedState = null),
    a
  );
}
function qj(s, e) {
  return (
    (e = pj({ mode: "visible", children: e }, s.mode, 0, null)),
    (e.return = s),
    (s.child = e)
  );
}
function sj(s, e, o, a) {
  return (
    a !== null && Jg(a),
    Ug(e, s.child, null, o),
    (s = qj(e, e.pendingProps.children)),
    (s.flags |= 2),
    (e.memoizedState = null),
    s
  );
}
function rj(s, e, o, a, c, d, g) {
  if (o)
    return e.flags & 256
      ? ((e.flags &= -257), (a = Ki(Error(p$1(422)))), sj(s, e, g, a))
      : e.memoizedState !== null
      ? ((e.child = s.child), (e.flags |= 128), null)
      : ((d = a.fallback),
        (c = e.mode),
        (a = pj({ mode: "visible", children: a.children }, c, 0, null)),
        (d = Tg(d, c, g, null)),
        (d.flags |= 2),
        (a.return = e),
        (d.return = e),
        (a.sibling = d),
        (e.child = a),
        e.mode & 1 && Ug(e, s.child, null, g),
        (e.child.memoizedState = nj(g)),
        (e.memoizedState = mj),
        d);
  if (!(e.mode & 1)) return sj(s, e, g, null);
  if (c.data === "$!") {
    if (((a = c.nextSibling && c.nextSibling.dataset), a)) var _ = a.dgst;
    return (
      (a = _), (d = Error(p$1(419))), (a = Ki(d, a, void 0)), sj(s, e, g, a)
    );
  }
  if (((_ = (g & s.childLanes) !== 0), dh || _)) {
    if (((a = Q), a !== null)) {
      switch (g & -g) {
        case 4:
          c = 2;
          break;
        case 16:
          c = 8;
          break;
        case 64:
        case 128:
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
        case 67108864:
          c = 32;
          break;
        case 536870912:
          c = 268435456;
          break;
        default:
          c = 0;
      }
      (c = c & (a.suspendedLanes | g) ? 0 : c),
        c !== 0 &&
          c !== d.retryLane &&
          ((d.retryLane = c), ih(s, c), gi(a, s, c, -1));
    }
    return tj(), (a = Ki(Error(p$1(421)))), sj(s, e, g, a);
  }
  return c.data === "$?"
    ? ((e.flags |= 128),
      (e.child = s.child),
      (e = uj.bind(null, s)),
      (c._reactRetry = e),
      null)
    : ((s = d.treeContext),
      (yg = Lf(c.nextSibling)),
      (xg = e),
      (I = !0),
      (zg = null),
      s !== null &&
        ((og[pg++] = rg),
        (og[pg++] = sg),
        (og[pg++] = qg),
        (rg = s.id),
        (sg = s.overflow),
        (qg = e)),
      (e = qj(e, a.children)),
      (e.flags |= 4096),
      e);
}
function vj(s, e, o) {
  s.lanes |= e;
  var a = s.alternate;
  a !== null && (a.lanes |= e), bh(s.return, e, o);
}
function wj(s, e, o, a, c) {
  var d = s.memoizedState;
  d === null
    ? (s.memoizedState = {
        isBackwards: e,
        rendering: null,
        renderingStartTime: 0,
        last: a,
        tail: o,
        tailMode: c,
      })
    : ((d.isBackwards = e),
      (d.rendering = null),
      (d.renderingStartTime = 0),
      (d.last = a),
      (d.tail = o),
      (d.tailMode = c));
}
function xj(s, e, o) {
  var a = e.pendingProps,
    c = a.revealOrder,
    d = a.tail;
  if ((Xi(s, e, a.children, o), (a = L.current), a & 2))
    (a = (a & 1) | 2), (e.flags |= 128);
  else {
    if (s !== null && s.flags & 128)
      e: for (s = e.child; s !== null; ) {
        if (s.tag === 13) s.memoizedState !== null && vj(s, o, e);
        else if (s.tag === 19) vj(s, o, e);
        else if (s.child !== null) {
          (s.child.return = s), (s = s.child);
          continue;
        }
        if (s === e) break e;
        for (; s.sibling === null; ) {
          if (s.return === null || s.return === e) break e;
          s = s.return;
        }
        (s.sibling.return = s.return), (s = s.sibling);
      }
    a &= 1;
  }
  if ((G(L, a), !(e.mode & 1))) e.memoizedState = null;
  else
    switch (c) {
      case "forwards":
        for (o = e.child, c = null; o !== null; )
          (s = o.alternate),
            s !== null && Ch(s) === null && (c = o),
            (o = o.sibling);
        (o = c),
          o === null
            ? ((c = e.child), (e.child = null))
            : ((c = o.sibling), (o.sibling = null)),
          wj(e, !1, c, o, d);
        break;
      case "backwards":
        for (o = null, c = e.child, e.child = null; c !== null; ) {
          if (((s = c.alternate), s !== null && Ch(s) === null)) {
            e.child = c;
            break;
          }
          (s = c.sibling), (c.sibling = o), (o = c), (c = s);
        }
        wj(e, !0, o, null, d);
        break;
      case "together":
        wj(e, !1, null, null, void 0);
        break;
      default:
        e.memoizedState = null;
    }
  return e.child;
}
function ij(s, e) {
  !(e.mode & 1) &&
    s !== null &&
    ((s.alternate = null), (e.alternate = null), (e.flags |= 2));
}
function Zi(s, e, o) {
  if (
    (s !== null && (e.dependencies = s.dependencies),
    (rh |= e.lanes),
    !(o & e.childLanes))
  )
    return null;
  if (s !== null && e.child !== s.child) throw Error(p$1(153));
  if (e.child !== null) {
    for (
      s = e.child, o = Pg(s, s.pendingProps), e.child = o, o.return = e;
      s.sibling !== null;

    )
      (s = s.sibling), (o = o.sibling = Pg(s, s.pendingProps)), (o.return = e);
    o.sibling = null;
  }
  return e.child;
}
function yj(s, e, o) {
  switch (e.tag) {
    case 3:
      kj(e), Ig();
      break;
    case 5:
      Ah(e);
      break;
    case 1:
      Zf(e.type) && cg(e);
      break;
    case 4:
      yh(e, e.stateNode.containerInfo);
      break;
    case 10:
      var a = e.type._context,
        c = e.memoizedProps.value;
      G(Wg, a._currentValue), (a._currentValue = c);
      break;
    case 13:
      if (((a = e.memoizedState), a !== null))
        return a.dehydrated !== null
          ? (G(L, L.current & 1), (e.flags |= 128), null)
          : o & e.child.childLanes
          ? oj(s, e, o)
          : (G(L, L.current & 1),
            (s = Zi(s, e, o)),
            s !== null ? s.sibling : null);
      G(L, L.current & 1);
      break;
    case 19:
      if (((a = (o & e.childLanes) !== 0), s.flags & 128)) {
        if (a) return xj(s, e, o);
        e.flags |= 128;
      }
      if (
        ((c = e.memoizedState),
        c !== null &&
          ((c.rendering = null), (c.tail = null), (c.lastEffect = null)),
        G(L, L.current),
        a)
      )
        break;
      return null;
    case 22:
    case 23:
      return (e.lanes = 0), dj(s, e, o);
  }
  return Zi(s, e, o);
}
var zj, Aj, Bj, Cj;
zj = function (s, e) {
  for (var o = e.child; o !== null; ) {
    if (o.tag === 5 || o.tag === 6) s.appendChild(o.stateNode);
    else if (o.tag !== 4 && o.child !== null) {
      (o.child.return = o), (o = o.child);
      continue;
    }
    if (o === e) break;
    for (; o.sibling === null; ) {
      if (o.return === null || o.return === e) return;
      o = o.return;
    }
    (o.sibling.return = o.return), (o = o.sibling);
  }
};
Aj = function () {};
Bj = function (s, e, o, a) {
  var c = s.memoizedProps;
  if (c !== a) {
    (s = e.stateNode), xh(uh.current);
    var d = null;
    switch (o) {
      case "input":
        (c = Ya(s, c)), (a = Ya(s, a)), (d = []);
        break;
      case "select":
        (c = A({}, c, { value: void 0 })),
          (a = A({}, a, { value: void 0 })),
          (d = []);
        break;
      case "textarea":
        (c = gb(s, c)), (a = gb(s, a)), (d = []);
        break;
      default:
        typeof c.onClick != "function" &&
          typeof a.onClick == "function" &&
          (s.onclick = Bf);
    }
    ub(o, a);
    var g;
    o = null;
    for (j in c)
      if (!a.hasOwnProperty(j) && c.hasOwnProperty(j) && c[j] != null)
        if (j === "style") {
          var _ = c[j];
          for (g in _) _.hasOwnProperty(g) && (o || (o = {}), (o[g] = ""));
        } else
          j !== "dangerouslySetInnerHTML" &&
            j !== "children" &&
            j !== "suppressContentEditableWarning" &&
            j !== "suppressHydrationWarning" &&
            j !== "autoFocus" &&
            (ea.hasOwnProperty(j)
              ? d || (d = [])
              : (d = d || []).push(j, null));
    for (j in a) {
      var b = a[j];
      if (
        ((_ = c != null ? c[j] : void 0),
        a.hasOwnProperty(j) && b !== _ && (b != null || _ != null))
      )
        if (j === "style")
          if (_) {
            for (g in _)
              !_.hasOwnProperty(g) ||
                (b && b.hasOwnProperty(g)) ||
                (o || (o = {}), (o[g] = ""));
            for (g in b)
              b.hasOwnProperty(g) &&
                _[g] !== b[g] &&
                (o || (o = {}), (o[g] = b[g]));
          } else o || (d || (d = []), d.push(j, o)), (o = b);
        else
          j === "dangerouslySetInnerHTML"
            ? ((b = b ? b.__html : void 0),
              (_ = _ ? _.__html : void 0),
              b != null && _ !== b && (d = d || []).push(j, b))
            : j === "children"
            ? (typeof b != "string" && typeof b != "number") ||
              (d = d || []).push(j, "" + b)
            : j !== "suppressContentEditableWarning" &&
              j !== "suppressHydrationWarning" &&
              (ea.hasOwnProperty(j)
                ? (b != null && j === "onScroll" && D("scroll", s),
                  d || _ === b || (d = []))
                : (d = d || []).push(j, b));
    }
    o && (d = d || []).push("style", o);
    var j = d;
    (e.updateQueue = j) && (e.flags |= 4);
  }
};
Cj = function (s, e, o, a) {
  o !== a && (e.flags |= 4);
};
function Dj(s, e) {
  if (!I)
    switch (s.tailMode) {
      case "hidden":
        e = s.tail;
        for (var o = null; e !== null; )
          e.alternate !== null && (o = e), (e = e.sibling);
        o === null ? (s.tail = null) : (o.sibling = null);
        break;
      case "collapsed":
        o = s.tail;
        for (var a = null; o !== null; )
          o.alternate !== null && (a = o), (o = o.sibling);
        a === null
          ? e || s.tail === null
            ? (s.tail = null)
            : (s.tail.sibling = null)
          : (a.sibling = null);
    }
}
function S(s) {
  var e = s.alternate !== null && s.alternate.child === s.child,
    o = 0,
    a = 0;
  if (e)
    for (var c = s.child; c !== null; )
      (o |= c.lanes | c.childLanes),
        (a |= c.subtreeFlags & 14680064),
        (a |= c.flags & 14680064),
        (c.return = s),
        (c = c.sibling);
  else
    for (c = s.child; c !== null; )
      (o |= c.lanes | c.childLanes),
        (a |= c.subtreeFlags),
        (a |= c.flags),
        (c.return = s),
        (c = c.sibling);
  return (s.subtreeFlags |= a), (s.childLanes = o), e;
}
function Ej(s, e, o) {
  var a = e.pendingProps;
  switch ((wg(e), e.tag)) {
    case 2:
    case 16:
    case 15:
    case 0:
    case 11:
    case 7:
    case 8:
    case 12:
    case 9:
    case 14:
      return S(e), null;
    case 1:
      return Zf(e.type) && $f(), S(e), null;
    case 3:
      return (
        (a = e.stateNode),
        zh(),
        E(Wf),
        E(H),
        Eh(),
        a.pendingContext &&
          ((a.context = a.pendingContext), (a.pendingContext = null)),
        (s === null || s.child === null) &&
          (Gg(e)
            ? (e.flags |= 4)
            : s === null ||
              (s.memoizedState.isDehydrated && !(e.flags & 256)) ||
              ((e.flags |= 1024), zg !== null && (Fj(zg), (zg = null)))),
        Aj(s, e),
        S(e),
        null
      );
    case 5:
      Bh(e);
      var c = xh(wh.current);
      if (((o = e.type), s !== null && e.stateNode != null))
        Bj(s, e, o, a, c),
          s.ref !== e.ref && ((e.flags |= 512), (e.flags |= 2097152));
      else {
        if (!a) {
          if (e.stateNode === null) throw Error(p$1(166));
          return S(e), null;
        }
        if (((s = xh(uh.current)), Gg(e))) {
          (a = e.stateNode), (o = e.type);
          var d = e.memoizedProps;
          switch (((a[Of] = e), (a[Pf] = d), (s = (e.mode & 1) !== 0), o)) {
            case "dialog":
              D("cancel", a), D("close", a);
              break;
            case "iframe":
            case "object":
            case "embed":
              D("load", a);
              break;
            case "video":
            case "audio":
              for (c = 0; c < lf.length; c++) D(lf[c], a);
              break;
            case "source":
              D("error", a);
              break;
            case "img":
            case "image":
            case "link":
              D("error", a), D("load", a);
              break;
            case "details":
              D("toggle", a);
              break;
            case "input":
              Za(a, d), D("invalid", a);
              break;
            case "select":
              (a._wrapperState = { wasMultiple: !!d.multiple }),
                D("invalid", a);
              break;
            case "textarea":
              hb(a, d), D("invalid", a);
          }
          ub(o, d), (c = null);
          for (var g in d)
            if (d.hasOwnProperty(g)) {
              var _ = d[g];
              g === "children"
                ? typeof _ == "string"
                  ? a.textContent !== _ &&
                    (d.suppressHydrationWarning !== !0 &&
                      Af(a.textContent, _, s),
                    (c = ["children", _]))
                  : typeof _ == "number" &&
                    a.textContent !== "" + _ &&
                    (d.suppressHydrationWarning !== !0 &&
                      Af(a.textContent, _, s),
                    (c = ["children", "" + _]))
                : ea.hasOwnProperty(g) &&
                  _ != null &&
                  g === "onScroll" &&
                  D("scroll", a);
            }
          switch (o) {
            case "input":
              Va(a), db(a, d, !0);
              break;
            case "textarea":
              Va(a), jb(a);
              break;
            case "select":
            case "option":
              break;
            default:
              typeof d.onClick == "function" && (a.onclick = Bf);
          }
          (a = c), (e.updateQueue = a), a !== null && (e.flags |= 4);
        } else {
          (g = c.nodeType === 9 ? c : c.ownerDocument),
            s === "http://www.w3.org/1999/xhtml" && (s = kb(o)),
            s === "http://www.w3.org/1999/xhtml"
              ? o === "script"
                ? ((s = g.createElement("div")),
                  (s.innerHTML = "<script></script>"),
                  (s = s.removeChild(s.firstChild)))
                : typeof a.is == "string"
                ? (s = g.createElement(o, { is: a.is }))
                : ((s = g.createElement(o)),
                  o === "select" &&
                    ((g = s),
                    a.multiple
                      ? (g.multiple = !0)
                      : a.size && (g.size = a.size)))
              : (s = g.createElementNS(s, o)),
            (s[Of] = e),
            (s[Pf] = a),
            zj(s, e, !1, !1),
            (e.stateNode = s);
          e: {
            switch (((g = vb(o, a)), o)) {
              case "dialog":
                D("cancel", s), D("close", s), (c = a);
                break;
              case "iframe":
              case "object":
              case "embed":
                D("load", s), (c = a);
                break;
              case "video":
              case "audio":
                for (c = 0; c < lf.length; c++) D(lf[c], s);
                c = a;
                break;
              case "source":
                D("error", s), (c = a);
                break;
              case "img":
              case "image":
              case "link":
                D("error", s), D("load", s), (c = a);
                break;
              case "details":
                D("toggle", s), (c = a);
                break;
              case "input":
                Za(s, a), (c = Ya(s, a)), D("invalid", s);
                break;
              case "option":
                c = a;
                break;
              case "select":
                (s._wrapperState = { wasMultiple: !!a.multiple }),
                  (c = A({}, a, { value: void 0 })),
                  D("invalid", s);
                break;
              case "textarea":
                hb(s, a), (c = gb(s, a)), D("invalid", s);
                break;
              default:
                c = a;
            }
            ub(o, c), (_ = c);
            for (d in _)
              if (_.hasOwnProperty(d)) {
                var b = _[d];
                d === "style"
                  ? sb(s, b)
                  : d === "dangerouslySetInnerHTML"
                  ? ((b = b ? b.__html : void 0), b != null && nb(s, b))
                  : d === "children"
                  ? typeof b == "string"
                    ? (o !== "textarea" || b !== "") && ob(s, b)
                    : typeof b == "number" && ob(s, "" + b)
                  : d !== "suppressContentEditableWarning" &&
                    d !== "suppressHydrationWarning" &&
                    d !== "autoFocus" &&
                    (ea.hasOwnProperty(d)
                      ? b != null && d === "onScroll" && D("scroll", s)
                      : b != null && ta(s, d, b, g));
              }
            switch (o) {
              case "input":
                Va(s), db(s, a, !1);
                break;
              case "textarea":
                Va(s), jb(s);
                break;
              case "option":
                a.value != null && s.setAttribute("value", "" + Sa(a.value));
                break;
              case "select":
                (s.multiple = !!a.multiple),
                  (d = a.value),
                  d != null
                    ? fb$1(s, !!a.multiple, d, !1)
                    : a.defaultValue != null &&
                      fb$1(s, !!a.multiple, a.defaultValue, !0);
                break;
              default:
                typeof c.onClick == "function" && (s.onclick = Bf);
            }
            switch (o) {
              case "button":
              case "input":
              case "select":
              case "textarea":
                a = !!a.autoFocus;
                break e;
              case "img":
                a = !0;
                break e;
              default:
                a = !1;
            }
          }
          a && (e.flags |= 4);
        }
        e.ref !== null && ((e.flags |= 512), (e.flags |= 2097152));
      }
      return S(e), null;
    case 6:
      if (s && e.stateNode != null) Cj(s, e, s.memoizedProps, a);
      else {
        if (typeof a != "string" && e.stateNode === null) throw Error(p$1(166));
        if (((o = xh(wh.current)), xh(uh.current), Gg(e))) {
          if (
            ((a = e.stateNode),
            (o = e.memoizedProps),
            (a[Of] = e),
            (d = a.nodeValue !== o) && ((s = xg), s !== null))
          )
            switch (s.tag) {
              case 3:
                Af(a.nodeValue, o, (s.mode & 1) !== 0);
                break;
              case 5:
                s.memoizedProps.suppressHydrationWarning !== !0 &&
                  Af(a.nodeValue, o, (s.mode & 1) !== 0);
            }
          d && (e.flags |= 4);
        } else
          (a = (o.nodeType === 9 ? o : o.ownerDocument).createTextNode(a)),
            (a[Of] = e),
            (e.stateNode = a);
      }
      return S(e), null;
    case 13:
      if (
        (E(L),
        (a = e.memoizedState),
        s === null ||
          (s.memoizedState !== null && s.memoizedState.dehydrated !== null))
      ) {
        if (I && yg !== null && e.mode & 1 && !(e.flags & 128))
          Hg(), Ig(), (e.flags |= 98560), (d = !1);
        else if (((d = Gg(e)), a !== null && a.dehydrated !== null)) {
          if (s === null) {
            if (!d) throw Error(p$1(318));
            if (
              ((d = e.memoizedState),
              (d = d !== null ? d.dehydrated : null),
              !d)
            )
              throw Error(p$1(317));
            d[Of] = e;
          } else
            Ig(), !(e.flags & 128) && (e.memoizedState = null), (e.flags |= 4);
          S(e), (d = !1);
        } else zg !== null && (Fj(zg), (zg = null)), (d = !0);
        if (!d) return e.flags & 65536 ? e : null;
      }
      return e.flags & 128
        ? ((e.lanes = o), e)
        : ((a = a !== null),
          a !== (s !== null && s.memoizedState !== null) &&
            a &&
            ((e.child.flags |= 8192),
            e.mode & 1 &&
              (s === null || L.current & 1 ? T === 0 && (T = 3) : tj())),
          e.updateQueue !== null && (e.flags |= 4),
          S(e),
          null);
    case 4:
      return (
        zh(), Aj(s, e), s === null && sf(e.stateNode.containerInfo), S(e), null
      );
    case 10:
      return ah(e.type._context), S(e), null;
    case 17:
      return Zf(e.type) && $f(), S(e), null;
    case 19:
      if ((E(L), (d = e.memoizedState), d === null)) return S(e), null;
      if (((a = (e.flags & 128) !== 0), (g = d.rendering), g === null))
        if (a) Dj(d, !1);
        else {
          if (T !== 0 || (s !== null && s.flags & 128))
            for (s = e.child; s !== null; ) {
              if (((g = Ch(s)), g !== null)) {
                for (
                  e.flags |= 128,
                    Dj(d, !1),
                    a = g.updateQueue,
                    a !== null && ((e.updateQueue = a), (e.flags |= 4)),
                    e.subtreeFlags = 0,
                    a = o,
                    o = e.child;
                  o !== null;

                )
                  (d = o),
                    (s = a),
                    (d.flags &= 14680066),
                    (g = d.alternate),
                    g === null
                      ? ((d.childLanes = 0),
                        (d.lanes = s),
                        (d.child = null),
                        (d.subtreeFlags = 0),
                        (d.memoizedProps = null),
                        (d.memoizedState = null),
                        (d.updateQueue = null),
                        (d.dependencies = null),
                        (d.stateNode = null))
                      : ((d.childLanes = g.childLanes),
                        (d.lanes = g.lanes),
                        (d.child = g.child),
                        (d.subtreeFlags = 0),
                        (d.deletions = null),
                        (d.memoizedProps = g.memoizedProps),
                        (d.memoizedState = g.memoizedState),
                        (d.updateQueue = g.updateQueue),
                        (d.type = g.type),
                        (s = g.dependencies),
                        (d.dependencies =
                          s === null
                            ? null
                            : {
                                lanes: s.lanes,
                                firstContext: s.firstContext,
                              })),
                    (o = o.sibling);
                return G(L, (L.current & 1) | 2), e.child;
              }
              s = s.sibling;
            }
          d.tail !== null &&
            B() > Gj &&
            ((e.flags |= 128), (a = !0), Dj(d, !1), (e.lanes = 4194304));
        }
      else {
        if (!a)
          if (((s = Ch(g)), s !== null)) {
            if (
              ((e.flags |= 128),
              (a = !0),
              (o = s.updateQueue),
              o !== null && ((e.updateQueue = o), (e.flags |= 4)),
              Dj(d, !0),
              d.tail === null && d.tailMode === "hidden" && !g.alternate && !I)
            )
              return S(e), null;
          } else
            2 * B() - d.renderingStartTime > Gj &&
              o !== 1073741824 &&
              ((e.flags |= 128), (a = !0), Dj(d, !1), (e.lanes = 4194304));
        d.isBackwards
          ? ((g.sibling = e.child), (e.child = g))
          : ((o = d.last),
            o !== null ? (o.sibling = g) : (e.child = g),
            (d.last = g));
      }
      return d.tail !== null
        ? ((e = d.tail),
          (d.rendering = e),
          (d.tail = e.sibling),
          (d.renderingStartTime = B()),
          (e.sibling = null),
          (o = L.current),
          G(L, a ? (o & 1) | 2 : o & 1),
          e)
        : (S(e), null);
    case 22:
    case 23:
      return (
        Hj(),
        (a = e.memoizedState !== null),
        s !== null && (s.memoizedState !== null) !== a && (e.flags |= 8192),
        a && e.mode & 1
          ? fj & 1073741824 && (S(e), e.subtreeFlags & 6 && (e.flags |= 8192))
          : S(e),
        null
      );
    case 24:
      return null;
    case 25:
      return null;
  }
  throw Error(p$1(156, e.tag));
}
function Ij(s, e) {
  switch ((wg(e), e.tag)) {
    case 1:
      return (
        Zf(e.type) && $f(),
        (s = e.flags),
        s & 65536 ? ((e.flags = (s & -65537) | 128), e) : null
      );
    case 3:
      return (
        zh(),
        E(Wf),
        E(H),
        Eh(),
        (s = e.flags),
        s & 65536 && !(s & 128) ? ((e.flags = (s & -65537) | 128), e) : null
      );
    case 5:
      return Bh(e), null;
    case 13:
      if ((E(L), (s = e.memoizedState), s !== null && s.dehydrated !== null)) {
        if (e.alternate === null) throw Error(p$1(340));
        Ig();
      }
      return (
        (s = e.flags), s & 65536 ? ((e.flags = (s & -65537) | 128), e) : null
      );
    case 19:
      return E(L), null;
    case 4:
      return zh(), null;
    case 10:
      return ah(e.type._context), null;
    case 22:
    case 23:
      return Hj(), null;
    case 24:
      return null;
    default:
      return null;
  }
}
var Jj = !1,
  U = !1,
  Kj = typeof WeakSet == "function" ? WeakSet : Set,
  V = null;
function Lj(s, e) {
  var o = s.ref;
  if (o !== null)
    if (typeof o == "function")
      try {
        o(null);
      } catch (a) {
        W(s, e, a);
      }
    else o.current = null;
}
function Mj(s, e, o) {
  try {
    o();
  } catch (a) {
    W(s, e, a);
  }
}
var Nj = !1;
function Oj(s, e) {
  if (((Cf = dd), (s = Me()), Ne(s))) {
    if ("selectionStart" in s)
      var o = { start: s.selectionStart, end: s.selectionEnd };
    else
      e: {
        o = ((o = s.ownerDocument) && o.defaultView) || window;
        var a = o.getSelection && o.getSelection();
        if (a && a.rangeCount !== 0) {
          o = a.anchorNode;
          var c = a.anchorOffset,
            d = a.focusNode;
          a = a.focusOffset;
          try {
            o.nodeType, d.nodeType;
          } catch {
            o = null;
            break e;
          }
          var g = 0,
            _ = -1,
            b = -1,
            j = 0,
            $ = 0,
            _e = s,
            et = null;
          t: for (;;) {
            for (
              var rt;
              _e !== o || (c !== 0 && _e.nodeType !== 3) || (_ = g + c),
                _e !== d || (a !== 0 && _e.nodeType !== 3) || (b = g + a),
                _e.nodeType === 3 && (g += _e.nodeValue.length),
                (rt = _e.firstChild) !== null;

            )
              (et = _e), (_e = rt);
            for (;;) {
              if (_e === s) break t;
              if (
                (et === o && ++j === c && (_ = g),
                et === d && ++$ === a && (b = g),
                (rt = _e.nextSibling) !== null)
              )
                break;
              (_e = et), (et = _e.parentNode);
            }
            _e = rt;
          }
          o = _ === -1 || b === -1 ? null : { start: _, end: b };
        } else o = null;
      }
    o = o || { start: 0, end: 0 };
  } else o = null;
  for (Df = { focusedElem: s, selectionRange: o }, dd = !1, V = e; V !== null; )
    if (((e = V), (s = e.child), (e.subtreeFlags & 1028) !== 0 && s !== null))
      (s.return = e), (V = s);
    else
      for (; V !== null; ) {
        e = V;
        try {
          var st = e.alternate;
          if (e.flags & 1024)
            switch (e.tag) {
              case 0:
              case 11:
              case 15:
                break;
              case 1:
                if (st !== null) {
                  var at = st.memoizedProps,
                    ct = st.memoizedState,
                    it = e.stateNode,
                    lt = it.getSnapshotBeforeUpdate(
                      e.elementType === e.type ? at : Ci(e.type, at),
                      ct
                    );
                  it.__reactInternalSnapshotBeforeUpdate = lt;
                }
                break;
              case 3:
                var ot = e.stateNode.containerInfo;
                ot.nodeType === 1
                  ? (ot.textContent = "")
                  : ot.nodeType === 9 &&
                    ot.documentElement &&
                    ot.removeChild(ot.documentElement);
                break;
              case 5:
              case 6:
              case 4:
              case 17:
                break;
              default:
                throw Error(p$1(163));
            }
        } catch (ut) {
          W(e, e.return, ut);
        }
        if (((s = e.sibling), s !== null)) {
          (s.return = e.return), (V = s);
          break;
        }
        V = e.return;
      }
  return (st = Nj), (Nj = !1), st;
}
function Pj(s, e, o) {
  var a = e.updateQueue;
  if (((a = a !== null ? a.lastEffect : null), a !== null)) {
    var c = (a = a.next);
    do {
      if ((c.tag & s) === s) {
        var d = c.destroy;
        (c.destroy = void 0), d !== void 0 && Mj(e, o, d);
      }
      c = c.next;
    } while (c !== a);
  }
}
function Qj(s, e) {
  if (
    ((e = e.updateQueue), (e = e !== null ? e.lastEffect : null), e !== null)
  ) {
    var o = (e = e.next);
    do {
      if ((o.tag & s) === s) {
        var a = o.create;
        o.destroy = a();
      }
      o = o.next;
    } while (o !== e);
  }
}
function Rj(s) {
  var e = s.ref;
  if (e !== null) {
    var o = s.stateNode;
    switch (s.tag) {
      case 5:
        s = o;
        break;
      default:
        s = o;
    }
    typeof e == "function" ? e(s) : (e.current = s);
  }
}
function Sj(s) {
  var e = s.alternate;
  e !== null && ((s.alternate = null), Sj(e)),
    (s.child = null),
    (s.deletions = null),
    (s.sibling = null),
    s.tag === 5 &&
      ((e = s.stateNode),
      e !== null &&
        (delete e[Of], delete e[Pf], delete e[of], delete e[Qf], delete e[Rf])),
    (s.stateNode = null),
    (s.return = null),
    (s.dependencies = null),
    (s.memoizedProps = null),
    (s.memoizedState = null),
    (s.pendingProps = null),
    (s.stateNode = null),
    (s.updateQueue = null);
}
function Tj(s) {
  return s.tag === 5 || s.tag === 3 || s.tag === 4;
}
function Uj(s) {
  e: for (;;) {
    for (; s.sibling === null; ) {
      if (s.return === null || Tj(s.return)) return null;
      s = s.return;
    }
    for (
      s.sibling.return = s.return, s = s.sibling;
      s.tag !== 5 && s.tag !== 6 && s.tag !== 18;

    ) {
      if (s.flags & 2 || s.child === null || s.tag === 4) continue e;
      (s.child.return = s), (s = s.child);
    }
    if (!(s.flags & 2)) return s.stateNode;
  }
}
function Vj(s, e, o) {
  var a = s.tag;
  if (a === 5 || a === 6)
    (s = s.stateNode),
      e
        ? o.nodeType === 8
          ? o.parentNode.insertBefore(s, e)
          : o.insertBefore(s, e)
        : (o.nodeType === 8
            ? ((e = o.parentNode), e.insertBefore(s, o))
            : ((e = o), e.appendChild(s)),
          (o = o._reactRootContainer),
          o != null || e.onclick !== null || (e.onclick = Bf));
  else if (a !== 4 && ((s = s.child), s !== null))
    for (Vj(s, e, o), s = s.sibling; s !== null; ) Vj(s, e, o), (s = s.sibling);
}
function Wj(s, e, o) {
  var a = s.tag;
  if (a === 5 || a === 6)
    (s = s.stateNode), e ? o.insertBefore(s, e) : o.appendChild(s);
  else if (a !== 4 && ((s = s.child), s !== null))
    for (Wj(s, e, o), s = s.sibling; s !== null; ) Wj(s, e, o), (s = s.sibling);
}
var X = null,
  Xj = !1;
function Yj(s, e, o) {
  for (o = o.child; o !== null; ) Zj(s, e, o), (o = o.sibling);
}
function Zj(s, e, o) {
  if (lc && typeof lc.onCommitFiberUnmount == "function")
    try {
      lc.onCommitFiberUnmount(kc, o);
    } catch {}
  switch (o.tag) {
    case 5:
      U || Lj(o, e);
    case 6:
      var a = X,
        c = Xj;
      (X = null),
        Yj(s, e, o),
        (X = a),
        (Xj = c),
        X !== null &&
          (Xj
            ? ((s = X),
              (o = o.stateNode),
              s.nodeType === 8 ? s.parentNode.removeChild(o) : s.removeChild(o))
            : X.removeChild(o.stateNode));
      break;
    case 18:
      X !== null &&
        (Xj
          ? ((s = X),
            (o = o.stateNode),
            s.nodeType === 8
              ? Kf(s.parentNode, o)
              : s.nodeType === 1 && Kf(s, o),
            bd(s))
          : Kf(X, o.stateNode));
      break;
    case 4:
      (a = X),
        (c = Xj),
        (X = o.stateNode.containerInfo),
        (Xj = !0),
        Yj(s, e, o),
        (X = a),
        (Xj = c);
      break;
    case 0:
    case 11:
    case 14:
    case 15:
      if (
        !U &&
        ((a = o.updateQueue), a !== null && ((a = a.lastEffect), a !== null))
      ) {
        c = a = a.next;
        do {
          var d = c,
            g = d.destroy;
          (d = d.tag),
            g !== void 0 && (d & 2 || d & 4) && Mj(o, e, g),
            (c = c.next);
        } while (c !== a);
      }
      Yj(s, e, o);
      break;
    case 1:
      if (
        !U &&
        (Lj(o, e),
        (a = o.stateNode),
        typeof a.componentWillUnmount == "function")
      )
        try {
          (a.props = o.memoizedProps),
            (a.state = o.memoizedState),
            a.componentWillUnmount();
        } catch (_) {
          W(o, e, _);
        }
      Yj(s, e, o);
      break;
    case 21:
      Yj(s, e, o);
      break;
    case 22:
      o.mode & 1
        ? ((U = (a = U) || o.memoizedState !== null), Yj(s, e, o), (U = a))
        : Yj(s, e, o);
      break;
    default:
      Yj(s, e, o);
  }
}
function ak(s) {
  var e = s.updateQueue;
  if (e !== null) {
    s.updateQueue = null;
    var o = s.stateNode;
    o === null && (o = s.stateNode = new Kj()),
      e.forEach(function (a) {
        var c = bk.bind(null, s, a);
        o.has(a) || (o.add(a), a.then(c, c));
      });
  }
}
function ck(s, e) {
  var o = e.deletions;
  if (o !== null)
    for (var a = 0; a < o.length; a++) {
      var c = o[a];
      try {
        var d = s,
          g = e,
          _ = g;
        e: for (; _ !== null; ) {
          switch (_.tag) {
            case 5:
              (X = _.stateNode), (Xj = !1);
              break e;
            case 3:
              (X = _.stateNode.containerInfo), (Xj = !0);
              break e;
            case 4:
              (X = _.stateNode.containerInfo), (Xj = !0);
              break e;
          }
          _ = _.return;
        }
        if (X === null) throw Error(p$1(160));
        Zj(d, g, c), (X = null), (Xj = !1);
        var b = c.alternate;
        b !== null && (b.return = null), (c.return = null);
      } catch (j) {
        W(c, e, j);
      }
    }
  if (e.subtreeFlags & 12854)
    for (e = e.child; e !== null; ) dk(e, s), (e = e.sibling);
}
function dk(s, e) {
  var o = s.alternate,
    a = s.flags;
  switch (s.tag) {
    case 0:
    case 11:
    case 14:
    case 15:
      if ((ck(e, s), ek(s), a & 4)) {
        try {
          Pj(3, s, s.return), Qj(3, s);
        } catch (at) {
          W(s, s.return, at);
        }
        try {
          Pj(5, s, s.return);
        } catch (at) {
          W(s, s.return, at);
        }
      }
      break;
    case 1:
      ck(e, s), ek(s), a & 512 && o !== null && Lj(o, o.return);
      break;
    case 5:
      if (
        (ck(e, s),
        ek(s),
        a & 512 && o !== null && Lj(o, o.return),
        s.flags & 32)
      ) {
        var c = s.stateNode;
        try {
          ob(c, "");
        } catch (at) {
          W(s, s.return, at);
        }
      }
      if (a & 4 && ((c = s.stateNode), c != null)) {
        var d = s.memoizedProps,
          g = o !== null ? o.memoizedProps : d,
          _ = s.type,
          b = s.updateQueue;
        if (((s.updateQueue = null), b !== null))
          try {
            _ === "input" && d.type === "radio" && d.name != null && ab(c, d),
              vb(_, g);
            var j = vb(_, d);
            for (g = 0; g < b.length; g += 2) {
              var $ = b[g],
                _e = b[g + 1];
              $ === "style"
                ? sb(c, _e)
                : $ === "dangerouslySetInnerHTML"
                ? nb(c, _e)
                : $ === "children"
                ? ob(c, _e)
                : ta(c, $, _e, j);
            }
            switch (_) {
              case "input":
                bb(c, d);
                break;
              case "textarea":
                ib(c, d);
                break;
              case "select":
                var et = c._wrapperState.wasMultiple;
                c._wrapperState.wasMultiple = !!d.multiple;
                var rt = d.value;
                rt != null
                  ? fb$1(c, !!d.multiple, rt, !1)
                  : et !== !!d.multiple &&
                    (d.defaultValue != null
                      ? fb$1(c, !!d.multiple, d.defaultValue, !0)
                      : fb$1(c, !!d.multiple, d.multiple ? [] : "", !1));
            }
            c[Pf] = d;
          } catch (at) {
            W(s, s.return, at);
          }
      }
      break;
    case 6:
      if ((ck(e, s), ek(s), a & 4)) {
        if (s.stateNode === null) throw Error(p$1(162));
        (c = s.stateNode), (d = s.memoizedProps);
        try {
          c.nodeValue = d;
        } catch (at) {
          W(s, s.return, at);
        }
      }
      break;
    case 3:
      if (
        (ck(e, s), ek(s), a & 4 && o !== null && o.memoizedState.isDehydrated)
      )
        try {
          bd(e.containerInfo);
        } catch (at) {
          W(s, s.return, at);
        }
      break;
    case 4:
      ck(e, s), ek(s);
      break;
    case 13:
      ck(e, s),
        ek(s),
        (c = s.child),
        c.flags & 8192 &&
          ((d = c.memoizedState !== null),
          (c.stateNode.isHidden = d),
          !d ||
            (c.alternate !== null && c.alternate.memoizedState !== null) ||
            (fk = B())),
        a & 4 && ak(s);
      break;
    case 22:
      if (
        (($ = o !== null && o.memoizedState !== null),
        s.mode & 1 ? ((U = (j = U) || $), ck(e, s), (U = j)) : ck(e, s),
        ek(s),
        a & 8192)
      ) {
        if (
          ((j = s.memoizedState !== null),
          (s.stateNode.isHidden = j) && !$ && s.mode & 1)
        )
          for (V = s, $ = s.child; $ !== null; ) {
            for (_e = V = $; V !== null; ) {
              switch (((et = V), (rt = et.child), et.tag)) {
                case 0:
                case 11:
                case 14:
                case 15:
                  Pj(4, et, et.return);
                  break;
                case 1:
                  Lj(et, et.return);
                  var st = et.stateNode;
                  if (typeof st.componentWillUnmount == "function") {
                    (a = et), (o = et.return);
                    try {
                      (e = a),
                        (st.props = e.memoizedProps),
                        (st.state = e.memoizedState),
                        st.componentWillUnmount();
                    } catch (at) {
                      W(a, o, at);
                    }
                  }
                  break;
                case 5:
                  Lj(et, et.return);
                  break;
                case 22:
                  if (et.memoizedState !== null) {
                    gk(_e);
                    continue;
                  }
              }
              rt !== null ? ((rt.return = et), (V = rt)) : gk(_e);
            }
            $ = $.sibling;
          }
        e: for ($ = null, _e = s; ; ) {
          if (_e.tag === 5) {
            if ($ === null) {
              $ = _e;
              try {
                (c = _e.stateNode),
                  j
                    ? ((d = c.style),
                      typeof d.setProperty == "function"
                        ? d.setProperty("display", "none", "important")
                        : (d.display = "none"))
                    : ((_ = _e.stateNode),
                      (b = _e.memoizedProps.style),
                      (g =
                        b != null && b.hasOwnProperty("display")
                          ? b.display
                          : null),
                      (_.style.display = rb("display", g)));
              } catch (at) {
                W(s, s.return, at);
              }
            }
          } else if (_e.tag === 6) {
            if ($ === null)
              try {
                _e.stateNode.nodeValue = j ? "" : _e.memoizedProps;
              } catch (at) {
                W(s, s.return, at);
              }
          } else if (
            ((_e.tag !== 22 && _e.tag !== 23) ||
              _e.memoizedState === null ||
              _e === s) &&
            _e.child !== null
          ) {
            (_e.child.return = _e), (_e = _e.child);
            continue;
          }
          if (_e === s) break e;
          for (; _e.sibling === null; ) {
            if (_e.return === null || _e.return === s) break e;
            $ === _e && ($ = null), (_e = _e.return);
          }
          $ === _e && ($ = null),
            (_e.sibling.return = _e.return),
            (_e = _e.sibling);
        }
      }
      break;
    case 19:
      ck(e, s), ek(s), a & 4 && ak(s);
      break;
    case 21:
      break;
    default:
      ck(e, s), ek(s);
  }
}
function ek(s) {
  var e = s.flags;
  if (e & 2) {
    try {
      e: {
        for (var o = s.return; o !== null; ) {
          if (Tj(o)) {
            var a = o;
            break e;
          }
          o = o.return;
        }
        throw Error(p$1(160));
      }
      switch (a.tag) {
        case 5:
          var c = a.stateNode;
          a.flags & 32 && (ob(c, ""), (a.flags &= -33));
          var d = Uj(s);
          Wj(s, d, c);
          break;
        case 3:
        case 4:
          var g = a.stateNode.containerInfo,
            _ = Uj(s);
          Vj(s, _, g);
          break;
        default:
          throw Error(p$1(161));
      }
    } catch (b) {
      W(s, s.return, b);
    }
    s.flags &= -3;
  }
  e & 4096 && (s.flags &= -4097);
}
function hk(s, e, o) {
  (V = s), ik(s);
}
function ik(s, e, o) {
  for (var a = (s.mode & 1) !== 0; V !== null; ) {
    var c = V,
      d = c.child;
    if (c.tag === 22 && a) {
      var g = c.memoizedState !== null || Jj;
      if (!g) {
        var _ = c.alternate,
          b = (_ !== null && _.memoizedState !== null) || U;
        _ = Jj;
        var j = U;
        if (((Jj = g), (U = b) && !j))
          for (V = c; V !== null; )
            (g = V),
              (b = g.child),
              g.tag === 22 && g.memoizedState !== null
                ? jk(c)
                : b !== null
                ? ((b.return = g), (V = b))
                : jk(c);
        for (; d !== null; ) (V = d), ik(d), (d = d.sibling);
        (V = c), (Jj = _), (U = j);
      }
      kk(s);
    } else
      c.subtreeFlags & 8772 && d !== null ? ((d.return = c), (V = d)) : kk(s);
  }
}
function kk(s) {
  for (; V !== null; ) {
    var e = V;
    if (e.flags & 8772) {
      var o = e.alternate;
      try {
        if (e.flags & 8772)
          switch (e.tag) {
            case 0:
            case 11:
            case 15:
              U || Qj(5, e);
              break;
            case 1:
              var a = e.stateNode;
              if (e.flags & 4 && !U)
                if (o === null) a.componentDidMount();
                else {
                  var c =
                    e.elementType === e.type
                      ? o.memoizedProps
                      : Ci(e.type, o.memoizedProps);
                  a.componentDidUpdate(
                    c,
                    o.memoizedState,
                    a.__reactInternalSnapshotBeforeUpdate
                  );
                }
              var d = e.updateQueue;
              d !== null && sh(e, d, a);
              break;
            case 3:
              var g = e.updateQueue;
              if (g !== null) {
                if (((o = null), e.child !== null))
                  switch (e.child.tag) {
                    case 5:
                      o = e.child.stateNode;
                      break;
                    case 1:
                      o = e.child.stateNode;
                  }
                sh(e, g, o);
              }
              break;
            case 5:
              var _ = e.stateNode;
              if (o === null && e.flags & 4) {
                o = _;
                var b = e.memoizedProps;
                switch (e.type) {
                  case "button":
                  case "input":
                  case "select":
                  case "textarea":
                    b.autoFocus && o.focus();
                    break;
                  case "img":
                    b.src && (o.src = b.src);
                }
              }
              break;
            case 6:
              break;
            case 4:
              break;
            case 12:
              break;
            case 13:
              if (e.memoizedState === null) {
                var j = e.alternate;
                if (j !== null) {
                  var $ = j.memoizedState;
                  if ($ !== null) {
                    var _e = $.dehydrated;
                    _e !== null && bd(_e);
                  }
                }
              }
              break;
            case 19:
            case 17:
            case 21:
            case 22:
            case 23:
            case 25:
              break;
            default:
              throw Error(p$1(163));
          }
        U || (e.flags & 512 && Rj(e));
      } catch (et) {
        W(e, e.return, et);
      }
    }
    if (e === s) {
      V = null;
      break;
    }
    if (((o = e.sibling), o !== null)) {
      (o.return = e.return), (V = o);
      break;
    }
    V = e.return;
  }
}
function gk(s) {
  for (; V !== null; ) {
    var e = V;
    if (e === s) {
      V = null;
      break;
    }
    var o = e.sibling;
    if (o !== null) {
      (o.return = e.return), (V = o);
      break;
    }
    V = e.return;
  }
}
function jk(s) {
  for (; V !== null; ) {
    var e = V;
    try {
      switch (e.tag) {
        case 0:
        case 11:
        case 15:
          var o = e.return;
          try {
            Qj(4, e);
          } catch (b) {
            W(e, o, b);
          }
          break;
        case 1:
          var a = e.stateNode;
          if (typeof a.componentDidMount == "function") {
            var c = e.return;
            try {
              a.componentDidMount();
            } catch (b) {
              W(e, c, b);
            }
          }
          var d = e.return;
          try {
            Rj(e);
          } catch (b) {
            W(e, d, b);
          }
          break;
        case 5:
          var g = e.return;
          try {
            Rj(e);
          } catch (b) {
            W(e, g, b);
          }
      }
    } catch (b) {
      W(e, e.return, b);
    }
    if (e === s) {
      V = null;
      break;
    }
    var _ = e.sibling;
    if (_ !== null) {
      (_.return = e.return), (V = _);
      break;
    }
    V = e.return;
  }
}
var lk = Math.ceil,
  mk = ua.ReactCurrentDispatcher,
  nk = ua.ReactCurrentOwner,
  ok = ua.ReactCurrentBatchConfig,
  K = 0,
  Q = null,
  Y = null,
  Z = 0,
  fj = 0,
  ej = Uf(0),
  T = 0,
  pk = null,
  rh = 0,
  qk = 0,
  rk = 0,
  sk = null,
  tk = null,
  fk = 0,
  Gj = 1 / 0,
  uk = null,
  Oi = !1,
  Pi = null,
  Ri = null,
  vk = !1,
  wk = null,
  xk = 0,
  yk = 0,
  zk = null,
  Ak = -1,
  Bk = 0;
function R() {
  return K & 6 ? B() : Ak !== -1 ? Ak : (Ak = B());
}
function yi(s) {
  return s.mode & 1
    ? K & 2 && Z !== 0
      ? Z & -Z
      : Kg.transition !== null
      ? (Bk === 0 && (Bk = yc()), Bk)
      : ((s = C),
        s !== 0 || ((s = window.event), (s = s === void 0 ? 16 : jd(s.type))),
        s)
    : 1;
}
function gi(s, e, o, a) {
  if (50 < yk) throw ((yk = 0), (zk = null), Error(p$1(185)));
  Ac(s, o, a),
    (!(K & 2) || s !== Q) &&
      (s === Q && (!(K & 2) && (qk |= o), T === 4 && Ck(s, Z)),
      Dk(s, a),
      o === 1 && K === 0 && !(e.mode & 1) && ((Gj = B() + 500), fg && jg()));
}
function Dk(s, e) {
  var o = s.callbackNode;
  wc(s, e);
  var a = uc(s, s === Q ? Z : 0);
  if (a === 0)
    o !== null && bc(o), (s.callbackNode = null), (s.callbackPriority = 0);
  else if (((e = a & -a), s.callbackPriority !== e)) {
    if ((o != null && bc(o), e === 1))
      s.tag === 0 ? ig(Ek.bind(null, s)) : hg(Ek.bind(null, s)),
        Jf(function () {
          !(K & 6) && jg();
        }),
        (o = null);
    else {
      switch (Dc(a)) {
        case 1:
          o = fc;
          break;
        case 4:
          o = gc;
          break;
        case 16:
          o = hc;
          break;
        case 536870912:
          o = jc;
          break;
        default:
          o = hc;
      }
      o = Fk(o, Gk.bind(null, s));
    }
    (s.callbackPriority = e), (s.callbackNode = o);
  }
}
function Gk(s, e) {
  if (((Ak = -1), (Bk = 0), K & 6)) throw Error(p$1(327));
  var o = s.callbackNode;
  if (Hk() && s.callbackNode !== o) return null;
  var a = uc(s, s === Q ? Z : 0);
  if (a === 0) return null;
  if (a & 30 || a & s.expiredLanes || e) e = Ik(s, a);
  else {
    e = a;
    var c = K;
    K |= 2;
    var d = Jk();
    (Q !== s || Z !== e) && ((uk = null), (Gj = B() + 500), Kk(s, e));
    do
      try {
        Lk();
        break;
      } catch (_) {
        Mk(s, _);
      }
    while (!0);
    $g(),
      (mk.current = d),
      (K = c),
      Y !== null ? (e = 0) : ((Q = null), (Z = 0), (e = T));
  }
  if (e !== 0) {
    if (
      (e === 2 && ((c = xc(s)), c !== 0 && ((a = c), (e = Nk(s, c)))), e === 1)
    )
      throw ((o = pk), Kk(s, 0), Ck(s, a), Dk(s, B()), o);
    if (e === 6) Ck(s, a);
    else {
      if (
        ((c = s.current.alternate),
        !(a & 30) &&
          !Ok(c) &&
          ((e = Ik(s, a)),
          e === 2 && ((d = xc(s)), d !== 0 && ((a = d), (e = Nk(s, d)))),
          e === 1))
      )
        throw ((o = pk), Kk(s, 0), Ck(s, a), Dk(s, B()), o);
      switch (((s.finishedWork = c), (s.finishedLanes = a), e)) {
        case 0:
        case 1:
          throw Error(p$1(345));
        case 2:
          Pk(s, tk, uk);
          break;
        case 3:
          if (
            (Ck(s, a), (a & 130023424) === a && ((e = fk + 500 - B()), 10 < e))
          ) {
            if (uc(s, 0) !== 0) break;
            if (((c = s.suspendedLanes), (c & a) !== a)) {
              R(), (s.pingedLanes |= s.suspendedLanes & c);
              break;
            }
            s.timeoutHandle = Ff(Pk.bind(null, s, tk, uk), e);
            break;
          }
          Pk(s, tk, uk);
          break;
        case 4:
          if ((Ck(s, a), (a & 4194240) === a)) break;
          for (e = s.eventTimes, c = -1; 0 < a; ) {
            var g = 31 - oc(a);
            (d = 1 << g), (g = e[g]), g > c && (c = g), (a &= ~d);
          }
          if (
            ((a = c),
            (a = B() - a),
            (a =
              (120 > a
                ? 120
                : 480 > a
                ? 480
                : 1080 > a
                ? 1080
                : 1920 > a
                ? 1920
                : 3e3 > a
                ? 3e3
                : 4320 > a
                ? 4320
                : 1960 * lk(a / 1960)) - a),
            10 < a)
          ) {
            s.timeoutHandle = Ff(Pk.bind(null, s, tk, uk), a);
            break;
          }
          Pk(s, tk, uk);
          break;
        case 5:
          Pk(s, tk, uk);
          break;
        default:
          throw Error(p$1(329));
      }
    }
  }
  return Dk(s, B()), s.callbackNode === o ? Gk.bind(null, s) : null;
}
function Nk(s, e) {
  var o = sk;
  return (
    s.current.memoizedState.isDehydrated && (Kk(s, e).flags |= 256),
    (s = Ik(s, e)),
    s !== 2 && ((e = tk), (tk = o), e !== null && Fj(e)),
    s
  );
}
function Fj(s) {
  tk === null ? (tk = s) : tk.push.apply(tk, s);
}
function Ok(s) {
  for (var e = s; ; ) {
    if (e.flags & 16384) {
      var o = e.updateQueue;
      if (o !== null && ((o = o.stores), o !== null))
        for (var a = 0; a < o.length; a++) {
          var c = o[a],
            d = c.getSnapshot;
          c = c.value;
          try {
            if (!He(d(), c)) return !1;
          } catch {
            return !1;
          }
        }
    }
    if (((o = e.child), e.subtreeFlags & 16384 && o !== null))
      (o.return = e), (e = o);
    else {
      if (e === s) break;
      for (; e.sibling === null; ) {
        if (e.return === null || e.return === s) return !0;
        e = e.return;
      }
      (e.sibling.return = e.return), (e = e.sibling);
    }
  }
  return !0;
}
function Ck(s, e) {
  for (
    e &= ~rk,
      e &= ~qk,
      s.suspendedLanes |= e,
      s.pingedLanes &= ~e,
      s = s.expirationTimes;
    0 < e;

  ) {
    var o = 31 - oc(e),
      a = 1 << o;
    (s[o] = -1), (e &= ~a);
  }
}
function Ek(s) {
  if (K & 6) throw Error(p$1(327));
  Hk();
  var e = uc(s, 0);
  if (!(e & 1)) return Dk(s, B()), null;
  var o = Ik(s, e);
  if (s.tag !== 0 && o === 2) {
    var a = xc(s);
    a !== 0 && ((e = a), (o = Nk(s, a)));
  }
  if (o === 1) throw ((o = pk), Kk(s, 0), Ck(s, e), Dk(s, B()), o);
  if (o === 6) throw Error(p$1(345));
  return (
    (s.finishedWork = s.current.alternate),
    (s.finishedLanes = e),
    Pk(s, tk, uk),
    Dk(s, B()),
    null
  );
}
function Qk(s, e) {
  var o = K;
  K |= 1;
  try {
    return s(e);
  } finally {
    (K = o), K === 0 && ((Gj = B() + 500), fg && jg());
  }
}
function Rk(s) {
  wk !== null && wk.tag === 0 && !(K & 6) && Hk();
  var e = K;
  K |= 1;
  var o = ok.transition,
    a = C;
  try {
    if (((ok.transition = null), (C = 1), s)) return s();
  } finally {
    (C = a), (ok.transition = o), (K = e), !(K & 6) && jg();
  }
}
function Hj() {
  (fj = ej.current), E(ej);
}
function Kk(s, e) {
  (s.finishedWork = null), (s.finishedLanes = 0);
  var o = s.timeoutHandle;
  if ((o !== -1 && ((s.timeoutHandle = -1), Gf(o)), Y !== null))
    for (o = Y.return; o !== null; ) {
      var a = o;
      switch ((wg(a), a.tag)) {
        case 1:
          (a = a.type.childContextTypes), a != null && $f();
          break;
        case 3:
          zh(), E(Wf), E(H), Eh();
          break;
        case 5:
          Bh(a);
          break;
        case 4:
          zh();
          break;
        case 13:
          E(L);
          break;
        case 19:
          E(L);
          break;
        case 10:
          ah(a.type._context);
          break;
        case 22:
        case 23:
          Hj();
      }
      o = o.return;
    }
  if (
    ((Q = s),
    (Y = s = Pg(s.current, null)),
    (Z = fj = e),
    (T = 0),
    (pk = null),
    (rk = qk = rh = 0),
    (tk = sk = null),
    fh !== null)
  ) {
    for (e = 0; e < fh.length; e++)
      if (((o = fh[e]), (a = o.interleaved), a !== null)) {
        o.interleaved = null;
        var c = a.next,
          d = o.pending;
        if (d !== null) {
          var g = d.next;
          (d.next = c), (a.next = g);
        }
        o.pending = a;
      }
    fh = null;
  }
  return s;
}
function Mk(s, e) {
  do {
    var o = Y;
    try {
      if (($g(), (Fh.current = Rh), Ih)) {
        for (var a = M.memoizedState; a !== null; ) {
          var c = a.queue;
          c !== null && (c.pending = null), (a = a.next);
        }
        Ih = !1;
      }
      if (
        ((Hh = 0),
        (O = N = M = null),
        (Jh = !1),
        (Kh = 0),
        (nk.current = null),
        o === null || o.return === null)
      ) {
        (T = 1), (pk = e), (Y = null);
        break;
      }
      e: {
        var d = s,
          g = o.return,
          _ = o,
          b = e;
        if (
          ((e = Z),
          (_.flags |= 32768),
          b !== null && typeof b == "object" && typeof b.then == "function")
        ) {
          var j = b,
            $ = _,
            _e = $.tag;
          if (!($.mode & 1) && (_e === 0 || _e === 11 || _e === 15)) {
            var et = $.alternate;
            et
              ? (($.updateQueue = et.updateQueue),
                ($.memoizedState = et.memoizedState),
                ($.lanes = et.lanes))
              : (($.updateQueue = null), ($.memoizedState = null));
          }
          var rt = Ui(g);
          if (rt !== null) {
            (rt.flags &= -257),
              Vi(rt, g, _, d, e),
              rt.mode & 1 && Si(d, j, e),
              (e = rt),
              (b = j);
            var st = e.updateQueue;
            if (st === null) {
              var at = new Set();
              at.add(b), (e.updateQueue = at);
            } else st.add(b);
            break e;
          } else {
            if (!(e & 1)) {
              Si(d, j, e), tj();
              break e;
            }
            b = Error(p$1(426));
          }
        } else if (I && _.mode & 1) {
          var ct = Ui(g);
          if (ct !== null) {
            !(ct.flags & 65536) && (ct.flags |= 256),
              Vi(ct, g, _, d, e),
              Jg(Ji(b, _));
            break e;
          }
        }
        (d = b = Ji(b, _)),
          T !== 4 && (T = 2),
          sk === null ? (sk = [d]) : sk.push(d),
          (d = g);
        do {
          switch (d.tag) {
            case 3:
              (d.flags |= 65536), (e &= -e), (d.lanes |= e);
              var it = Ni(d, b, e);
              ph(d, it);
              break e;
            case 1:
              _ = b;
              var lt = d.type,
                ot = d.stateNode;
              if (
                !(d.flags & 128) &&
                (typeof lt.getDerivedStateFromError == "function" ||
                  (ot !== null &&
                    typeof ot.componentDidCatch == "function" &&
                    (Ri === null || !Ri.has(ot))))
              ) {
                (d.flags |= 65536), (e &= -e), (d.lanes |= e);
                var ut = Qi(d, _, e);
                ph(d, ut);
                break e;
              }
          }
          d = d.return;
        } while (d !== null);
      }
      Sk(o);
    } catch (pt) {
      (e = pt), Y === o && o !== null && (Y = o = o.return);
      continue;
    }
    break;
  } while (!0);
}
function Jk() {
  var s = mk.current;
  return (mk.current = Rh), s === null ? Rh : s;
}
function tj() {
  (T === 0 || T === 3 || T === 2) && (T = 4),
    Q === null || (!(rh & 268435455) && !(qk & 268435455)) || Ck(Q, Z);
}
function Ik(s, e) {
  var o = K;
  K |= 2;
  var a = Jk();
  (Q !== s || Z !== e) && ((uk = null), Kk(s, e));
  do
    try {
      Tk();
      break;
    } catch (c) {
      Mk(s, c);
    }
  while (!0);
  if (($g(), (K = o), (mk.current = a), Y !== null)) throw Error(p$1(261));
  return (Q = null), (Z = 0), T;
}
function Tk() {
  for (; Y !== null; ) Uk(Y);
}
function Lk() {
  for (; Y !== null && !cc(); ) Uk(Y);
}
function Uk(s) {
  var e = Vk(s.alternate, s, fj);
  (s.memoizedProps = s.pendingProps),
    e === null ? Sk(s) : (Y = e),
    (nk.current = null);
}
function Sk(s) {
  var e = s;
  do {
    var o = e.alternate;
    if (((s = e.return), e.flags & 32768)) {
      if (((o = Ij(o, e)), o !== null)) {
        (o.flags &= 32767), (Y = o);
        return;
      }
      if (s !== null)
        (s.flags |= 32768), (s.subtreeFlags = 0), (s.deletions = null);
      else {
        (T = 6), (Y = null);
        return;
      }
    } else if (((o = Ej(o, e, fj)), o !== null)) {
      Y = o;
      return;
    }
    if (((e = e.sibling), e !== null)) {
      Y = e;
      return;
    }
    Y = e = s;
  } while (e !== null);
  T === 0 && (T = 5);
}
function Pk(s, e, o) {
  var a = C,
    c = ok.transition;
  try {
    (ok.transition = null), (C = 1), Wk(s, e, o, a);
  } finally {
    (ok.transition = c), (C = a);
  }
  return null;
}
function Wk(s, e, o, a) {
  do Hk();
  while (wk !== null);
  if (K & 6) throw Error(p$1(327));
  o = s.finishedWork;
  var c = s.finishedLanes;
  if (o === null) return null;
  if (((s.finishedWork = null), (s.finishedLanes = 0), o === s.current))
    throw Error(p$1(177));
  (s.callbackNode = null), (s.callbackPriority = 0);
  var d = o.lanes | o.childLanes;
  if (
    (Bc(s, d),
    s === Q && ((Y = Q = null), (Z = 0)),
    (!(o.subtreeFlags & 2064) && !(o.flags & 2064)) ||
      vk ||
      ((vk = !0),
      Fk(hc, function () {
        return Hk(), null;
      })),
    (d = (o.flags & 15990) !== 0),
    o.subtreeFlags & 15990 || d)
  ) {
    (d = ok.transition), (ok.transition = null);
    var g = C;
    C = 1;
    var _ = K;
    (K |= 4),
      (nk.current = null),
      Oj(s, o),
      dk(o, s),
      Oe(Df),
      (dd = !!Cf),
      (Df = Cf = null),
      (s.current = o),
      hk(o),
      dc(),
      (K = _),
      (C = g),
      (ok.transition = d);
  } else s.current = o;
  if (
    (vk && ((vk = !1), (wk = s), (xk = c)),
    (d = s.pendingLanes),
    d === 0 && (Ri = null),
    mc(o.stateNode),
    Dk(s, B()),
    e !== null)
  )
    for (a = s.onRecoverableError, o = 0; o < e.length; o++)
      (c = e[o]), a(c.value, { componentStack: c.stack, digest: c.digest });
  if (Oi) throw ((Oi = !1), (s = Pi), (Pi = null), s);
  return (
    xk & 1 && s.tag !== 0 && Hk(),
    (d = s.pendingLanes),
    d & 1 ? (s === zk ? yk++ : ((yk = 0), (zk = s))) : (yk = 0),
    jg(),
    null
  );
}
function Hk() {
  if (wk !== null) {
    var s = Dc(xk),
      e = ok.transition,
      o = C;
    try {
      if (((ok.transition = null), (C = 16 > s ? 16 : s), wk === null))
        var a = !1;
      else {
        if (((s = wk), (wk = null), (xk = 0), K & 6)) throw Error(p$1(331));
        var c = K;
        for (K |= 4, V = s.current; V !== null; ) {
          var d = V,
            g = d.child;
          if (V.flags & 16) {
            var _ = d.deletions;
            if (_ !== null) {
              for (var b = 0; b < _.length; b++) {
                var j = _[b];
                for (V = j; V !== null; ) {
                  var $ = V;
                  switch ($.tag) {
                    case 0:
                    case 11:
                    case 15:
                      Pj(8, $, d);
                  }
                  var _e = $.child;
                  if (_e !== null) (_e.return = $), (V = _e);
                  else
                    for (; V !== null; ) {
                      $ = V;
                      var et = $.sibling,
                        rt = $.return;
                      if ((Sj($), $ === j)) {
                        V = null;
                        break;
                      }
                      if (et !== null) {
                        (et.return = rt), (V = et);
                        break;
                      }
                      V = rt;
                    }
                }
              }
              var st = d.alternate;
              if (st !== null) {
                var at = st.child;
                if (at !== null) {
                  st.child = null;
                  do {
                    var ct = at.sibling;
                    (at.sibling = null), (at = ct);
                  } while (at !== null);
                }
              }
              V = d;
            }
          }
          if (d.subtreeFlags & 2064 && g !== null) (g.return = d), (V = g);
          else
            e: for (; V !== null; ) {
              if (((d = V), d.flags & 2048))
                switch (d.tag) {
                  case 0:
                  case 11:
                  case 15:
                    Pj(9, d, d.return);
                }
              var it = d.sibling;
              if (it !== null) {
                (it.return = d.return), (V = it);
                break e;
              }
              V = d.return;
            }
        }
        var lt = s.current;
        for (V = lt; V !== null; ) {
          g = V;
          var ot = g.child;
          if (g.subtreeFlags & 2064 && ot !== null) (ot.return = g), (V = ot);
          else
            e: for (g = lt; V !== null; ) {
              if (((_ = V), _.flags & 2048))
                try {
                  switch (_.tag) {
                    case 0:
                    case 11:
                    case 15:
                      Qj(9, _);
                  }
                } catch (pt) {
                  W(_, _.return, pt);
                }
              if (_ === g) {
                V = null;
                break e;
              }
              var ut = _.sibling;
              if (ut !== null) {
                (ut.return = _.return), (V = ut);
                break e;
              }
              V = _.return;
            }
        }
        if (
          ((K = c), jg(), lc && typeof lc.onPostCommitFiberRoot == "function")
        )
          try {
            lc.onPostCommitFiberRoot(kc, s);
          } catch {}
        a = !0;
      }
      return a;
    } finally {
      (C = o), (ok.transition = e);
    }
  }
  return !1;
}
function Xk(s, e, o) {
  (e = Ji(o, e)),
    (e = Ni(s, e, 1)),
    (s = nh(s, e, 1)),
    (e = R()),
    s !== null && (Ac(s, 1, e), Dk(s, e));
}
function W(s, e, o) {
  if (s.tag === 3) Xk(s, s, o);
  else
    for (; e !== null; ) {
      if (e.tag === 3) {
        Xk(e, s, o);
        break;
      } else if (e.tag === 1) {
        var a = e.stateNode;
        if (
          typeof e.type.getDerivedStateFromError == "function" ||
          (typeof a.componentDidCatch == "function" &&
            (Ri === null || !Ri.has(a)))
        ) {
          (s = Ji(o, s)),
            (s = Qi(e, s, 1)),
            (e = nh(e, s, 1)),
            (s = R()),
            e !== null && (Ac(e, 1, s), Dk(e, s));
          break;
        }
      }
      e = e.return;
    }
}
function Ti(s, e, o) {
  var a = s.pingCache;
  a !== null && a.delete(e),
    (e = R()),
    (s.pingedLanes |= s.suspendedLanes & o),
    Q === s &&
      (Z & o) === o &&
      (T === 4 || (T === 3 && (Z & 130023424) === Z && 500 > B() - fk)
        ? Kk(s, 0)
        : (rk |= o)),
    Dk(s, e);
}
function Yk(s, e) {
  e === 0 &&
    (s.mode & 1
      ? ((e = sc), (sc <<= 1), !(sc & 130023424) && (sc = 4194304))
      : (e = 1));
  var o = R();
  (s = ih(s, e)), s !== null && (Ac(s, e, o), Dk(s, o));
}
function uj(s) {
  var e = s.memoizedState,
    o = 0;
  e !== null && (o = e.retryLane), Yk(s, o);
}
function bk(s, e) {
  var o = 0;
  switch (s.tag) {
    case 13:
      var a = s.stateNode,
        c = s.memoizedState;
      c !== null && (o = c.retryLane);
      break;
    case 19:
      a = s.stateNode;
      break;
    default:
      throw Error(p$1(314));
  }
  a !== null && a.delete(e), Yk(s, o);
}
var Vk;
Vk = function (s, e, o) {
  if (s !== null)
    if (s.memoizedProps !== e.pendingProps || Wf.current) dh = !0;
    else {
      if (!(s.lanes & o) && !(e.flags & 128)) return (dh = !1), yj(s, e, o);
      dh = !!(s.flags & 131072);
    }
  else (dh = !1), I && e.flags & 1048576 && ug(e, ng, e.index);
  switch (((e.lanes = 0), e.tag)) {
    case 2:
      var a = e.type;
      ij(s, e), (s = e.pendingProps);
      var c = Yf(e, H.current);
      ch$1(e, o), (c = Nh(null, e, a, s, c, o));
      var d = Sh();
      return (
        (e.flags |= 1),
        typeof c == "object" &&
        c !== null &&
        typeof c.render == "function" &&
        c.$$typeof === void 0
          ? ((e.tag = 1),
            (e.memoizedState = null),
            (e.updateQueue = null),
            Zf(a) ? ((d = !0), cg(e)) : (d = !1),
            (e.memoizedState =
              c.state !== null && c.state !== void 0 ? c.state : null),
            kh(e),
            (c.updater = Ei),
            (e.stateNode = c),
            (c._reactInternals = e),
            Ii(e, a, s, o),
            (e = jj(null, e, a, !0, d, o)))
          : ((e.tag = 0), I && d && vg(e), Xi(null, e, c, o), (e = e.child)),
        e
      );
    case 16:
      a = e.elementType;
      e: {
        switch (
          (ij(s, e),
          (s = e.pendingProps),
          (c = a._init),
          (a = c(a._payload)),
          (e.type = a),
          (c = e.tag = Zk(a)),
          (s = Ci(a, s)),
          c)
        ) {
          case 0:
            e = cj(null, e, a, s, o);
            break e;
          case 1:
            e = hj(null, e, a, s, o);
            break e;
          case 11:
            e = Yi(null, e, a, s, o);
            break e;
          case 14:
            e = $i(null, e, a, Ci(a.type, s), o);
            break e;
        }
        throw Error(p$1(306, a, ""));
      }
      return e;
    case 0:
      return (
        (a = e.type),
        (c = e.pendingProps),
        (c = e.elementType === a ? c : Ci(a, c)),
        cj(s, e, a, c, o)
      );
    case 1:
      return (
        (a = e.type),
        (c = e.pendingProps),
        (c = e.elementType === a ? c : Ci(a, c)),
        hj(s, e, a, c, o)
      );
    case 3:
      e: {
        if ((kj(e), s === null)) throw Error(p$1(387));
        (a = e.pendingProps),
          (d = e.memoizedState),
          (c = d.element),
          lh(s, e),
          qh(e, a, null, o);
        var g = e.memoizedState;
        if (((a = g.element), d.isDehydrated))
          if (
            ((d = {
              element: a,
              isDehydrated: !1,
              cache: g.cache,
              pendingSuspenseBoundaries: g.pendingSuspenseBoundaries,
              transitions: g.transitions,
            }),
            (e.updateQueue.baseState = d),
            (e.memoizedState = d),
            e.flags & 256)
          ) {
            (c = Ji(Error(p$1(423)), e)), (e = lj(s, e, a, o, c));
            break e;
          } else if (a !== c) {
            (c = Ji(Error(p$1(424)), e)), (e = lj(s, e, a, o, c));
            break e;
          } else
            for (
              yg = Lf(e.stateNode.containerInfo.firstChild),
                xg = e,
                I = !0,
                zg = null,
                o = Vg(e, null, a, o),
                e.child = o;
              o;

            )
              (o.flags = (o.flags & -3) | 4096), (o = o.sibling);
        else {
          if ((Ig(), a === c)) {
            e = Zi(s, e, o);
            break e;
          }
          Xi(s, e, a, o);
        }
        e = e.child;
      }
      return e;
    case 5:
      return (
        Ah(e),
        s === null && Eg(e),
        (a = e.type),
        (c = e.pendingProps),
        (d = s !== null ? s.memoizedProps : null),
        (g = c.children),
        Ef(a, c) ? (g = null) : d !== null && Ef(a, d) && (e.flags |= 32),
        gj(s, e),
        Xi(s, e, g, o),
        e.child
      );
    case 6:
      return s === null && Eg(e), null;
    case 13:
      return oj(s, e, o);
    case 4:
      return (
        yh(e, e.stateNode.containerInfo),
        (a = e.pendingProps),
        s === null ? (e.child = Ug(e, null, a, o)) : Xi(s, e, a, o),
        e.child
      );
    case 11:
      return (
        (a = e.type),
        (c = e.pendingProps),
        (c = e.elementType === a ? c : Ci(a, c)),
        Yi(s, e, a, c, o)
      );
    case 7:
      return Xi(s, e, e.pendingProps, o), e.child;
    case 8:
      return Xi(s, e, e.pendingProps.children, o), e.child;
    case 12:
      return Xi(s, e, e.pendingProps.children, o), e.child;
    case 10:
      e: {
        if (
          ((a = e.type._context),
          (c = e.pendingProps),
          (d = e.memoizedProps),
          (g = c.value),
          G(Wg, a._currentValue),
          (a._currentValue = g),
          d !== null)
        )
          if (He(d.value, g)) {
            if (d.children === c.children && !Wf.current) {
              e = Zi(s, e, o);
              break e;
            }
          } else
            for (d = e.child, d !== null && (d.return = e); d !== null; ) {
              var _ = d.dependencies;
              if (_ !== null) {
                g = d.child;
                for (var b = _.firstContext; b !== null; ) {
                  if (b.context === a) {
                    if (d.tag === 1) {
                      (b = mh(-1, o & -o)), (b.tag = 2);
                      var j = d.updateQueue;
                      if (j !== null) {
                        j = j.shared;
                        var $ = j.pending;
                        $ === null
                          ? (b.next = b)
                          : ((b.next = $.next), ($.next = b)),
                          (j.pending = b);
                      }
                    }
                    (d.lanes |= o),
                      (b = d.alternate),
                      b !== null && (b.lanes |= o),
                      bh(d.return, o, e),
                      (_.lanes |= o);
                    break;
                  }
                  b = b.next;
                }
              } else if (d.tag === 10) g = d.type === e.type ? null : d.child;
              else if (d.tag === 18) {
                if (((g = d.return), g === null)) throw Error(p$1(341));
                (g.lanes |= o),
                  (_ = g.alternate),
                  _ !== null && (_.lanes |= o),
                  bh(g, o, e),
                  (g = d.sibling);
              } else g = d.child;
              if (g !== null) g.return = d;
              else
                for (g = d; g !== null; ) {
                  if (g === e) {
                    g = null;
                    break;
                  }
                  if (((d = g.sibling), d !== null)) {
                    (d.return = g.return), (g = d);
                    break;
                  }
                  g = g.return;
                }
              d = g;
            }
        Xi(s, e, c.children, o), (e = e.child);
      }
      return e;
    case 9:
      return (
        (c = e.type),
        (a = e.pendingProps.children),
        ch$1(e, o),
        (c = eh(c)),
        (a = a(c)),
        (e.flags |= 1),
        Xi(s, e, a, o),
        e.child
      );
    case 14:
      return (
        (a = e.type),
        (c = Ci(a, e.pendingProps)),
        (c = Ci(a.type, c)),
        $i(s, e, a, c, o)
      );
    case 15:
      return bj(s, e, e.type, e.pendingProps, o);
    case 17:
      return (
        (a = e.type),
        (c = e.pendingProps),
        (c = e.elementType === a ? c : Ci(a, c)),
        ij(s, e),
        (e.tag = 1),
        Zf(a) ? ((s = !0), cg(e)) : (s = !1),
        ch$1(e, o),
        Gi(e, a, c),
        Ii(e, a, c, o),
        jj(null, e, a, !0, s, o)
      );
    case 19:
      return xj(s, e, o);
    case 22:
      return dj(s, e, o);
  }
  throw Error(p$1(156, e.tag));
};
function Fk(s, e) {
  return ac(s, e);
}
function $k(s, e, o, a) {
  (this.tag = s),
    (this.key = o),
    (this.sibling =
      this.child =
      this.return =
      this.stateNode =
      this.type =
      this.elementType =
        null),
    (this.index = 0),
    (this.ref = null),
    (this.pendingProps = e),
    (this.dependencies =
      this.memoizedState =
      this.updateQueue =
      this.memoizedProps =
        null),
    (this.mode = a),
    (this.subtreeFlags = this.flags = 0),
    (this.deletions = null),
    (this.childLanes = this.lanes = 0),
    (this.alternate = null);
}
function Bg(s, e, o, a) {
  return new $k(s, e, o, a);
}
function aj(s) {
  return (s = s.prototype), !(!s || !s.isReactComponent);
}
function Zk(s) {
  if (typeof s == "function") return aj(s) ? 1 : 0;
  if (s != null) {
    if (((s = s.$$typeof), s === Da)) return 11;
    if (s === Ga) return 14;
  }
  return 2;
}
function Pg(s, e) {
  var o = s.alternate;
  return (
    o === null
      ? ((o = Bg(s.tag, e, s.key, s.mode)),
        (o.elementType = s.elementType),
        (o.type = s.type),
        (o.stateNode = s.stateNode),
        (o.alternate = s),
        (s.alternate = o))
      : ((o.pendingProps = e),
        (o.type = s.type),
        (o.flags = 0),
        (o.subtreeFlags = 0),
        (o.deletions = null)),
    (o.flags = s.flags & 14680064),
    (o.childLanes = s.childLanes),
    (o.lanes = s.lanes),
    (o.child = s.child),
    (o.memoizedProps = s.memoizedProps),
    (o.memoizedState = s.memoizedState),
    (o.updateQueue = s.updateQueue),
    (e = s.dependencies),
    (o.dependencies =
      e === null ? null : { lanes: e.lanes, firstContext: e.firstContext }),
    (o.sibling = s.sibling),
    (o.index = s.index),
    (o.ref = s.ref),
    o
  );
}
function Rg(s, e, o, a, c, d) {
  var g = 2;
  if (((a = s), typeof s == "function")) aj(s) && (g = 1);
  else if (typeof s == "string") g = 5;
  else
    e: switch (s) {
      case ya:
        return Tg(o.children, c, d, e);
      case za:
        (g = 8), (c |= 8);
        break;
      case Aa:
        return (
          (s = Bg(12, o, e, c | 2)), (s.elementType = Aa), (s.lanes = d), s
        );
      case Ea:
        return (s = Bg(13, o, e, c)), (s.elementType = Ea), (s.lanes = d), s;
      case Fa:
        return (s = Bg(19, o, e, c)), (s.elementType = Fa), (s.lanes = d), s;
      case Ia:
        return pj(o, c, d, e);
      default:
        if (typeof s == "object" && s !== null)
          switch (s.$$typeof) {
            case Ba:
              g = 10;
              break e;
            case Ca:
              g = 9;
              break e;
            case Da:
              g = 11;
              break e;
            case Ga:
              g = 14;
              break e;
            case Ha:
              (g = 16), (a = null);
              break e;
          }
        throw Error(p$1(130, s == null ? s : typeof s, ""));
    }
  return (
    (e = Bg(g, o, e, c)), (e.elementType = s), (e.type = a), (e.lanes = d), e
  );
}
function Tg(s, e, o, a) {
  return (s = Bg(7, s, a, e)), (s.lanes = o), s;
}
function pj(s, e, o, a) {
  return (
    (s = Bg(22, s, a, e)),
    (s.elementType = Ia),
    (s.lanes = o),
    (s.stateNode = { isHidden: !1 }),
    s
  );
}
function Qg(s, e, o) {
  return (s = Bg(6, s, null, e)), (s.lanes = o), s;
}
function Sg(s, e, o) {
  return (
    (e = Bg(4, s.children !== null ? s.children : [], s.key, e)),
    (e.lanes = o),
    (e.stateNode = {
      containerInfo: s.containerInfo,
      pendingChildren: null,
      implementation: s.implementation,
    }),
    e
  );
}
function al(s, e, o, a, c) {
  (this.tag = e),
    (this.containerInfo = s),
    (this.finishedWork =
      this.pingCache =
      this.current =
      this.pendingChildren =
        null),
    (this.timeoutHandle = -1),
    (this.callbackNode = this.pendingContext = this.context = null),
    (this.callbackPriority = 0),
    (this.eventTimes = zc(0)),
    (this.expirationTimes = zc(-1)),
    (this.entangledLanes =
      this.finishedLanes =
      this.mutableReadLanes =
      this.expiredLanes =
      this.pingedLanes =
      this.suspendedLanes =
      this.pendingLanes =
        0),
    (this.entanglements = zc(0)),
    (this.identifierPrefix = a),
    (this.onRecoverableError = c),
    (this.mutableSourceEagerHydrationData = null);
}
function bl(s, e, o, a, c, d, g, _, b) {
  return (
    (s = new al(s, e, o, _, b)),
    e === 1 ? ((e = 1), d === !0 && (e |= 8)) : (e = 0),
    (d = Bg(3, null, null, e)),
    (s.current = d),
    (d.stateNode = s),
    (d.memoizedState = {
      element: a,
      isDehydrated: o,
      cache: null,
      transitions: null,
      pendingSuspenseBoundaries: null,
    }),
    kh(d),
    s
  );
}
function cl(s, e, o) {
  var a = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null;
  return {
    $$typeof: wa$1,
    key: a == null ? null : "" + a,
    children: s,
    containerInfo: e,
    implementation: o,
  };
}
function dl(s) {
  if (!s) return Vf;
  s = s._reactInternals;
  e: {
    if (Vb(s) !== s || s.tag !== 1) throw Error(p$1(170));
    var e = s;
    do {
      switch (e.tag) {
        case 3:
          e = e.stateNode.context;
          break e;
        case 1:
          if (Zf(e.type)) {
            e = e.stateNode.__reactInternalMemoizedMergedChildContext;
            break e;
          }
      }
      e = e.return;
    } while (e !== null);
    throw Error(p$1(171));
  }
  if (s.tag === 1) {
    var o = s.type;
    if (Zf(o)) return bg$1(s, o, e);
  }
  return e;
}
function el(s, e, o, a, c, d, g, _, b) {
  return (
    (s = bl(o, a, !0, s, c, d, g, _, b)),
    (s.context = dl(null)),
    (o = s.current),
    (a = R()),
    (c = yi(o)),
    (d = mh(a, c)),
    (d.callback = e ?? null),
    nh(o, d, c),
    (s.current.lanes = c),
    Ac(s, c, a),
    Dk(s, a),
    s
  );
}
function fl(s, e, o, a) {
  var c = e.current,
    d = R(),
    g = yi(c);
  return (
    (o = dl(o)),
    e.context === null ? (e.context = o) : (e.pendingContext = o),
    (e = mh(d, g)),
    (e.payload = { element: s }),
    (a = a === void 0 ? null : a),
    a !== null && (e.callback = a),
    (s = nh(c, e, g)),
    s !== null && (gi(s, c, g, d), oh(s, c, g)),
    g
  );
}
function gl(s) {
  if (((s = s.current), !s.child)) return null;
  switch (s.child.tag) {
    case 5:
      return s.child.stateNode;
    default:
      return s.child.stateNode;
  }
}
function hl(s, e) {
  if (((s = s.memoizedState), s !== null && s.dehydrated !== null)) {
    var o = s.retryLane;
    s.retryLane = o !== 0 && o < e ? o : e;
  }
}
function il(s, e) {
  hl(s, e), (s = s.alternate) && hl(s, e);
}
function jl() {
  return null;
}
var kl =
  typeof reportError == "function"
    ? reportError
    : function (s) {
        console.error(s);
      };
function ll(s) {
  this._internalRoot = s;
}
ml.prototype.render = ll.prototype.render = function (s) {
  var e = this._internalRoot;
  if (e === null) throw Error(p$1(409));
  fl(s, e, null, null);
};
ml.prototype.unmount = ll.prototype.unmount = function () {
  var s = this._internalRoot;
  if (s !== null) {
    this._internalRoot = null;
    var e = s.containerInfo;
    Rk(function () {
      fl(null, s, null, null);
    }),
      (e[uf] = null);
  }
};
function ml(s) {
  this._internalRoot = s;
}
ml.prototype.unstable_scheduleHydration = function (s) {
  if (s) {
    var e = Hc();
    s = { blockedOn: null, target: s, priority: e };
    for (var o = 0; o < Qc.length && e !== 0 && e < Qc[o].priority; o++);
    Qc.splice(o, 0, s), o === 0 && Vc(s);
  }
};
function nl(s) {
  return !(!s || (s.nodeType !== 1 && s.nodeType !== 9 && s.nodeType !== 11));
}
function ol(s) {
  return !(
    !s ||
    (s.nodeType !== 1 &&
      s.nodeType !== 9 &&
      s.nodeType !== 11 &&
      (s.nodeType !== 8 || s.nodeValue !== " react-mount-point-unstable "))
  );
}
function pl() {}
function ql(s, e, o, a, c) {
  if (c) {
    if (typeof a == "function") {
      var d = a;
      a = function () {
        var j = gl(g);
        d.call(j);
      };
    }
    var g = el(e, a, s, 0, null, !1, !1, "", pl);
    return (
      (s._reactRootContainer = g),
      (s[uf] = g.current),
      sf(s.nodeType === 8 ? s.parentNode : s),
      Rk(),
      g
    );
  }
  for (; (c = s.lastChild); ) s.removeChild(c);
  if (typeof a == "function") {
    var _ = a;
    a = function () {
      var j = gl(b);
      _.call(j);
    };
  }
  var b = bl(s, 0, !1, null, null, !1, !1, "", pl);
  return (
    (s._reactRootContainer = b),
    (s[uf] = b.current),
    sf(s.nodeType === 8 ? s.parentNode : s),
    Rk(function () {
      fl(e, b, o, a);
    }),
    b
  );
}
function rl(s, e, o, a, c) {
  var d = o._reactRootContainer;
  if (d) {
    var g = d;
    if (typeof c == "function") {
      var _ = c;
      c = function () {
        var b = gl(g);
        _.call(b);
      };
    }
    fl(e, g, s, c);
  } else g = ql(o, e, s, c, a);
  return gl(g);
}
Ec = function (s) {
  switch (s.tag) {
    case 3:
      var e = s.stateNode;
      if (e.current.memoizedState.isDehydrated) {
        var o = tc(e.pendingLanes);
        o !== 0 &&
          (Cc(e, o | 1), Dk(e, B()), !(K & 6) && ((Gj = B() + 500), jg()));
      }
      break;
    case 13:
      Rk(function () {
        var a = ih(s, 1);
        if (a !== null) {
          var c = R();
          gi(a, s, 1, c);
        }
      }),
        il(s, 1);
  }
};
Fc = function (s) {
  if (s.tag === 13) {
    var e = ih(s, 134217728);
    if (e !== null) {
      var o = R();
      gi(e, s, 134217728, o);
    }
    il(s, 134217728);
  }
};
Gc = function (s) {
  if (s.tag === 13) {
    var e = yi(s),
      o = ih(s, e);
    if (o !== null) {
      var a = R();
      gi(o, s, e, a);
    }
    il(s, e);
  }
};
Hc = function () {
  return C;
};
Ic = function (s, e) {
  var o = C;
  try {
    return (C = s), e();
  } finally {
    C = o;
  }
};
yb = function (s, e, o) {
  switch (e) {
    case "input":
      if ((bb(s, o), (e = o.name), o.type === "radio" && e != null)) {
        for (o = s; o.parentNode; ) o = o.parentNode;
        for (
          o = o.querySelectorAll(
            "input[name=" + JSON.stringify("" + e) + '][type="radio"]'
          ),
            e = 0;
          e < o.length;
          e++
        ) {
          var a = o[e];
          if (a !== s && a.form === s.form) {
            var c = Db(a);
            if (!c) throw Error(p$1(90));
            Wa(a), bb(a, c);
          }
        }
      }
      break;
    case "textarea":
      ib(s, o);
      break;
    case "select":
      (e = o.value), e != null && fb$1(s, !!o.multiple, e, !1);
  }
};
Gb = Qk;
Hb = Rk;
var sl = { usingClientEntryPoint: !1, Events: [Cb, ue, Db, Eb, Fb, Qk] },
  tl = {
    findFiberByHostInstance: Wc,
    bundleType: 0,
    version: "18.3.1",
    rendererPackageName: "react-dom",
  },
  ul = {
    bundleType: tl.bundleType,
    version: tl.version,
    rendererPackageName: tl.rendererPackageName,
    rendererConfig: tl.rendererConfig,
    overrideHookState: null,
    overrideHookStateDeletePath: null,
    overrideHookStateRenamePath: null,
    overrideProps: null,
    overridePropsDeletePath: null,
    overridePropsRenamePath: null,
    setErrorHandler: null,
    setSuspenseHandler: null,
    scheduleUpdate: null,
    currentDispatcherRef: ua.ReactCurrentDispatcher,
    findHostInstanceByFiber: function (s) {
      return (s = Zb(s)), s === null ? null : s.stateNode;
    },
    findFiberByHostInstance: tl.findFiberByHostInstance || jl,
    findHostInstancesForRefresh: null,
    scheduleRefresh: null,
    scheduleRoot: null,
    setRefreshHandler: null,
    getCurrentFiber: null,
    reconcilerVersion: "18.3.1-next-f1338f8080-20240426",
  };
if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u") {
  var vl = __REACT_DEVTOOLS_GLOBAL_HOOK__;
  if (!vl.isDisabled && vl.supportsFiber)
    try {
      (kc = vl.inject(ul)), (lc = vl);
    } catch {}
}
reactDom_production_min.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = sl;
reactDom_production_min.createPortal = function (s, e) {
  var o = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null;
  if (!nl(e)) throw Error(p$1(200));
  return cl(s, e, null, o);
};
reactDom_production_min.createRoot = function (s, e) {
  if (!nl(s)) throw Error(p$1(299));
  var o = !1,
    a = "",
    c = kl;
  return (
    e != null &&
      (e.unstable_strictMode === !0 && (o = !0),
      e.identifierPrefix !== void 0 && (a = e.identifierPrefix),
      e.onRecoverableError !== void 0 && (c = e.onRecoverableError)),
    (e = bl(s, 1, !1, null, null, o, !1, a, c)),
    (s[uf] = e.current),
    sf(s.nodeType === 8 ? s.parentNode : s),
    new ll(e)
  );
};
reactDom_production_min.findDOMNode = function (s) {
  if (s == null) return null;
  if (s.nodeType === 1) return s;
  var e = s._reactInternals;
  if (e === void 0)
    throw typeof s.render == "function"
      ? Error(p$1(188))
      : ((s = Object.keys(s).join(",")), Error(p$1(268, s)));
  return (s = Zb(e)), (s = s === null ? null : s.stateNode), s;
};
reactDom_production_min.flushSync = function (s) {
  return Rk(s);
};
reactDom_production_min.hydrate = function (s, e, o) {
  if (!ol(e)) throw Error(p$1(200));
  return rl(null, s, e, !0, o);
};
reactDom_production_min.hydrateRoot = function (s, e, o) {
  if (!nl(s)) throw Error(p$1(405));
  var a = (o != null && o.hydratedSources) || null,
    c = !1,
    d = "",
    g = kl;
  if (
    (o != null &&
      (o.unstable_strictMode === !0 && (c = !0),
      o.identifierPrefix !== void 0 && (d = o.identifierPrefix),
      o.onRecoverableError !== void 0 && (g = o.onRecoverableError)),
    (e = el(e, null, s, 1, o ?? null, c, !1, d, g)),
    (s[uf] = e.current),
    sf(s),
    a)
  )
    for (s = 0; s < a.length; s++)
      (o = a[s]),
        (c = o._getVersion),
        (c = c(o._source)),
        e.mutableSourceEagerHydrationData == null
          ? (e.mutableSourceEagerHydrationData = [o, c])
          : e.mutableSourceEagerHydrationData.push(o, c);
  return new ml(e);
};
reactDom_production_min.render = function (s, e, o) {
  if (!ol(e)) throw Error(p$1(200));
  return rl(null, s, e, !1, o);
};
reactDom_production_min.unmountComponentAtNode = function (s) {
  if (!ol(s)) throw Error(p$1(40));
  return s._reactRootContainer
    ? (Rk(function () {
        rl(null, null, s, !1, function () {
          (s._reactRootContainer = null), (s[uf] = null);
        });
      }),
      !0)
    : !1;
};
reactDom_production_min.unstable_batchedUpdates = Qk;
reactDom_production_min.unstable_renderSubtreeIntoContainer = function (
  s,
  e,
  o,
  a
) {
  if (!ol(o)) throw Error(p$1(200));
  if (s == null || s._reactInternals === void 0) throw Error(p$1(38));
  return rl(s, e, o, !1, a);
};
reactDom_production_min.version = "18.3.1-next-f1338f8080-20240426";
function checkDCE() {
  if (
    !(
      typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" ||
      typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function"
    )
  )
    try {
      __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);
    } catch (s) {
      console.error(s);
    }
}
checkDCE(), (reactDom.exports = reactDom_production_min);
var reactDomExports = reactDom.exports,
  createRoot$1,
  m$1 = reactDomExports;
(createRoot$1 = client.createRoot = m$1.createRoot),
  (client.hydrateRoot = m$1.hydrateRoot);
const MotionConfigContext = reactExports$1.createContext({
    transformPagePoint: (s) => s,
    isStatic: !1,
    reducedMotion: "never",
  }),
  MotionContext = reactExports$1.createContext({}),
  PresenceContext = reactExports$1.createContext(null),
  isBrowser$1 = typeof window < "u",
  useIsomorphicLayoutEffect$3 = isBrowser$1
    ? reactExports$1.useLayoutEffect
    : reactExports$1.useEffect,
  LazyContext = reactExports$1.createContext({ strict: !1 }),
  camelToDash = (s) => s.replace(/([a-z])([A-Z])/gu, "$1-$2").toLowerCase(),
  optimizedAppearDataId = "framerAppearId",
  optimizedAppearDataAttribute = "data-" + camelToDash(optimizedAppearDataId),
  MotionGlobalConfig = { skipAnimations: !1, useManualTiming: !1 };
function createRenderStep(s) {
  let e = new Set(),
    o = new Set(),
    a = !1,
    c = !1;
  const d = new WeakSet();
  let g = { delta: 0, timestamp: 0, isProcessing: !1 };
  function _(j) {
    d.has(j) && (b.schedule(j), s()), j(g);
  }
  const b = {
    schedule: (j, $ = !1, _e = !1) => {
      const rt = _e && a ? e : o;
      return $ && d.add(j), rt.has(j) || rt.add(j), j;
    },
    cancel: (j) => {
      o.delete(j), d.delete(j);
    },
    process: (j) => {
      if (((g = j), a)) {
        c = !0;
        return;
      }
      (a = !0),
        ([e, o] = [o, e]),
        o.clear(),
        e.forEach(_),
        (a = !1),
        c && ((c = !1), b.process(j));
    },
  };
  return b;
}
const stepsOrder = [
    "read",
    "resolveKeyframes",
    "update",
    "preRender",
    "render",
    "postRender",
  ],
  maxElapsed = 40;
function createRenderBatcher(s, e) {
  let o = !1,
    a = !0;
  const c = { delta: 0, timestamp: 0, isProcessing: !1 },
    d = () => (o = !0),
    g = stepsOrder.reduce((it, lt) => ((it[lt] = createRenderStep(d)), it), {}),
    {
      read: _,
      resolveKeyframes: b,
      update: j,
      preRender: $,
      render: _e,
      postRender: et,
    } = g,
    rt = () => {
      const it = performance.now();
      (o = !1),
        (c.delta = a
          ? 1e3 / 60
          : Math.max(Math.min(it - c.timestamp, maxElapsed), 1)),
        (c.timestamp = it),
        (c.isProcessing = !0),
        _.process(c),
        b.process(c),
        j.process(c),
        $.process(c),
        _e.process(c),
        et.process(c),
        (c.isProcessing = !1),
        o && e && ((a = !1), s(rt));
    },
    st = () => {
      (o = !0), (a = !0), c.isProcessing || s(rt);
    };
  return {
    schedule: stepsOrder.reduce((it, lt) => {
      const ot = g[lt];
      return (
        (it[lt] = (ut, pt = !1, ft = !1) => (
          o || st(), ot.schedule(ut, pt, ft)
        )),
        it
      );
    }, {}),
    cancel: (it) => {
      for (let lt = 0; lt < stepsOrder.length; lt++)
        g[stepsOrder[lt]].cancel(it);
    },
    state: c,
    steps: g,
  };
}
const { schedule: microtask, cancel: cancelMicrotask } = createRenderBatcher(
  queueMicrotask,
  !1
);
function isRefObject$1(s) {
  return (
    s &&
    typeof s == "object" &&
    Object.prototype.hasOwnProperty.call(s, "current")
  );
}
const SwitchLayoutGroupContext = reactExports$1.createContext({});
let scheduleHandoffComplete = !1;
function useVisualElement(s, e, o, a, c) {
  const { visualElement: d } = reactExports$1.useContext(MotionContext),
    g = reactExports$1.useContext(LazyContext),
    _ = reactExports$1.useContext(PresenceContext),
    b = reactExports$1.useContext(MotionConfigContext).reducedMotion,
    j = reactExports$1.useRef();
  (a = a || g.renderer),
    !j.current &&
      a &&
      (j.current = a(s, {
        visualState: e,
        parent: d,
        props: o,
        presenceContext: _,
        blockInitialAnimation: _ ? _.initial === !1 : !1,
        reducedMotionConfig: b,
      }));
  const $ = j.current,
    _e = reactExports$1.useContext(SwitchLayoutGroupContext);
  $ &&
    !$.projection &&
    c &&
    ($.type === "html" || $.type === "svg") &&
    createProjectionNode$1(j.current, o, c, _e),
    reactExports$1.useInsertionEffect(() => {
      $ && $.update(o, _);
    });
  const et = reactExports$1.useRef(
    !!(o[optimizedAppearDataAttribute] && !window.HandoffComplete)
  );
  return (
    useIsomorphicLayoutEffect$3(() => {
      $ &&
        ($.updateFeatures(),
        microtask.render($.render),
        et.current && $.animationState && $.animationState.animateChanges());
    }),
    reactExports$1.useEffect(() => {
      $ &&
        (!et.current && $.animationState && $.animationState.animateChanges(),
        et.current &&
          ((et.current = !1),
          scheduleHandoffComplete ||
            ((scheduleHandoffComplete = !0), queueMicrotask(completeHandoff))));
    }),
    $
  );
}
function completeHandoff() {
  window.HandoffComplete = !0;
}
function createProjectionNode$1(s, e, o, a) {
  const {
    layoutId: c,
    layout: d,
    drag: g,
    dragConstraints: _,
    layoutScroll: b,
    layoutRoot: j,
  } = e;
  (s.projection = new o(
    s.latestValues,
    e["data-framer-portal-id"] ? void 0 : getClosestProjectingNode(s.parent)
  )),
    s.projection.setOptions({
      layoutId: c,
      layout: d,
      alwaysMeasureLayout: !!g || (_ && isRefObject$1(_)),
      visualElement: s,
      animationType: typeof d == "string" ? d : "both",
      initialPromotionConfig: a,
      layoutScroll: b,
      layoutRoot: j,
    });
}
function getClosestProjectingNode(s) {
  if (s)
    return s.options.allowProjection !== !1
      ? s.projection
      : getClosestProjectingNode(s.parent);
}
function useMotionRef(s, e, o) {
  return reactExports$1.useCallback(
    (a) => {
      a && s.mount && s.mount(a),
        e && (a ? e.mount(a) : e.unmount()),
        o &&
          (typeof o == "function" ? o(a) : isRefObject$1(o) && (o.current = a));
    },
    [e]
  );
}
function isVariantLabel(s) {
  return typeof s == "string" || Array.isArray(s);
}
function isAnimationControls(s) {
  return s !== null && typeof s == "object" && typeof s.start == "function";
}
const variantPriorityOrder = [
    "animate",
    "whileInView",
    "whileFocus",
    "whileHover",
    "whileTap",
    "whileDrag",
    "exit",
  ],
  variantProps = ["initial", ...variantPriorityOrder];
function isControllingVariants(s) {
  return (
    isAnimationControls(s.animate) ||
    variantProps.some((e) => isVariantLabel(s[e]))
  );
}
function isVariantNode(s) {
  return !!(isControllingVariants(s) || s.variants);
}
function getCurrentTreeVariants(s, e) {
  if (isControllingVariants(s)) {
    const { initial: o, animate: a } = s;
    return {
      initial: o === !1 || isVariantLabel(o) ? o : void 0,
      animate: isVariantLabel(a) ? a : void 0,
    };
  }
  return s.inherit !== !1 ? e : {};
}
function useCreateMotionContext(s) {
  const { initial: e, animate: o } = getCurrentTreeVariants(
    s,
    reactExports$1.useContext(MotionContext)
  );
  return reactExports$1.useMemo(
    () => ({ initial: e, animate: o }),
    [variantLabelsAsDependency(e), variantLabelsAsDependency(o)]
  );
}
function variantLabelsAsDependency(s) {
  return Array.isArray(s) ? s.join(" ") : s;
}
const featureProps = {
    animation: [
      "animate",
      "variants",
      "whileHover",
      "whileTap",
      "exit",
      "whileInView",
      "whileFocus",
      "whileDrag",
    ],
    exit: ["exit"],
    drag: ["drag", "dragControls"],
    focus: ["whileFocus"],
    hover: ["whileHover", "onHoverStart", "onHoverEnd"],
    tap: ["whileTap", "onTap", "onTapStart", "onTapCancel"],
    pan: ["onPan", "onPanStart", "onPanSessionStart", "onPanEnd"],
    inView: ["whileInView", "onViewportEnter", "onViewportLeave"],
    layout: ["layout", "layoutId"],
  },
  featureDefinitions = {};
for (const s in featureProps)
  featureDefinitions[s] = {
    isEnabled: (e) => featureProps[s].some((o) => !!e[o]),
  };
function loadFeatures(s) {
  for (const e in s)
    featureDefinitions[e] = { ...featureDefinitions[e], ...s[e] };
}
const LayoutGroupContext = reactExports$1.createContext({}),
  motionComponentSymbol = Symbol.for("motionComponentSymbol"),
  noop = (s) => s;
let invariant$1 = noop;
function createMotionComponent({
  preloadedFeatures: s,
  createVisualElement: e,
  useRender: o,
  useVisualState: a,
  Component: c,
}) {
  s && loadFeatures(s);
  function d(_, b) {
    let j;
    const $ = {
        ...reactExports$1.useContext(MotionConfigContext),
        ..._,
        layoutId: useLayoutId(_),
      },
      { isStatic: _e } = $,
      et = useCreateMotionContext(_),
      rt = a(_, _e);
    if (!_e && isBrowser$1) {
      useStrictMode();
      const st = getProjectionFunctionality($);
      (j = st.MeasureLayout),
        (et.visualElement = useVisualElement(c, rt, $, e, st.ProjectionNode));
    }
    return jsxRuntimeExports.jsxs(MotionContext.Provider, {
      value: et,
      children: [
        j && et.visualElement
          ? jsxRuntimeExports.jsx(j, { visualElement: et.visualElement, ...$ })
          : null,
        o(
          c,
          _,
          useMotionRef(rt, et.visualElement, b),
          rt,
          _e,
          et.visualElement
        ),
      ],
    });
  }
  const g = reactExports$1.forwardRef(d);
  return (g[motionComponentSymbol] = c), g;
}
function useLayoutId({ layoutId: s }) {
  const e = reactExports$1.useContext(LayoutGroupContext).id;
  return e && s !== void 0 ? e + "-" + s : s;
}
function useStrictMode(s, e) {
  reactExports$1.useContext(LazyContext).strict;
}
function getProjectionFunctionality(s) {
  const { drag: e, layout: o } = featureDefinitions;
  if (!e && !o) return {};
  const a = { ...e, ...o };
  return {
    MeasureLayout:
      (e != null && e.isEnabled(s)) || (o != null && o.isEnabled(s))
        ? a.MeasureLayout
        : void 0,
    ProjectionNode: a.ProjectionNode,
  };
}
function createMotionProxy(s) {
  function e(a, c = {}) {
    return createMotionComponent(s(a, c));
  }
  if (typeof Proxy > "u") return e;
  const o = new Map();
  return new Proxy(e, {
    get: (a, c) => (o.has(c) || o.set(c, e(c)), o.get(c)),
  });
}
const lowercaseSVGElements = [
  "animate",
  "circle",
  "defs",
  "desc",
  "ellipse",
  "g",
  "image",
  "line",
  "filter",
  "marker",
  "mask",
  "metadata",
  "path",
  "pattern",
  "polygon",
  "polyline",
  "rect",
  "stop",
  "switch",
  "symbol",
  "svg",
  "text",
  "tspan",
  "use",
  "view",
];
function isSVGComponent(s) {
  return typeof s != "string" || s.includes("-")
    ? !1
    : !!(lowercaseSVGElements.indexOf(s) > -1 || /[A-Z]/u.test(s));
}
const scaleCorrectors = {};
function addScaleCorrector(s) {
  Object.assign(scaleCorrectors, s);
}
const transformPropOrder = [
    "transformPerspective",
    "x",
    "y",
    "z",
    "translateX",
    "translateY",
    "translateZ",
    "scale",
    "scaleX",
    "scaleY",
    "rotate",
    "rotateX",
    "rotateY",
    "rotateZ",
    "skew",
    "skewX",
    "skewY",
  ],
  transformProps = new Set(transformPropOrder);
function isForcedMotionValue(s, { layout: e, layoutId: o }) {
  return (
    transformProps.has(s) ||
    s.startsWith("origin") ||
    ((e || o !== void 0) && (!!scaleCorrectors[s] || s === "opacity"))
  );
}
const isMotionValue = (s) => !!(s && s.getVelocity),
  translateAlias = {
    x: "translateX",
    y: "translateY",
    z: "translateZ",
    transformPerspective: "perspective",
  },
  numTransforms = transformPropOrder.length;
function buildTransform(s, e, o) {
  let a = "";
  for (let c = 0; c < numTransforms; c++) {
    const d = transformPropOrder[c];
    if (s[d] !== void 0) {
      const g = translateAlias[d] || d;
      a += `${g}(${s[d]}) `;
    }
  }
  return (a = a.trim()), o ? (a = o(s, e ? "" : a)) : e && (a = "none"), a;
}
const checkStringStartsWith = (s) => (e) =>
    typeof e == "string" && e.startsWith(s),
  isCSSVariableName = checkStringStartsWith("--"),
  startsAsVariableToken = checkStringStartsWith("var(--"),
  isCSSVariableToken = (s) =>
    startsAsVariableToken(s)
      ? singleCssVariableRegex.test(s.split("/*")[0].trim())
      : !1,
  singleCssVariableRegex =
    /var\(--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)$/iu,
  getValueAsType = (s, e) => (e && typeof s == "number" ? e.transform(s) : s),
  clamp$1 = (s, e, o) => (o > e ? e : o < s ? s : o),
  number = {
    test: (s) => typeof s == "number",
    parse: parseFloat,
    transform: (s) => s,
  },
  alpha = { ...number, transform: (s) => clamp$1(0, 1, s) },
  scale = { ...number, default: 1 },
  sanitize = (s) => Math.round(s * 1e5) / 1e5,
  floatRegex = /-?(?:\d+(?:\.\d+)?|\.\d+)/gu,
  colorRegex =
    /(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))/giu,
  singleColorRegex =
    /^(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))$/iu;
function isString(s) {
  return typeof s == "string";
}
function isNullish(s) {
  return s == null;
}
const createUnitType = (s) => ({
    test: (e) => isString(e) && e.endsWith(s) && e.split(" ").length === 1,
    parse: parseFloat,
    transform: (e) => `${e}${s}`,
  }),
  degrees = createUnitType("deg"),
  percent = createUnitType("%"),
  px$1 = createUnitType("px"),
  vh = createUnitType("vh"),
  vw = createUnitType("vw"),
  progressPercentage = {
    ...percent,
    parse: (s) => percent.parse(s) / 100,
    transform: (s) => percent.transform(s * 100),
  },
  int = { ...number, transform: Math.round },
  numberValueTypes = {
    borderWidth: px$1,
    borderTopWidth: px$1,
    borderRightWidth: px$1,
    borderBottomWidth: px$1,
    borderLeftWidth: px$1,
    borderRadius: px$1,
    radius: px$1,
    borderTopLeftRadius: px$1,
    borderTopRightRadius: px$1,
    borderBottomRightRadius: px$1,
    borderBottomLeftRadius: px$1,
    width: px$1,
    maxWidth: px$1,
    height: px$1,
    maxHeight: px$1,
    size: px$1,
    top: px$1,
    right: px$1,
    bottom: px$1,
    left: px$1,
    padding: px$1,
    paddingTop: px$1,
    paddingRight: px$1,
    paddingBottom: px$1,
    paddingLeft: px$1,
    margin: px$1,
    marginTop: px$1,
    marginRight: px$1,
    marginBottom: px$1,
    marginLeft: px$1,
    rotate: degrees,
    rotateX: degrees,
    rotateY: degrees,
    rotateZ: degrees,
    scale,
    scaleX: scale,
    scaleY: scale,
    scaleZ: scale,
    skew: degrees,
    skewX: degrees,
    skewY: degrees,
    distance: px$1,
    translateX: px$1,
    translateY: px$1,
    translateZ: px$1,
    x: px$1,
    y: px$1,
    z: px$1,
    perspective: px$1,
    transformPerspective: px$1,
    opacity: alpha,
    originX: progressPercentage,
    originY: progressPercentage,
    originZ: px$1,
    zIndex: int,
    backgroundPositionX: px$1,
    backgroundPositionY: px$1,
    fillOpacity: alpha,
    strokeOpacity: alpha,
    numOctaves: int,
  };
function buildHTMLStyles(s, e, o) {
  const { style: a, vars: c, transform: d, transformOrigin: g } = s;
  let _ = !1,
    b = !1,
    j = !0;
  for (const $ in e) {
    const _e = e[$];
    if (isCSSVariableName($)) {
      c[$] = _e;
      continue;
    }
    const et = numberValueTypes[$],
      rt = getValueAsType(_e, et);
    if (transformProps.has($)) {
      if (((_ = !0), (d[$] = rt), !j)) continue;
      _e !== (et.default || 0) && (j = !1);
    } else $.startsWith("origin") ? ((b = !0), (g[$] = rt)) : (a[$] = rt);
  }
  if (
    (e.transform ||
      (_ || o
        ? (a.transform = buildTransform(s.transform, j, o))
        : a.transform && (a.transform = "none")),
    b)
  ) {
    const { originX: $ = "50%", originY: _e = "50%", originZ: et = 0 } = g;
    a.transformOrigin = `${$} ${_e} ${et}`;
  }
}
const createHtmlRenderState = () => ({
  style: {},
  transform: {},
  transformOrigin: {},
  vars: {},
});
function copyRawValuesOnly(s, e, o) {
  for (const a in e)
    !isMotionValue(e[a]) && !isForcedMotionValue(a, o) && (s[a] = e[a]);
}
function useInitialMotionValues({ transformTemplate: s }, e) {
  return reactExports$1.useMemo(() => {
    const o = createHtmlRenderState();
    return buildHTMLStyles(o, e, s), Object.assign({}, o.vars, o.style);
  }, [e]);
}
function useStyle(s, e) {
  const o = s.style || {},
    a = {};
  return (
    copyRawValuesOnly(a, o, s),
    Object.assign(a, useInitialMotionValues(s, e)),
    a
  );
}
function useHTMLProps(s, e) {
  const o = {},
    a = useStyle(s, e);
  return (
    s.drag &&
      s.dragListener !== !1 &&
      ((o.draggable = !1),
      (a.userSelect = a.WebkitUserSelect = a.WebkitTouchCallout = "none"),
      (a.touchAction =
        s.drag === !0 ? "none" : `pan-${s.drag === "x" ? "y" : "x"}`)),
    s.tabIndex === void 0 &&
      (s.onTap || s.onTapStart || s.whileTap) &&
      (o.tabIndex = 0),
    (o.style = a),
    o
  );
}
const validMotionProps = new Set([
  "animate",
  "exit",
  "variants",
  "initial",
  "style",
  "values",
  "variants",
  "transition",
  "transformTemplate",
  "custom",
  "inherit",
  "onBeforeLayoutMeasure",
  "onAnimationStart",
  "onAnimationComplete",
  "onUpdate",
  "onDragStart",
  "onDrag",
  "onDragEnd",
  "onMeasureDragConstraints",
  "onDirectionLock",
  "onDragTransitionEnd",
  "_dragX",
  "_dragY",
  "onHoverStart",
  "onHoverEnd",
  "onViewportEnter",
  "onViewportLeave",
  "globalTapTarget",
  "ignoreStrict",
  "viewport",
]);
function isValidMotionProp(s) {
  return (
    s.startsWith("while") ||
    (s.startsWith("drag") && s !== "draggable") ||
    s.startsWith("layout") ||
    s.startsWith("onTap") ||
    s.startsWith("onPan") ||
    s.startsWith("onLayout") ||
    validMotionProps.has(s)
  );
}
let shouldForward = (s) => !isValidMotionProp(s);
function loadExternalIsValidProp(s) {
  s &&
    (shouldForward = (e) =>
      e.startsWith("on") ? !isValidMotionProp(e) : s(e));
}
try {
  loadExternalIsValidProp(require("@emotion/is-prop-valid").default);
} catch {}
function filterProps(s, e, o) {
  const a = {};
  for (const c in s)
    (c === "values" && typeof s.values == "object") ||
      ((shouldForward(c) ||
        (o === !0 && isValidMotionProp(c)) ||
        (!e && !isValidMotionProp(c)) ||
        (s.draggable && c.startsWith("onDrag"))) &&
        (a[c] = s[c]));
  return a;
}
function calcOrigin$1(s, e, o) {
  return typeof s == "string" ? s : px$1.transform(e + o * s);
}
function calcSVGTransformOrigin(s, e, o) {
  const a = calcOrigin$1(e, s.x, s.width),
    c = calcOrigin$1(o, s.y, s.height);
  return `${a} ${c}`;
}
const dashKeys = { offset: "stroke-dashoffset", array: "stroke-dasharray" },
  camelKeys = { offset: "strokeDashoffset", array: "strokeDasharray" };
function buildSVGPath(s, e, o = 1, a = 0, c = !0) {
  s.pathLength = 1;
  const d = c ? dashKeys : camelKeys;
  s[d.offset] = px$1.transform(-a);
  const g = px$1.transform(e),
    _ = px$1.transform(o);
  s[d.array] = `${g} ${_}`;
}
function buildSVGAttrs(
  s,
  {
    attrX: e,
    attrY: o,
    attrScale: a,
    originX: c,
    originY: d,
    pathLength: g,
    pathSpacing: _ = 1,
    pathOffset: b = 0,
    ...j
  },
  $,
  _e
) {
  if ((buildHTMLStyles(s, j, _e), $)) {
    s.style.viewBox && (s.attrs.viewBox = s.style.viewBox);
    return;
  }
  (s.attrs = s.style), (s.style = {});
  const { attrs: et, style: rt, dimensions: st } = s;
  et.transform && (st && (rt.transform = et.transform), delete et.transform),
    st &&
      (c !== void 0 || d !== void 0 || rt.transform) &&
      (rt.transformOrigin = calcSVGTransformOrigin(
        st,
        c !== void 0 ? c : 0.5,
        d !== void 0 ? d : 0.5
      )),
    e !== void 0 && (et.x = e),
    o !== void 0 && (et.y = o),
    a !== void 0 && (et.scale = a),
    g !== void 0 && buildSVGPath(et, g, _, b, !1);
}
const createSvgRenderState = () => ({ ...createHtmlRenderState(), attrs: {} }),
  isSVGTag = (s) => typeof s == "string" && s.toLowerCase() === "svg";
function useSVGProps(s, e, o, a) {
  const c = reactExports$1.useMemo(() => {
    const d = createSvgRenderState();
    return (
      buildSVGAttrs(d, e, isSVGTag(a), s.transformTemplate),
      { ...d.attrs, style: { ...d.style } }
    );
  }, [e]);
  if (s.style) {
    const d = {};
    copyRawValuesOnly(d, s.style, s), (c.style = { ...d, ...c.style });
  }
  return c;
}
function createUseRender(s = !1) {
  return (o, a, c, { latestValues: d }, g) => {
    const b = (isSVGComponent(o) ? useSVGProps : useHTMLProps)(a, d, g, o),
      j = filterProps(a, typeof o == "string", s),
      $ = o !== reactExports$1.Fragment ? { ...j, ...b, ref: c } : {},
      { children: _e } = a,
      et = reactExports$1.useMemo(
        () => (isMotionValue(_e) ? _e.get() : _e),
        [_e]
      );
    return reactExports$1.createElement(o, { ...$, children: et });
  };
}
function renderHTML(s, { style: e, vars: o }, a, c) {
  Object.assign(s.style, e, c && c.getProjectionStyles(a));
  for (const d in o) s.style.setProperty(d, o[d]);
}
const camelCaseAttributes = new Set([
  "baseFrequency",
  "diffuseConstant",
  "kernelMatrix",
  "kernelUnitLength",
  "keySplines",
  "keyTimes",
  "limitingConeAngle",
  "markerHeight",
  "markerWidth",
  "numOctaves",
  "targetX",
  "targetY",
  "surfaceScale",
  "specularConstant",
  "specularExponent",
  "stdDeviation",
  "tableValues",
  "viewBox",
  "gradientTransform",
  "pathLength",
  "startOffset",
  "textLength",
  "lengthAdjust",
]);
function renderSVG(s, e, o, a) {
  renderHTML(s, e, void 0, a);
  for (const c in e.attrs)
    s.setAttribute(camelCaseAttributes.has(c) ? c : camelToDash(c), e.attrs[c]);
}
function scrapeMotionValuesFromProps$1(s, e, o) {
  var a;
  const { style: c } = s,
    d = {};
  for (const g in c)
    (isMotionValue(c[g]) ||
      (e.style && isMotionValue(e.style[g])) ||
      isForcedMotionValue(g, s) ||
      ((a = o == null ? void 0 : o.getValue(g)) === null || a === void 0
        ? void 0
        : a.liveStyle) !== void 0) &&
      (d[g] = c[g]);
  return (
    o && c && typeof c.willChange == "string" && (o.applyWillChange = !1), d
  );
}
function scrapeMotionValuesFromProps(s, e, o) {
  const a = scrapeMotionValuesFromProps$1(s, e, o);
  for (const c in s)
    if (isMotionValue(s[c]) || isMotionValue(e[c])) {
      const d =
        transformPropOrder.indexOf(c) !== -1
          ? "attr" + c.charAt(0).toUpperCase() + c.substring(1)
          : c;
      a[d] = s[c];
    }
  return a;
}
function getValueState(s) {
  const e = [{}, {}];
  return (
    s == null ||
      s.values.forEach((o, a) => {
        (e[0][a] = o.get()), (e[1][a] = o.getVelocity());
      }),
    e
  );
}
function resolveVariantFromProps(s, e, o, a) {
  if (typeof e == "function") {
    const [c, d] = getValueState(a);
    e = e(o !== void 0 ? o : s.custom, c, d);
  }
  if (
    (typeof e == "string" && (e = s.variants && s.variants[e]),
    typeof e == "function")
  ) {
    const [c, d] = getValueState(a);
    e = e(o !== void 0 ? o : s.custom, c, d);
  }
  return e;
}
function useConstant(s) {
  const e = reactExports$1.useRef(null);
  return e.current === null && (e.current = s()), e.current;
}
const isKeyframesTarget = (s) => Array.isArray(s),
  isCustomValue = (s) => !!(s && typeof s == "object" && s.mix && s.toValue),
  resolveFinalValueInKeyframes = (s) =>
    isKeyframesTarget(s) ? s[s.length - 1] || 0 : s;
function resolveMotionValue(s) {
  const e = isMotionValue(s) ? s.get() : s;
  return isCustomValue(e) ? e.toValue() : e;
}
const acceleratedValues = new Set([
  "opacity",
  "clipPath",
  "filter",
  "transform",
]);
function getWillChangeName(s) {
  if (transformProps.has(s)) return "transform";
  if (acceleratedValues.has(s)) return camelToDash(s);
}
function addUniqueItem(s, e) {
  s.indexOf(e) === -1 && s.push(e);
}
function removeItem(s, e) {
  const o = s.indexOf(e);
  o > -1 && s.splice(o, 1);
}
function makeState(
  {
    applyWillChange: s = !1,
    scrapeMotionValuesFromProps: e,
    createRenderState: o,
    onMount: a,
  },
  c,
  d,
  g,
  _
) {
  const b = {
    latestValues: makeLatestValues(c, d, g, _ ? !1 : s, e),
    renderState: o(),
  };
  return a && (b.mount = (j) => a(c, j, b)), b;
}
const makeUseVisualState = (s) => (e, o) => {
  const a = reactExports$1.useContext(MotionContext),
    c = reactExports$1.useContext(PresenceContext),
    d = () => makeState(s, e, a, c, o);
  return o ? d() : useConstant(d);
};
function addWillChange(s, e) {
  const o = getWillChangeName(e);
  o && addUniqueItem(s, o);
}
function forEachDefinition(s, e, o) {
  const a = Array.isArray(e) ? e : [e];
  for (let c = 0; c < a.length; c++) {
    const d = resolveVariantFromProps(s, a[c]);
    if (d) {
      const { transitionEnd: g, transition: _, ...b } = d;
      o(b, g);
    }
  }
}
function makeLatestValues(s, e, o, a, c) {
  var d;
  const g = {},
    _ = [],
    b =
      a &&
      ((d = s.style) === null || d === void 0 ? void 0 : d.willChange) ===
        void 0,
    j = c(s, {});
  for (const ct in j) g[ct] = resolveMotionValue(j[ct]);
  let { initial: $, animate: _e } = s;
  const et = isControllingVariants(s),
    rt = isVariantNode(s);
  e &&
    rt &&
    !et &&
    s.inherit !== !1 &&
    ($ === void 0 && ($ = e.initial), _e === void 0 && (_e = e.animate));
  let st = o ? o.initial === !1 : !1;
  st = st || $ === !1;
  const at = st ? _e : $;
  return (
    at &&
      typeof at != "boolean" &&
      !isAnimationControls(at) &&
      forEachDefinition(s, at, (ct, it) => {
        for (const lt in ct) {
          let ot = ct[lt];
          if (Array.isArray(ot)) {
            const ut = st ? ot.length - 1 : 0;
            ot = ot[ut];
          }
          ot !== null && (g[lt] = ot);
        }
        for (const lt in it) g[lt] = it[lt];
      }),
    b &&
      (_e &&
        $ !== !1 &&
        !isAnimationControls(_e) &&
        forEachDefinition(s, _e, (ct) => {
          for (const it in ct) addWillChange(_, it);
        }),
      _.length && (g.willChange = _.join(","))),
    g
  );
}
const {
    schedule: frame,
    cancel: cancelFrame,
    state: frameData,
    steps,
  } = createRenderBatcher(
    typeof requestAnimationFrame < "u" ? requestAnimationFrame : noop,
    !0
  ),
  svgMotionConfig = {
    useVisualState: makeUseVisualState({
      scrapeMotionValuesFromProps,
      createRenderState: createSvgRenderState,
      onMount: (s, e, { renderState: o, latestValues: a }) => {
        frame.read(() => {
          try {
            o.dimensions =
              typeof e.getBBox == "function"
                ? e.getBBox()
                : e.getBoundingClientRect();
          } catch {
            o.dimensions = { x: 0, y: 0, width: 0, height: 0 };
          }
        }),
          frame.render(() => {
            buildSVGAttrs(o, a, isSVGTag(e.tagName), s.transformTemplate),
              renderSVG(e, o);
          });
      },
    }),
  },
  htmlMotionConfig = {
    useVisualState: makeUseVisualState({
      applyWillChange: !0,
      scrapeMotionValuesFromProps: scrapeMotionValuesFromProps$1,
      createRenderState: createHtmlRenderState,
    }),
  };
function createDomMotionConfig(s, { forwardMotionProps: e = !1 }, o, a) {
  return {
    ...(isSVGComponent(s) ? svgMotionConfig : htmlMotionConfig),
    preloadedFeatures: o,
    useRender: createUseRender(e),
    createVisualElement: a,
    Component: s,
  };
}
function addDomEvent(s, e, o, a = { passive: !0 }) {
  return s.addEventListener(e, o, a), () => s.removeEventListener(e, o);
}
const isPrimaryPointer = (s) =>
  s.pointerType === "mouse"
    ? typeof s.button != "number" || s.button <= 0
    : s.isPrimary !== !1;
function extractEventInfo(s, e = "page") {
  return { point: { x: s[`${e}X`], y: s[`${e}Y`] } };
}
const addPointerInfo = (s) => (e) =>
  isPrimaryPointer(e) && s(e, extractEventInfo(e));
function addPointerEvent(s, e, o, a) {
  return addDomEvent(s, e, addPointerInfo(o), a);
}
const combineFunctions = (s, e) => (o) => e(s(o)),
  pipe = (...s) => s.reduce(combineFunctions);
function createLock(s) {
  let e = null;
  return () => {
    const o = () => {
      e = null;
    };
    return e === null ? ((e = s), o) : !1;
  };
}
const globalHorizontalLock = createLock("dragHorizontal"),
  globalVerticalLock = createLock("dragVertical");
function getGlobalLock(s) {
  let e = !1;
  if (s === "y") e = globalVerticalLock();
  else if (s === "x") e = globalHorizontalLock();
  else {
    const o = globalHorizontalLock(),
      a = globalVerticalLock();
    o && a
      ? (e = () => {
          o(), a();
        })
      : (o && o(), a && a());
  }
  return e;
}
function isDragActive() {
  const s = getGlobalLock(!0);
  return s ? (s(), !1) : !0;
}
class Feature {
  constructor(e) {
    (this.isMounted = !1), (this.node = e);
  }
  update() {}
}
function addHoverEvent(s, e) {
  const o = e ? "pointerenter" : "pointerleave",
    a = e ? "onHoverStart" : "onHoverEnd",
    c = (d, g) => {
      if (d.pointerType === "touch" || isDragActive()) return;
      const _ = s.getProps();
      s.animationState &&
        _.whileHover &&
        s.animationState.setActive("whileHover", e);
      const b = _[a];
      b && frame.postRender(() => b(d, g));
    };
  return addPointerEvent(s.current, o, c, { passive: !s.getProps()[a] });
}
class HoverGesture extends Feature {
  mount() {
    this.unmount = pipe(
      addHoverEvent(this.node, !0),
      addHoverEvent(this.node, !1)
    );
  }
  unmount() {}
}
class FocusGesture extends Feature {
  constructor() {
    super(...arguments), (this.isActive = !1);
  }
  onFocus() {
    let e = !1;
    try {
      e = this.node.current.matches(":focus-visible");
    } catch {
      e = !0;
    }
    !e ||
      !this.node.animationState ||
      (this.node.animationState.setActive("whileFocus", !0),
      (this.isActive = !0));
  }
  onBlur() {
    !this.isActive ||
      !this.node.animationState ||
      (this.node.animationState.setActive("whileFocus", !1),
      (this.isActive = !1));
  }
  mount() {
    this.unmount = pipe(
      addDomEvent(this.node.current, "focus", () => this.onFocus()),
      addDomEvent(this.node.current, "blur", () => this.onBlur())
    );
  }
  unmount() {}
}
const isNodeOrChild = (s, e) =>
  e ? (s === e ? !0 : isNodeOrChild(s, e.parentElement)) : !1;
function fireSyntheticPointerEvent(s, e) {
  if (!e) return;
  const o = new PointerEvent("pointer" + s);
  e(o, extractEventInfo(o));
}
class PressGesture extends Feature {
  constructor() {
    super(...arguments),
      (this.removeStartListeners = noop),
      (this.removeEndListeners = noop),
      (this.removeAccessibleListeners = noop),
      (this.startPointerPress = (e, o) => {
        if (this.isPressing) return;
        this.removeEndListeners();
        const a = this.node.getProps(),
          d = addPointerEvent(
            window,
            "pointerup",
            (_, b) => {
              if (!this.checkPressEnd()) return;
              const {
                  onTap: j,
                  onTapCancel: $,
                  globalTapTarget: _e,
                } = this.node.getProps(),
                et = !_e && !isNodeOrChild(this.node.current, _.target) ? $ : j;
              et && frame.update(() => et(_, b));
            },
            { passive: !(a.onTap || a.onPointerUp) }
          ),
          g = addPointerEvent(
            window,
            "pointercancel",
            (_, b) => this.cancelPress(_, b),
            { passive: !(a.onTapCancel || a.onPointerCancel) }
          );
        (this.removeEndListeners = pipe(d, g)), this.startPress(e, o);
      }),
      (this.startAccessiblePress = () => {
        const e = (d) => {
            if (d.key !== "Enter" || this.isPressing) return;
            const g = (_) => {
              _.key !== "Enter" ||
                !this.checkPressEnd() ||
                fireSyntheticPointerEvent("up", (b, j) => {
                  const { onTap: $ } = this.node.getProps();
                  $ && frame.postRender(() => $(b, j));
                });
            };
            this.removeEndListeners(),
              (this.removeEndListeners = addDomEvent(
                this.node.current,
                "keyup",
                g
              )),
              fireSyntheticPointerEvent("down", (_, b) => {
                this.startPress(_, b);
              });
          },
          o = addDomEvent(this.node.current, "keydown", e),
          a = () => {
            this.isPressing &&
              fireSyntheticPointerEvent("cancel", (d, g) =>
                this.cancelPress(d, g)
              );
          },
          c = addDomEvent(this.node.current, "blur", a);
        this.removeAccessibleListeners = pipe(o, c);
      });
  }
  startPress(e, o) {
    this.isPressing = !0;
    const { onTapStart: a, whileTap: c } = this.node.getProps();
    c &&
      this.node.animationState &&
      this.node.animationState.setActive("whileTap", !0),
      a && frame.postRender(() => a(e, o));
  }
  checkPressEnd() {
    return (
      this.removeEndListeners(),
      (this.isPressing = !1),
      this.node.getProps().whileTap &&
        this.node.animationState &&
        this.node.animationState.setActive("whileTap", !1),
      !isDragActive()
    );
  }
  cancelPress(e, o) {
    if (!this.checkPressEnd()) return;
    const { onTapCancel: a } = this.node.getProps();
    a && frame.postRender(() => a(e, o));
  }
  mount() {
    const e = this.node.getProps(),
      o = addPointerEvent(
        e.globalTapTarget ? window : this.node.current,
        "pointerdown",
        this.startPointerPress,
        { passive: !(e.onTapStart || e.onPointerStart) }
      ),
      a = addDomEvent(this.node.current, "focus", this.startAccessiblePress);
    this.removeStartListeners = pipe(o, a);
  }
  unmount() {
    this.removeStartListeners(),
      this.removeEndListeners(),
      this.removeAccessibleListeners();
  }
}
const observerCallbacks = new WeakMap(),
  observers = new WeakMap(),
  fireObserverCallback = (s) => {
    const e = observerCallbacks.get(s.target);
    e && e(s);
  },
  fireAllObserverCallbacks = (s) => {
    s.forEach(fireObserverCallback);
  };
function initIntersectionObserver({ root: s, ...e }) {
  const o = s || document;
  observers.has(o) || observers.set(o, {});
  const a = observers.get(o),
    c = JSON.stringify(e);
  return (
    a[c] ||
      (a[c] = new IntersectionObserver(fireAllObserverCallbacks, {
        root: s,
        ...e,
      })),
    a[c]
  );
}
function observeIntersection(s, e, o) {
  const a = initIntersectionObserver(e);
  return (
    observerCallbacks.set(s, o),
    a.observe(s),
    () => {
      observerCallbacks.delete(s), a.unobserve(s);
    }
  );
}
const thresholdNames = { some: 0, all: 1 };
class InViewFeature extends Feature {
  constructor() {
    super(...arguments), (this.hasEnteredView = !1), (this.isInView = !1);
  }
  startObserver() {
    this.unmount();
    const { viewport: e = {} } = this.node.getProps(),
      { root: o, margin: a, amount: c = "some", once: d } = e,
      g = {
        root: o ? o.current : void 0,
        rootMargin: a,
        threshold: typeof c == "number" ? c : thresholdNames[c],
      },
      _ = (b) => {
        const { isIntersecting: j } = b;
        if (
          this.isInView === j ||
          ((this.isInView = j), d && !j && this.hasEnteredView)
        )
          return;
        j && (this.hasEnteredView = !0),
          this.node.animationState &&
            this.node.animationState.setActive("whileInView", j);
        const { onViewportEnter: $, onViewportLeave: _e } =
            this.node.getProps(),
          et = j ? $ : _e;
        et && et(b);
      };
    return observeIntersection(this.node.current, g, _);
  }
  mount() {
    this.startObserver();
  }
  update() {
    if (typeof IntersectionObserver > "u") return;
    const { props: e, prevProps: o } = this.node;
    ["amount", "margin", "root"].some(hasViewportOptionChanged(e, o)) &&
      this.startObserver();
  }
  unmount() {}
}
function hasViewportOptionChanged(
  { viewport: s = {} },
  { viewport: e = {} } = {}
) {
  return (o) => s[o] !== e[o];
}
const gestureAnimations = {
  inView: { Feature: InViewFeature },
  tap: { Feature: PressGesture },
  focus: { Feature: FocusGesture },
  hover: { Feature: HoverGesture },
};
function shallowCompare(s, e) {
  if (!Array.isArray(e)) return !1;
  const o = e.length;
  if (o !== s.length) return !1;
  for (let a = 0; a < o; a++) if (e[a] !== s[a]) return !1;
  return !0;
}
function resolveVariant(s, e, o) {
  const a = s.getProps();
  return resolveVariantFromProps(a, e, o !== void 0 ? o : a.custom, s);
}
const secondsToMilliseconds = (s) => s * 1e3,
  millisecondsToSeconds = (s) => s / 1e3,
  underDampedSpring = {
    type: "spring",
    stiffness: 500,
    damping: 25,
    restSpeed: 10,
  },
  criticallyDampedSpring = (s) => ({
    type: "spring",
    stiffness: 550,
    damping: s === 0 ? 2 * Math.sqrt(550) : 30,
    restSpeed: 10,
  }),
  keyframesTransition = { type: "keyframes", duration: 0.8 },
  ease = { type: "keyframes", ease: [0.25, 0.1, 0.35, 1], duration: 0.3 },
  getDefaultTransition = (s, { keyframes: e }) =>
    e.length > 2
      ? keyframesTransition
      : transformProps.has(s)
      ? s.startsWith("scale")
        ? criticallyDampedSpring(e[1])
        : underDampedSpring
      : ease;
function isTransitionDefined({
  when: s,
  delay: e,
  delayChildren: o,
  staggerChildren: a,
  staggerDirection: c,
  repeat: d,
  repeatType: g,
  repeatDelay: _,
  from: b,
  elapsed: j,
  ...$
}) {
  return !!Object.keys($).length;
}
function getValueTransition(s, e) {
  return s[e] || s.default || s;
}
const isNotNull = (s) => s !== null;
function getFinalKeyframe(s, { repeat: e, repeatType: o = "loop" }, a) {
  const c = s.filter(isNotNull),
    d = e && o !== "loop" && e % 2 === 1 ? 0 : c.length - 1;
  return !d || a === void 0 ? c[d] : a;
}
let now$1;
function clearTime() {
  now$1 = void 0;
}
const time = {
    now: () => (
      now$1 === void 0 &&
        time.set(
          frameData.isProcessing || MotionGlobalConfig.useManualTiming
            ? frameData.timestamp
            : performance.now()
        ),
      now$1
    ),
    set: (s) => {
      (now$1 = s), queueMicrotask(clearTime);
    },
  },
  isZeroValueString = (s) => /^0[^.\s]+$/u.test(s);
function isNone(s) {
  return typeof s == "number"
    ? s === 0
    : s !== null
    ? s === "none" || s === "0" || isZeroValueString(s)
    : !0;
}
const isNumericalString = (s) => /^-?(?:\d+(?:\.\d+)?|\.\d+)$/u.test(s),
  splitCSSVariableRegex =
    /^var\(--(?:([\w-]+)|([\w-]+), ?([a-zA-Z\d ()%#.,-]+))\)/u;
function parseCSSVariable(s) {
  const e = splitCSSVariableRegex.exec(s);
  if (!e) return [,];
  const [, o, a, c] = e;
  return [`--${o ?? a}`, c];
}
function getVariableValue(s, e, o = 1) {
  const [a, c] = parseCSSVariable(s);
  if (!a) return;
  const d = window.getComputedStyle(e).getPropertyValue(a);
  if (d) {
    const g = d.trim();
    return isNumericalString(g) ? parseFloat(g) : g;
  }
  return isCSSVariableToken(c) ? getVariableValue(c, e, o + 1) : c;
}
const positionalKeys = new Set([
    "width",
    "height",
    "top",
    "left",
    "right",
    "bottom",
    "x",
    "y",
    "translateX",
    "translateY",
  ]),
  isNumOrPxType = (s) => s === number || s === px$1,
  getPosFromMatrix = (s, e) => parseFloat(s.split(", ")[e]),
  getTranslateFromMatrix =
    (s, e) =>
    (o, { transform: a }) => {
      if (a === "none" || !a) return 0;
      const c = a.match(/^matrix3d\((.+)\)$/u);
      if (c) return getPosFromMatrix(c[1], e);
      {
        const d = a.match(/^matrix\((.+)\)$/u);
        return d ? getPosFromMatrix(d[1], s) : 0;
      }
    },
  transformKeys = new Set(["x", "y", "z"]),
  nonTranslationalTransformKeys = transformPropOrder.filter(
    (s) => !transformKeys.has(s)
  );
function removeNonTranslationalTransform(s) {
  const e = [];
  return (
    nonTranslationalTransformKeys.forEach((o) => {
      const a = s.getValue(o);
      a !== void 0 &&
        (e.push([o, a.get()]), a.set(o.startsWith("scale") ? 1 : 0));
    }),
    e
  );
}
const positionalValues = {
  width: ({ x: s }, { paddingLeft: e = "0", paddingRight: o = "0" }) =>
    s.max - s.min - parseFloat(e) - parseFloat(o),
  height: ({ y: s }, { paddingTop: e = "0", paddingBottom: o = "0" }) =>
    s.max - s.min - parseFloat(e) - parseFloat(o),
  top: (s, { top: e }) => parseFloat(e),
  left: (s, { left: e }) => parseFloat(e),
  bottom: ({ y: s }, { top: e }) => parseFloat(e) + (s.max - s.min),
  right: ({ x: s }, { left: e }) => parseFloat(e) + (s.max - s.min),
  x: getTranslateFromMatrix(4, 13),
  y: getTranslateFromMatrix(5, 14),
};
positionalValues.translateX = positionalValues.x;
positionalValues.translateY = positionalValues.y;
const testValueType = (s) => (e) => e.test(s),
  auto = { test: (s) => s === "auto", parse: (s) => s },
  dimensionValueTypes = [number, px$1, percent, degrees, vw, vh, auto],
  findDimensionValueType = (s) => dimensionValueTypes.find(testValueType(s)),
  toResolve = new Set();
let isScheduled = !1,
  anyNeedsMeasurement = !1;
function measureAllKeyframes() {
  if (anyNeedsMeasurement) {
    const s = Array.from(toResolve).filter((a) => a.needsMeasurement),
      e = new Set(s.map((a) => a.element)),
      o = new Map();
    e.forEach((a) => {
      const c = removeNonTranslationalTransform(a);
      c.length && (o.set(a, c), a.render());
    }),
      s.forEach((a) => a.measureInitialState()),
      e.forEach((a) => {
        a.render();
        const c = o.get(a);
        c &&
          c.forEach(([d, g]) => {
            var _;
            (_ = a.getValue(d)) === null || _ === void 0 || _.set(g);
          });
      }),
      s.forEach((a) => a.measureEndState()),
      s.forEach((a) => {
        a.suspendedScrollY !== void 0 && window.scrollTo(0, a.suspendedScrollY);
      });
  }
  (anyNeedsMeasurement = !1),
    (isScheduled = !1),
    toResolve.forEach((s) => s.complete()),
    toResolve.clear();
}
function readAllKeyframes() {
  toResolve.forEach((s) => {
    s.readKeyframes(), s.needsMeasurement && (anyNeedsMeasurement = !0);
  });
}
function flushKeyframeResolvers() {
  readAllKeyframes(), measureAllKeyframes();
}
class KeyframeResolver {
  constructor(e, o, a, c, d, g = !1) {
    (this.isComplete = !1),
      (this.isAsync = !1),
      (this.needsMeasurement = !1),
      (this.isScheduled = !1),
      (this.unresolvedKeyframes = [...e]),
      (this.onComplete = o),
      (this.name = a),
      (this.motionValue = c),
      (this.element = d),
      (this.isAsync = g);
  }
  scheduleResolve() {
    (this.isScheduled = !0),
      this.isAsync
        ? (toResolve.add(this),
          isScheduled ||
            ((isScheduled = !0),
            frame.read(readAllKeyframes),
            frame.resolveKeyframes(measureAllKeyframes)))
        : (this.readKeyframes(), this.complete());
  }
  readKeyframes() {
    const {
      unresolvedKeyframes: e,
      name: o,
      element: a,
      motionValue: c,
    } = this;
    for (let d = 0; d < e.length; d++)
      if (e[d] === null)
        if (d === 0) {
          const g = c == null ? void 0 : c.get(),
            _ = e[e.length - 1];
          if (g !== void 0) e[0] = g;
          else if (a && o) {
            const b = a.readValue(o, _);
            b != null && (e[0] = b);
          }
          e[0] === void 0 && (e[0] = _), c && g === void 0 && c.set(e[0]);
        } else e[d] = e[d - 1];
  }
  setFinalKeyframe() {}
  measureInitialState() {}
  renderEndStyles() {}
  measureEndState() {}
  complete() {
    (this.isComplete = !0),
      this.onComplete(this.unresolvedKeyframes, this.finalKeyframe),
      toResolve.delete(this);
  }
  cancel() {
    this.isComplete || ((this.isScheduled = !1), toResolve.delete(this));
  }
  resume() {
    this.isComplete || this.scheduleResolve();
  }
}
const isColorString = (s, e) => (o) =>
    !!(
      (isString(o) && singleColorRegex.test(o) && o.startsWith(s)) ||
      (e && !isNullish(o) && Object.prototype.hasOwnProperty.call(o, e))
    ),
  splitColor = (s, e, o) => (a) => {
    if (!isString(a)) return a;
    const [c, d, g, _] = a.match(floatRegex);
    return {
      [s]: parseFloat(c),
      [e]: parseFloat(d),
      [o]: parseFloat(g),
      alpha: _ !== void 0 ? parseFloat(_) : 1,
    };
  },
  clampRgbUnit = (s) => clamp$1(0, 255, s),
  rgbUnit = { ...number, transform: (s) => Math.round(clampRgbUnit(s)) },
  rgba = {
    test: isColorString("rgb", "red"),
    parse: splitColor("red", "green", "blue"),
    transform: ({ red: s, green: e, blue: o, alpha: a = 1 }) =>
      "rgba(" +
      rgbUnit.transform(s) +
      ", " +
      rgbUnit.transform(e) +
      ", " +
      rgbUnit.transform(o) +
      ", " +
      sanitize(alpha.transform(a)) +
      ")",
  };
function parseHex(s) {
  let e = "",
    o = "",
    a = "",
    c = "";
  return (
    s.length > 5
      ? ((e = s.substring(1, 3)),
        (o = s.substring(3, 5)),
        (a = s.substring(5, 7)),
        (c = s.substring(7, 9)))
      : ((e = s.substring(1, 2)),
        (o = s.substring(2, 3)),
        (a = s.substring(3, 4)),
        (c = s.substring(4, 5)),
        (e += e),
        (o += o),
        (a += a),
        (c += c)),
    {
      red: parseInt(e, 16),
      green: parseInt(o, 16),
      blue: parseInt(a, 16),
      alpha: c ? parseInt(c, 16) / 255 : 1,
    }
  );
}
const hex = {
    test: isColorString("#"),
    parse: parseHex,
    transform: rgba.transform,
  },
  hsla = {
    test: isColorString("hsl", "hue"),
    parse: splitColor("hue", "saturation", "lightness"),
    transform: ({ hue: s, saturation: e, lightness: o, alpha: a = 1 }) =>
      "hsla(" +
      Math.round(s) +
      ", " +
      percent.transform(sanitize(e)) +
      ", " +
      percent.transform(sanitize(o)) +
      ", " +
      sanitize(alpha.transform(a)) +
      ")",
  },
  color = {
    test: (s) => rgba.test(s) || hex.test(s) || hsla.test(s),
    parse: (s) =>
      rgba.test(s)
        ? rgba.parse(s)
        : hsla.test(s)
        ? hsla.parse(s)
        : hex.parse(s),
    transform: (s) =>
      isString(s)
        ? s
        : s.hasOwnProperty("red")
        ? rgba.transform(s)
        : hsla.transform(s),
  };
function test(s) {
  var e, o;
  return (
    isNaN(s) &&
    isString(s) &&
    (((e = s.match(floatRegex)) === null || e === void 0 ? void 0 : e.length) ||
      0) +
      (((o = s.match(colorRegex)) === null || o === void 0
        ? void 0
        : o.length) || 0) >
      0
  );
}
const NUMBER_TOKEN = "number",
  COLOR_TOKEN = "color",
  VAR_TOKEN = "var",
  VAR_FUNCTION_TOKEN = "var(",
  SPLIT_TOKEN = "${}",
  complexRegex =
    /var\s*\(\s*--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)|#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\)|-?(?:\d+(?:\.\d+)?|\.\d+)/giu;
function analyseComplexValue(s) {
  const e = s.toString(),
    o = [],
    a = { color: [], number: [], var: [] },
    c = [];
  let d = 0;
  const _ = e
    .replace(
      complexRegex,
      (b) => (
        color.test(b)
          ? (a.color.push(d), c.push(COLOR_TOKEN), o.push(color.parse(b)))
          : b.startsWith(VAR_FUNCTION_TOKEN)
          ? (a.var.push(d), c.push(VAR_TOKEN), o.push(b))
          : (a.number.push(d), c.push(NUMBER_TOKEN), o.push(parseFloat(b))),
        ++d,
        SPLIT_TOKEN
      )
    )
    .split(SPLIT_TOKEN);
  return { values: o, split: _, indexes: a, types: c };
}
function parseComplexValue(s) {
  return analyseComplexValue(s).values;
}
function createTransformer(s) {
  const { split: e, types: o } = analyseComplexValue(s),
    a = e.length;
  return (c) => {
    let d = "";
    for (let g = 0; g < a; g++)
      if (((d += e[g]), c[g] !== void 0)) {
        const _ = o[g];
        _ === NUMBER_TOKEN
          ? (d += sanitize(c[g]))
          : _ === COLOR_TOKEN
          ? (d += color.transform(c[g]))
          : (d += c[g]);
      }
    return d;
  };
}
const convertNumbersToZero = (s) => (typeof s == "number" ? 0 : s);
function getAnimatableNone$1(s) {
  const e = parseComplexValue(s);
  return createTransformer(s)(e.map(convertNumbersToZero));
}
const complex = {
    test,
    parse: parseComplexValue,
    createTransformer,
    getAnimatableNone: getAnimatableNone$1,
  },
  maxDefaults = new Set(["brightness", "contrast", "saturate", "opacity"]);
function applyDefaultFilter(s) {
  const [e, o] = s.slice(0, -1).split("(");
  if (e === "drop-shadow") return s;
  const [a] = o.match(floatRegex) || [];
  if (!a) return s;
  const c = o.replace(a, "");
  let d = maxDefaults.has(e) ? 1 : 0;
  return a !== o && (d *= 100), e + "(" + d + c + ")";
}
const functionRegex = /\b([a-z-]*)\(.*?\)/gu,
  filter = {
    ...complex,
    getAnimatableNone: (s) => {
      const e = s.match(functionRegex);
      return e ? e.map(applyDefaultFilter).join(" ") : s;
    },
  },
  defaultValueTypes = {
    ...numberValueTypes,
    color,
    backgroundColor: color,
    outlineColor: color,
    fill: color,
    stroke: color,
    borderColor: color,
    borderTopColor: color,
    borderRightColor: color,
    borderBottomColor: color,
    borderLeftColor: color,
    filter,
    WebkitFilter: filter,
  },
  getDefaultValueType = (s) => defaultValueTypes[s];
function getAnimatableNone(s, e) {
  let o = getDefaultValueType(s);
  return (
    o !== filter && (o = complex),
    o.getAnimatableNone ? o.getAnimatableNone(e) : void 0
  );
}
const invalidTemplates = new Set(["auto", "none", "0"]);
function makeNoneKeyframesAnimatable(s, e, o) {
  let a = 0,
    c;
  for (; a < s.length && !c; ) {
    const d = s[a];
    typeof d == "string" &&
      !invalidTemplates.has(d) &&
      analyseComplexValue(d).values.length &&
      (c = s[a]),
      a++;
  }
  if (c && o) for (const d of e) s[d] = getAnimatableNone(o, c);
}
class DOMKeyframesResolver extends KeyframeResolver {
  constructor(e, o, a, c) {
    super(e, o, a, c, c == null ? void 0 : c.owner, !0);
  }
  readKeyframes() {
    const { unresolvedKeyframes: e, element: o, name: a } = this;
    if (!o.current) return;
    super.readKeyframes();
    for (let b = 0; b < e.length; b++) {
      let j = e[b];
      if (typeof j == "string" && ((j = j.trim()), isCSSVariableToken(j))) {
        const $ = getVariableValue(j, o.current);
        $ !== void 0 && (e[b] = $),
          b === e.length - 1 && (this.finalKeyframe = j);
      }
    }
    if ((this.resolveNoneKeyframes(), !positionalKeys.has(a) || e.length !== 2))
      return;
    const [c, d] = e,
      g = findDimensionValueType(c),
      _ = findDimensionValueType(d);
    if (g !== _)
      if (isNumOrPxType(g) && isNumOrPxType(_))
        for (let b = 0; b < e.length; b++) {
          const j = e[b];
          typeof j == "string" && (e[b] = parseFloat(j));
        }
      else this.needsMeasurement = !0;
  }
  resolveNoneKeyframes() {
    const { unresolvedKeyframes: e, name: o } = this,
      a = [];
    for (let c = 0; c < e.length; c++) isNone(e[c]) && a.push(c);
    a.length && makeNoneKeyframesAnimatable(e, a, o);
  }
  measureInitialState() {
    const { element: e, unresolvedKeyframes: o, name: a } = this;
    if (!e.current) return;
    a === "height" && (this.suspendedScrollY = window.pageYOffset),
      (this.measuredOrigin = positionalValues[a](
        e.measureViewportBox(),
        window.getComputedStyle(e.current)
      )),
      (o[0] = this.measuredOrigin);
    const c = o[o.length - 1];
    c !== void 0 && e.getValue(a, c).jump(c, !1);
  }
  measureEndState() {
    var e;
    const { element: o, name: a, unresolvedKeyframes: c } = this;
    if (!o.current) return;
    const d = o.getValue(a);
    d && d.jump(this.measuredOrigin, !1);
    const g = c.length - 1,
      _ = c[g];
    (c[g] = positionalValues[a](
      o.measureViewportBox(),
      window.getComputedStyle(o.current)
    )),
      _ !== null && this.finalKeyframe === void 0 && (this.finalKeyframe = _),
      !((e = this.removedTransforms) === null || e === void 0) &&
        e.length &&
        this.removedTransforms.forEach(([b, j]) => {
          o.getValue(b).set(j);
        }),
      this.resolveNoneKeyframes();
  }
}
function memo(s) {
  let e;
  return () => (e === void 0 && (e = s()), e);
}
const isAnimatable = (s, e) =>
  e === "zIndex"
    ? !1
    : !!(
        typeof s == "number" ||
        Array.isArray(s) ||
        (typeof s == "string" &&
          (complex.test(s) || s === "0") &&
          !s.startsWith("url("))
      );
function hasKeyframesChanged(s) {
  const e = s[0];
  if (s.length === 1) return !0;
  for (let o = 0; o < s.length; o++) if (s[o] !== e) return !0;
}
function canAnimate(s, e, o, a) {
  const c = s[0];
  if (c === null) return !1;
  if (e === "display" || e === "visibility") return !0;
  const d = s[s.length - 1],
    g = isAnimatable(c, e),
    _ = isAnimatable(d, e);
  return !g || !_ ? !1 : hasKeyframesChanged(s) || (o === "spring" && a);
}
class BaseAnimation {
  constructor({
    autoplay: e = !0,
    delay: o = 0,
    type: a = "keyframes",
    repeat: c = 0,
    repeatDelay: d = 0,
    repeatType: g = "loop",
    ..._
  }) {
    (this.isStopped = !1),
      (this.hasAttemptedResolve = !1),
      (this.options = {
        autoplay: e,
        delay: o,
        type: a,
        repeat: c,
        repeatDelay: d,
        repeatType: g,
        ..._,
      }),
      this.updateFinishedPromise();
  }
  get resolved() {
    return (
      !this._resolved && !this.hasAttemptedResolve && flushKeyframeResolvers(),
      this._resolved
    );
  }
  onKeyframesResolved(e, o) {
    this.hasAttemptedResolve = !0;
    const {
      name: a,
      type: c,
      velocity: d,
      delay: g,
      onComplete: _,
      onUpdate: b,
      isGenerator: j,
    } = this.options;
    if (!j && !canAnimate(e, a, c, d))
      if (g) this.options.duration = 0;
      else {
        b == null || b(getFinalKeyframe(e, this.options, o)),
          _ == null || _(),
          this.resolveFinishedPromise();
        return;
      }
    const $ = this.initPlayback(e, o);
    $ !== !1 &&
      ((this._resolved = { keyframes: e, finalKeyframe: o, ...$ }),
      this.onPostResolved());
  }
  onPostResolved() {}
  then(e, o) {
    return this.currentFinishedPromise.then(e, o);
  }
  updateFinishedPromise() {
    this.currentFinishedPromise = new Promise((e) => {
      this.resolveFinishedPromise = e;
    });
  }
}
function velocityPerSecond(s, e) {
  return e ? s * (1e3 / e) : 0;
}
const velocitySampleDuration = 5;
function calcGeneratorVelocity(s, e, o) {
  const a = Math.max(e - velocitySampleDuration, 0);
  return velocityPerSecond(o - s(a), e - a);
}
const safeMin = 0.001,
  minDuration = 0.01,
  maxDuration$1 = 10,
  minDamping = 0.05,
  maxDamping = 1;
function findSpring({
  duration: s = 800,
  bounce: e = 0.25,
  velocity: o = 0,
  mass: a = 1,
}) {
  let c,
    d,
    g = 1 - e;
  (g = clamp$1(minDamping, maxDamping, g)),
    (s = clamp$1(minDuration, maxDuration$1, millisecondsToSeconds(s))),
    g < 1
      ? ((c = (j) => {
          const $ = j * g,
            _e = $ * s,
            et = $ - o,
            rt = calcAngularFreq(j, g),
            st = Math.exp(-_e);
          return safeMin - (et / rt) * st;
        }),
        (d = (j) => {
          const _e = j * g * s,
            et = _e * o + o,
            rt = Math.pow(g, 2) * Math.pow(j, 2) * s,
            st = Math.exp(-_e),
            at = calcAngularFreq(Math.pow(j, 2), g);
          return ((-c(j) + safeMin > 0 ? -1 : 1) * ((et - rt) * st)) / at;
        }))
      : ((c = (j) => {
          const $ = Math.exp(-j * s),
            _e = (j - o) * s + 1;
          return -safeMin + $ * _e;
        }),
        (d = (j) => {
          const $ = Math.exp(-j * s),
            _e = (o - j) * (s * s);
          return $ * _e;
        }));
  const _ = 5 / s,
    b = approximateRoot(c, d, _);
  if (((s = secondsToMilliseconds(s)), isNaN(b)))
    return { stiffness: 100, damping: 10, duration: s };
  {
    const j = Math.pow(b, 2) * a;
    return { stiffness: j, damping: g * 2 * Math.sqrt(a * j), duration: s };
  }
}
const rootIterations = 12;
function approximateRoot(s, e, o) {
  let a = o;
  for (let c = 1; c < rootIterations; c++) a = a - s(a) / e(a);
  return a;
}
function calcAngularFreq(s, e) {
  return s * Math.sqrt(1 - e * e);
}
const durationKeys = ["duration", "bounce"],
  physicsKeys = ["stiffness", "damping", "mass"];
function isSpringType(s, e) {
  return e.some((o) => s[o] !== void 0);
}
function getSpringOptions(s) {
  let e = {
    velocity: 0,
    stiffness: 100,
    damping: 10,
    mass: 1,
    isResolvedFromDuration: !1,
    ...s,
  };
  if (!isSpringType(s, physicsKeys) && isSpringType(s, durationKeys)) {
    const o = findSpring(s);
    (e = { ...e, ...o, mass: 1 }), (e.isResolvedFromDuration = !0);
  }
  return e;
}
function spring({ keyframes: s, restDelta: e, restSpeed: o, ...a }) {
  const c = s[0],
    d = s[s.length - 1],
    g = { done: !1, value: c },
    {
      stiffness: _,
      damping: b,
      mass: j,
      duration: $,
      velocity: _e,
      isResolvedFromDuration: et,
    } = getSpringOptions({
      ...a,
      velocity: -millisecondsToSeconds(a.velocity || 0),
    }),
    rt = _e || 0,
    st = b / (2 * Math.sqrt(_ * j)),
    at = d - c,
    ct = millisecondsToSeconds(Math.sqrt(_ / j)),
    it = Math.abs(at) < 5;
  o || (o = it ? 0.01 : 2), e || (e = it ? 0.005 : 0.5);
  let lt;
  if (st < 1) {
    const ot = calcAngularFreq(ct, st);
    lt = (ut) => {
      const pt = Math.exp(-st * ct * ut);
      return (
        d -
        pt *
          (((rt + st * ct * at) / ot) * Math.sin(ot * ut) +
            at * Math.cos(ot * ut))
      );
    };
  } else if (st === 1)
    lt = (ot) => d - Math.exp(-ct * ot) * (at + (rt + ct * at) * ot);
  else {
    const ot = ct * Math.sqrt(st * st - 1);
    lt = (ut) => {
      const pt = Math.exp(-st * ct * ut),
        ft = Math.min(ot * ut, 300);
      return (
        d -
        (pt * ((rt + st * ct * at) * Math.sinh(ft) + ot * at * Math.cosh(ft))) /
          ot
      );
    };
  }
  return {
    calculatedDuration: (et && $) || null,
    next: (ot) => {
      const ut = lt(ot);
      if (et) g.done = ot >= $;
      else {
        let pt = rt;
        ot !== 0 &&
          (st < 1 ? (pt = calcGeneratorVelocity(lt, ot, ut)) : (pt = 0));
        const ft = Math.abs(pt) <= o,
          gt = Math.abs(d - ut) <= e;
        g.done = ft && gt;
      }
      return (g.value = g.done ? d : ut), g;
    },
  };
}
function inertia({
  keyframes: s,
  velocity: e = 0,
  power: o = 0.8,
  timeConstant: a = 325,
  bounceDamping: c = 10,
  bounceStiffness: d = 500,
  modifyTarget: g,
  min: _,
  max: b,
  restDelta: j = 0.5,
  restSpeed: $,
}) {
  const _e = s[0],
    et = { done: !1, value: _e },
    rt = (xt) => (_ !== void 0 && xt < _) || (b !== void 0 && xt > b),
    st = (xt) =>
      _ === void 0
        ? b
        : b === void 0 || Math.abs(_ - xt) < Math.abs(b - xt)
        ? _
        : b;
  let at = o * e;
  const ct = _e + at,
    it = g === void 0 ? ct : g(ct);
  it !== ct && (at = it - _e);
  const lt = (xt) => -at * Math.exp(-xt / a),
    ot = (xt) => it + lt(xt),
    ut = (xt) => {
      const _t = lt(xt),
        St = ot(xt);
      (et.done = Math.abs(_t) <= j), (et.value = et.done ? it : St);
    };
  let pt, ft;
  const gt = (xt) => {
    rt(et.value) &&
      ((pt = xt),
      (ft = spring({
        keyframes: [et.value, st(et.value)],
        velocity: calcGeneratorVelocity(ot, xt, et.value),
        damping: c,
        stiffness: d,
        restDelta: j,
        restSpeed: $,
      })));
  };
  return (
    gt(0),
    {
      calculatedDuration: null,
      next: (xt) => {
        let _t = !1;
        return (
          !ft && pt === void 0 && ((_t = !0), ut(xt), gt(xt)),
          pt !== void 0 && xt >= pt ? ft.next(xt - pt) : (!_t && ut(xt), et)
        );
      },
    }
  );
}
const calcBezier = (s, e, o) =>
    (((1 - 3 * o + 3 * e) * s + (3 * o - 6 * e)) * s + 3 * e) * s,
  subdivisionPrecision = 1e-7,
  subdivisionMaxIterations = 12;
function binarySubdivide(s, e, o, a, c) {
  let d,
    g,
    _ = 0;
  do
    (g = e + (o - e) / 2),
      (d = calcBezier(g, a, c) - s),
      d > 0 ? (o = g) : (e = g);
  while (Math.abs(d) > subdivisionPrecision && ++_ < subdivisionMaxIterations);
  return g;
}
function cubicBezier(s, e, o, a) {
  if (s === e && o === a) return noop;
  const c = (d) => binarySubdivide(d, 0, 1, s, o);
  return (d) => (d === 0 || d === 1 ? d : calcBezier(c(d), e, a));
}
const easeIn = cubicBezier(0.42, 0, 1, 1),
  easeOut = cubicBezier(0, 0, 0.58, 1),
  easeInOut = cubicBezier(0.42, 0, 0.58, 1),
  isEasingArray = (s) => Array.isArray(s) && typeof s[0] != "number",
  mirrorEasing = (s) => (e) =>
    e <= 0.5 ? s(2 * e) / 2 : (2 - s(2 * (1 - e))) / 2,
  reverseEasing = (s) => (e) => 1 - s(1 - e),
  circIn = (s) => 1 - Math.sin(Math.acos(s)),
  circOut = reverseEasing(circIn),
  circInOut = mirrorEasing(circIn),
  backOut = cubicBezier(0.33, 1.53, 0.69, 0.99),
  backIn = reverseEasing(backOut),
  backInOut = mirrorEasing(backIn),
  anticipate = (s) =>
    (s *= 2) < 1 ? 0.5 * backIn(s) : 0.5 * (2 - Math.pow(2, -10 * (s - 1))),
  easingLookup = {
    linear: noop,
    easeIn,
    easeInOut,
    easeOut,
    circIn,
    circInOut,
    circOut,
    backIn,
    backInOut,
    backOut,
    anticipate,
  },
  easingDefinitionToFunction = (s) => {
    if (Array.isArray(s)) {
      invariant$1(s.length === 4);
      const [e, o, a, c] = s;
      return cubicBezier(e, o, a, c);
    } else if (typeof s == "string")
      return invariant$1(easingLookup[s] !== void 0), easingLookup[s];
    return s;
  },
  progress = (s, e, o) => {
    const a = e - s;
    return a === 0 ? 1 : (o - s) / a;
  },
  mixNumber$1 = (s, e, o) => s + (e - s) * o;
function hueToRgb(s, e, o) {
  return (
    o < 0 && (o += 1),
    o > 1 && (o -= 1),
    o < 1 / 6
      ? s + (e - s) * 6 * o
      : o < 1 / 2
      ? e
      : o < 2 / 3
      ? s + (e - s) * (2 / 3 - o) * 6
      : s
  );
}
function hslaToRgba({ hue: s, saturation: e, lightness: o, alpha: a }) {
  (s /= 360), (e /= 100), (o /= 100);
  let c = 0,
    d = 0,
    g = 0;
  if (!e) c = d = g = o;
  else {
    const _ = o < 0.5 ? o * (1 + e) : o + e - o * e,
      b = 2 * o - _;
    (c = hueToRgb(b, _, s + 1 / 3)),
      (d = hueToRgb(b, _, s)),
      (g = hueToRgb(b, _, s - 1 / 3));
  }
  return {
    red: Math.round(c * 255),
    green: Math.round(d * 255),
    blue: Math.round(g * 255),
    alpha: a,
  };
}
function mixImmediate(s, e) {
  return (o) => (o > 0 ? e : s);
}
const mixLinearColor = (s, e, o) => {
    const a = s * s,
      c = o * (e * e - a) + a;
    return c < 0 ? 0 : Math.sqrt(c);
  },
  colorTypes = [hex, rgba, hsla],
  getColorType = (s) => colorTypes.find((e) => e.test(s));
function asRGBA(s) {
  const e = getColorType(s);
  if (!e) return !1;
  let o = e.parse(s);
  return e === hsla && (o = hslaToRgba(o)), o;
}
const mixColor = (s, e) => {
    const o = asRGBA(s),
      a = asRGBA(e);
    if (!o || !a) return mixImmediate(s, e);
    const c = { ...o };
    return (d) => (
      (c.red = mixLinearColor(o.red, a.red, d)),
      (c.green = mixLinearColor(o.green, a.green, d)),
      (c.blue = mixLinearColor(o.blue, a.blue, d)),
      (c.alpha = mixNumber$1(o.alpha, a.alpha, d)),
      rgba.transform(c)
    );
  },
  invisibleValues = new Set(["none", "hidden"]);
function mixVisibility(s, e) {
  return invisibleValues.has(s)
    ? (o) => (o <= 0 ? s : e)
    : (o) => (o >= 1 ? e : s);
}
function mixNumber(s, e) {
  return (o) => mixNumber$1(s, e, o);
}
function getMixer(s) {
  return typeof s == "number"
    ? mixNumber
    : typeof s == "string"
    ? isCSSVariableToken(s)
      ? mixImmediate
      : color.test(s)
      ? mixColor
      : mixComplex
    : Array.isArray(s)
    ? mixArray
    : typeof s == "object"
    ? color.test(s)
      ? mixColor
      : mixObject
    : mixImmediate;
}
function mixArray(s, e) {
  const o = [...s],
    a = o.length,
    c = s.map((d, g) => getMixer(d)(d, e[g]));
  return (d) => {
    for (let g = 0; g < a; g++) o[g] = c[g](d);
    return o;
  };
}
function mixObject(s, e) {
  const o = { ...s, ...e },
    a = {};
  for (const c in o)
    s[c] !== void 0 && e[c] !== void 0 && (a[c] = getMixer(s[c])(s[c], e[c]));
  return (c) => {
    for (const d in a) o[d] = a[d](c);
    return o;
  };
}
function matchOrder(s, e) {
  var o;
  const a = [],
    c = { color: 0, var: 0, number: 0 };
  for (let d = 0; d < e.values.length; d++) {
    const g = e.types[d],
      _ = s.indexes[g][c[g]],
      b = (o = s.values[_]) !== null && o !== void 0 ? o : 0;
    (a[d] = b), c[g]++;
  }
  return a;
}
const mixComplex = (s, e) => {
  const o = complex.createTransformer(e),
    a = analyseComplexValue(s),
    c = analyseComplexValue(e);
  return a.indexes.var.length === c.indexes.var.length &&
    a.indexes.color.length === c.indexes.color.length &&
    a.indexes.number.length >= c.indexes.number.length
    ? (invisibleValues.has(s) && !c.values.length) ||
      (invisibleValues.has(e) && !a.values.length)
      ? mixVisibility(s, e)
      : pipe(mixArray(matchOrder(a, c), c.values), o)
    : mixImmediate(s, e);
};
function mix(s, e, o) {
  return typeof s == "number" && typeof e == "number" && typeof o == "number"
    ? mixNumber$1(s, e, o)
    : getMixer(s)(s, e);
}
function createMixers(s, e, o) {
  const a = [],
    c = o || mix,
    d = s.length - 1;
  for (let g = 0; g < d; g++) {
    let _ = c(s[g], s[g + 1]);
    if (e) {
      const b = Array.isArray(e) ? e[g] || noop : e;
      _ = pipe(b, _);
    }
    a.push(_);
  }
  return a;
}
function interpolate(s, e, { clamp: o = !0, ease: a, mixer: c } = {}) {
  const d = s.length;
  if ((invariant$1(d === e.length), d === 1)) return () => e[0];
  if (d === 2 && s[0] === s[1]) return () => e[1];
  s[0] > s[d - 1] && ((s = [...s].reverse()), (e = [...e].reverse()));
  const g = createMixers(e, a, c),
    _ = g.length,
    b = (j) => {
      let $ = 0;
      if (_ > 1) for (; $ < s.length - 2 && !(j < s[$ + 1]); $++);
      const _e = progress(s[$], s[$ + 1], j);
      return g[$](_e);
    };
  return o ? (j) => b(clamp$1(s[0], s[d - 1], j)) : b;
}
function fillOffset(s, e) {
  const o = s[s.length - 1];
  for (let a = 1; a <= e; a++) {
    const c = progress(0, e, a);
    s.push(mixNumber$1(o, 1, c));
  }
}
function defaultOffset(s) {
  const e = [0];
  return fillOffset(e, s.length - 1), e;
}
function convertOffsetToTimes(s, e) {
  return s.map((o) => o * e);
}
function defaultEasing(s, e) {
  return s.map(() => e || easeInOut).splice(0, s.length - 1);
}
function keyframes({
  duration: s = 300,
  keyframes: e,
  times: o,
  ease: a = "easeInOut",
}) {
  const c = isEasingArray(a)
      ? a.map(easingDefinitionToFunction)
      : easingDefinitionToFunction(a),
    d = { done: !1, value: e[0] },
    g = convertOffsetToTimes(
      o && o.length === e.length ? o : defaultOffset(e),
      s
    ),
    _ = interpolate(g, e, { ease: Array.isArray(c) ? c : defaultEasing(e, c) });
  return {
    calculatedDuration: s,
    next: (b) => ((d.value = _(b)), (d.done = b >= s), d),
  };
}
const maxGeneratorDuration = 2e4;
function calcGeneratorDuration(s) {
  let e = 0;
  const o = 50;
  let a = s.next(e);
  for (; !a.done && e < maxGeneratorDuration; ) (e += o), (a = s.next(e));
  return e >= maxGeneratorDuration ? 1 / 0 : e;
}
const frameloopDriver = (s) => {
    const e = ({ timestamp: o }) => s(o);
    return {
      start: () => frame.update(e, !0),
      stop: () => cancelFrame(e),
      now: () => (frameData.isProcessing ? frameData.timestamp : time.now()),
    };
  },
  generators = { decay: inertia, inertia, tween: keyframes, keyframes, spring },
  percentToProgress = (s) => s / 100;
class MainThreadAnimation extends BaseAnimation {
  constructor({ KeyframeResolver: e = KeyframeResolver, ...o }) {
    super(o),
      (this.holdTime = null),
      (this.startTime = null),
      (this.cancelTime = null),
      (this.currentTime = 0),
      (this.playbackSpeed = 1),
      (this.pendingPlayState = "running"),
      (this.state = "idle"),
      (this.stop = () => {
        if (
          (this.resolver.cancel(), (this.isStopped = !0), this.state === "idle")
        )
          return;
        this.teardown();
        const { onStop: _ } = this.options;
        _ && _();
      });
    const { name: a, motionValue: c, keyframes: d } = this.options,
      g = (_, b) => this.onKeyframesResolved(_, b);
    a && c && c.owner
      ? (this.resolver = c.owner.resolveKeyframes(d, g, a, c))
      : (this.resolver = new e(d, g, a, c)),
      this.resolver.scheduleResolve();
  }
  initPlayback(e) {
    const {
        type: o = "keyframes",
        repeat: a = 0,
        repeatDelay: c = 0,
        repeatType: d,
        velocity: g = 0,
      } = this.options,
      _ = generators[o] || keyframes;
    let b, j;
    _ !== keyframes &&
      typeof e[0] != "number" &&
      ((b = pipe(percentToProgress, mix(e[0], e[1]))), (e = [0, 100]));
    const $ = _({ ...this.options, keyframes: e });
    d === "mirror" &&
      (j = _({ ...this.options, keyframes: [...e].reverse(), velocity: -g })),
      $.calculatedDuration === null &&
        ($.calculatedDuration = calcGeneratorDuration($));
    const { calculatedDuration: _e } = $,
      et = _e + c,
      rt = et * (a + 1) - c;
    return {
      generator: $,
      mirroredGenerator: j,
      mapPercentToKeyframes: b,
      calculatedDuration: _e,
      resolvedDuration: et,
      totalDuration: rt,
    };
  }
  onPostResolved() {
    const { autoplay: e = !0 } = this.options;
    this.play(),
      this.pendingPlayState === "paused" || !e
        ? this.pause()
        : (this.state = this.pendingPlayState);
  }
  tick(e, o = !1) {
    const { resolved: a } = this;
    if (!a) {
      const { keyframes: xt } = this.options;
      return { done: !0, value: xt[xt.length - 1] };
    }
    const {
      finalKeyframe: c,
      generator: d,
      mirroredGenerator: g,
      mapPercentToKeyframes: _,
      keyframes: b,
      calculatedDuration: j,
      totalDuration: $,
      resolvedDuration: _e,
    } = a;
    if (this.startTime === null) return d.next(0);
    const {
      delay: et,
      repeat: rt,
      repeatType: st,
      repeatDelay: at,
      onUpdate: ct,
    } = this.options;
    this.speed > 0
      ? (this.startTime = Math.min(this.startTime, e))
      : this.speed < 0 &&
        (this.startTime = Math.min(e - $ / this.speed, this.startTime)),
      o
        ? (this.currentTime = e)
        : this.holdTime !== null
        ? (this.currentTime = this.holdTime)
        : (this.currentTime = Math.round(e - this.startTime) * this.speed);
    const it = this.currentTime - et * (this.speed >= 0 ? 1 : -1),
      lt = this.speed >= 0 ? it < 0 : it > $;
    (this.currentTime = Math.max(it, 0)),
      this.state === "finished" &&
        this.holdTime === null &&
        (this.currentTime = $);
    let ot = this.currentTime,
      ut = d;
    if (rt) {
      const xt = Math.min(this.currentTime, $) / _e;
      let _t = Math.floor(xt),
        St = xt % 1;
      !St && xt >= 1 && (St = 1),
        St === 1 && _t--,
        (_t = Math.min(_t, rt + 1)),
        !!(_t % 2) &&
          (st === "reverse"
            ? ((St = 1 - St), at && (St -= at / _e))
            : st === "mirror" && (ut = g)),
        (ot = clamp$1(0, 1, St) * _e);
    }
    const pt = lt ? { done: !1, value: b[0] } : ut.next(ot);
    _ && (pt.value = _(pt.value));
    let { done: ft } = pt;
    !lt &&
      j !== null &&
      (ft = this.speed >= 0 ? this.currentTime >= $ : this.currentTime <= 0);
    const gt =
      this.holdTime === null &&
      (this.state === "finished" || (this.state === "running" && ft));
    return (
      gt && c !== void 0 && (pt.value = getFinalKeyframe(b, this.options, c)),
      ct && ct(pt.value),
      gt && this.finish(),
      pt
    );
  }
  get duration() {
    const { resolved: e } = this;
    return e ? millisecondsToSeconds(e.calculatedDuration) : 0;
  }
  get time() {
    return millisecondsToSeconds(this.currentTime);
  }
  set time(e) {
    (e = secondsToMilliseconds(e)),
      (this.currentTime = e),
      this.holdTime !== null || this.speed === 0
        ? (this.holdTime = e)
        : this.driver && (this.startTime = this.driver.now() - e / this.speed);
  }
  get speed() {
    return this.playbackSpeed;
  }
  set speed(e) {
    const o = this.playbackSpeed !== e;
    (this.playbackSpeed = e),
      o && (this.time = millisecondsToSeconds(this.currentTime));
  }
  play() {
    if (
      (this.resolver.isScheduled || this.resolver.resume(), !this._resolved)
    ) {
      this.pendingPlayState = "running";
      return;
    }
    if (this.isStopped) return;
    const { driver: e = frameloopDriver, onPlay: o } = this.options;
    this.driver || (this.driver = e((c) => this.tick(c))), o && o();
    const a = this.driver.now();
    this.holdTime !== null
      ? (this.startTime = a - this.holdTime)
      : (!this.startTime || this.state === "finished") && (this.startTime = a),
      this.state === "finished" && this.updateFinishedPromise(),
      (this.cancelTime = this.startTime),
      (this.holdTime = null),
      (this.state = "running"),
      this.driver.start();
  }
  pause() {
    var e;
    if (!this._resolved) {
      this.pendingPlayState = "paused";
      return;
    }
    (this.state = "paused"),
      (this.holdTime = (e = this.currentTime) !== null && e !== void 0 ? e : 0);
  }
  complete() {
    this.state !== "running" && this.play(),
      (this.pendingPlayState = this.state = "finished"),
      (this.holdTime = null);
  }
  finish() {
    this.teardown(), (this.state = "finished");
    const { onComplete: e } = this.options;
    e && e();
  }
  cancel() {
    this.cancelTime !== null && this.tick(this.cancelTime),
      this.teardown(),
      this.updateFinishedPromise();
  }
  teardown() {
    (this.state = "idle"),
      this.stopDriver(),
      this.resolveFinishedPromise(),
      this.updateFinishedPromise(),
      (this.startTime = this.cancelTime = null),
      this.resolver.cancel();
  }
  stopDriver() {
    this.driver && (this.driver.stop(), (this.driver = void 0));
  }
  sample(e) {
    return (this.startTime = 0), this.tick(e, !0);
  }
}
const isBezierDefinition = (s) => Array.isArray(s) && typeof s[0] == "number";
function isWaapiSupportedEasing(s) {
  return !!(
    !s ||
    (typeof s == "string" && s in supportedWaapiEasing) ||
    isBezierDefinition(s) ||
    (Array.isArray(s) && s.every(isWaapiSupportedEasing))
  );
}
const cubicBezierAsString = ([s, e, o, a]) =>
    `cubic-bezier(${s}, ${e}, ${o}, ${a})`,
  supportedWaapiEasing = {
    linear: "linear",
    ease: "ease",
    easeIn: "ease-in",
    easeOut: "ease-out",
    easeInOut: "ease-in-out",
    circIn: cubicBezierAsString([0, 0.65, 0.55, 1]),
    circOut: cubicBezierAsString([0.55, 0, 1, 0.45]),
    backIn: cubicBezierAsString([0.31, 0.01, 0.66, -0.59]),
    backOut: cubicBezierAsString([0.33, 1.53, 0.69, 0.99]),
  };
function mapEasingToNativeEasingWithDefault(s) {
  return mapEasingToNativeEasing(s) || supportedWaapiEasing.easeOut;
}
function mapEasingToNativeEasing(s) {
  if (s)
    return isBezierDefinition(s)
      ? cubicBezierAsString(s)
      : Array.isArray(s)
      ? s.map(mapEasingToNativeEasingWithDefault)
      : supportedWaapiEasing[s];
}
function animateStyle(
  s,
  e,
  o,
  {
    delay: a = 0,
    duration: c = 300,
    repeat: d = 0,
    repeatType: g = "loop",
    ease: _,
    times: b,
  } = {}
) {
  const j = { [e]: o };
  b && (j.offset = b);
  const $ = mapEasingToNativeEasing(_);
  return (
    Array.isArray($) && (j.easing = $),
    s.animate(j, {
      delay: a,
      duration: c,
      easing: Array.isArray($) ? "linear" : $,
      fill: "both",
      iterations: d + 1,
      direction: g === "reverse" ? "alternate" : "normal",
    })
  );
}
const supportsWaapi = memo(() =>
    Object.hasOwnProperty.call(Element.prototype, "animate")
  ),
  sampleDelta = 10,
  maxDuration = 2e4;
function requiresPregeneratedKeyframes(s) {
  return s.type === "spring" || !isWaapiSupportedEasing(s.ease);
}
function pregenerateKeyframes(s, e) {
  const o = new MainThreadAnimation({
    ...e,
    keyframes: s,
    repeat: 0,
    delay: 0,
    isGenerator: !0,
  });
  let a = { done: !1, value: s[0] };
  const c = [];
  let d = 0;
  for (; !a.done && d < maxDuration; )
    (a = o.sample(d)), c.push(a.value), (d += sampleDelta);
  return {
    times: void 0,
    keyframes: c,
    duration: d - sampleDelta,
    ease: "linear",
  };
}
class AcceleratedAnimation extends BaseAnimation {
  constructor(e) {
    super(e);
    const { name: o, motionValue: a, keyframes: c } = this.options;
    (this.resolver = new DOMKeyframesResolver(
      c,
      (d, g) => this.onKeyframesResolved(d, g),
      o,
      a
    )),
      this.resolver.scheduleResolve();
  }
  initPlayback(e, o) {
    var a;
    let {
      duration: c = 300,
      times: d,
      ease: g,
      type: _,
      motionValue: b,
      name: j,
    } = this.options;
    if (!(!((a = b.owner) === null || a === void 0) && a.current)) return !1;
    if (requiresPregeneratedKeyframes(this.options)) {
      const {
          onComplete: _e,
          onUpdate: et,
          motionValue: rt,
          ...st
        } = this.options,
        at = pregenerateKeyframes(e, st);
      (e = at.keyframes),
        e.length === 1 && (e[1] = e[0]),
        (c = at.duration),
        (d = at.times),
        (g = at.ease),
        (_ = "keyframes");
    }
    const $ = animateStyle(b.owner.current, j, e, {
      ...this.options,
      duration: c,
      times: d,
      ease: g,
    });
    return (
      ($.startTime = time.now()),
      this.pendingTimeline
        ? (($.timeline = this.pendingTimeline), (this.pendingTimeline = void 0))
        : ($.onfinish = () => {
            const { onComplete: _e } = this.options;
            b.set(getFinalKeyframe(e, this.options, o)),
              _e && _e(),
              this.cancel(),
              this.resolveFinishedPromise();
          }),
      { animation: $, duration: c, times: d, type: _, ease: g, keyframes: e }
    );
  }
  get duration() {
    const { resolved: e } = this;
    if (!e) return 0;
    const { duration: o } = e;
    return millisecondsToSeconds(o);
  }
  get time() {
    const { resolved: e } = this;
    if (!e) return 0;
    const { animation: o } = e;
    return millisecondsToSeconds(o.currentTime || 0);
  }
  set time(e) {
    const { resolved: o } = this;
    if (!o) return;
    const { animation: a } = o;
    a.currentTime = secondsToMilliseconds(e);
  }
  get speed() {
    const { resolved: e } = this;
    if (!e) return 1;
    const { animation: o } = e;
    return o.playbackRate;
  }
  set speed(e) {
    const { resolved: o } = this;
    if (!o) return;
    const { animation: a } = o;
    a.playbackRate = e;
  }
  get state() {
    const { resolved: e } = this;
    if (!e) return "idle";
    const { animation: o } = e;
    return o.playState;
  }
  attachTimeline(e) {
    if (!this._resolved) this.pendingTimeline = e;
    else {
      const { resolved: o } = this;
      if (!o) return noop;
      const { animation: a } = o;
      (a.timeline = e), (a.onfinish = null);
    }
    return noop;
  }
  play() {
    if (this.isStopped) return;
    const { resolved: e } = this;
    if (!e) return;
    const { animation: o } = e;
    o.playState === "finished" && this.updateFinishedPromise(), o.play();
  }
  pause() {
    const { resolved: e } = this;
    if (!e) return;
    const { animation: o } = e;
    o.pause();
  }
  stop() {
    if ((this.resolver.cancel(), (this.isStopped = !0), this.state === "idle"))
      return;
    this.resolveFinishedPromise(), this.updateFinishedPromise();
    const { resolved: e } = this;
    if (!e) return;
    const {
      animation: o,
      keyframes: a,
      duration: c,
      type: d,
      ease: g,
      times: _,
    } = e;
    if (o.playState === "idle" || o.playState === "finished") return;
    if (this.time) {
      const {
          motionValue: j,
          onUpdate: $,
          onComplete: _e,
          ...et
        } = this.options,
        rt = new MainThreadAnimation({
          ...et,
          keyframes: a,
          duration: c,
          type: d,
          ease: g,
          times: _,
          isGenerator: !0,
        }),
        st = secondsToMilliseconds(this.time);
      j.setWithVelocity(
        rt.sample(st - sampleDelta).value,
        rt.sample(st).value,
        sampleDelta
      );
    }
    const { onStop: b } = this.options;
    b && b(), this.cancel();
  }
  complete() {
    const { resolved: e } = this;
    e && e.animation.finish();
  }
  cancel() {
    const { resolved: e } = this;
    e && e.animation.cancel();
  }
  static supports(e) {
    const {
      motionValue: o,
      name: a,
      repeatDelay: c,
      repeatType: d,
      damping: g,
      type: _,
    } = e;
    return (
      supportsWaapi() &&
      a &&
      acceleratedValues.has(a) &&
      o &&
      o.owner &&
      o.owner.current instanceof HTMLElement &&
      !o.owner.getProps().onUpdate &&
      !c &&
      d !== "mirror" &&
      g !== 0 &&
      _ !== "inertia"
    );
  }
}
function observeTimeline(s, e) {
  let o;
  const a = () => {
    const { currentTime: c } = e,
      g = (c === null ? 0 : c.value) / 100;
    o !== g && s(g), (o = g);
  };
  return frame.update(a, !0), () => cancelFrame(a);
}
const supportsScrollTimeline = memo(() => window.ScrollTimeline !== void 0);
class GroupPlaybackControls {
  constructor(e) {
    (this.stop = () => this.runAll("stop")),
      (this.animations = e.filter(Boolean));
  }
  then(e, o) {
    return Promise.all(this.animations).then(e).catch(o);
  }
  getAll(e) {
    return this.animations[0][e];
  }
  setAll(e, o) {
    for (let a = 0; a < this.animations.length; a++) this.animations[a][e] = o;
  }
  attachTimeline(e) {
    const o = this.animations.map((a) => {
      if (supportsScrollTimeline() && a.attachTimeline) a.attachTimeline(e);
      else
        return (
          a.pause(),
          observeTimeline((c) => {
            a.time = a.duration * c;
          }, e)
        );
    });
    return () => {
      o.forEach((a, c) => {
        a && a(), this.animations[c].stop();
      });
    };
  }
  get time() {
    return this.getAll("time");
  }
  set time(e) {
    this.setAll("time", e);
  }
  get speed() {
    return this.getAll("speed");
  }
  set speed(e) {
    this.setAll("speed", e);
  }
  get duration() {
    let e = 0;
    for (let o = 0; o < this.animations.length; o++)
      e = Math.max(e, this.animations[o].duration);
    return e;
  }
  runAll(e) {
    this.animations.forEach((o) => o[e]());
  }
  play() {
    this.runAll("play");
  }
  pause() {
    this.runAll("pause");
  }
  cancel() {
    this.runAll("cancel");
  }
  complete() {
    this.runAll("complete");
  }
}
const animateMotionValue =
  (s, e, o, a = {}, c, d, g) =>
  (_) => {
    const b = getValueTransition(a, s) || {},
      j = b.delay || a.delay || 0;
    let { elapsed: $ = 0 } = a;
    $ = $ - secondsToMilliseconds(j);
    let _e = {
      keyframes: Array.isArray(o) ? o : [null, o],
      ease: "easeOut",
      velocity: e.getVelocity(),
      ...b,
      delay: -$,
      onUpdate: (rt) => {
        e.set(rt), b.onUpdate && b.onUpdate(rt);
      },
      onComplete: () => {
        _(), b.onComplete && b.onComplete(), g && g();
      },
      onStop: g,
      name: s,
      motionValue: e,
      element: d ? void 0 : c,
    };
    isTransitionDefined(b) || (_e = { ..._e, ...getDefaultTransition(s, _e) }),
      _e.duration && (_e.duration = secondsToMilliseconds(_e.duration)),
      _e.repeatDelay &&
        (_e.repeatDelay = secondsToMilliseconds(_e.repeatDelay)),
      _e.from !== void 0 && (_e.keyframes[0] = _e.from);
    let et = !1;
    if (
      ((_e.type === !1 || (_e.duration === 0 && !_e.repeatDelay)) &&
        ((_e.duration = 0), _e.delay === 0 && (et = !0)),
      et && !d && e.get() !== void 0)
    ) {
      const rt = getFinalKeyframe(_e.keyframes, b);
      if (rt !== void 0)
        return (
          frame.update(() => {
            _e.onUpdate(rt), _e.onComplete();
          }),
          new GroupPlaybackControls([])
        );
    }
    return !d && AcceleratedAnimation.supports(_e)
      ? new AcceleratedAnimation(_e)
      : new MainThreadAnimation(_e);
  };
class SubscriptionManager {
  constructor() {
    this.subscriptions = [];
  }
  add(e) {
    return (
      addUniqueItem(this.subscriptions, e),
      () => removeItem(this.subscriptions, e)
    );
  }
  notify(e, o, a) {
    const c = this.subscriptions.length;
    if (c)
      if (c === 1) this.subscriptions[0](e, o, a);
      else
        for (let d = 0; d < c; d++) {
          const g = this.subscriptions[d];
          g && g(e, o, a);
        }
  }
  getSize() {
    return this.subscriptions.length;
  }
  clear() {
    this.subscriptions.length = 0;
  }
}
const MAX_VELOCITY_DELTA = 30,
  isFloat = (s) => !isNaN(parseFloat(s));
class MotionValue {
  constructor(e, o = {}) {
    (this.version = "11.3.19"),
      (this.canTrackVelocity = null),
      (this.events = {}),
      (this.updateAndNotify = (a, c = !0) => {
        const d = time.now();
        this.updatedAt !== d && this.setPrevFrameValue(),
          (this.prev = this.current),
          this.setCurrent(a),
          this.current !== this.prev &&
            this.events.change &&
            this.events.change.notify(this.current),
          c &&
            this.events.renderRequest &&
            this.events.renderRequest.notify(this.current);
      }),
      (this.hasAnimated = !1),
      this.setCurrent(e),
      (this.owner = o.owner);
  }
  setCurrent(e) {
    (this.current = e),
      (this.updatedAt = time.now()),
      this.canTrackVelocity === null &&
        e !== void 0 &&
        (this.canTrackVelocity = isFloat(this.current));
  }
  setPrevFrameValue(e = this.current) {
    (this.prevFrameValue = e), (this.prevUpdatedAt = this.updatedAt);
  }
  onChange(e) {
    return this.on("change", e);
  }
  on(e, o) {
    this.events[e] || (this.events[e] = new SubscriptionManager());
    const a = this.events[e].add(o);
    return e === "change"
      ? () => {
          a(),
            frame.read(() => {
              this.events.change.getSize() || this.stop();
            });
        }
      : a;
  }
  clearListeners() {
    for (const e in this.events) this.events[e].clear();
  }
  attach(e, o) {
    (this.passiveEffect = e), (this.stopPassiveEffect = o);
  }
  set(e, o = !0) {
    !o || !this.passiveEffect
      ? this.updateAndNotify(e, o)
      : this.passiveEffect(e, this.updateAndNotify);
  }
  setWithVelocity(e, o, a) {
    this.set(o),
      (this.prev = void 0),
      (this.prevFrameValue = e),
      (this.prevUpdatedAt = this.updatedAt - a);
  }
  jump(e, o = !0) {
    this.updateAndNotify(e),
      (this.prev = e),
      (this.prevUpdatedAt = this.prevFrameValue = void 0),
      o && this.stop(),
      this.stopPassiveEffect && this.stopPassiveEffect();
  }
  get() {
    return this.current;
  }
  getPrevious() {
    return this.prev;
  }
  getVelocity() {
    const e = time.now();
    if (
      !this.canTrackVelocity ||
      this.prevFrameValue === void 0 ||
      e - this.updatedAt > MAX_VELOCITY_DELTA
    )
      return 0;
    const o = Math.min(this.updatedAt - this.prevUpdatedAt, MAX_VELOCITY_DELTA);
    return velocityPerSecond(
      parseFloat(this.current) - parseFloat(this.prevFrameValue),
      o
    );
  }
  start(e) {
    return (
      this.stop(),
      new Promise((o) => {
        (this.hasAnimated = !0),
          (this.animation = e(o)),
          this.events.animationStart && this.events.animationStart.notify();
      }).then(() => {
        this.events.animationComplete && this.events.animationComplete.notify(),
          this.clearAnimation();
      })
    );
  }
  stop() {
    this.animation &&
      (this.animation.stop(),
      this.events.animationCancel && this.events.animationCancel.notify()),
      this.clearAnimation();
  }
  isAnimating() {
    return !!this.animation;
  }
  clearAnimation() {
    delete this.animation;
  }
  destroy() {
    this.clearListeners(),
      this.stop(),
      this.stopPassiveEffect && this.stopPassiveEffect();
  }
}
function motionValue(s, e) {
  return new MotionValue(s, e);
}
function setMotionValue(s, e, o) {
  s.hasValue(e) ? s.getValue(e).set(o) : s.addValue(e, motionValue(o));
}
function setTarget(s, e) {
  const o = resolveVariant(s, e);
  let { transitionEnd: a = {}, transition: c = {}, ...d } = o || {};
  d = { ...d, ...a };
  for (const g in d) {
    const _ = resolveFinalValueInKeyframes(d[g]);
    setMotionValue(s, g, _);
  }
}
function getOptimisedAppearId(s) {
  return s.getProps()[optimizedAppearDataAttribute];
}
class WillChangeMotionValue extends MotionValue {
  constructor() {
    super(...arguments), (this.output = []), (this.counts = new Map());
  }
  add(e) {
    const o = getWillChangeName(e);
    if (!o) return;
    const a = this.counts.get(o) || 0;
    this.counts.set(o, a + 1), a === 0 && (this.output.push(o), this.update());
    let c = !1;
    return () => {
      if (c) return;
      c = !0;
      const d = this.counts.get(o) - 1;
      this.counts.set(o, d),
        d === 0 && (removeItem(this.output, o), this.update());
    };
  }
  update() {
    this.set(this.output.length ? this.output.join(", ") : "auto");
  }
}
function isWillChangeMotionValue(s) {
  return !!(isMotionValue(s) && s.add);
}
function addValueToWillChange(s, e) {
  var o;
  if (!s.applyWillChange) return;
  let a = s.getValue("willChange");
  if (
    (!a &&
      !(!((o = s.props.style) === null || o === void 0) && o.willChange) &&
      ((a = new WillChangeMotionValue("auto")), s.addValue("willChange", a)),
    isWillChangeMotionValue(a))
  )
    return a.add(e);
}
function shouldBlockAnimation({ protectedKeys: s, needsAnimating: e }, o) {
  const a = s.hasOwnProperty(o) && e[o] !== !0;
  return (e[o] = !1), a;
}
function animateTarget(
  s,
  e,
  { delay: o = 0, transitionOverride: a, type: c } = {}
) {
  var d;
  let { transition: g = s.getDefaultTransition(), transitionEnd: _, ...b } = e;
  a && (g = a);
  const j = [],
    $ = c && s.animationState && s.animationState.getState()[c];
  for (const _e in b) {
    const et = s.getValue(
        _e,
        (d = s.latestValues[_e]) !== null && d !== void 0 ? d : null
      ),
      rt = b[_e];
    if (rt === void 0 || ($ && shouldBlockAnimation($, _e))) continue;
    const st = { delay: o, elapsed: 0, ...getValueTransition(g || {}, _e) };
    let at = !1;
    if (window.HandoffAppearAnimations) {
      const it = getOptimisedAppearId(s);
      if (it) {
        const lt = window.HandoffAppearAnimations(it, _e, et, frame);
        lt !== null && ((st.elapsed = lt), (at = !0));
      }
    }
    et.start(
      animateMotionValue(
        _e,
        et,
        rt,
        s.shouldReduceMotion && transformProps.has(_e) ? { type: !1 } : st,
        s,
        at,
        addValueToWillChange(s, _e)
      )
    );
    const ct = et.animation;
    ct && j.push(ct);
  }
  return (
    _ &&
      Promise.all(j).then(() => {
        frame.update(() => {
          _ && setTarget(s, _);
        });
      }),
    j
  );
}
function animateVariant(s, e, o = {}) {
  var a;
  const c = resolveVariant(
    s,
    e,
    o.type === "exit"
      ? (a = s.presenceContext) === null || a === void 0
        ? void 0
        : a.custom
      : void 0
  );
  let { transition: d = s.getDefaultTransition() || {} } = c || {};
  o.transitionOverride && (d = o.transitionOverride);
  const g = c
      ? () => Promise.all(animateTarget(s, c, o))
      : () => Promise.resolve(),
    _ =
      s.variantChildren && s.variantChildren.size
        ? (j = 0) => {
            const {
              delayChildren: $ = 0,
              staggerChildren: _e,
              staggerDirection: et,
            } = d;
            return animateChildren(s, e, $ + j, _e, et, o);
          }
        : () => Promise.resolve(),
    { when: b } = d;
  if (b) {
    const [j, $] = b === "beforeChildren" ? [g, _] : [_, g];
    return j().then(() => $());
  } else return Promise.all([g(), _(o.delay)]);
}
function animateChildren(s, e, o = 0, a = 0, c = 1, d) {
  const g = [],
    _ = (s.variantChildren.size - 1) * a,
    b = c === 1 ? (j = 0) => j * a : (j = 0) => _ - j * a;
  return (
    Array.from(s.variantChildren)
      .sort(sortByTreeOrder)
      .forEach((j, $) => {
        j.notify("AnimationStart", e),
          g.push(
            animateVariant(j, e, { ...d, delay: o + b($) }).then(() =>
              j.notify("AnimationComplete", e)
            )
          );
      }),
    Promise.all(g)
  );
}
function sortByTreeOrder(s, e) {
  return s.sortNodePosition(e);
}
function animateVisualElement(s, e, o = {}) {
  s.notify("AnimationStart", e);
  let a;
  if (Array.isArray(e)) {
    const c = e.map((d) => animateVariant(s, d, o));
    a = Promise.all(c);
  } else if (typeof e == "string") a = animateVariant(s, e, o);
  else {
    const c = typeof e == "function" ? resolveVariant(s, e, o.custom) : e;
    a = Promise.all(animateTarget(s, c, o));
  }
  return a.then(() => {
    s.notify("AnimationComplete", e);
  });
}
const reversePriorityOrder = [...variantPriorityOrder].reverse(),
  numAnimationTypes = variantPriorityOrder.length;
function animateList(s) {
  return (e) =>
    Promise.all(
      e.map(({ animation: o, options: a }) => animateVisualElement(s, o, a))
    );
}
function createAnimationState(s) {
  let e = animateList(s),
    o = createState(),
    a = !0;
  const c = (b) => (j, $) => {
    var _e;
    const et = resolveVariant(
      s,
      $,
      b === "exit"
        ? (_e = s.presenceContext) === null || _e === void 0
          ? void 0
          : _e.custom
        : void 0
    );
    if (et) {
      const { transition: rt, transitionEnd: st, ...at } = et;
      j = { ...j, ...at, ...st };
    }
    return j;
  };
  function d(b) {
    e = b(s);
  }
  function g(b) {
    const j = s.getProps(),
      $ = s.getVariantContext(!0) || {},
      _e = [],
      et = new Set();
    let rt = {},
      st = 1 / 0;
    for (let ct = 0; ct < numAnimationTypes; ct++) {
      const it = reversePriorityOrder[ct],
        lt = o[it],
        ot = j[it] !== void 0 ? j[it] : $[it],
        ut = isVariantLabel(ot),
        pt = it === b ? lt.isActive : null;
      pt === !1 && (st = ct);
      let ft = ot === $[it] && ot !== j[it] && ut;
      if (
        (ft && a && s.manuallyAnimateOnMount && (ft = !1),
        (lt.protectedKeys = { ...rt }),
        (!lt.isActive && pt === null) ||
          (!ot && !lt.prevProp) ||
          isAnimationControls(ot) ||
          typeof ot == "boolean")
      )
        continue;
      let xt =
          checkVariantsDidChange(lt.prevProp, ot) ||
          (it === b && lt.isActive && !ft && ut) ||
          (ct > st && ut),
        _t = !1;
      const St = Array.isArray(ot) ? ot : [ot];
      let Mt = St.reduce(c(it), {});
      pt === !1 && (Mt = {});
      const { prevResolvedValues: Rt = {} } = lt,
        Ft = { ...Rt, ...Mt },
        Ot = (Lt) => {
          (xt = !0),
            et.has(Lt) && ((_t = !0), et.delete(Lt)),
            (lt.needsAnimating[Lt] = !0);
          const Et = s.getValue(Lt);
          Et && (Et.liveStyle = !1);
        };
      for (const Lt in Ft) {
        const Et = Mt[Lt],
          bt = Rt[Lt];
        if (rt.hasOwnProperty(Lt)) continue;
        let mt = !1;
        isKeyframesTarget(Et) && isKeyframesTarget(bt)
          ? (mt = !shallowCompare(Et, bt))
          : (mt = Et !== bt),
          mt
            ? Et != null
              ? Ot(Lt)
              : et.add(Lt)
            : Et !== void 0 && et.has(Lt)
            ? Ot(Lt)
            : (lt.protectedKeys[Lt] = !0);
      }
      (lt.prevProp = ot),
        (lt.prevResolvedValues = Mt),
        lt.isActive && (rt = { ...rt, ...Mt }),
        a && s.blockInitialAnimation && (xt = !1),
        xt &&
          (!ft || _t) &&
          _e.push(
            ...St.map((Lt) => ({ animation: Lt, options: { type: it } }))
          );
    }
    if (et.size) {
      const ct = {};
      et.forEach((it) => {
        const lt = s.getBaseTarget(it),
          ot = s.getValue(it);
        ot && (ot.liveStyle = !0), (ct[it] = lt ?? null);
      }),
        _e.push({ animation: ct });
    }
    let at = !!_e.length;
    return (
      a &&
        (j.initial === !1 || j.initial === j.animate) &&
        !s.manuallyAnimateOnMount &&
        (at = !1),
      (a = !1),
      at ? e(_e) : Promise.resolve()
    );
  }
  function _(b, j) {
    var $;
    if (o[b].isActive === j) return Promise.resolve();
    ($ = s.variantChildren) === null ||
      $ === void 0 ||
      $.forEach((et) => {
        var rt;
        return (rt = et.animationState) === null || rt === void 0
          ? void 0
          : rt.setActive(b, j);
      }),
      (o[b].isActive = j);
    const _e = g(b);
    for (const et in o) o[et].protectedKeys = {};
    return _e;
  }
  return {
    animateChanges: g,
    setActive: _,
    setAnimateFunction: d,
    getState: () => o,
    reset: () => {
      (o = createState()), (a = !0);
    },
  };
}
function checkVariantsDidChange(s, e) {
  return typeof e == "string"
    ? e !== s
    : Array.isArray(e)
    ? !shallowCompare(e, s)
    : !1;
}
function createTypeState(s = !1) {
  return {
    isActive: s,
    protectedKeys: {},
    needsAnimating: {},
    prevResolvedValues: {},
  };
}
function createState() {
  return {
    animate: createTypeState(!0),
    whileInView: createTypeState(),
    whileHover: createTypeState(),
    whileTap: createTypeState(),
    whileDrag: createTypeState(),
    whileFocus: createTypeState(),
    exit: createTypeState(),
  };
}
class AnimationFeature extends Feature {
  constructor(e) {
    super(e), e.animationState || (e.animationState = createAnimationState(e));
  }
  updateAnimationControlsSubscription() {
    const { animate: e } = this.node.getProps();
    isAnimationControls(e) && (this.unmountControls = e.subscribe(this.node));
  }
  mount() {
    this.updateAnimationControlsSubscription();
  }
  update() {
    const { animate: e } = this.node.getProps(),
      { animate: o } = this.node.prevProps || {};
    e !== o && this.updateAnimationControlsSubscription();
  }
  unmount() {
    var e;
    this.node.animationState.reset(),
      (e = this.unmountControls) === null || e === void 0 || e.call(this);
  }
}
let id$1 = 0;
class ExitAnimationFeature extends Feature {
  constructor() {
    super(...arguments), (this.id = id$1++);
  }
  update() {
    if (!this.node.presenceContext) return;
    const { isPresent: e, onExitComplete: o } = this.node.presenceContext,
      { isPresent: a } = this.node.prevPresenceContext || {};
    if (!this.node.animationState || e === a) return;
    const c = this.node.animationState.setActive("exit", !e);
    o && !e && c.then(() => o(this.id));
  }
  mount() {
    const { register: e } = this.node.presenceContext || {};
    e && (this.unmount = e(this.id));
  }
  unmount() {}
}
const animations = {
    animation: { Feature: AnimationFeature },
    exit: { Feature: ExitAnimationFeature },
  },
  distance = (s, e) => Math.abs(s - e);
function distance2D(s, e) {
  const o = distance(s.x, e.x),
    a = distance(s.y, e.y);
  return Math.sqrt(o ** 2 + a ** 2);
}
class PanSession {
  constructor(
    e,
    o,
    { transformPagePoint: a, contextWindow: c, dragSnapToOrigin: d = !1 } = {}
  ) {
    if (
      ((this.startEvent = null),
      (this.lastMoveEvent = null),
      (this.lastMoveEventInfo = null),
      (this.handlers = {}),
      (this.contextWindow = window),
      (this.updatePoint = () => {
        if (!(this.lastMoveEvent && this.lastMoveEventInfo)) return;
        const _e = getPanInfo(this.lastMoveEventInfo, this.history),
          et = this.startEvent !== null,
          rt = distance2D(_e.offset, { x: 0, y: 0 }) >= 3;
        if (!et && !rt) return;
        const { point: st } = _e,
          { timestamp: at } = frameData;
        this.history.push({ ...st, timestamp: at });
        const { onStart: ct, onMove: it } = this.handlers;
        et ||
          (ct && ct(this.lastMoveEvent, _e),
          (this.startEvent = this.lastMoveEvent)),
          it && it(this.lastMoveEvent, _e);
      }),
      (this.handlePointerMove = (_e, et) => {
        (this.lastMoveEvent = _e),
          (this.lastMoveEventInfo = transformPoint(
            et,
            this.transformPagePoint
          )),
          frame.update(this.updatePoint, !0);
      }),
      (this.handlePointerUp = (_e, et) => {
        this.end();
        const {
          onEnd: rt,
          onSessionEnd: st,
          resumeAnimation: at,
        } = this.handlers;
        if (
          (this.dragSnapToOrigin && at && at(),
          !(this.lastMoveEvent && this.lastMoveEventInfo))
        )
          return;
        const ct = getPanInfo(
          _e.type === "pointercancel"
            ? this.lastMoveEventInfo
            : transformPoint(et, this.transformPagePoint),
          this.history
        );
        this.startEvent && rt && rt(_e, ct), st && st(_e, ct);
      }),
      !isPrimaryPointer(e))
    )
      return;
    (this.dragSnapToOrigin = d),
      (this.handlers = o),
      (this.transformPagePoint = a),
      (this.contextWindow = c || window);
    const g = extractEventInfo(e),
      _ = transformPoint(g, this.transformPagePoint),
      { point: b } = _,
      { timestamp: j } = frameData;
    this.history = [{ ...b, timestamp: j }];
    const { onSessionStart: $ } = o;
    $ && $(e, getPanInfo(_, this.history)),
      (this.removeListeners = pipe(
        addPointerEvent(
          this.contextWindow,
          "pointermove",
          this.handlePointerMove
        ),
        addPointerEvent(this.contextWindow, "pointerup", this.handlePointerUp),
        addPointerEvent(
          this.contextWindow,
          "pointercancel",
          this.handlePointerUp
        )
      ));
  }
  updateHandlers(e) {
    this.handlers = e;
  }
  end() {
    this.removeListeners && this.removeListeners(),
      cancelFrame(this.updatePoint);
  }
}
function transformPoint(s, e) {
  return e ? { point: e(s.point) } : s;
}
function subtractPoint(s, e) {
  return { x: s.x - e.x, y: s.y - e.y };
}
function getPanInfo({ point: s }, e) {
  return {
    point: s,
    delta: subtractPoint(s, lastDevicePoint(e)),
    offset: subtractPoint(s, startDevicePoint(e)),
    velocity: getVelocity(e, 0.1),
  };
}
function startDevicePoint(s) {
  return s[0];
}
function lastDevicePoint(s) {
  return s[s.length - 1];
}
function getVelocity(s, e) {
  if (s.length < 2) return { x: 0, y: 0 };
  let o = s.length - 1,
    a = null;
  const c = lastDevicePoint(s);
  for (
    ;
    o >= 0 &&
    ((a = s[o]), !(c.timestamp - a.timestamp > secondsToMilliseconds(e)));

  )
    o--;
  if (!a) return { x: 0, y: 0 };
  const d = millisecondsToSeconds(c.timestamp - a.timestamp);
  if (d === 0) return { x: 0, y: 0 };
  const g = { x: (c.x - a.x) / d, y: (c.y - a.y) / d };
  return g.x === 1 / 0 && (g.x = 0), g.y === 1 / 0 && (g.y = 0), g;
}
const SCALE_PRECISION = 1e-4,
  SCALE_MIN = 1 - SCALE_PRECISION,
  SCALE_MAX = 1 + SCALE_PRECISION,
  TRANSLATE_PRECISION = 0.01,
  TRANSLATE_MIN = 0 - TRANSLATE_PRECISION,
  TRANSLATE_MAX = 0 + TRANSLATE_PRECISION;
function calcLength(s) {
  return s.max - s.min;
}
function isNear(s, e, o) {
  return Math.abs(s - e) <= o;
}
function calcAxisDelta(s, e, o, a = 0.5) {
  (s.origin = a),
    (s.originPoint = mixNumber$1(e.min, e.max, s.origin)),
    (s.scale = calcLength(o) / calcLength(e)),
    (s.translate = mixNumber$1(o.min, o.max, s.origin) - s.originPoint),
    ((s.scale >= SCALE_MIN && s.scale <= SCALE_MAX) || isNaN(s.scale)) &&
      (s.scale = 1),
    ((s.translate >= TRANSLATE_MIN && s.translate <= TRANSLATE_MAX) ||
      isNaN(s.translate)) &&
      (s.translate = 0);
}
function calcBoxDelta(s, e, o, a) {
  calcAxisDelta(s.x, e.x, o.x, a ? a.originX : void 0),
    calcAxisDelta(s.y, e.y, o.y, a ? a.originY : void 0);
}
function calcRelativeAxis(s, e, o) {
  (s.min = o.min + e.min), (s.max = s.min + calcLength(e));
}
function calcRelativeBox(s, e, o) {
  calcRelativeAxis(s.x, e.x, o.x), calcRelativeAxis(s.y, e.y, o.y);
}
function calcRelativeAxisPosition(s, e, o) {
  (s.min = e.min - o.min), (s.max = s.min + calcLength(e));
}
function calcRelativePosition(s, e, o) {
  calcRelativeAxisPosition(s.x, e.x, o.x),
    calcRelativeAxisPosition(s.y, e.y, o.y);
}
function applyConstraints(s, { min: e, max: o }, a) {
  return (
    e !== void 0 && s < e
      ? (s = a ? mixNumber$1(e, s, a.min) : Math.max(s, e))
      : o !== void 0 &&
        s > o &&
        (s = a ? mixNumber$1(o, s, a.max) : Math.min(s, o)),
    s
  );
}
function calcRelativeAxisConstraints(s, e, o) {
  return {
    min: e !== void 0 ? s.min + e : void 0,
    max: o !== void 0 ? s.max + o - (s.max - s.min) : void 0,
  };
}
function calcRelativeConstraints(s, { top: e, left: o, bottom: a, right: c }) {
  return {
    x: calcRelativeAxisConstraints(s.x, o, c),
    y: calcRelativeAxisConstraints(s.y, e, a),
  };
}
function calcViewportAxisConstraints(s, e) {
  let o = e.min - s.min,
    a = e.max - s.max;
  return e.max - e.min < s.max - s.min && ([o, a] = [a, o]), { min: o, max: a };
}
function calcViewportConstraints(s, e) {
  return {
    x: calcViewportAxisConstraints(s.x, e.x),
    y: calcViewportAxisConstraints(s.y, e.y),
  };
}
function calcOrigin(s, e) {
  let o = 0.5;
  const a = calcLength(s),
    c = calcLength(e);
  return (
    c > a
      ? (o = progress(e.min, e.max - a, s.min))
      : a > c && (o = progress(s.min, s.max - c, e.min)),
    clamp$1(0, 1, o)
  );
}
function rebaseAxisConstraints(s, e) {
  const o = {};
  return (
    e.min !== void 0 && (o.min = e.min - s.min),
    e.max !== void 0 && (o.max = e.max - s.min),
    o
  );
}
const defaultElastic = 0.35;
function resolveDragElastic(s = defaultElastic) {
  return (
    s === !1 ? (s = 0) : s === !0 && (s = defaultElastic),
    {
      x: resolveAxisElastic(s, "left", "right"),
      y: resolveAxisElastic(s, "top", "bottom"),
    }
  );
}
function resolveAxisElastic(s, e, o) {
  return { min: resolvePointElastic(s, e), max: resolvePointElastic(s, o) };
}
function resolvePointElastic(s, e) {
  return typeof s == "number" ? s : s[e] || 0;
}
const createAxisDelta = () => ({
    translate: 0,
    scale: 1,
    origin: 0,
    originPoint: 0,
  }),
  createDelta = () => ({ x: createAxisDelta(), y: createAxisDelta() }),
  createAxis = () => ({ min: 0, max: 0 }),
  createBox = () => ({ x: createAxis(), y: createAxis() });
function eachAxis(s) {
  return [s("x"), s("y")];
}
function convertBoundingBoxToBox({ top: s, left: e, right: o, bottom: a }) {
  return { x: { min: e, max: o }, y: { min: s, max: a } };
}
function convertBoxToBoundingBox({ x: s, y: e }) {
  return { top: e.min, right: s.max, bottom: e.max, left: s.min };
}
function transformBoxPoints(s, e) {
  if (!e) return s;
  const o = e({ x: s.left, y: s.top }),
    a = e({ x: s.right, y: s.bottom });
  return { top: o.y, left: o.x, bottom: a.y, right: a.x };
}
function isIdentityScale(s) {
  return s === void 0 || s === 1;
}
function hasScale({ scale: s, scaleX: e, scaleY: o }) {
  return !isIdentityScale(s) || !isIdentityScale(e) || !isIdentityScale(o);
}
function hasTransform(s) {
  return (
    hasScale(s) ||
    has2DTranslate(s) ||
    s.z ||
    s.rotate ||
    s.rotateX ||
    s.rotateY ||
    s.skewX ||
    s.skewY
  );
}
function has2DTranslate(s) {
  return is2DTranslate(s.x) || is2DTranslate(s.y);
}
function is2DTranslate(s) {
  return s && s !== "0%";
}
function scalePoint(s, e, o) {
  const a = s - o,
    c = e * a;
  return o + c;
}
function applyPointDelta(s, e, o, a, c) {
  return c !== void 0 && (s = scalePoint(s, c, a)), scalePoint(s, o, a) + e;
}
function applyAxisDelta(s, e = 0, o = 1, a, c) {
  (s.min = applyPointDelta(s.min, e, o, a, c)),
    (s.max = applyPointDelta(s.max, e, o, a, c));
}
function applyBoxDelta(s, { x: e, y: o }) {
  applyAxisDelta(s.x, e.translate, e.scale, e.originPoint),
    applyAxisDelta(s.y, o.translate, o.scale, o.originPoint);
}
const TREE_SCALE_SNAP_MIN = 0.999999999999,
  TREE_SCALE_SNAP_MAX = 1.0000000000001;
function applyTreeDeltas(s, e, o, a = !1) {
  const c = o.length;
  if (!c) return;
  e.x = e.y = 1;
  let d, g;
  for (let _ = 0; _ < c; _++) {
    (d = o[_]), (g = d.projectionDelta);
    const { visualElement: b } = d.options;
    (b && b.props.style && b.props.style.display === "contents") ||
      (a &&
        d.options.layoutScroll &&
        d.scroll &&
        d !== d.root &&
        transformBox(s, { x: -d.scroll.offset.x, y: -d.scroll.offset.y }),
      g && ((e.x *= g.x.scale), (e.y *= g.y.scale), applyBoxDelta(s, g)),
      a && hasTransform(d.latestValues) && transformBox(s, d.latestValues));
  }
  e.x < TREE_SCALE_SNAP_MAX && e.x > TREE_SCALE_SNAP_MIN && (e.x = 1),
    e.y < TREE_SCALE_SNAP_MAX && e.y > TREE_SCALE_SNAP_MIN && (e.y = 1);
}
function translateAxis(s, e) {
  (s.min = s.min + e), (s.max = s.max + e);
}
function transformAxis(s, e, o, a, c = 0.5) {
  const d = mixNumber$1(s.min, s.max, c);
  applyAxisDelta(s, e, o, d, a);
}
function transformBox(s, e) {
  transformAxis(s.x, e.x, e.scaleX, e.scale, e.originX),
    transformAxis(s.y, e.y, e.scaleY, e.scale, e.originY);
}
function measureViewportBox(s, e) {
  return convertBoundingBoxToBox(
    transformBoxPoints(s.getBoundingClientRect(), e)
  );
}
function measurePageBox(s, e, o) {
  const a = measureViewportBox(s, o),
    { scroll: c } = e;
  return (
    c && (translateAxis(a.x, c.offset.x), translateAxis(a.y, c.offset.y)), a
  );
}
const getContextWindow = ({ current: s }) =>
    s ? s.ownerDocument.defaultView : null,
  elementDragControls = new WeakMap();
class VisualElementDragControls {
  constructor(e) {
    (this.openGlobalLock = null),
      (this.isDragging = !1),
      (this.currentDirection = null),
      (this.originPoint = { x: 0, y: 0 }),
      (this.constraints = !1),
      (this.hasMutatedConstraints = !1),
      (this.elastic = createBox()),
      (this.visualElement = e);
  }
  start(e, { snapToCursor: o = !1 } = {}) {
    const { presenceContext: a } = this.visualElement;
    if (a && a.isPresent === !1) return;
    const c = ($) => {
        const { dragSnapToOrigin: _e } = this.getProps();
        _e ? this.pauseAnimation() : this.stopAnimation(),
          o && this.snapToCursor(extractEventInfo($, "page").point);
      },
      d = ($, _e) => {
        var et;
        const {
          drag: rt,
          dragPropagation: st,
          onDragStart: at,
        } = this.getProps();
        if (
          rt &&
          !st &&
          (this.openGlobalLock && this.openGlobalLock(),
          (this.openGlobalLock = getGlobalLock(rt)),
          !this.openGlobalLock)
        )
          return;
        (this.isDragging = !0),
          (this.currentDirection = null),
          this.resolveConstraints(),
          this.visualElement.projection &&
            ((this.visualElement.projection.isAnimationBlocked = !0),
            (this.visualElement.projection.target = void 0)),
          eachAxis((it) => {
            let lt = this.getAxisMotionValue(it).get() || 0;
            if (percent.test(lt)) {
              const { projection: ot } = this.visualElement;
              if (ot && ot.layout) {
                const ut = ot.layout.layoutBox[it];
                ut && (lt = calcLength(ut) * (parseFloat(lt) / 100));
              }
            }
            this.originPoint[it] = lt;
          }),
          at && frame.postRender(() => at($, _e)),
          (et = this.removeWillChange) === null ||
            et === void 0 ||
            et.call(this),
          (this.removeWillChange = addValueToWillChange(
            this.visualElement,
            "transform"
          ));
        const { animationState: ct } = this.visualElement;
        ct && ct.setActive("whileDrag", !0);
      },
      g = ($, _e) => {
        const {
          dragPropagation: et,
          dragDirectionLock: rt,
          onDirectionLock: st,
          onDrag: at,
        } = this.getProps();
        if (!et && !this.openGlobalLock) return;
        const { offset: ct } = _e;
        if (rt && this.currentDirection === null) {
          (this.currentDirection = getCurrentDirection(ct)),
            this.currentDirection !== null && st && st(this.currentDirection);
          return;
        }
        this.updateAxis("x", _e.point, ct),
          this.updateAxis("y", _e.point, ct),
          this.visualElement.render(),
          at && at($, _e);
      },
      _ = ($, _e) => this.stop($, _e),
      b = () =>
        eachAxis(($) => {
          var _e;
          return (
            this.getAnimationState($) === "paused" &&
            ((_e = this.getAxisMotionValue($).animation) === null ||
            _e === void 0
              ? void 0
              : _e.play())
          );
        }),
      { dragSnapToOrigin: j } = this.getProps();
    this.panSession = new PanSession(
      e,
      {
        onSessionStart: c,
        onStart: d,
        onMove: g,
        onSessionEnd: _,
        resumeAnimation: b,
      },
      {
        transformPagePoint: this.visualElement.getTransformPagePoint(),
        dragSnapToOrigin: j,
        contextWindow: getContextWindow(this.visualElement),
      }
    );
  }
  stop(e, o) {
    var a;
    (a = this.removeWillChange) === null || a === void 0 || a.call(this);
    const c = this.isDragging;
    if ((this.cancel(), !c)) return;
    const { velocity: d } = o;
    this.startAnimation(d);
    const { onDragEnd: g } = this.getProps();
    g && frame.postRender(() => g(e, o));
  }
  cancel() {
    this.isDragging = !1;
    const { projection: e, animationState: o } = this.visualElement;
    e && (e.isAnimationBlocked = !1),
      this.panSession && this.panSession.end(),
      (this.panSession = void 0);
    const { dragPropagation: a } = this.getProps();
    !a &&
      this.openGlobalLock &&
      (this.openGlobalLock(), (this.openGlobalLock = null)),
      o && o.setActive("whileDrag", !1);
  }
  updateAxis(e, o, a) {
    const { drag: c } = this.getProps();
    if (!a || !shouldDrag(e, c, this.currentDirection)) return;
    const d = this.getAxisMotionValue(e);
    let g = this.originPoint[e] + a[e];
    this.constraints &&
      this.constraints[e] &&
      (g = applyConstraints(g, this.constraints[e], this.elastic[e])),
      d.set(g);
  }
  resolveConstraints() {
    var e;
    const { dragConstraints: o, dragElastic: a } = this.getProps(),
      c =
        this.visualElement.projection && !this.visualElement.projection.layout
          ? this.visualElement.projection.measure(!1)
          : (e = this.visualElement.projection) === null || e === void 0
          ? void 0
          : e.layout,
      d = this.constraints;
    o && isRefObject$1(o)
      ? this.constraints || (this.constraints = this.resolveRefConstraints())
      : o && c
      ? (this.constraints = calcRelativeConstraints(c.layoutBox, o))
      : (this.constraints = !1),
      (this.elastic = resolveDragElastic(a)),
      d !== this.constraints &&
        c &&
        this.constraints &&
        !this.hasMutatedConstraints &&
        eachAxis((g) => {
          this.constraints !== !1 &&
            this.getAxisMotionValue(g) &&
            (this.constraints[g] = rebaseAxisConstraints(
              c.layoutBox[g],
              this.constraints[g]
            ));
        });
  }
  resolveRefConstraints() {
    const { dragConstraints: e, onMeasureDragConstraints: o } = this.getProps();
    if (!e || !isRefObject$1(e)) return !1;
    const a = e.current,
      { projection: c } = this.visualElement;
    if (!c || !c.layout) return !1;
    const d = measurePageBox(
      a,
      c.root,
      this.visualElement.getTransformPagePoint()
    );
    let g = calcViewportConstraints(c.layout.layoutBox, d);
    if (o) {
      const _ = o(convertBoxToBoundingBox(g));
      (this.hasMutatedConstraints = !!_), _ && (g = convertBoundingBoxToBox(_));
    }
    return g;
  }
  startAnimation(e) {
    const {
        drag: o,
        dragMomentum: a,
        dragElastic: c,
        dragTransition: d,
        dragSnapToOrigin: g,
        onDragTransitionEnd: _,
      } = this.getProps(),
      b = this.constraints || {},
      j = eachAxis(($) => {
        if (!shouldDrag($, o, this.currentDirection)) return;
        let _e = (b && b[$]) || {};
        g && (_e = { min: 0, max: 0 });
        const et = c ? 200 : 1e6,
          rt = c ? 40 : 1e7,
          st = {
            type: "inertia",
            velocity: a ? e[$] : 0,
            bounceStiffness: et,
            bounceDamping: rt,
            timeConstant: 750,
            restDelta: 1,
            restSpeed: 10,
            ...d,
            ..._e,
          };
        return this.startAxisValueAnimation($, st);
      });
    return Promise.all(j).then(_);
  }
  startAxisValueAnimation(e, o) {
    const a = this.getAxisMotionValue(e);
    return a.start(
      animateMotionValue(
        e,
        a,
        0,
        o,
        this.visualElement,
        !1,
        addValueToWillChange(this.visualElement, e)
      )
    );
  }
  stopAnimation() {
    eachAxis((e) => this.getAxisMotionValue(e).stop());
  }
  pauseAnimation() {
    eachAxis((e) => {
      var o;
      return (o = this.getAxisMotionValue(e).animation) === null || o === void 0
        ? void 0
        : o.pause();
    });
  }
  getAnimationState(e) {
    var o;
    return (o = this.getAxisMotionValue(e).animation) === null || o === void 0
      ? void 0
      : o.state;
  }
  getAxisMotionValue(e) {
    const o = `_drag${e.toUpperCase()}`,
      a = this.visualElement.getProps(),
      c = a[o];
    return (
      c ||
      this.visualElement.getValue(e, (a.initial ? a.initial[e] : void 0) || 0)
    );
  }
  snapToCursor(e) {
    eachAxis((o) => {
      const { drag: a } = this.getProps();
      if (!shouldDrag(o, a, this.currentDirection)) return;
      const { projection: c } = this.visualElement,
        d = this.getAxisMotionValue(o);
      if (c && c.layout) {
        const { min: g, max: _ } = c.layout.layoutBox[o];
        d.set(e[o] - mixNumber$1(g, _, 0.5));
      }
    });
  }
  scalePositionWithinConstraints() {
    if (!this.visualElement.current) return;
    const { drag: e, dragConstraints: o } = this.getProps(),
      { projection: a } = this.visualElement;
    if (!isRefObject$1(o) || !a || !this.constraints) return;
    this.stopAnimation();
    const c = { x: 0, y: 0 };
    eachAxis((g) => {
      const _ = this.getAxisMotionValue(g);
      if (_ && this.constraints !== !1) {
        const b = _.get();
        c[g] = calcOrigin({ min: b, max: b }, this.constraints[g]);
      }
    });
    const { transformTemplate: d } = this.visualElement.getProps();
    (this.visualElement.current.style.transform = d ? d({}, "") : "none"),
      a.root && a.root.updateScroll(),
      a.updateLayout(),
      this.resolveConstraints(),
      eachAxis((g) => {
        if (!shouldDrag(g, e, null)) return;
        const _ = this.getAxisMotionValue(g),
          { min: b, max: j } = this.constraints[g];
        _.set(mixNumber$1(b, j, c[g]));
      });
  }
  addListeners() {
    if (!this.visualElement.current) return;
    elementDragControls.set(this.visualElement, this);
    const e = this.visualElement.current,
      o = addPointerEvent(e, "pointerdown", (b) => {
        const { drag: j, dragListener: $ = !0 } = this.getProps();
        j && $ && this.start(b);
      }),
      a = () => {
        const { dragConstraints: b } = this.getProps();
        isRefObject$1(b) &&
          b.current &&
          (this.constraints = this.resolveRefConstraints());
      },
      { projection: c } = this.visualElement,
      d = c.addEventListener("measure", a);
    c && !c.layout && (c.root && c.root.updateScroll(), c.updateLayout()),
      frame.read(a);
    const g = addDomEvent(window, "resize", () =>
        this.scalePositionWithinConstraints()
      ),
      _ = c.addEventListener(
        "didUpdate",
        ({ delta: b, hasLayoutChanged: j }) => {
          this.isDragging &&
            j &&
            (eachAxis(($) => {
              const _e = this.getAxisMotionValue($);
              _e &&
                ((this.originPoint[$] += b[$].translate),
                _e.set(_e.get() + b[$].translate));
            }),
            this.visualElement.render());
        }
      );
    return () => {
      g(), o(), d(), _ && _();
    };
  }
  getProps() {
    const e = this.visualElement.getProps(),
      {
        drag: o = !1,
        dragDirectionLock: a = !1,
        dragPropagation: c = !1,
        dragConstraints: d = !1,
        dragElastic: g = defaultElastic,
        dragMomentum: _ = !0,
      } = e;
    return {
      ...e,
      drag: o,
      dragDirectionLock: a,
      dragPropagation: c,
      dragConstraints: d,
      dragElastic: g,
      dragMomentum: _,
    };
  }
}
function shouldDrag(s, e, o) {
  return (e === !0 || e === s) && (o === null || o === s);
}
function getCurrentDirection(s, e = 10) {
  let o = null;
  return Math.abs(s.y) > e ? (o = "y") : Math.abs(s.x) > e && (o = "x"), o;
}
class DragGesture extends Feature {
  constructor(e) {
    super(e),
      (this.removeGroupControls = noop),
      (this.removeListeners = noop),
      (this.controls = new VisualElementDragControls(e));
  }
  mount() {
    const { dragControls: e } = this.node.getProps();
    e && (this.removeGroupControls = e.subscribe(this.controls)),
      (this.removeListeners = this.controls.addListeners() || noop);
  }
  unmount() {
    this.removeGroupControls(), this.removeListeners();
  }
}
const asyncHandler = (s) => (e, o) => {
  s && frame.postRender(() => s(e, o));
};
class PanGesture extends Feature {
  constructor() {
    super(...arguments), (this.removePointerDownListener = noop);
  }
  onPointerDown(e) {
    this.session = new PanSession(e, this.createPanHandlers(), {
      transformPagePoint: this.node.getTransformPagePoint(),
      contextWindow: getContextWindow(this.node),
    });
  }
  createPanHandlers() {
    const {
      onPanSessionStart: e,
      onPanStart: o,
      onPan: a,
      onPanEnd: c,
    } = this.node.getProps();
    return {
      onSessionStart: asyncHandler(e),
      onStart: asyncHandler(o),
      onMove: a,
      onEnd: (d, g) => {
        delete this.session, c && frame.postRender(() => c(d, g));
      },
    };
  }
  mount() {
    this.removePointerDownListener = addPointerEvent(
      this.node.current,
      "pointerdown",
      (e) => this.onPointerDown(e)
    );
  }
  update() {
    this.session && this.session.updateHandlers(this.createPanHandlers());
  }
  unmount() {
    this.removePointerDownListener(), this.session && this.session.end();
  }
}
function usePresence() {
  const s = reactExports$1.useContext(PresenceContext);
  if (s === null) return [!0, null];
  const { isPresent: e, onExitComplete: o, register: a } = s,
    c = reactExports$1.useId();
  reactExports$1.useEffect(() => a(c), []);
  const d = reactExports$1.useCallback(() => o && o(c), [c, o]);
  return !e && o ? [!1, d] : [!0];
}
const globalProjectionState = {
  hasAnimatedSinceResize: !0,
  hasEverUpdated: !1,
};
function pixelsToPercent(s, e) {
  return e.max === e.min ? 0 : (s / (e.max - e.min)) * 100;
}
const correctBorderRadius = {
    correct: (s, e) => {
      if (!e.target) return s;
      if (typeof s == "string")
        if (px$1.test(s)) s = parseFloat(s);
        else return s;
      const o = pixelsToPercent(s, e.target.x),
        a = pixelsToPercent(s, e.target.y);
      return `${o}% ${a}%`;
    },
  },
  correctBoxShadow = {
    correct: (s, { treeScale: e, projectionDelta: o }) => {
      const a = s,
        c = complex.parse(s);
      if (c.length > 5) return a;
      const d = complex.createTransformer(s),
        g = typeof c[0] != "number" ? 1 : 0,
        _ = o.x.scale * e.x,
        b = o.y.scale * e.y;
      (c[0 + g] /= _), (c[1 + g] /= b);
      const j = mixNumber$1(_, b, 0.5);
      return (
        typeof c[2 + g] == "number" && (c[2 + g] /= j),
        typeof c[3 + g] == "number" && (c[3 + g] /= j),
        d(c)
      );
    },
  };
class MeasureLayoutWithContext extends reactExports$1.Component {
  componentDidMount() {
    const {
        visualElement: e,
        layoutGroup: o,
        switchLayoutGroup: a,
        layoutId: c,
      } = this.props,
      { projection: d } = e;
    addScaleCorrector(defaultScaleCorrectors),
      d &&
        (o.group && o.group.add(d),
        a && a.register && c && a.register(d),
        d.root.didUpdate(),
        d.addEventListener("animationComplete", () => {
          this.safeToRemove();
        }),
        d.setOptions({
          ...d.options,
          onExitComplete: () => this.safeToRemove(),
        })),
      (globalProjectionState.hasEverUpdated = !0);
  }
  getSnapshotBeforeUpdate(e) {
    const {
        layoutDependency: o,
        visualElement: a,
        drag: c,
        isPresent: d,
      } = this.props,
      g = a.projection;
    return (
      g &&
        ((g.isPresent = d),
        c || e.layoutDependency !== o || o === void 0
          ? g.willUpdate()
          : this.safeToRemove(),
        e.isPresent !== d &&
          (d
            ? g.promote()
            : g.relegate() ||
              frame.postRender(() => {
                const _ = g.getStack();
                (!_ || !_.members.length) && this.safeToRemove();
              }))),
      null
    );
  }
  componentDidUpdate() {
    const { projection: e } = this.props.visualElement;
    e &&
      (e.root.didUpdate(),
      microtask.postRender(() => {
        !e.currentAnimation && e.isLead() && this.safeToRemove();
      }));
  }
  componentWillUnmount() {
    const {
        visualElement: e,
        layoutGroup: o,
        switchLayoutGroup: a,
      } = this.props,
      { projection: c } = e;
    c &&
      (c.scheduleCheckAfterUnmount(),
      o && o.group && o.group.remove(c),
      a && a.deregister && a.deregister(c));
  }
  safeToRemove() {
    const { safeToRemove: e } = this.props;
    e && e();
  }
  render() {
    return null;
  }
}
function MeasureLayout(s) {
  const [e, o] = usePresence(),
    a = reactExports$1.useContext(LayoutGroupContext);
  return jsxRuntimeExports.jsx(MeasureLayoutWithContext, {
    ...s,
    layoutGroup: a,
    switchLayoutGroup: reactExports$1.useContext(SwitchLayoutGroupContext),
    isPresent: e,
    safeToRemove: o,
  });
}
const defaultScaleCorrectors = {
    borderRadius: {
      ...correctBorderRadius,
      applyTo: [
        "borderTopLeftRadius",
        "borderTopRightRadius",
        "borderBottomLeftRadius",
        "borderBottomRightRadius",
      ],
    },
    borderTopLeftRadius: correctBorderRadius,
    borderTopRightRadius: correctBorderRadius,
    borderBottomLeftRadius: correctBorderRadius,
    borderBottomRightRadius: correctBorderRadius,
    boxShadow: correctBoxShadow,
  },
  borders = ["TopLeft", "TopRight", "BottomLeft", "BottomRight"],
  numBorders = borders.length,
  asNumber = (s) => (typeof s == "string" ? parseFloat(s) : s),
  isPx = (s) => typeof s == "number" || px$1.test(s);
function mixValues(s, e, o, a, c, d) {
  c
    ? ((s.opacity = mixNumber$1(
        0,
        o.opacity !== void 0 ? o.opacity : 1,
        easeCrossfadeIn(a)
      )),
      (s.opacityExit = mixNumber$1(
        e.opacity !== void 0 ? e.opacity : 1,
        0,
        easeCrossfadeOut(a)
      )))
    : d &&
      (s.opacity = mixNumber$1(
        e.opacity !== void 0 ? e.opacity : 1,
        o.opacity !== void 0 ? o.opacity : 1,
        a
      ));
  for (let g = 0; g < numBorders; g++) {
    const _ = `border${borders[g]}Radius`;
    let b = getRadius(e, _),
      j = getRadius(o, _);
    if (b === void 0 && j === void 0) continue;
    b || (b = 0),
      j || (j = 0),
      b === 0 || j === 0 || isPx(b) === isPx(j)
        ? ((s[_] = Math.max(mixNumber$1(asNumber(b), asNumber(j), a), 0)),
          (percent.test(j) || percent.test(b)) && (s[_] += "%"))
        : (s[_] = j);
  }
  (e.rotate || o.rotate) &&
    (s.rotate = mixNumber$1(e.rotate || 0, o.rotate || 0, a));
}
function getRadius(s, e) {
  return s[e] !== void 0 ? s[e] : s.borderRadius;
}
const easeCrossfadeIn = compress(0, 0.5, circOut),
  easeCrossfadeOut = compress(0.5, 0.95, noop);
function compress(s, e, o) {
  return (a) => (a < s ? 0 : a > e ? 1 : o(progress(s, e, a)));
}
function copyAxisInto(s, e) {
  (s.min = e.min), (s.max = e.max);
}
function copyBoxInto(s, e) {
  copyAxisInto(s.x, e.x), copyAxisInto(s.y, e.y);
}
function copyAxisDeltaInto(s, e) {
  (s.translate = e.translate),
    (s.scale = e.scale),
    (s.originPoint = e.originPoint),
    (s.origin = e.origin);
}
function removePointDelta(s, e, o, a, c) {
  return (
    (s -= e),
    (s = scalePoint(s, 1 / o, a)),
    c !== void 0 && (s = scalePoint(s, 1 / c, a)),
    s
  );
}
function removeAxisDelta(s, e = 0, o = 1, a = 0.5, c, d = s, g = s) {
  if (
    (percent.test(e) &&
      ((e = parseFloat(e)), (e = mixNumber$1(g.min, g.max, e / 100) - g.min)),
    typeof e != "number")
  )
    return;
  let _ = mixNumber$1(d.min, d.max, a);
  s === d && (_ -= e),
    (s.min = removePointDelta(s.min, e, o, _, c)),
    (s.max = removePointDelta(s.max, e, o, _, c));
}
function removeAxisTransforms(s, e, [o, a, c], d, g) {
  removeAxisDelta(s, e[o], e[a], e[c], e.scale, d, g);
}
const xKeys = ["x", "scaleX", "originX"],
  yKeys = ["y", "scaleY", "originY"];
function removeBoxTransforms(s, e, o, a) {
  removeAxisTransforms(s.x, e, xKeys, o ? o.x : void 0, a ? a.x : void 0),
    removeAxisTransforms(s.y, e, yKeys, o ? o.y : void 0, a ? a.y : void 0);
}
function isAxisDeltaZero(s) {
  return s.translate === 0 && s.scale === 1;
}
function isDeltaZero(s) {
  return isAxisDeltaZero(s.x) && isAxisDeltaZero(s.y);
}
function axisEquals(s, e) {
  return s.min === e.min && s.max === e.max;
}
function boxEquals(s, e) {
  return axisEquals(s.x, e.x) && axisEquals(s.y, e.y);
}
function axisEqualsRounded(s, e) {
  return (
    Math.round(s.min) === Math.round(e.min) &&
    Math.round(s.max) === Math.round(e.max)
  );
}
function boxEqualsRounded(s, e) {
  return axisEqualsRounded(s.x, e.x) && axisEqualsRounded(s.y, e.y);
}
function aspectRatio(s) {
  return calcLength(s.x) / calcLength(s.y);
}
function axisDeltaEquals(s, e) {
  return (
    s.translate === e.translate &&
    s.scale === e.scale &&
    s.originPoint === e.originPoint
  );
}
class NodeStack {
  constructor() {
    this.members = [];
  }
  add(e) {
    addUniqueItem(this.members, e), e.scheduleRender();
  }
  remove(e) {
    if (
      (removeItem(this.members, e),
      e === this.prevLead && (this.prevLead = void 0),
      e === this.lead)
    ) {
      const o = this.members[this.members.length - 1];
      o && this.promote(o);
    }
  }
  relegate(e) {
    const o = this.members.findIndex((c) => e === c);
    if (o === 0) return !1;
    let a;
    for (let c = o; c >= 0; c--) {
      const d = this.members[c];
      if (d.isPresent !== !1) {
        a = d;
        break;
      }
    }
    return a ? (this.promote(a), !0) : !1;
  }
  promote(e, o) {
    const a = this.lead;
    if (e !== a && ((this.prevLead = a), (this.lead = e), e.show(), a)) {
      a.instance && a.scheduleRender(),
        e.scheduleRender(),
        (e.resumeFrom = a),
        o && (e.resumeFrom.preserveOpacity = !0),
        a.snapshot &&
          ((e.snapshot = a.snapshot),
          (e.snapshot.latestValues = a.animationValues || a.latestValues)),
        e.root && e.root.isUpdating && (e.isLayoutDirty = !0);
      const { crossfade: c } = e.options;
      c === !1 && a.hide();
    }
  }
  exitAnimationComplete() {
    this.members.forEach((e) => {
      const { options: o, resumingFrom: a } = e;
      o.onExitComplete && o.onExitComplete(),
        a && a.options.onExitComplete && a.options.onExitComplete();
    });
  }
  scheduleRender() {
    this.members.forEach((e) => {
      e.instance && e.scheduleRender(!1);
    });
  }
  removeLeadSnapshot() {
    this.lead && this.lead.snapshot && (this.lead.snapshot = void 0);
  }
}
function buildProjectionTransform(s, e, o) {
  let a = "";
  const c = s.x.translate / e.x,
    d = s.y.translate / e.y,
    g = (o == null ? void 0 : o.z) || 0;
  if (
    ((c || d || g) && (a = `translate3d(${c}px, ${d}px, ${g}px) `),
    (e.x !== 1 || e.y !== 1) && (a += `scale(${1 / e.x}, ${1 / e.y}) `),
    o)
  ) {
    const {
      transformPerspective: j,
      rotate: $,
      rotateX: _e,
      rotateY: et,
      skewX: rt,
      skewY: st,
    } = o;
    j && (a = `perspective(${j}px) ${a}`),
      $ && (a += `rotate(${$}deg) `),
      _e && (a += `rotateX(${_e}deg) `),
      et && (a += `rotateY(${et}deg) `),
      rt && (a += `skewX(${rt}deg) `),
      st && (a += `skewY(${st}deg) `);
  }
  const _ = s.x.scale * e.x,
    b = s.y.scale * e.y;
  return (_ !== 1 || b !== 1) && (a += `scale(${_}, ${b})`), a || "none";
}
const compareByDepth = (s, e) => s.depth - e.depth;
class FlatTree {
  constructor() {
    (this.children = []), (this.isDirty = !1);
  }
  add(e) {
    addUniqueItem(this.children, e), (this.isDirty = !0);
  }
  remove(e) {
    removeItem(this.children, e), (this.isDirty = !0);
  }
  forEach(e) {
    this.isDirty && this.children.sort(compareByDepth),
      (this.isDirty = !1),
      this.children.forEach(e);
  }
}
function delay(s, e) {
  const o = time.now(),
    a = ({ timestamp: c }) => {
      const d = c - o;
      d >= e && (cancelFrame(a), s(d - e));
    };
  return frame.read(a, !0), () => cancelFrame(a);
}
function isSVGElement(s) {
  return s instanceof SVGElement && s.tagName !== "svg";
}
function animateSingleValue(s, e, o) {
  const a = isMotionValue(s) ? s : motionValue(s);
  return a.start(animateMotionValue("", a, e, o)), a.animation;
}
const metrics = {
    type: "projectionFrame",
    totalNodes: 0,
    resolvedTargetDeltas: 0,
    recalculatedProjection: 0,
  },
  isDebug = typeof window < "u" && window.MotionDebug !== void 0,
  transformAxes = ["", "X", "Y", "Z"],
  hiddenVisibility = { visibility: "hidden" },
  animationTarget = 1e3;
let id = 0;
function resetDistortingTransform(s, e, o, a) {
  const { latestValues: c } = e;
  c[s] && ((o[s] = c[s]), e.setStaticValue(s, 0), a && (a[s] = 0));
}
function isOptimisedAppearTree(s) {
  if (((s.hasCheckedOptimisedAppear = !0), s.root === s)) return !1;
  const { visualElement: e } = s.options;
  return e
    ? getOptimisedAppearId(e)
      ? !0
      : s.parent && !s.parent.hasCheckedOptimisedAppear
      ? isOptimisedAppearTree(s.parent)
      : !1
    : !1;
}
function createProjectionNode({
  attachResizeListener: s,
  defaultParent: e,
  measureScroll: o,
  checkIsScrollRoot: a,
  resetTransform: c,
}) {
  return class {
    constructor(g = {}, _ = e == null ? void 0 : e()) {
      (this.id = id++),
        (this.animationId = 0),
        (this.children = new Set()),
        (this.options = {}),
        (this.isTreeAnimating = !1),
        (this.isAnimationBlocked = !1),
        (this.isLayoutDirty = !1),
        (this.isProjectionDirty = !1),
        (this.isSharedProjectionDirty = !1),
        (this.isTransformDirty = !1),
        (this.updateManuallyBlocked = !1),
        (this.updateBlockedByResize = !1),
        (this.isUpdating = !1),
        (this.isSVG = !1),
        (this.needsReset = !1),
        (this.shouldResetTransform = !1),
        (this.hasCheckedOptimisedAppear = !1),
        (this.treeScale = { x: 1, y: 1 }),
        (this.eventHandlers = new Map()),
        (this.hasTreeAnimated = !1),
        (this.updateScheduled = !1),
        (this.scheduleUpdate = () => this.update()),
        (this.projectionUpdateScheduled = !1),
        (this.checkUpdateFailed = () => {
          this.isUpdating && ((this.isUpdating = !1), this.clearAllSnapshots());
        }),
        (this.updateProjection = () => {
          (this.projectionUpdateScheduled = !1),
            isDebug &&
              (metrics.totalNodes =
                metrics.resolvedTargetDeltas =
                metrics.recalculatedProjection =
                  0),
            this.nodes.forEach(propagateDirtyNodes),
            this.nodes.forEach(resolveTargetDelta),
            this.nodes.forEach(calcProjection),
            this.nodes.forEach(cleanDirtyNodes),
            isDebug && window.MotionDebug.record(metrics);
        }),
        (this.resolvedRelativeTargetAt = 0),
        (this.hasProjected = !1),
        (this.isVisible = !0),
        (this.animationProgress = 0),
        (this.sharedNodes = new Map()),
        (this.latestValues = g),
        (this.root = _ ? _.root || _ : this),
        (this.path = _ ? [..._.path, _] : []),
        (this.parent = _),
        (this.depth = _ ? _.depth + 1 : 0);
      for (let b = 0; b < this.path.length; b++)
        this.path[b].shouldResetTransform = !0;
      this.root === this && (this.nodes = new FlatTree());
    }
    addEventListener(g, _) {
      return (
        this.eventHandlers.has(g) ||
          this.eventHandlers.set(g, new SubscriptionManager()),
        this.eventHandlers.get(g).add(_)
      );
    }
    notifyListeners(g, ..._) {
      const b = this.eventHandlers.get(g);
      b && b.notify(..._);
    }
    hasListeners(g) {
      return this.eventHandlers.has(g);
    }
    mount(g, _ = this.root.hasTreeAnimated) {
      if (this.instance) return;
      (this.isSVG = isSVGElement(g)), (this.instance = g);
      const { layoutId: b, layout: j, visualElement: $ } = this.options;
      if (
        ($ && !$.current && $.mount(g),
        this.root.nodes.add(this),
        this.parent && this.parent.children.add(this),
        _ && (j || b) && (this.isLayoutDirty = !0),
        s)
      ) {
        let _e;
        const et = () => (this.root.updateBlockedByResize = !1);
        s(g, () => {
          (this.root.updateBlockedByResize = !0),
            _e && _e(),
            (_e = delay(et, 250)),
            globalProjectionState.hasAnimatedSinceResize &&
              ((globalProjectionState.hasAnimatedSinceResize = !1),
              this.nodes.forEach(finishAnimation));
        });
      }
      b && this.root.registerSharedNode(b, this),
        this.options.animate !== !1 &&
          $ &&
          (b || j) &&
          this.addEventListener(
            "didUpdate",
            ({
              delta: _e,
              hasLayoutChanged: et,
              hasRelativeTargetChanged: rt,
              layout: st,
            }) => {
              if (this.isTreeAnimationBlocked()) {
                (this.target = void 0), (this.relativeTarget = void 0);
                return;
              }
              const at =
                  this.options.transition ||
                  $.getDefaultTransition() ||
                  defaultLayoutTransition,
                { onLayoutAnimationStart: ct, onLayoutAnimationComplete: it } =
                  $.getProps(),
                lt =
                  !this.targetLayout ||
                  !boxEqualsRounded(this.targetLayout, st) ||
                  rt,
                ot = !et && rt;
              if (
                this.options.layoutRoot ||
                (this.resumeFrom && this.resumeFrom.instance) ||
                ot ||
                (et && (lt || !this.currentAnimation))
              ) {
                this.resumeFrom &&
                  ((this.resumingFrom = this.resumeFrom),
                  (this.resumingFrom.resumingFrom = void 0)),
                  this.setAnimationOrigin(_e, ot);
                const ut = {
                  ...getValueTransition(at, "layout"),
                  onPlay: ct,
                  onComplete: it,
                };
                ($.shouldReduceMotion || this.options.layoutRoot) &&
                  ((ut.delay = 0), (ut.type = !1)),
                  this.startAnimation(ut);
              } else
                et || finishAnimation(this),
                  this.isLead() &&
                    this.options.onExitComplete &&
                    this.options.onExitComplete();
              this.targetLayout = st;
            }
          );
    }
    unmount() {
      this.options.layoutId && this.willUpdate(), this.root.nodes.remove(this);
      const g = this.getStack();
      g && g.remove(this),
        this.parent && this.parent.children.delete(this),
        (this.instance = void 0),
        cancelFrame(this.updateProjection);
    }
    blockUpdate() {
      this.updateManuallyBlocked = !0;
    }
    unblockUpdate() {
      this.updateManuallyBlocked = !1;
    }
    isUpdateBlocked() {
      return this.updateManuallyBlocked || this.updateBlockedByResize;
    }
    isTreeAnimationBlocked() {
      return (
        this.isAnimationBlocked ||
        (this.parent && this.parent.isTreeAnimationBlocked()) ||
        !1
      );
    }
    startUpdate() {
      this.isUpdateBlocked() ||
        ((this.isUpdating = !0),
        this.nodes && this.nodes.forEach(resetSkewAndRotation),
        this.animationId++);
    }
    getTransformTemplate() {
      const { visualElement: g } = this.options;
      return g && g.getProps().transformTemplate;
    }
    willUpdate(g = !0) {
      if (((this.root.hasTreeAnimated = !0), this.root.isUpdateBlocked())) {
        this.options.onExitComplete && this.options.onExitComplete();
        return;
      }
      if (
        (window.HandoffCancelAllAnimations &&
          isOptimisedAppearTree(this) &&
          window.HandoffCancelAllAnimations(),
        !this.root.isUpdating && this.root.startUpdate(),
        this.isLayoutDirty)
      )
        return;
      this.isLayoutDirty = !0;
      for (let $ = 0; $ < this.path.length; $++) {
        const _e = this.path[$];
        (_e.shouldResetTransform = !0),
          _e.updateScroll("snapshot"),
          _e.options.layoutRoot && _e.willUpdate(!1);
      }
      const { layoutId: _, layout: b } = this.options;
      if (_ === void 0 && !b) return;
      const j = this.getTransformTemplate();
      (this.prevTransformTemplateValue = j ? j(this.latestValues, "") : void 0),
        this.updateSnapshot(),
        g && this.notifyListeners("willUpdate");
    }
    update() {
      if (((this.updateScheduled = !1), this.isUpdateBlocked())) {
        this.unblockUpdate(),
          this.clearAllSnapshots(),
          this.nodes.forEach(clearMeasurements);
        return;
      }
      this.isUpdating || this.nodes.forEach(clearIsLayoutDirty),
        (this.isUpdating = !1),
        this.nodes.forEach(resetTransformStyle),
        this.nodes.forEach(updateLayout),
        this.nodes.forEach(notifyLayoutUpdate),
        this.clearAllSnapshots();
      const _ = time.now();
      (frameData.delta = clamp$1(0, 1e3 / 60, _ - frameData.timestamp)),
        (frameData.timestamp = _),
        (frameData.isProcessing = !0),
        steps.update.process(frameData),
        steps.preRender.process(frameData),
        steps.render.process(frameData),
        (frameData.isProcessing = !1);
    }
    didUpdate() {
      this.updateScheduled ||
        ((this.updateScheduled = !0), microtask.read(this.scheduleUpdate));
    }
    clearAllSnapshots() {
      this.nodes.forEach(clearSnapshot),
        this.sharedNodes.forEach(removeLeadSnapshots);
    }
    scheduleUpdateProjection() {
      this.projectionUpdateScheduled ||
        ((this.projectionUpdateScheduled = !0),
        frame.preRender(this.updateProjection, !1, !0));
    }
    scheduleCheckAfterUnmount() {
      frame.postRender(() => {
        this.isLayoutDirty
          ? this.root.didUpdate()
          : this.root.checkUpdateFailed();
      });
    }
    updateSnapshot() {
      this.snapshot || !this.instance || (this.snapshot = this.measure());
    }
    updateLayout() {
      if (
        !this.instance ||
        (this.updateScroll(),
        !(this.options.alwaysMeasureLayout && this.isLead()) &&
          !this.isLayoutDirty)
      )
        return;
      if (this.resumeFrom && !this.resumeFrom.instance)
        for (let b = 0; b < this.path.length; b++) this.path[b].updateScroll();
      const g = this.layout;
      (this.layout = this.measure(!1)),
        (this.layoutCorrected = createBox()),
        (this.isLayoutDirty = !1),
        (this.projectionDelta = void 0),
        this.notifyListeners("measure", this.layout.layoutBox);
      const { visualElement: _ } = this.options;
      _ &&
        _.notify(
          "LayoutMeasure",
          this.layout.layoutBox,
          g ? g.layoutBox : void 0
        );
    }
    updateScroll(g = "measure") {
      let _ = !!(this.options.layoutScroll && this.instance);
      if (
        (this.scroll &&
          this.scroll.animationId === this.root.animationId &&
          this.scroll.phase === g &&
          (_ = !1),
        _)
      ) {
        const b = a(this.instance);
        this.scroll = {
          animationId: this.root.animationId,
          phase: g,
          isRoot: b,
          offset: o(this.instance),
          wasRoot: this.scroll ? this.scroll.isRoot : b,
        };
      }
    }
    resetTransform() {
      if (!c) return;
      const g =
          this.isLayoutDirty ||
          this.shouldResetTransform ||
          this.options.alwaysMeasureLayout,
        _ = this.projectionDelta && !isDeltaZero(this.projectionDelta),
        b = this.getTransformTemplate(),
        j = b ? b(this.latestValues, "") : void 0,
        $ = j !== this.prevTransformTemplateValue;
      g &&
        (_ || hasTransform(this.latestValues) || $) &&
        (c(this.instance, j),
        (this.shouldResetTransform = !1),
        this.scheduleRender());
    }
    measure(g = !0) {
      const _ = this.measurePageBox();
      let b = this.removeElementScroll(_);
      return (
        g && (b = this.removeTransform(b)),
        roundBox(b),
        {
          animationId: this.root.animationId,
          measuredBox: _,
          layoutBox: b,
          latestValues: {},
          source: this.id,
        }
      );
    }
    measurePageBox() {
      var g;
      const { visualElement: _ } = this.options;
      if (!_) return createBox();
      const b = _.measureViewportBox();
      if (
        !(
          ((g = this.scroll) === null || g === void 0 ? void 0 : g.wasRoot) ||
          this.path.some(checkNodeWasScrollRoot)
        )
      ) {
        const { scroll: $ } = this.root;
        $ && (translateAxis(b.x, $.offset.x), translateAxis(b.y, $.offset.y));
      }
      return b;
    }
    removeElementScroll(g) {
      var _;
      const b = createBox();
      if (
        (copyBoxInto(b, g),
        !((_ = this.scroll) === null || _ === void 0) && _.wasRoot)
      )
        return b;
      for (let j = 0; j < this.path.length; j++) {
        const $ = this.path[j],
          { scroll: _e, options: et } = $;
        $ !== this.root &&
          _e &&
          et.layoutScroll &&
          (_e.wasRoot && copyBoxInto(b, g),
          translateAxis(b.x, _e.offset.x),
          translateAxis(b.y, _e.offset.y));
      }
      return b;
    }
    applyTransform(g, _ = !1) {
      const b = createBox();
      copyBoxInto(b, g);
      for (let j = 0; j < this.path.length; j++) {
        const $ = this.path[j];
        !_ &&
          $.options.layoutScroll &&
          $.scroll &&
          $ !== $.root &&
          transformBox(b, { x: -$.scroll.offset.x, y: -$.scroll.offset.y }),
          hasTransform($.latestValues) && transformBox(b, $.latestValues);
      }
      return (
        hasTransform(this.latestValues) && transformBox(b, this.latestValues), b
      );
    }
    removeTransform(g) {
      const _ = createBox();
      copyBoxInto(_, g);
      for (let b = 0; b < this.path.length; b++) {
        const j = this.path[b];
        if (!j.instance || !hasTransform(j.latestValues)) continue;
        hasScale(j.latestValues) && j.updateSnapshot();
        const $ = createBox(),
          _e = j.measurePageBox();
        copyBoxInto($, _e),
          removeBoxTransforms(
            _,
            j.latestValues,
            j.snapshot ? j.snapshot.layoutBox : void 0,
            $
          );
      }
      return (
        hasTransform(this.latestValues) &&
          removeBoxTransforms(_, this.latestValues),
        _
      );
    }
    setTargetDelta(g) {
      (this.targetDelta = g),
        this.root.scheduleUpdateProjection(),
        (this.isProjectionDirty = !0);
    }
    setOptions(g) {
      this.options = {
        ...this.options,
        ...g,
        crossfade: g.crossfade !== void 0 ? g.crossfade : !0,
      };
    }
    clearMeasurements() {
      (this.scroll = void 0),
        (this.layout = void 0),
        (this.snapshot = void 0),
        (this.prevTransformTemplateValue = void 0),
        (this.targetDelta = void 0),
        (this.target = void 0),
        (this.isLayoutDirty = !1);
    }
    forceRelativeParentToResolveTarget() {
      this.relativeParent &&
        this.relativeParent.resolvedRelativeTargetAt !== frameData.timestamp &&
        this.relativeParent.resolveTargetDelta(!0);
    }
    resolveTargetDelta(g = !1) {
      var _;
      const b = this.getLead();
      this.isProjectionDirty || (this.isProjectionDirty = b.isProjectionDirty),
        this.isTransformDirty || (this.isTransformDirty = b.isTransformDirty),
        this.isSharedProjectionDirty ||
          (this.isSharedProjectionDirty = b.isSharedProjectionDirty);
      const j = !!this.resumingFrom || this !== b;
      if (
        !(
          g ||
          (j && this.isSharedProjectionDirty) ||
          this.isProjectionDirty ||
          (!((_ = this.parent) === null || _ === void 0) &&
            _.isProjectionDirty) ||
          this.attemptToResolveRelativeTarget ||
          this.root.updateBlockedByResize
        )
      )
        return;
      const { layout: _e, layoutId: et } = this.options;
      if (!(!this.layout || !(_e || et))) {
        if (
          ((this.resolvedRelativeTargetAt = frameData.timestamp),
          !this.targetDelta && !this.relativeTarget)
        ) {
          const rt = this.getClosestProjectingParent();
          rt && rt.layout && this.animationProgress !== 1
            ? ((this.relativeParent = rt),
              this.forceRelativeParentToResolveTarget(),
              (this.relativeTarget = createBox()),
              (this.relativeTargetOrigin = createBox()),
              calcRelativePosition(
                this.relativeTargetOrigin,
                this.layout.layoutBox,
                rt.layout.layoutBox
              ),
              copyBoxInto(this.relativeTarget, this.relativeTargetOrigin))
            : (this.relativeParent = this.relativeTarget = void 0);
        }
        if (!(!this.relativeTarget && !this.targetDelta)) {
          if (
            (this.target ||
              ((this.target = createBox()),
              (this.targetWithTransforms = createBox())),
            this.relativeTarget &&
            this.relativeTargetOrigin &&
            this.relativeParent &&
            this.relativeParent.target
              ? (this.forceRelativeParentToResolveTarget(),
                calcRelativeBox(
                  this.target,
                  this.relativeTarget,
                  this.relativeParent.target
                ))
              : this.targetDelta
              ? (this.resumingFrom
                  ? (this.target = this.applyTransform(this.layout.layoutBox))
                  : copyBoxInto(this.target, this.layout.layoutBox),
                applyBoxDelta(this.target, this.targetDelta))
              : copyBoxInto(this.target, this.layout.layoutBox),
            this.attemptToResolveRelativeTarget)
          ) {
            this.attemptToResolveRelativeTarget = !1;
            const rt = this.getClosestProjectingParent();
            rt &&
            !!rt.resumingFrom == !!this.resumingFrom &&
            !rt.options.layoutScroll &&
            rt.target &&
            this.animationProgress !== 1
              ? ((this.relativeParent = rt),
                this.forceRelativeParentToResolveTarget(),
                (this.relativeTarget = createBox()),
                (this.relativeTargetOrigin = createBox()),
                calcRelativePosition(
                  this.relativeTargetOrigin,
                  this.target,
                  rt.target
                ),
                copyBoxInto(this.relativeTarget, this.relativeTargetOrigin))
              : (this.relativeParent = this.relativeTarget = void 0);
          }
          isDebug && metrics.resolvedTargetDeltas++;
        }
      }
    }
    getClosestProjectingParent() {
      if (
        !(
          !this.parent ||
          hasScale(this.parent.latestValues) ||
          has2DTranslate(this.parent.latestValues)
        )
      )
        return this.parent.isProjecting()
          ? this.parent
          : this.parent.getClosestProjectingParent();
    }
    isProjecting() {
      return !!(
        (this.relativeTarget || this.targetDelta || this.options.layoutRoot) &&
        this.layout
      );
    }
    calcProjection() {
      var g;
      const _ = this.getLead(),
        b = !!this.resumingFrom || this !== _;
      let j = !0;
      if (
        ((this.isProjectionDirty ||
          (!((g = this.parent) === null || g === void 0) &&
            g.isProjectionDirty)) &&
          (j = !1),
        b &&
          (this.isSharedProjectionDirty || this.isTransformDirty) &&
          (j = !1),
        this.resolvedRelativeTargetAt === frameData.timestamp && (j = !1),
        j)
      )
        return;
      const { layout: $, layoutId: _e } = this.options;
      if (
        ((this.isTreeAnimating = !!(
          (this.parent && this.parent.isTreeAnimating) ||
          this.currentAnimation ||
          this.pendingAnimation
        )),
        this.isTreeAnimating ||
          (this.targetDelta = this.relativeTarget = void 0),
        !this.layout || !($ || _e))
      )
        return;
      copyBoxInto(this.layoutCorrected, this.layout.layoutBox);
      const et = this.treeScale.x,
        rt = this.treeScale.y;
      applyTreeDeltas(this.layoutCorrected, this.treeScale, this.path, b),
        _.layout &&
          !_.target &&
          (this.treeScale.x !== 1 || this.treeScale.y !== 1) &&
          ((_.target = _.layout.layoutBox),
          (_.targetWithTransforms = createBox()));
      const { target: st } = _;
      if (!st) {
        this.prevProjectionDelta &&
          (this.createProjectionDeltas(), this.scheduleRender());
        return;
      }
      !this.projectionDelta || !this.prevProjectionDelta
        ? this.createProjectionDeltas()
        : (copyAxisDeltaInto(
            this.prevProjectionDelta.x,
            this.projectionDelta.x
          ),
          copyAxisDeltaInto(
            this.prevProjectionDelta.y,
            this.projectionDelta.y
          )),
        calcBoxDelta(
          this.projectionDelta,
          this.layoutCorrected,
          st,
          this.latestValues
        ),
        (this.treeScale.x !== et ||
          this.treeScale.y !== rt ||
          !axisDeltaEquals(
            this.projectionDelta.x,
            this.prevProjectionDelta.x
          ) ||
          !axisDeltaEquals(
            this.projectionDelta.y,
            this.prevProjectionDelta.y
          )) &&
          ((this.hasProjected = !0),
          this.scheduleRender(),
          this.notifyListeners("projectionUpdate", st)),
        isDebug && metrics.recalculatedProjection++;
    }
    hide() {
      this.isVisible = !1;
    }
    show() {
      this.isVisible = !0;
    }
    scheduleRender(g = !0) {
      var _;
      if (
        ((_ = this.options.visualElement) === null ||
          _ === void 0 ||
          _.scheduleRender(),
        g)
      ) {
        const b = this.getStack();
        b && b.scheduleRender();
      }
      this.resumingFrom &&
        !this.resumingFrom.instance &&
        (this.resumingFrom = void 0);
    }
    createProjectionDeltas() {
      (this.prevProjectionDelta = createDelta()),
        (this.projectionDelta = createDelta()),
        (this.projectionDeltaWithTransform = createDelta());
    }
    setAnimationOrigin(g, _ = !1) {
      const b = this.snapshot,
        j = b ? b.latestValues : {},
        $ = { ...this.latestValues },
        _e = createDelta();
      (!this.relativeParent || !this.relativeParent.options.layoutRoot) &&
        (this.relativeTarget = this.relativeTargetOrigin = void 0),
        (this.attemptToResolveRelativeTarget = !_);
      const et = createBox(),
        rt = b ? b.source : void 0,
        st = this.layout ? this.layout.source : void 0,
        at = rt !== st,
        ct = this.getStack(),
        it = !ct || ct.members.length <= 1,
        lt = !!(
          at &&
          !it &&
          this.options.crossfade === !0 &&
          !this.path.some(hasOpacityCrossfade)
        );
      this.animationProgress = 0;
      let ot;
      (this.mixTargetDelta = (ut) => {
        const pt = ut / 1e3;
        mixAxisDelta(_e.x, g.x, pt),
          mixAxisDelta(_e.y, g.y, pt),
          this.setTargetDelta(_e),
          this.relativeTarget &&
            this.relativeTargetOrigin &&
            this.layout &&
            this.relativeParent &&
            this.relativeParent.layout &&
            (calcRelativePosition(
              et,
              this.layout.layoutBox,
              this.relativeParent.layout.layoutBox
            ),
            mixBox(this.relativeTarget, this.relativeTargetOrigin, et, pt),
            ot &&
              boxEquals(this.relativeTarget, ot) &&
              (this.isProjectionDirty = !1),
            ot || (ot = createBox()),
            copyBoxInto(ot, this.relativeTarget)),
          at &&
            ((this.animationValues = $),
            mixValues($, j, this.latestValues, pt, lt, it)),
          this.root.scheduleUpdateProjection(),
          this.scheduleRender(),
          (this.animationProgress = pt);
      }),
        this.mixTargetDelta(this.options.layoutRoot ? 1e3 : 0);
    }
    startAnimation(g) {
      this.notifyListeners("animationStart"),
        this.currentAnimation && this.currentAnimation.stop(),
        this.resumingFrom &&
          this.resumingFrom.currentAnimation &&
          this.resumingFrom.currentAnimation.stop(),
        this.pendingAnimation &&
          (cancelFrame(this.pendingAnimation),
          (this.pendingAnimation = void 0)),
        (this.pendingAnimation = frame.update(() => {
          (globalProjectionState.hasAnimatedSinceResize = !0),
            (this.currentAnimation = animateSingleValue(0, animationTarget, {
              ...g,
              onUpdate: (_) => {
                this.mixTargetDelta(_), g.onUpdate && g.onUpdate(_);
              },
              onComplete: () => {
                g.onComplete && g.onComplete(), this.completeAnimation();
              },
            })),
            this.resumingFrom &&
              (this.resumingFrom.currentAnimation = this.currentAnimation),
            (this.pendingAnimation = void 0);
        }));
    }
    completeAnimation() {
      this.resumingFrom &&
        ((this.resumingFrom.currentAnimation = void 0),
        (this.resumingFrom.preserveOpacity = void 0));
      const g = this.getStack();
      g && g.exitAnimationComplete(),
        (this.resumingFrom =
          this.currentAnimation =
          this.animationValues =
            void 0),
        this.notifyListeners("animationComplete");
    }
    finishAnimation() {
      this.currentAnimation &&
        (this.mixTargetDelta && this.mixTargetDelta(animationTarget),
        this.currentAnimation.stop()),
        this.completeAnimation();
    }
    applyTransformsToTarget() {
      const g = this.getLead();
      let {
        targetWithTransforms: _,
        target: b,
        layout: j,
        latestValues: $,
      } = g;
      if (!(!_ || !b || !j)) {
        if (
          this !== g &&
          this.layout &&
          j &&
          shouldAnimatePositionOnly(
            this.options.animationType,
            this.layout.layoutBox,
            j.layoutBox
          )
        ) {
          b = this.target || createBox();
          const _e = calcLength(this.layout.layoutBox.x);
          (b.x.min = g.target.x.min), (b.x.max = b.x.min + _e);
          const et = calcLength(this.layout.layoutBox.y);
          (b.y.min = g.target.y.min), (b.y.max = b.y.min + et);
        }
        copyBoxInto(_, b),
          transformBox(_, $),
          calcBoxDelta(
            this.projectionDeltaWithTransform,
            this.layoutCorrected,
            _,
            $
          );
      }
    }
    registerSharedNode(g, _) {
      this.sharedNodes.has(g) || this.sharedNodes.set(g, new NodeStack()),
        this.sharedNodes.get(g).add(_);
      const j = _.options.initialPromotionConfig;
      _.promote({
        transition: j ? j.transition : void 0,
        preserveFollowOpacity:
          j && j.shouldPreserveFollowOpacity
            ? j.shouldPreserveFollowOpacity(_)
            : void 0,
      });
    }
    isLead() {
      const g = this.getStack();
      return g ? g.lead === this : !0;
    }
    getLead() {
      var g;
      const { layoutId: _ } = this.options;
      return _
        ? ((g = this.getStack()) === null || g === void 0 ? void 0 : g.lead) ||
            this
        : this;
    }
    getPrevLead() {
      var g;
      const { layoutId: _ } = this.options;
      return _
        ? (g = this.getStack()) === null || g === void 0
          ? void 0
          : g.prevLead
        : void 0;
    }
    getStack() {
      const { layoutId: g } = this.options;
      if (g) return this.root.sharedNodes.get(g);
    }
    promote({ needsReset: g, transition: _, preserveFollowOpacity: b } = {}) {
      const j = this.getStack();
      j && j.promote(this, b),
        g && ((this.projectionDelta = void 0), (this.needsReset = !0)),
        _ && this.setOptions({ transition: _ });
    }
    relegate() {
      const g = this.getStack();
      return g ? g.relegate(this) : !1;
    }
    resetSkewAndRotation() {
      const { visualElement: g } = this.options;
      if (!g) return;
      let _ = !1;
      const { latestValues: b } = g;
      if (
        ((b.z ||
          b.rotate ||
          b.rotateX ||
          b.rotateY ||
          b.rotateZ ||
          b.skewX ||
          b.skewY) &&
          (_ = !0),
        !_)
      )
        return;
      const j = {};
      b.z && resetDistortingTransform("z", g, j, this.animationValues);
      for (let $ = 0; $ < transformAxes.length; $++)
        resetDistortingTransform(
          `rotate${transformAxes[$]}`,
          g,
          j,
          this.animationValues
        ),
          resetDistortingTransform(
            `skew${transformAxes[$]}`,
            g,
            j,
            this.animationValues
          );
      g.render();
      for (const $ in j)
        g.setStaticValue($, j[$]),
          this.animationValues && (this.animationValues[$] = j[$]);
      g.scheduleRender();
    }
    getProjectionStyles(g) {
      var _, b;
      if (!this.instance || this.isSVG) return;
      if (!this.isVisible) return hiddenVisibility;
      const j = { visibility: "" },
        $ = this.getTransformTemplate();
      if (this.needsReset)
        return (
          (this.needsReset = !1),
          (j.opacity = ""),
          (j.pointerEvents =
            resolveMotionValue(g == null ? void 0 : g.pointerEvents) || ""),
          (j.transform = $ ? $(this.latestValues, "") : "none"),
          j
        );
      const _e = this.getLead();
      if (!this.projectionDelta || !this.layout || !_e.target) {
        const at = {};
        return (
          this.options.layoutId &&
            ((at.opacity =
              this.latestValues.opacity !== void 0
                ? this.latestValues.opacity
                : 1),
            (at.pointerEvents =
              resolveMotionValue(g == null ? void 0 : g.pointerEvents) || "")),
          this.hasProjected &&
            !hasTransform(this.latestValues) &&
            ((at.transform = $ ? $({}, "") : "none"), (this.hasProjected = !1)),
          at
        );
      }
      const et = _e.animationValues || _e.latestValues;
      this.applyTransformsToTarget(),
        (j.transform = buildProjectionTransform(
          this.projectionDeltaWithTransform,
          this.treeScale,
          et
        )),
        $ && (j.transform = $(et, j.transform));
      const { x: rt, y: st } = this.projectionDelta;
      (j.transformOrigin = `${rt.origin * 100}% ${st.origin * 100}% 0`),
        _e.animationValues
          ? (j.opacity =
              _e === this
                ? (b =
                    (_ = et.opacity) !== null && _ !== void 0
                      ? _
                      : this.latestValues.opacity) !== null && b !== void 0
                  ? b
                  : 1
                : this.preserveOpacity
                ? this.latestValues.opacity
                : et.opacityExit)
          : (j.opacity =
              _e === this
                ? et.opacity !== void 0
                  ? et.opacity
                  : ""
                : et.opacityExit !== void 0
                ? et.opacityExit
                : 0);
      for (const at in scaleCorrectors) {
        if (et[at] === void 0) continue;
        const { correct: ct, applyTo: it } = scaleCorrectors[at],
          lt = j.transform === "none" ? et[at] : ct(et[at], _e);
        if (it) {
          const ot = it.length;
          for (let ut = 0; ut < ot; ut++) j[it[ut]] = lt;
        } else j[at] = lt;
      }
      return (
        this.options.layoutId &&
          (j.pointerEvents =
            _e === this
              ? resolveMotionValue(g == null ? void 0 : g.pointerEvents) || ""
              : "none"),
        j
      );
    }
    clearSnapshot() {
      this.resumeFrom = this.snapshot = void 0;
    }
    resetTree() {
      this.root.nodes.forEach((g) => {
        var _;
        return (_ = g.currentAnimation) === null || _ === void 0
          ? void 0
          : _.stop();
      }),
        this.root.nodes.forEach(clearMeasurements),
        this.root.sharedNodes.clear();
    }
  };
}
function updateLayout(s) {
  s.updateLayout();
}
function notifyLayoutUpdate(s) {
  var e;
  const o =
    ((e = s.resumeFrom) === null || e === void 0 ? void 0 : e.snapshot) ||
    s.snapshot;
  if (s.isLead() && s.layout && o && s.hasListeners("didUpdate")) {
    const { layoutBox: a, measuredBox: c } = s.layout,
      { animationType: d } = s.options,
      g = o.source !== s.layout.source;
    d === "size"
      ? eachAxis((_e) => {
          const et = g ? o.measuredBox[_e] : o.layoutBox[_e],
            rt = calcLength(et);
          (et.min = a[_e].min), (et.max = et.min + rt);
        })
      : shouldAnimatePositionOnly(d, o.layoutBox, a) &&
        eachAxis((_e) => {
          const et = g ? o.measuredBox[_e] : o.layoutBox[_e],
            rt = calcLength(a[_e]);
          (et.max = et.min + rt),
            s.relativeTarget &&
              !s.currentAnimation &&
              ((s.isProjectionDirty = !0),
              (s.relativeTarget[_e].max = s.relativeTarget[_e].min + rt));
        });
    const _ = createDelta();
    calcBoxDelta(_, a, o.layoutBox);
    const b = createDelta();
    g
      ? calcBoxDelta(b, s.applyTransform(c, !0), o.measuredBox)
      : calcBoxDelta(b, a, o.layoutBox);
    const j = !isDeltaZero(_);
    let $ = !1;
    if (!s.resumeFrom) {
      const _e = s.getClosestProjectingParent();
      if (_e && !_e.resumeFrom) {
        const { snapshot: et, layout: rt } = _e;
        if (et && rt) {
          const st = createBox();
          calcRelativePosition(st, o.layoutBox, et.layoutBox);
          const at = createBox();
          calcRelativePosition(at, a, rt.layoutBox),
            boxEqualsRounded(st, at) || ($ = !0),
            _e.options.layoutRoot &&
              ((s.relativeTarget = at),
              (s.relativeTargetOrigin = st),
              (s.relativeParent = _e));
        }
      }
    }
    s.notifyListeners("didUpdate", {
      layout: a,
      snapshot: o,
      delta: b,
      layoutDelta: _,
      hasLayoutChanged: j,
      hasRelativeTargetChanged: $,
    });
  } else if (s.isLead()) {
    const { onExitComplete: a } = s.options;
    a && a();
  }
  s.options.transition = void 0;
}
function propagateDirtyNodes(s) {
  isDebug && metrics.totalNodes++,
    s.parent &&
      (s.isProjecting() || (s.isProjectionDirty = s.parent.isProjectionDirty),
      s.isSharedProjectionDirty ||
        (s.isSharedProjectionDirty = !!(
          s.isProjectionDirty ||
          s.parent.isProjectionDirty ||
          s.parent.isSharedProjectionDirty
        )),
      s.isTransformDirty || (s.isTransformDirty = s.parent.isTransformDirty));
}
function cleanDirtyNodes(s) {
  s.isProjectionDirty = s.isSharedProjectionDirty = s.isTransformDirty = !1;
}
function clearSnapshot(s) {
  s.clearSnapshot();
}
function clearMeasurements(s) {
  s.clearMeasurements();
}
function clearIsLayoutDirty(s) {
  s.isLayoutDirty = !1;
}
function resetTransformStyle(s) {
  const { visualElement: e } = s.options;
  e && e.getProps().onBeforeLayoutMeasure && e.notify("BeforeLayoutMeasure"),
    s.resetTransform();
}
function finishAnimation(s) {
  s.finishAnimation(),
    (s.targetDelta = s.relativeTarget = s.target = void 0),
    (s.isProjectionDirty = !0);
}
function resolveTargetDelta(s) {
  s.resolveTargetDelta();
}
function calcProjection(s) {
  s.calcProjection();
}
function resetSkewAndRotation(s) {
  s.resetSkewAndRotation();
}
function removeLeadSnapshots(s) {
  s.removeLeadSnapshot();
}
function mixAxisDelta(s, e, o) {
  (s.translate = mixNumber$1(e.translate, 0, o)),
    (s.scale = mixNumber$1(e.scale, 1, o)),
    (s.origin = e.origin),
    (s.originPoint = e.originPoint);
}
function mixAxis(s, e, o, a) {
  (s.min = mixNumber$1(e.min, o.min, a)),
    (s.max = mixNumber$1(e.max, o.max, a));
}
function mixBox(s, e, o, a) {
  mixAxis(s.x, e.x, o.x, a), mixAxis(s.y, e.y, o.y, a);
}
function hasOpacityCrossfade(s) {
  return s.animationValues && s.animationValues.opacityExit !== void 0;
}
const defaultLayoutTransition = { duration: 0.45, ease: [0.4, 0, 0.1, 1] },
  userAgentContains = (s) =>
    typeof navigator < "u" &&
    navigator.userAgent &&
    navigator.userAgent.toLowerCase().includes(s),
  roundPoint =
    userAgentContains("applewebkit/") && !userAgentContains("chrome/")
      ? Math.round
      : noop;
function roundAxis(s) {
  (s.min = roundPoint(s.min)), (s.max = roundPoint(s.max));
}
function roundBox(s) {
  roundAxis(s.x), roundAxis(s.y);
}
function shouldAnimatePositionOnly(s, e, o) {
  return (
    s === "position" ||
    (s === "preserve-aspect" && !isNear(aspectRatio(e), aspectRatio(o), 0.2))
  );
}
function checkNodeWasScrollRoot(s) {
  var e;
  return (
    s !== s.root &&
    ((e = s.scroll) === null || e === void 0 ? void 0 : e.wasRoot)
  );
}
const DocumentProjectionNode = createProjectionNode({
    attachResizeListener: (s, e) => addDomEvent(s, "resize", e),
    measureScroll: () => ({
      x: document.documentElement.scrollLeft || document.body.scrollLeft,
      y: document.documentElement.scrollTop || document.body.scrollTop,
    }),
    checkIsScrollRoot: () => !0,
  }),
  rootProjectionNode = { current: void 0 },
  HTMLProjectionNode = createProjectionNode({
    measureScroll: (s) => ({ x: s.scrollLeft, y: s.scrollTop }),
    defaultParent: () => {
      if (!rootProjectionNode.current) {
        const s = new DocumentProjectionNode({});
        s.mount(window),
          s.setOptions({ layoutScroll: !0 }),
          (rootProjectionNode.current = s);
      }
      return rootProjectionNode.current;
    },
    resetTransform: (s, e) => {
      s.style.transform = e !== void 0 ? e : "none";
    },
    checkIsScrollRoot: (s) => window.getComputedStyle(s).position === "fixed",
  }),
  drag = {
    pan: { Feature: PanGesture },
    drag: {
      Feature: DragGesture,
      ProjectionNode: HTMLProjectionNode,
      MeasureLayout,
    },
  },
  prefersReducedMotion = { current: null },
  hasReducedMotionListener = { current: !1 };
function initPrefersReducedMotion() {
  if (((hasReducedMotionListener.current = !0), !!isBrowser$1))
    if (window.matchMedia) {
      const s = window.matchMedia("(prefers-reduced-motion)"),
        e = () => (prefersReducedMotion.current = s.matches);
      s.addListener(e), e();
    } else prefersReducedMotion.current = !1;
}
function updateMotionValuesFromProps(s, e, o) {
  for (const a in e) {
    const c = e[a],
      d = o[a];
    if (isMotionValue(c)) s.addValue(a, c);
    else if (isMotionValue(d)) s.addValue(a, motionValue(c, { owner: s }));
    else if (d !== c)
      if (s.hasValue(a)) {
        const g = s.getValue(a);
        g.liveStyle === !0 ? g.jump(c) : g.hasAnimated || g.set(c);
      } else {
        const g = s.getStaticValue(a);
        s.addValue(a, motionValue(g !== void 0 ? g : c, { owner: s }));
      }
  }
  for (const a in o) e[a] === void 0 && s.removeValue(a);
  return e;
}
const visualElementStore = new WeakMap(),
  valueTypes = [...dimensionValueTypes, color, complex],
  findValueType = (s) => valueTypes.find(testValueType(s)),
  propEventHandlers = [
    "AnimationStart",
    "AnimationComplete",
    "Update",
    "BeforeLayoutMeasure",
    "LayoutMeasure",
    "LayoutAnimationStart",
    "LayoutAnimationComplete",
  ],
  numVariantProps = variantProps.length;
class VisualElement {
  scrapeMotionValuesFromProps(e, o, a) {
    return {};
  }
  constructor(
    {
      parent: e,
      props: o,
      presenceContext: a,
      reducedMotionConfig: c,
      blockInitialAnimation: d,
      visualState: g,
    },
    _ = {}
  ) {
    (this.applyWillChange = !1),
      (this.resolveKeyframes = (et, rt, st, at) =>
        new this.KeyframeResolver(et, rt, st, at, this)),
      (this.current = null),
      (this.children = new Set()),
      (this.isVariantNode = !1),
      (this.isControllingVariants = !1),
      (this.shouldReduceMotion = null),
      (this.values = new Map()),
      (this.KeyframeResolver = KeyframeResolver),
      (this.features = {}),
      (this.valueSubscriptions = new Map()),
      (this.prevMotionValues = {}),
      (this.events = {}),
      (this.propEventSubscriptions = {}),
      (this.notifyUpdate = () => this.notify("Update", this.latestValues)),
      (this.render = () => {
        (this.isRenderScheduled = !1),
          this.current &&
            (this.triggerBuild(),
            this.renderInstance(
              this.current,
              this.renderState,
              this.props.style,
              this.projection
            ));
      }),
      (this.isRenderScheduled = !1),
      (this.scheduleRender = () => {
        this.isRenderScheduled ||
          ((this.isRenderScheduled = !0), frame.render(this.render, !1, !0));
      });
    const { latestValues: b, renderState: j } = g;
    (this.latestValues = b),
      (this.baseTarget = { ...b }),
      (this.initialValues = o.initial ? { ...b } : {}),
      (this.renderState = j),
      (this.parent = e),
      (this.props = o),
      (this.presenceContext = a),
      (this.depth = e ? e.depth + 1 : 0),
      (this.reducedMotionConfig = c),
      (this.options = _),
      (this.blockInitialAnimation = !!d),
      (this.isControllingVariants = isControllingVariants(o)),
      (this.isVariantNode = isVariantNode(o)),
      this.isVariantNode && (this.variantChildren = new Set()),
      (this.manuallyAnimateOnMount = !!(e && e.current));
    const { willChange: $, ..._e } = this.scrapeMotionValuesFromProps(
      o,
      {},
      this
    );
    for (const et in _e) {
      const rt = _e[et];
      b[et] !== void 0 && isMotionValue(rt) && rt.set(b[et], !1);
    }
  }
  mount(e) {
    (this.current = e),
      visualElementStore.set(e, this),
      this.projection && !this.projection.instance && this.projection.mount(e),
      this.parent &&
        this.isVariantNode &&
        !this.isControllingVariants &&
        (this.removeFromVariantTree = this.parent.addVariantChild(this)),
      this.values.forEach((o, a) => this.bindToMotionValue(a, o)),
      hasReducedMotionListener.current || initPrefersReducedMotion(),
      (this.shouldReduceMotion =
        this.reducedMotionConfig === "never"
          ? !1
          : this.reducedMotionConfig === "always"
          ? !0
          : prefersReducedMotion.current),
      this.parent && this.parent.children.add(this),
      this.update(this.props, this.presenceContext);
  }
  unmount() {
    visualElementStore.delete(this.current),
      this.projection && this.projection.unmount(),
      cancelFrame(this.notifyUpdate),
      cancelFrame(this.render),
      this.valueSubscriptions.forEach((e) => e()),
      this.removeFromVariantTree && this.removeFromVariantTree(),
      this.parent && this.parent.children.delete(this);
    for (const e in this.events) this.events[e].clear();
    for (const e in this.features) {
      const o = this.features[e];
      o && (o.unmount(), (o.isMounted = !1));
    }
    this.current = null;
  }
  bindToMotionValue(e, o) {
    const a = transformProps.has(e),
      c = o.on("change", (g) => {
        (this.latestValues[e] = g),
          this.props.onUpdate && frame.preRender(this.notifyUpdate),
          a && this.projection && (this.projection.isTransformDirty = !0);
      }),
      d = o.on("renderRequest", this.scheduleRender);
    this.valueSubscriptions.set(e, () => {
      c(), d(), o.owner && o.stop();
    });
  }
  sortNodePosition(e) {
    return !this.current ||
      !this.sortInstanceNodePosition ||
      this.type !== e.type
      ? 0
      : this.sortInstanceNodePosition(this.current, e.current);
  }
  updateFeatures() {
    let e = "animation";
    for (e in featureDefinitions) {
      const o = featureDefinitions[e];
      if (!o) continue;
      const { isEnabled: a, Feature: c } = o;
      if (
        (!this.features[e] &&
          c &&
          a(this.props) &&
          (this.features[e] = new c(this)),
        this.features[e])
      ) {
        const d = this.features[e];
        d.isMounted ? d.update() : (d.mount(), (d.isMounted = !0));
      }
    }
  }
  triggerBuild() {
    this.build(this.renderState, this.latestValues, this.props);
  }
  measureViewportBox() {
    return this.current
      ? this.measureInstanceViewportBox(this.current, this.props)
      : createBox();
  }
  getStaticValue(e) {
    return this.latestValues[e];
  }
  setStaticValue(e, o) {
    this.latestValues[e] = o;
  }
  update(e, o) {
    (e.transformTemplate || this.props.transformTemplate) &&
      this.scheduleRender(),
      (this.prevProps = this.props),
      (this.props = e),
      (this.prevPresenceContext = this.presenceContext),
      (this.presenceContext = o);
    for (let a = 0; a < propEventHandlers.length; a++) {
      const c = propEventHandlers[a];
      this.propEventSubscriptions[c] &&
        (this.propEventSubscriptions[c](),
        delete this.propEventSubscriptions[c]);
      const d = "on" + c,
        g = e[d];
      g && (this.propEventSubscriptions[c] = this.on(c, g));
    }
    (this.prevMotionValues = updateMotionValuesFromProps(
      this,
      this.scrapeMotionValuesFromProps(e, this.prevProps, this),
      this.prevMotionValues
    )),
      this.handleChildMotionValue && this.handleChildMotionValue();
  }
  getProps() {
    return this.props;
  }
  getVariant(e) {
    return this.props.variants ? this.props.variants[e] : void 0;
  }
  getDefaultTransition() {
    return this.props.transition;
  }
  getTransformPagePoint() {
    return this.props.transformPagePoint;
  }
  getClosestVariantNode() {
    return this.isVariantNode
      ? this
      : this.parent
      ? this.parent.getClosestVariantNode()
      : void 0;
  }
  getVariantContext(e = !1) {
    if (e) return this.parent ? this.parent.getVariantContext() : void 0;
    if (!this.isControllingVariants) {
      const a = this.parent ? this.parent.getVariantContext() || {} : {};
      return (
        this.props.initial !== void 0 && (a.initial = this.props.initial), a
      );
    }
    const o = {};
    for (let a = 0; a < numVariantProps; a++) {
      const c = variantProps[a],
        d = this.props[c];
      (isVariantLabel(d) || d === !1) && (o[c] = d);
    }
    return o;
  }
  addVariantChild(e) {
    const o = this.getClosestVariantNode();
    if (o)
      return (
        o.variantChildren && o.variantChildren.add(e),
        () => o.variantChildren.delete(e)
      );
  }
  addValue(e, o) {
    const a = this.values.get(e);
    o !== a &&
      (a && this.removeValue(e),
      this.bindToMotionValue(e, o),
      this.values.set(e, o),
      (this.latestValues[e] = o.get()));
  }
  removeValue(e) {
    this.values.delete(e);
    const o = this.valueSubscriptions.get(e);
    o && (o(), this.valueSubscriptions.delete(e)),
      delete this.latestValues[e],
      this.removeValueFromRenderState(e, this.renderState);
  }
  hasValue(e) {
    return this.values.has(e);
  }
  getValue(e, o) {
    if (this.props.values && this.props.values[e]) return this.props.values[e];
    let a = this.values.get(e);
    return (
      a === void 0 &&
        o !== void 0 &&
        ((a = motionValue(o === null ? void 0 : o, { owner: this })),
        this.addValue(e, a)),
      a
    );
  }
  readValue(e, o) {
    var a;
    let c =
      this.latestValues[e] !== void 0 || !this.current
        ? this.latestValues[e]
        : (a = this.getBaseTargetFromProps(this.props, e)) !== null &&
          a !== void 0
        ? a
        : this.readValueFromInstance(this.current, e, this.options);
    return (
      c != null &&
        (typeof c == "string" && (isNumericalString(c) || isZeroValueString(c))
          ? (c = parseFloat(c))
          : !findValueType(c) &&
            complex.test(o) &&
            (c = getAnimatableNone(e, o)),
        this.setBaseTarget(e, isMotionValue(c) ? c.get() : c)),
      isMotionValue(c) ? c.get() : c
    );
  }
  setBaseTarget(e, o) {
    this.baseTarget[e] = o;
  }
  getBaseTarget(e) {
    var o;
    const { initial: a } = this.props;
    let c;
    if (typeof a == "string" || typeof a == "object") {
      const g = resolveVariantFromProps(
        this.props,
        a,
        (o = this.presenceContext) === null || o === void 0 ? void 0 : o.custom
      );
      g && (c = g[e]);
    }
    if (a && c !== void 0) return c;
    const d = this.getBaseTargetFromProps(this.props, e);
    return d !== void 0 && !isMotionValue(d)
      ? d
      : this.initialValues[e] !== void 0 && c === void 0
      ? void 0
      : this.baseTarget[e];
  }
  on(e, o) {
    return (
      this.events[e] || (this.events[e] = new SubscriptionManager()),
      this.events[e].add(o)
    );
  }
  notify(e, ...o) {
    this.events[e] && this.events[e].notify(...o);
  }
}
class DOMVisualElement extends VisualElement {
  constructor() {
    super(...arguments), (this.KeyframeResolver = DOMKeyframesResolver);
  }
  sortInstanceNodePosition(e, o) {
    return e.compareDocumentPosition(o) & 2 ? 1 : -1;
  }
  getBaseTargetFromProps(e, o) {
    return e.style ? e.style[o] : void 0;
  }
  removeValueFromRenderState(e, { vars: o, style: a }) {
    delete o[e], delete a[e];
  }
}
function getComputedStyle(s) {
  return window.getComputedStyle(s);
}
class HTMLVisualElement extends DOMVisualElement {
  constructor() {
    super(...arguments),
      (this.type = "html"),
      (this.applyWillChange = !0),
      (this.renderInstance = renderHTML);
  }
  readValueFromInstance(e, o) {
    if (transformProps.has(o)) {
      const a = getDefaultValueType(o);
      return (a && a.default) || 0;
    } else {
      const a = getComputedStyle(e),
        c = (isCSSVariableName(o) ? a.getPropertyValue(o) : a[o]) || 0;
      return typeof c == "string" ? c.trim() : c;
    }
  }
  measureInstanceViewportBox(e, { transformPagePoint: o }) {
    return measureViewportBox(e, o);
  }
  build(e, o, a) {
    buildHTMLStyles(e, o, a.transformTemplate);
  }
  scrapeMotionValuesFromProps(e, o, a) {
    return scrapeMotionValuesFromProps$1(e, o, a);
  }
  handleChildMotionValue() {
    this.childSubscription &&
      (this.childSubscription(), delete this.childSubscription);
    const { children: e } = this.props;
    isMotionValue(e) &&
      (this.childSubscription = e.on("change", (o) => {
        this.current && (this.current.textContent = `${o}`);
      }));
  }
}
class SVGVisualElement extends DOMVisualElement {
  constructor() {
    super(...arguments),
      (this.type = "svg"),
      (this.isSVGTag = !1),
      (this.measureInstanceViewportBox = createBox);
  }
  getBaseTargetFromProps(e, o) {
    return e[o];
  }
  readValueFromInstance(e, o) {
    if (transformProps.has(o)) {
      const a = getDefaultValueType(o);
      return (a && a.default) || 0;
    }
    return (
      (o = camelCaseAttributes.has(o) ? o : camelToDash(o)), e.getAttribute(o)
    );
  }
  scrapeMotionValuesFromProps(e, o, a) {
    return scrapeMotionValuesFromProps(e, o, a);
  }
  build(e, o, a) {
    buildSVGAttrs(e, o, this.isSVGTag, a.transformTemplate);
  }
  renderInstance(e, o, a, c) {
    renderSVG(e, o, a, c);
  }
  mount(e) {
    (this.isSVGTag = isSVGTag(e.tagName)), super.mount(e);
  }
}
const createDomVisualElement = (s, e) =>
    isSVGComponent(s)
      ? new SVGVisualElement(e)
      : new HTMLVisualElement(e, {
          allowProjection: s !== reactExports$1.Fragment,
        }),
  layout = { layout: { ProjectionNode: HTMLProjectionNode, MeasureLayout } },
  preloadedFeatures = {
    ...animations,
    ...gestureAnimations,
    ...drag,
    ...layout,
  },
  motion = createMotionProxy((s, e) =>
    createDomMotionConfig(s, e, preloadedFeatures, createDomVisualElement)
  );
function resolveElements(s, e, o) {
  return (
    typeof s == "string"
      ? (s = document.querySelectorAll(s))
      : s instanceof Element && (s = [s]),
    Array.from(s || [])
  );
}
function stopAnimation(s) {
  s.values.forEach((e) => e.stop());
}
function setVariants(s, e) {
  [...e].reverse().forEach((a) => {
    const c = s.getVariant(a);
    c && setTarget(s, c),
      s.variantChildren &&
        s.variantChildren.forEach((d) => {
          setVariants(d, e);
        });
  });
}
function setValues(s, e) {
  if (Array.isArray(e)) return setVariants(s, e);
  if (typeof e == "string") return setVariants(s, [e]);
  setTarget(s, e);
}
function animationControls() {
  const s = new Set(),
    e = {
      subscribe(o) {
        return s.add(o), () => void s.delete(o);
      },
      start(o, a) {
        const c = [];
        return (
          s.forEach((d) => {
            c.push(animateVisualElement(d, o, { transitionOverride: a }));
          }),
          Promise.all(c)
        );
      },
      set(o) {
        return s.forEach((a) => {
          setValues(a, o);
        });
      },
      stop() {
        s.forEach((o) => {
          stopAnimation(o);
        });
      },
      mount() {
        return () => {
          e.stop();
        };
      },
    };
  return e;
}
function useAnimationControls() {
  const s = useConstant(animationControls);
  return useIsomorphicLayoutEffect$3(s.mount, []), s;
}
const useAnimation = useAnimationControls,
  thresholds = { some: 0, all: 1 };
function inView(s, e, { root: o, margin: a, amount: c = "some" } = {}) {
  const d = resolveElements(s),
    g = new WeakMap(),
    _ = (j) => {
      j.forEach(($) => {
        const _e = g.get($.target);
        if ($.isIntersecting !== !!_e)
          if ($.isIntersecting) {
            const et = e($);
            typeof et == "function"
              ? g.set($.target, et)
              : b.unobserve($.target);
          } else _e && (_e($), g.delete($.target));
      });
    },
    b = new IntersectionObserver(_, {
      root: o,
      rootMargin: a,
      threshold: typeof c == "number" ? c : thresholds[c],
    });
  return d.forEach((j) => b.observe(j)), () => b.disconnect();
}
function useInView(s, { root: e, margin: o, amount: a, once: c = !1 } = {}) {
  const [d, g] = reactExports$1.useState(!1);
  return (
    reactExports$1.useEffect(() => {
      if (!s.current || (c && d)) return;
      const _ = () => (g(!0), c ? void 0 : () => g(!1)),
        b = { root: (e && e.current) || void 0, margin: o, amount: a };
      return inView(s.current, _, b);
    }, [e, s, o, c, a]),
    d
  );
}
/**
 * @remix-run/router v1.18.0
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */ function _extends$4() {
  return (
    (_extends$4 = Object.assign
      ? Object.assign.bind()
      : function (s) {
          for (var e = 1; e < arguments.length; e++) {
            var o = arguments[e];
            for (var a in o)
              Object.prototype.hasOwnProperty.call(o, a) && (s[a] = o[a]);
          }
          return s;
        }),
    _extends$4.apply(this, arguments)
  );
}
var Action;
(function (s) {
  (s.Pop = "POP"), (s.Push = "PUSH"), (s.Replace = "REPLACE");
})(Action || (Action = {}));
const PopStateEventType = "popstate";
function createHashHistory(s) {
  s === void 0 && (s = {});
  function e(c, d) {
    let {
      pathname: g = "/",
      search: _ = "",
      hash: b = "",
    } = parsePath(c.location.hash.substr(1));
    return (
      !g.startsWith("/") && !g.startsWith(".") && (g = "/" + g),
      createLocation(
        "",
        { pathname: g, search: _, hash: b },
        (d.state && d.state.usr) || null,
        (d.state && d.state.key) || "default"
      )
    );
  }
  function o(c, d) {
    let g = c.document.querySelector("base"),
      _ = "";
    if (g && g.getAttribute("href")) {
      let b = c.location.href,
        j = b.indexOf("#");
      _ = j === -1 ? b : b.slice(0, j);
    }
    return _ + "#" + (typeof d == "string" ? d : createPath(d));
  }
  function a(c, d) {
    warning(
      c.pathname.charAt(0) === "/",
      "relative pathnames are not supported in hash history.push(" +
        JSON.stringify(d) +
        ")"
    );
  }
  return getUrlBasedHistory(e, o, a, s);
}
function invariant(s, e) {
  if (s === !1 || s === null || typeof s > "u") throw new Error(e);
}
function warning(s, e) {
  if (!s) {
    typeof console < "u" && console.warn(e);
    try {
      throw new Error(e);
    } catch {}
  }
}
function createKey() {
  return Math.random().toString(36).substr(2, 8);
}
function getHistoryState(s, e) {
  return { usr: s.state, key: s.key, idx: e };
}
function createLocation(s, e, o, a) {
  return (
    o === void 0 && (o = null),
    _extends$4(
      { pathname: typeof s == "string" ? s : s.pathname, search: "", hash: "" },
      typeof e == "string" ? parsePath(e) : e,
      { state: o, key: (e && e.key) || a || createKey() }
    )
  );
}
function createPath(s) {
  let { pathname: e = "/", search: o = "", hash: a = "" } = s;
  return (
    o && o !== "?" && (e += o.charAt(0) === "?" ? o : "?" + o),
    a && a !== "#" && (e += a.charAt(0) === "#" ? a : "#" + a),
    e
  );
}
function parsePath(s) {
  let e = {};
  if (s) {
    let o = s.indexOf("#");
    o >= 0 && ((e.hash = s.substr(o)), (s = s.substr(0, o)));
    let a = s.indexOf("?");
    a >= 0 && ((e.search = s.substr(a)), (s = s.substr(0, a))),
      s && (e.pathname = s);
  }
  return e;
}
function getUrlBasedHistory(s, e, o, a) {
  a === void 0 && (a = {});
  let { window: c = document.defaultView, v5Compat: d = !1 } = a,
    g = c.history,
    _ = Action.Pop,
    b = null,
    j = $();
  j == null &&
    ((j = 0), g.replaceState(_extends$4({}, g.state, { idx: j }), ""));
  function $() {
    return (g.state || { idx: null }).idx;
  }
  function _e() {
    _ = Action.Pop;
    let ct = $(),
      it = ct == null ? null : ct - j;
    (j = ct), b && b({ action: _, location: at.location, delta: it });
  }
  function et(ct, it) {
    _ = Action.Push;
    let lt = createLocation(at.location, ct, it);
    o && o(lt, ct), (j = $() + 1);
    let ot = getHistoryState(lt, j),
      ut = at.createHref(lt);
    try {
      g.pushState(ot, "", ut);
    } catch (pt) {
      if (pt instanceof DOMException && pt.name === "DataCloneError") throw pt;
      c.location.assign(ut);
    }
    d && b && b({ action: _, location: at.location, delta: 1 });
  }
  function rt(ct, it) {
    _ = Action.Replace;
    let lt = createLocation(at.location, ct, it);
    o && o(lt, ct), (j = $());
    let ot = getHistoryState(lt, j),
      ut = at.createHref(lt);
    g.replaceState(ot, "", ut),
      d && b && b({ action: _, location: at.location, delta: 0 });
  }
  function st(ct) {
    let it = c.location.origin !== "null" ? c.location.origin : c.location.href,
      lt = typeof ct == "string" ? ct : createPath(ct);
    return (
      (lt = lt.replace(/ $/, "%20")),
      invariant(
        it,
        "No window.location.(origin|href) available to create URL for href: " +
          lt
      ),
      new URL(lt, it)
    );
  }
  let at = {
    get action() {
      return _;
    },
    get location() {
      return s(c, g);
    },
    listen(ct) {
      if (b) throw new Error("A history only accepts one active listener");
      return (
        c.addEventListener(PopStateEventType, _e),
        (b = ct),
        () => {
          c.removeEventListener(PopStateEventType, _e), (b = null);
        }
      );
    },
    createHref(ct) {
      return e(c, ct);
    },
    createURL: st,
    encodeLocation(ct) {
      let it = st(ct);
      return { pathname: it.pathname, search: it.search, hash: it.hash };
    },
    push: et,
    replace: rt,
    go(ct) {
      return g.go(ct);
    },
  };
  return at;
}
var ResultType;
(function (s) {
  (s.data = "data"),
    (s.deferred = "deferred"),
    (s.redirect = "redirect"),
    (s.error = "error");
})(ResultType || (ResultType = {}));
function matchRoutes(s, e, o) {
  return o === void 0 && (o = "/"), matchRoutesImpl(s, e, o, !1);
}
function matchRoutesImpl(s, e, o, a) {
  let c = typeof e == "string" ? parsePath(e) : e,
    d = stripBasename(c.pathname || "/", o);
  if (d == null) return null;
  let g = flattenRoutes(s);
  rankRouteBranches(g);
  let _ = null;
  for (let b = 0; _ == null && b < g.length; ++b) {
    let j = decodePath(d);
    _ = matchRouteBranch(g[b], j, a);
  }
  return _;
}
function flattenRoutes(s, e, o, a) {
  e === void 0 && (e = []), o === void 0 && (o = []), a === void 0 && (a = "");
  let c = (d, g, _) => {
    let b = {
      relativePath: _ === void 0 ? d.path || "" : _,
      caseSensitive: d.caseSensitive === !0,
      childrenIndex: g,
      route: d,
    };
    b.relativePath.startsWith("/") &&
      (invariant(
        b.relativePath.startsWith(a),
        'Absolute route path "' +
          b.relativePath +
          '" nested under path ' +
          ('"' + a + '" is not valid. An absolute child route path ') +
          "must start with the combined path of all its parent routes."
      ),
      (b.relativePath = b.relativePath.slice(a.length)));
    let j = joinPaths([a, b.relativePath]),
      $ = o.concat(b);
    d.children &&
      d.children.length > 0 &&
      (invariant(
        d.index !== !0,
        "Index routes must not have child routes. Please remove " +
          ('all child routes from route path "' + j + '".')
      ),
      flattenRoutes(d.children, e, $, j)),
      !(d.path == null && !d.index) &&
        e.push({ path: j, score: computeScore(j, d.index), routesMeta: $ });
  };
  return (
    s.forEach((d, g) => {
      var _;
      if (d.path === "" || !((_ = d.path) != null && _.includes("?"))) c(d, g);
      else for (let b of explodeOptionalSegments(d.path)) c(d, g, b);
    }),
    e
  );
}
function explodeOptionalSegments(s) {
  let e = s.split("/");
  if (e.length === 0) return [];
  let [o, ...a] = e,
    c = o.endsWith("?"),
    d = o.replace(/\?$/, "");
  if (a.length === 0) return c ? [d, ""] : [d];
  let g = explodeOptionalSegments(a.join("/")),
    _ = [];
  return (
    _.push(...g.map((b) => (b === "" ? d : [d, b].join("/")))),
    c && _.push(...g),
    _.map((b) => (s.startsWith("/") && b === "" ? "/" : b))
  );
}
function rankRouteBranches(s) {
  s.sort((e, o) =>
    e.score !== o.score
      ? o.score - e.score
      : compareIndexes(
          e.routesMeta.map((a) => a.childrenIndex),
          o.routesMeta.map((a) => a.childrenIndex)
        )
  );
}
const paramRe = /^:[\w-]+$/,
  dynamicSegmentValue = 3,
  indexRouteValue = 2,
  emptySegmentValue = 1,
  staticSegmentValue = 10,
  splatPenalty = -2,
  isSplat = (s) => s === "*";
function computeScore(s, e) {
  let o = s.split("/"),
    a = o.length;
  return (
    o.some(isSplat) && (a += splatPenalty),
    e && (a += indexRouteValue),
    o
      .filter((c) => !isSplat(c))
      .reduce(
        (c, d) =>
          c +
          (paramRe.test(d)
            ? dynamicSegmentValue
            : d === ""
            ? emptySegmentValue
            : staticSegmentValue),
        a
      )
  );
}
function compareIndexes(s, e) {
  return s.length === e.length && s.slice(0, -1).every((a, c) => a === e[c])
    ? s[s.length - 1] - e[e.length - 1]
    : 0;
}
function matchRouteBranch(s, e, o) {
  let { routesMeta: a } = s,
    c = {},
    d = "/",
    g = [];
  for (let _ = 0; _ < a.length; ++_) {
    let b = a[_],
      j = _ === a.length - 1,
      $ = d === "/" ? e : e.slice(d.length) || "/",
      _e = matchPath(
        { path: b.relativePath, caseSensitive: b.caseSensitive, end: j },
        $
      ),
      et = b.route;
    if (
      (!_e &&
        j &&
        o &&
        !a[a.length - 1].route.index &&
        (_e = matchPath(
          { path: b.relativePath, caseSensitive: b.caseSensitive, end: !1 },
          $
        )),
      !_e)
    )
      return null;
    Object.assign(c, _e.params),
      g.push({
        params: c,
        pathname: joinPaths([d, _e.pathname]),
        pathnameBase: normalizePathname(joinPaths([d, _e.pathnameBase])),
        route: et,
      }),
      _e.pathnameBase !== "/" && (d = joinPaths([d, _e.pathnameBase]));
  }
  return g;
}
function matchPath(s, e) {
  typeof s == "string" && (s = { path: s, caseSensitive: !1, end: !0 });
  let [o, a] = compilePath(s.path, s.caseSensitive, s.end),
    c = e.match(o);
  if (!c) return null;
  let d = c[0],
    g = d.replace(/(.)\/+$/, "$1"),
    _ = c.slice(1);
  return {
    params: a.reduce((j, $, _e) => {
      let { paramName: et, isOptional: rt } = $;
      if (et === "*") {
        let at = _[_e] || "";
        g = d.slice(0, d.length - at.length).replace(/(.)\/+$/, "$1");
      }
      const st = _[_e];
      return (
        rt && !st
          ? (j[et] = void 0)
          : (j[et] = (st || "").replace(/%2F/g, "/")),
        j
      );
    }, {}),
    pathname: d,
    pathnameBase: g,
    pattern: s,
  };
}
function compilePath(s, e, o) {
  e === void 0 && (e = !1),
    o === void 0 && (o = !0),
    warning(
      s === "*" || !s.endsWith("*") || s.endsWith("/*"),
      'Route path "' +
        s +
        '" will be treated as if it were ' +
        ('"' + s.replace(/\*$/, "/*") + '" because the `*` character must ') +
        "always follow a `/` in the pattern. To get rid of this warning, " +
        ('please change the route path to "' + s.replace(/\*$/, "/*") + '".')
    );
  let a = [],
    c =
      "^" +
      s
        .replace(/\/*\*?$/, "")
        .replace(/^\/*/, "/")
        .replace(/[\\.*+^${}|()[\]]/g, "\\$&")
        .replace(
          /\/:([\w-]+)(\?)?/g,
          (g, _, b) => (
            a.push({ paramName: _, isOptional: b != null }),
            b ? "/?([^\\/]+)?" : "/([^\\/]+)"
          )
        );
  return (
    s.endsWith("*")
      ? (a.push({ paramName: "*" }),
        (c += s === "*" || s === "/*" ? "(.*)$" : "(?:\\/(.+)|\\/*)$"))
      : o
      ? (c += "\\/*$")
      : s !== "" && s !== "/" && (c += "(?:(?=\\/|$))"),
    [new RegExp(c, e ? void 0 : "i"), a]
  );
}
function decodePath(s) {
  try {
    return s
      .split("/")
      .map((e) => decodeURIComponent(e).replace(/\//g, "%2F"))
      .join("/");
  } catch (e) {
    return (
      warning(
        !1,
        'The URL path "' +
          s +
          '" could not be decoded because it is is a malformed URL segment. This is probably due to a bad percent ' +
          ("encoding (" + e + ").")
      ),
      s
    );
  }
}
function stripBasename(s, e) {
  if (e === "/") return s;
  if (!s.toLowerCase().startsWith(e.toLowerCase())) return null;
  let o = e.endsWith("/") ? e.length - 1 : e.length,
    a = s.charAt(o);
  return a && a !== "/" ? null : s.slice(o) || "/";
}
function resolvePath(s, e) {
  e === void 0 && (e = "/");
  let {
    pathname: o,
    search: a = "",
    hash: c = "",
  } = typeof s == "string" ? parsePath(s) : s;
  return {
    pathname: o ? (o.startsWith("/") ? o : resolvePathname(o, e)) : e,
    search: normalizeSearch(a),
    hash: normalizeHash(c),
  };
}
function resolvePathname(s, e) {
  let o = e.replace(/\/+$/, "").split("/");
  return (
    s.split("/").forEach((c) => {
      c === ".." ? o.length > 1 && o.pop() : c !== "." && o.push(c);
    }),
    o.length > 1 ? o.join("/") : "/"
  );
}
function getInvalidPathError(s, e, o, a) {
  return (
    "Cannot include a '" +
    s +
    "' character in a manually specified " +
    ("`to." +
      e +
      "` field [" +
      JSON.stringify(a) +
      "].  Please separate it out to the ") +
    ("`to." + o + "` field. Alternatively you may provide the full path as ") +
    'a string in <Link to="..."> and the router will parse it for you.'
  );
}
function getPathContributingMatches(s) {
  return s.filter(
    (e, o) => o === 0 || (e.route.path && e.route.path.length > 0)
  );
}
function getResolveToMatches(s, e) {
  let o = getPathContributingMatches(s);
  return e
    ? o.map((a, c) => (c === o.length - 1 ? a.pathname : a.pathnameBase))
    : o.map((a) => a.pathnameBase);
}
function resolveTo(s, e, o, a) {
  a === void 0 && (a = !1);
  let c;
  typeof s == "string"
    ? (c = parsePath(s))
    : ((c = _extends$4({}, s)),
      invariant(
        !c.pathname || !c.pathname.includes("?"),
        getInvalidPathError("?", "pathname", "search", c)
      ),
      invariant(
        !c.pathname || !c.pathname.includes("#"),
        getInvalidPathError("#", "pathname", "hash", c)
      ),
      invariant(
        !c.search || !c.search.includes("#"),
        getInvalidPathError("#", "search", "hash", c)
      ));
  let d = s === "" || c.pathname === "",
    g = d ? "/" : c.pathname,
    _;
  if (g == null) _ = o;
  else {
    let _e = e.length - 1;
    if (!a && g.startsWith("..")) {
      let et = g.split("/");
      for (; et[0] === ".."; ) et.shift(), (_e -= 1);
      c.pathname = et.join("/");
    }
    _ = _e >= 0 ? e[_e] : "/";
  }
  let b = resolvePath(c, _),
    j = g && g !== "/" && g.endsWith("/"),
    $ = (d || g === ".") && o.endsWith("/");
  return !b.pathname.endsWith("/") && (j || $) && (b.pathname += "/"), b;
}
const joinPaths = (s) => s.join("/").replace(/\/\/+/g, "/"),
  normalizePathname = (s) => s.replace(/\/+$/, "").replace(/^\/*/, "/"),
  normalizeSearch = (s) =>
    !s || s === "?" ? "" : s.startsWith("?") ? s : "?" + s,
  normalizeHash = (s) =>
    !s || s === "#" ? "" : s.startsWith("#") ? s : "#" + s;
function isRouteErrorResponse(s) {
  return (
    s != null &&
    typeof s.status == "number" &&
    typeof s.statusText == "string" &&
    typeof s.internal == "boolean" &&
    "data" in s
  );
}
const validMutationMethodsArr = ["post", "put", "patch", "delete"];
new Set(validMutationMethodsArr);
const validRequestMethodsArr = ["get", ...validMutationMethodsArr];
new Set(validRequestMethodsArr);
/**
 * React Router v6.25.1
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */ function _extends$3() {
  return (
    (_extends$3 = Object.assign
      ? Object.assign.bind()
      : function (s) {
          for (var e = 1; e < arguments.length; e++) {
            var o = arguments[e];
            for (var a in o)
              Object.prototype.hasOwnProperty.call(o, a) && (s[a] = o[a]);
          }
          return s;
        }),
    _extends$3.apply(this, arguments)
  );
}
const DataRouterContext = reactExports$1.createContext(null),
  DataRouterStateContext = reactExports$1.createContext(null),
  NavigationContext = reactExports$1.createContext(null),
  LocationContext = reactExports$1.createContext(null),
  RouteContext = reactExports$1.createContext({
    outlet: null,
    matches: [],
    isDataRoute: !1,
  }),
  RouteErrorContext = reactExports$1.createContext(null);
function useHref(s, e) {
  let { relative: o } = e === void 0 ? {} : e;
  useInRouterContext() || invariant(!1);
  let { basename: a, navigator: c } =
      reactExports$1.useContext(NavigationContext),
    { hash: d, pathname: g, search: _ } = useResolvedPath(s, { relative: o }),
    b = g;
  return (
    a !== "/" && (b = g === "/" ? a : joinPaths([a, g])),
    c.createHref({ pathname: b, search: _, hash: d })
  );
}
function useInRouterContext() {
  return reactExports$1.useContext(LocationContext) != null;
}
function useLocation() {
  return (
    useInRouterContext() || invariant(!1),
    reactExports$1.useContext(LocationContext).location
  );
}
function useIsomorphicLayoutEffect$2(s) {
  reactExports$1.useContext(NavigationContext).static ||
    reactExports$1.useLayoutEffect(s);
}
function useNavigate() {
  let { isDataRoute: s } = reactExports$1.useContext(RouteContext);
  return s ? useNavigateStable() : useNavigateUnstable();
}
function useNavigateUnstable() {
  useInRouterContext() || invariant(!1);
  let s = reactExports$1.useContext(DataRouterContext),
    {
      basename: e,
      future: o,
      navigator: a,
    } = reactExports$1.useContext(NavigationContext),
    { matches: c } = reactExports$1.useContext(RouteContext),
    { pathname: d } = useLocation(),
    g = JSON.stringify(getResolveToMatches(c, o.v7_relativeSplatPath)),
    _ = reactExports$1.useRef(!1);
  return (
    useIsomorphicLayoutEffect$2(() => {
      _.current = !0;
    }),
    reactExports$1.useCallback(
      function (j, $) {
        if (($ === void 0 && ($ = {}), !_.current)) return;
        if (typeof j == "number") {
          a.go(j);
          return;
        }
        let _e = resolveTo(j, JSON.parse(g), d, $.relative === "path");
        s == null &&
          e !== "/" &&
          (_e.pathname = _e.pathname === "/" ? e : joinPaths([e, _e.pathname])),
          ($.replace ? a.replace : a.push)(_e, $.state, $);
      },
      [e, a, g, d, s]
    )
  );
}
function useResolvedPath(s, e) {
  let { relative: o } = e === void 0 ? {} : e,
    { future: a } = reactExports$1.useContext(NavigationContext),
    { matches: c } = reactExports$1.useContext(RouteContext),
    { pathname: d } = useLocation(),
    g = JSON.stringify(getResolveToMatches(c, a.v7_relativeSplatPath));
  return reactExports$1.useMemo(
    () => resolveTo(s, JSON.parse(g), d, o === "path"),
    [s, g, d, o]
  );
}
function useRoutes(s, e) {
  return useRoutesImpl(s, e);
}
function useRoutesImpl(s, e, o, a) {
  useInRouterContext() || invariant(!1);
  let { navigator: c } = reactExports$1.useContext(NavigationContext),
    { matches: d } = reactExports$1.useContext(RouteContext),
    g = d[d.length - 1],
    _ = g ? g.params : {};
  g && g.pathname;
  let b = g ? g.pathnameBase : "/";
  g && g.route;
  let j = useLocation(),
    $;
  if (e) {
    var _e;
    let ct = typeof e == "string" ? parsePath(e) : e;
    b === "/" ||
      ((_e = ct.pathname) != null && _e.startsWith(b)) ||
      invariant(!1),
      ($ = ct);
  } else $ = j;
  let et = $.pathname || "/",
    rt = et;
  if (b !== "/") {
    let ct = b.replace(/^\//, "").split("/");
    rt = "/" + et.replace(/^\//, "").split("/").slice(ct.length).join("/");
  }
  let st = matchRoutes(s, { pathname: rt }),
    at = _renderMatches(
      st &&
        st.map((ct) =>
          Object.assign({}, ct, {
            params: Object.assign({}, _, ct.params),
            pathname: joinPaths([
              b,
              c.encodeLocation
                ? c.encodeLocation(ct.pathname).pathname
                : ct.pathname,
            ]),
            pathnameBase:
              ct.pathnameBase === "/"
                ? b
                : joinPaths([
                    b,
                    c.encodeLocation
                      ? c.encodeLocation(ct.pathnameBase).pathname
                      : ct.pathnameBase,
                  ]),
          })
        ),
      d,
      o,
      a
    );
  return e && at
    ? reactExports$1.createElement(
        LocationContext.Provider,
        {
          value: {
            location: _extends$3(
              {
                pathname: "/",
                search: "",
                hash: "",
                state: null,
                key: "default",
              },
              $
            ),
            navigationType: Action.Pop,
          },
        },
        at
      )
    : at;
}
function DefaultErrorComponent() {
  let s = useRouteError(),
    e = isRouteErrorResponse(s)
      ? s.status + " " + s.statusText
      : s instanceof Error
      ? s.message
      : JSON.stringify(s),
    o = s instanceof Error ? s.stack : null,
    c = { padding: "0.5rem", backgroundColor: "rgba(200,200,200, 0.5)" };
  return reactExports$1.createElement(
    reactExports$1.Fragment,
    null,
    reactExports$1.createElement("h2", null, "Unexpected Application Error!"),
    reactExports$1.createElement("h3", { style: { fontStyle: "italic" } }, e),
    o ? reactExports$1.createElement("pre", { style: c }, o) : null,
    null
  );
}
const defaultErrorElement = reactExports$1.createElement(
  DefaultErrorComponent,
  null
);
class RenderErrorBoundary extends reactExports$1.Component {
  constructor(e) {
    super(e),
      (this.state = {
        location: e.location,
        revalidation: e.revalidation,
        error: e.error,
      });
  }
  static getDerivedStateFromError(e) {
    return { error: e };
  }
  static getDerivedStateFromProps(e, o) {
    return o.location !== e.location ||
      (o.revalidation !== "idle" && e.revalidation === "idle")
      ? { error: e.error, location: e.location, revalidation: e.revalidation }
      : {
          error: e.error !== void 0 ? e.error : o.error,
          location: o.location,
          revalidation: e.revalidation || o.revalidation,
        };
  }
  componentDidCatch(e, o) {
    console.error(
      "React Router caught the following error during render",
      e,
      o
    );
  }
  render() {
    return this.state.error !== void 0
      ? reactExports$1.createElement(
          RouteContext.Provider,
          { value: this.props.routeContext },
          reactExports$1.createElement(RouteErrorContext.Provider, {
            value: this.state.error,
            children: this.props.component,
          })
        )
      : this.props.children;
  }
}
function RenderedRoute(s) {
  let { routeContext: e, match: o, children: a } = s,
    c = reactExports$1.useContext(DataRouterContext);
  return (
    c &&
      c.static &&
      c.staticContext &&
      (o.route.errorElement || o.route.ErrorBoundary) &&
      (c.staticContext._deepestRenderedBoundaryId = o.route.id),
    reactExports$1.createElement(RouteContext.Provider, { value: e }, a)
  );
}
function _renderMatches(s, e, o, a) {
  var c;
  if (
    (e === void 0 && (e = []),
    o === void 0 && (o = null),
    a === void 0 && (a = null),
    s == null)
  ) {
    var d;
    if ((d = o) != null && d.errors) s = o.matches;
    else return null;
  }
  let g = s,
    _ = (c = o) == null ? void 0 : c.errors;
  if (_ != null) {
    let $ = g.findIndex(
      (_e) => _e.route.id && (_ == null ? void 0 : _[_e.route.id]) !== void 0
    );
    $ >= 0 || invariant(!1), (g = g.slice(0, Math.min(g.length, $ + 1)));
  }
  let b = !1,
    j = -1;
  if (o && a && a.v7_partialHydration)
    for (let $ = 0; $ < g.length; $++) {
      let _e = g[$];
      if (
        ((_e.route.HydrateFallback || _e.route.hydrateFallbackElement) &&
          (j = $),
        _e.route.id)
      ) {
        let { loaderData: et, errors: rt } = o,
          st =
            _e.route.loader &&
            et[_e.route.id] === void 0 &&
            (!rt || rt[_e.route.id] === void 0);
        if (_e.route.lazy || st) {
          (b = !0), j >= 0 ? (g = g.slice(0, j + 1)) : (g = [g[0]]);
          break;
        }
      }
    }
  return g.reduceRight(($, _e, et) => {
    let rt,
      st = !1,
      at = null,
      ct = null;
    o &&
      ((rt = _ && _e.route.id ? _[_e.route.id] : void 0),
      (at = _e.route.errorElement || defaultErrorElement),
      b &&
        (j < 0 && et === 0
          ? ((st = !0), (ct = null))
          : j === et &&
            ((st = !0), (ct = _e.route.hydrateFallbackElement || null))));
    let it = e.concat(g.slice(0, et + 1)),
      lt = () => {
        let ot;
        return (
          rt
            ? (ot = at)
            : st
            ? (ot = ct)
            : _e.route.Component
            ? (ot = reactExports$1.createElement(_e.route.Component, null))
            : _e.route.element
            ? (ot = _e.route.element)
            : (ot = $),
          reactExports$1.createElement(RenderedRoute, {
            match: _e,
            routeContext: { outlet: $, matches: it, isDataRoute: o != null },
            children: ot,
          })
        );
      };
    return o && (_e.route.ErrorBoundary || _e.route.errorElement || et === 0)
      ? reactExports$1.createElement(RenderErrorBoundary, {
          location: o.location,
          revalidation: o.revalidation,
          component: at,
          error: rt,
          children: lt(),
          routeContext: { outlet: null, matches: it, isDataRoute: !0 },
        })
      : lt();
  }, null);
}
var DataRouterHook$1 = (function (s) {
    return (
      (s.UseBlocker = "useBlocker"),
      (s.UseRevalidator = "useRevalidator"),
      (s.UseNavigateStable = "useNavigate"),
      s
    );
  })(DataRouterHook$1 || {}),
  DataRouterStateHook$1 = (function (s) {
    return (
      (s.UseBlocker = "useBlocker"),
      (s.UseLoaderData = "useLoaderData"),
      (s.UseActionData = "useActionData"),
      (s.UseRouteError = "useRouteError"),
      (s.UseNavigation = "useNavigation"),
      (s.UseRouteLoaderData = "useRouteLoaderData"),
      (s.UseMatches = "useMatches"),
      (s.UseRevalidator = "useRevalidator"),
      (s.UseNavigateStable = "useNavigate"),
      (s.UseRouteId = "useRouteId"),
      s
    );
  })(DataRouterStateHook$1 || {});
function useDataRouterContext(s) {
  let e = reactExports$1.useContext(DataRouterContext);
  return e || invariant(!1), e;
}
function useDataRouterState(s) {
  let e = reactExports$1.useContext(DataRouterStateContext);
  return e || invariant(!1), e;
}
function useRouteContext(s) {
  let e = reactExports$1.useContext(RouteContext);
  return e || invariant(!1), e;
}
function useCurrentRouteId(s) {
  let e = useRouteContext(),
    o = e.matches[e.matches.length - 1];
  return o.route.id || invariant(!1), o.route.id;
}
function useRouteError() {
  var s;
  let e = reactExports$1.useContext(RouteErrorContext),
    o = useDataRouterState(DataRouterStateHook$1.UseRouteError),
    a = useCurrentRouteId(DataRouterStateHook$1.UseRouteError);
  return e !== void 0 ? e : (s = o.errors) == null ? void 0 : s[a];
}
function useNavigateStable() {
  let { router: s } = useDataRouterContext(DataRouterHook$1.UseNavigateStable),
    e = useCurrentRouteId(DataRouterStateHook$1.UseNavigateStable),
    o = reactExports$1.useRef(!1);
  return (
    useIsomorphicLayoutEffect$2(() => {
      o.current = !0;
    }),
    reactExports$1.useCallback(
      function (c, d) {
        d === void 0 && (d = {}),
          o.current &&
            (typeof c == "number"
              ? s.navigate(c)
              : s.navigate(c, _extends$3({ fromRouteId: e }, d)));
      },
      [s, e]
    )
  );
}
function Route(s) {
  invariant(!1);
}
function Router(s) {
  let {
    basename: e = "/",
    children: o = null,
    location: a,
    navigationType: c = Action.Pop,
    navigator: d,
    static: g = !1,
    future: _,
  } = s;
  useInRouterContext() && invariant(!1);
  let b = e.replace(/^\/*/, "/"),
    j = reactExports$1.useMemo(
      () => ({
        basename: b,
        navigator: d,
        static: g,
        future: _extends$3({ v7_relativeSplatPath: !1 }, _),
      }),
      [b, _, d, g]
    );
  typeof a == "string" && (a = parsePath(a));
  let {
      pathname: $ = "/",
      search: _e = "",
      hash: et = "",
      state: rt = null,
      key: st = "default",
    } = a,
    at = reactExports$1.useMemo(() => {
      let ct = stripBasename($, b);
      return ct == null
        ? null
        : {
            location: {
              pathname: ct,
              search: _e,
              hash: et,
              state: rt,
              key: st,
            },
            navigationType: c,
          };
    }, [b, $, _e, et, rt, st, c]);
  return at == null
    ? null
    : reactExports$1.createElement(
        NavigationContext.Provider,
        { value: j },
        reactExports$1.createElement(LocationContext.Provider, {
          children: o,
          value: at,
        })
      );
}
function Routes(s) {
  let { children: e, location: o } = s;
  return useRoutes(createRoutesFromChildren(e), o);
}
new Promise(() => {});
function createRoutesFromChildren(s, e) {
  e === void 0 && (e = []);
  let o = [];
  return (
    reactExports$1.Children.forEach(s, (a, c) => {
      if (!reactExports$1.isValidElement(a)) return;
      let d = [...e, c];
      if (a.type === reactExports$1.Fragment) {
        o.push.apply(o, createRoutesFromChildren(a.props.children, d));
        return;
      }
      a.type !== Route && invariant(!1),
        !a.props.index || !a.props.children || invariant(!1);
      let g = {
        id: a.props.id || d.join("-"),
        caseSensitive: a.props.caseSensitive,
        element: a.props.element,
        Component: a.props.Component,
        index: a.props.index,
        path: a.props.path,
        loader: a.props.loader,
        action: a.props.action,
        errorElement: a.props.errorElement,
        ErrorBoundary: a.props.ErrorBoundary,
        hasErrorBoundary:
          a.props.ErrorBoundary != null || a.props.errorElement != null,
        shouldRevalidate: a.props.shouldRevalidate,
        handle: a.props.handle,
        lazy: a.props.lazy,
      };
      a.props.children &&
        (g.children = createRoutesFromChildren(a.props.children, d)),
        o.push(g);
    }),
    o
  );
}
/**
 * React Router DOM v6.25.1
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */ function _extends$2() {
  return (
    (_extends$2 = Object.assign
      ? Object.assign.bind()
      : function (s) {
          for (var e = 1; e < arguments.length; e++) {
            var o = arguments[e];
            for (var a in o)
              Object.prototype.hasOwnProperty.call(o, a) && (s[a] = o[a]);
          }
          return s;
        }),
    _extends$2.apply(this, arguments)
  );
}
function _objectWithoutPropertiesLoose$2(s, e) {
  if (s == null) return {};
  var o = {},
    a = Object.keys(s),
    c,
    d;
  for (d = 0; d < a.length; d++)
    (c = a[d]), !(e.indexOf(c) >= 0) && (o[c] = s[c]);
  return o;
}
function isModifiedEvent(s) {
  return !!(s.metaKey || s.altKey || s.ctrlKey || s.shiftKey);
}
function shouldProcessLinkClick(s, e) {
  return s.button === 0 && (!e || e === "_self") && !isModifiedEvent(s);
}
const _excluded$3 = [
    "onClick",
    "relative",
    "reloadDocument",
    "replace",
    "state",
    "target",
    "to",
    "preventScrollReset",
    "unstable_viewTransition",
  ],
  REACT_ROUTER_VERSION = "6";
try {
  window.__reactRouterVersion = REACT_ROUTER_VERSION;
} catch {}
const START_TRANSITION = "startTransition",
  startTransitionImpl = React$1[START_TRANSITION];
function HashRouter(s) {
  let { basename: e, children: o, future: a, window: c } = s,
    d = reactExports$1.useRef();
  d.current == null &&
    (d.current = createHashHistory({ window: c, v5Compat: !0 }));
  let g = d.current,
    [_, b] = reactExports$1.useState({
      action: g.action,
      location: g.location,
    }),
    { v7_startTransition: j } = a || {},
    $ = reactExports$1.useCallback(
      (_e) => {
        j && startTransitionImpl ? startTransitionImpl(() => b(_e)) : b(_e);
      },
      [b, j]
    );
  return (
    reactExports$1.useLayoutEffect(() => g.listen($), [g, $]),
    reactExports$1.createElement(Router, {
      basename: e,
      children: o,
      location: _.location,
      navigationType: _.action,
      navigator: g,
      future: a,
    })
  );
}
const isBrowser =
    typeof window < "u" &&
    typeof window.document < "u" &&
    typeof window.document.createElement < "u",
  ABSOLUTE_URL_REGEX = /^(?:[a-z][a-z0-9+.-]*:|\/\/)/i,
  Link = reactExports$1.forwardRef(function (e, o) {
    let {
        onClick: a,
        relative: c,
        reloadDocument: d,
        replace: g,
        state: _,
        target: b,
        to: j,
        preventScrollReset: $,
        unstable_viewTransition: _e,
      } = e,
      et = _objectWithoutPropertiesLoose$2(e, _excluded$3),
      { basename: rt } = reactExports$1.useContext(NavigationContext),
      st,
      at = !1;
    if (
      typeof j == "string" &&
      ABSOLUTE_URL_REGEX.test(j) &&
      ((st = j), isBrowser)
    )
      try {
        let ot = new URL(window.location.href),
          ut = j.startsWith("//") ? new URL(ot.protocol + j) : new URL(j),
          pt = stripBasename(ut.pathname, rt);
        ut.origin === ot.origin && pt != null
          ? (j = pt + ut.search + ut.hash)
          : (at = !0);
      } catch {}
    let ct = useHref(j, { relative: c }),
      it = useLinkClickHandler(j, {
        replace: g,
        state: _,
        target: b,
        preventScrollReset: $,
        relative: c,
        unstable_viewTransition: _e,
      });
    function lt(ot) {
      a && a(ot), ot.defaultPrevented || it(ot);
    }
    return reactExports$1.createElement(
      "a",
      _extends$2({}, et, {
        href: st || ct,
        onClick: at || d ? a : lt,
        ref: o,
        target: b,
      })
    );
  });
var DataRouterHook;
(function (s) {
  (s.UseScrollRestoration = "useScrollRestoration"),
    (s.UseSubmit = "useSubmit"),
    (s.UseSubmitFetcher = "useSubmitFetcher"),
    (s.UseFetcher = "useFetcher"),
    (s.useViewTransitionState = "useViewTransitionState");
})(DataRouterHook || (DataRouterHook = {}));
var DataRouterStateHook;
(function (s) {
  (s.UseFetcher = "useFetcher"),
    (s.UseFetchers = "useFetchers"),
    (s.UseScrollRestoration = "useScrollRestoration");
})(DataRouterStateHook || (DataRouterStateHook = {}));
function useLinkClickHandler(s, e) {
  let {
      target: o,
      replace: a,
      state: c,
      preventScrollReset: d,
      relative: g,
      unstable_viewTransition: _,
    } = e === void 0 ? {} : e,
    b = useNavigate(),
    j = useLocation(),
    $ = useResolvedPath(s, { relative: g });
  return reactExports$1.useCallback(
    (_e) => {
      if (shouldProcessLinkClick(_e, o)) {
        _e.preventDefault();
        let et = a !== void 0 ? a : createPath(j) === createPath($);
        b(s, {
          replace: et,
          state: c,
          preventScrollReset: d,
          relative: g,
          unstable_viewTransition: _,
        });
      }
    },
    [j, b, $, a, c, o, s, d, g, _]
  );
}
const logo = "./assets/logo-BsumD-8C.jpg";
var DefaultContext = {
    color: void 0,
    size: void 0,
    className: void 0,
    style: void 0,
    attr: void 0,
  },
  IconContext = React.createContext && React.createContext(DefaultContext),
  _excluded$2 = ["attr", "size", "title"];
function _objectWithoutProperties$1(s, e) {
  if (s == null) return {};
  var o = _objectWithoutPropertiesLoose$1(s, e),
    a,
    c;
  if (Object.getOwnPropertySymbols) {
    var d = Object.getOwnPropertySymbols(s);
    for (c = 0; c < d.length; c++)
      (a = d[c]),
        !(e.indexOf(a) >= 0) &&
          Object.prototype.propertyIsEnumerable.call(s, a) &&
          (o[a] = s[a]);
  }
  return o;
}
function _objectWithoutPropertiesLoose$1(s, e) {
  if (s == null) return {};
  var o = {};
  for (var a in s)
    if (Object.prototype.hasOwnProperty.call(s, a)) {
      if (e.indexOf(a) >= 0) continue;
      o[a] = s[a];
    }
  return o;
}
function _extends$1() {
  return (
    (_extends$1 = Object.assign
      ? Object.assign.bind()
      : function (s) {
          for (var e = 1; e < arguments.length; e++) {
            var o = arguments[e];
            for (var a in o)
              Object.prototype.hasOwnProperty.call(o, a) && (s[a] = o[a]);
          }
          return s;
        }),
    _extends$1.apply(this, arguments)
  );
}
function ownKeys$1(s, e) {
  var o = Object.keys(s);
  if (Object.getOwnPropertySymbols) {
    var a = Object.getOwnPropertySymbols(s);
    e &&
      (a = a.filter(function (c) {
        return Object.getOwnPropertyDescriptor(s, c).enumerable;
      })),
      o.push.apply(o, a);
  }
  return o;
}
function _objectSpread(s) {
  for (var e = 1; e < arguments.length; e++) {
    var o = arguments[e] != null ? arguments[e] : {};
    e % 2
      ? ownKeys$1(Object(o), !0).forEach(function (a) {
          _defineProperty$1(s, a, o[a]);
        })
      : Object.getOwnPropertyDescriptors
      ? Object.defineProperties(s, Object.getOwnPropertyDescriptors(o))
      : ownKeys$1(Object(o)).forEach(function (a) {
          Object.defineProperty(s, a, Object.getOwnPropertyDescriptor(o, a));
        });
  }
  return s;
}
function _defineProperty$1(s, e, o) {
  return (
    (e = _toPropertyKey$1(e)),
    e in s
      ? Object.defineProperty(s, e, {
          value: o,
          enumerable: !0,
          configurable: !0,
          writable: !0,
        })
      : (s[e] = o),
    s
  );
}
function _toPropertyKey$1(s) {
  var e = _toPrimitive$1(s, "string");
  return typeof e == "symbol" ? e : e + "";
}
function _toPrimitive$1(s, e) {
  if (typeof s != "object" || !s) return s;
  var o = s[Symbol.toPrimitive];
  if (o !== void 0) {
    var a = o.call(s, e || "default");
    if (typeof a != "object") return a;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (e === "string" ? String : Number)(s);
}
function Tree2Element(s) {
  return (
    s &&
    s.map((e, o) =>
      React.createElement(
        e.tag,
        _objectSpread({ key: o }, e.attr),
        Tree2Element(e.child)
      )
    )
  );
}
function GenIcon(s) {
  return (e) =>
    React.createElement(
      IconBase,
      _extends$1({ attr: _objectSpread({}, s.attr) }, e),
      Tree2Element(s.child)
    );
}
function IconBase(s) {
  var e = (o) => {
    var { attr: a, size: c, title: d } = s,
      g = _objectWithoutProperties$1(s, _excluded$2),
      _ = c || o.size || "1em",
      b;
    return (
      o.className && (b = o.className),
      s.className && (b = (b ? b + " " : "") + s.className),
      React.createElement(
        "svg",
        _extends$1(
          { stroke: "currentColor", fill: "currentColor", strokeWidth: "0" },
          o.attr,
          a,
          g,
          {
            className: b,
            style: _objectSpread(
              _objectSpread({ color: s.color || o.color }, o.style),
              s.style
            ),
            height: _,
            width: _,
            xmlns: "http://www.w3.org/2000/svg",
          }
        ),
        d && React.createElement("title", null, d),
        s.children
      )
    );
  };
  return IconContext !== void 0
    ? React.createElement(IconContext.Consumer, null, (o) => e(o))
    : e(DefaultContext);
}
const TextAnimation = ({ children: s, width: e = "fit-content" }) => {
    const o = reactExports$1.useRef(null),
      a = useInView(o, { once: !0 }),
      c = useAnimation(),
      d = useAnimation();
    return (
      reactExports$1.useEffect(() => {
        a && (c.start("visible"), d.start("visible"));
      }, [a]),
      jsxRuntimeExports.jsxs("div", {
        ref: o,
        style: { position: "relative", width: e, overflow: "hidden" },
        children: [
          jsxRuntimeExports.jsx(motion.div, {
            variants: {
              hidden: { opacity: 0, y: 75 },
              visible: { opacity: 1, y: 0 },
            },
            initial: "hidden",
            animate: c,
            transition: { duration: 0.5, delay: 0.25 },
            children: s,
          }),
          jsxRuntimeExports.jsx(motion.div, {
            variants: { hidden: { left: 0 }, visible: { left: "100%" } },
            initial: "hidden",
            animate: d,
            transition: { duration: 0.5, ease: "easeIn" },
            style: {
              position: "absolute",
              top: 4,
              bottom: 4,
              left: 0,
              right: 0,
              background: "lightskyblue",
              zIndex: 20,
              textDecoration: "none",
            },
          }),
        ],
      })
    );
  },
  CustomButtonOne = ({ text: s }) =>
    jsxRuntimeExports.jsx(Link, {
      to: "/contact",
      children: jsxRuntimeExports.jsxs("a", {
        className: "contactbutton OO oooo",
        href: "",
        children: [
          jsxRuntimeExports.jsx("span", {}),
          jsxRuntimeExports.jsx("span", {}),
          jsxRuntimeExports.jsx("span", {}),
          jsxRuntimeExports.jsx("span", {}),
          jsxRuntimeExports.jsx(TextAnimation, {
            children: jsxRuntimeExports.jsx("p", {
              className: "two",
              children: s,
            }),
          }),
        ],
      }),
    });
function RiCloseLine(s) {
  return GenIcon({
    tag: "svg",
    attr: { viewBox: "0 0 24 24", fill: "currentColor" },
    child: [
      {
        tag: "path",
        attr: {
          d: "M11.9997 10.5865L16.9495 5.63672L18.3637 7.05093L13.4139 12.0007L18.3637 16.9504L16.9495 18.3646L11.9997 13.4149L7.04996 18.3646L5.63574 16.9504L10.5855 12.0007L5.63574 7.05093L7.04996 5.63672L11.9997 10.5865Z",
        },
        child: [],
      },
    ],
  })(s);
}
function RiMenu3Line(s) {
  return GenIcon({
    tag: "svg",
    attr: { viewBox: "0 0 24 24", fill: "currentColor" },
    child: [
      {
        tag: "path",
        attr: { d: "M3 4H21V6H3V4ZM9 11H21V13H9V11ZM3 18H21V20H3V18Z" },
        child: [],
      },
    ],
  })(s);
}
function RiSearchEyeLine(s) {
  return GenIcon({
    tag: "svg",
    attr: { viewBox: "0 0 24 24", fill: "currentColor" },
    child: [
      {
        tag: "path",
        attr: {
          d: "M18.031 16.6168L22.3137 20.8995L20.8995 22.3137L16.6168 18.031C15.0769 19.263 13.124 20 11 20C6.032 20 2 15.968 2 11C2 6.032 6.032 2 11 2C15.968 2 20 6.032 20 11C20 13.124 19.263 15.0769 18.031 16.6168ZM16.0247 15.8748C17.2475 14.6146 18 12.8956 18 11C18 7.1325 14.8675 4 11 4C7.1325 4 4 7.1325 4 11C4 14.8675 7.1325 18 11 18C12.8956 18 14.6146 17.2475 15.8748 16.0247L16.0247 15.8748ZM12.1779 7.17624C11.4834 7.48982 11 8.18846 11 9C11 10.1046 11.8954 11 13 11C13.8115 11 14.5102 10.5166 14.8238 9.82212C14.9383 10.1945 15 10.59 15 11C15 13.2091 13.2091 15 11 15C8.79086 15 7 13.2091 7 11C7 8.79086 8.79086 7 11 7C11.41 7 11.8055 7.06167 12.1779 7.17624Z",
        },
        child: [],
      },
    ],
  })(s);
}
const Textasbuttom = ({ children: s }) => {
  const e = reactExports$1.useRef(null),
    o = useInView(e, { once: !0 }),
    a = useAnimation();
  return (
    reactExports$1.useEffect(() => {
      o && a.start("visible");
    }, [o]),
    jsxRuntimeExports.jsx("div", {
      ref: e,
      style: {
        position: "relative",
        display: "flex",
        width: "fit-content",
        height: "100%",
        justifyContent: "center",
        alignItems: "center",
        flexDirection: "column",
        overflow: "hidden",
      },
      children: jsxRuntimeExports.jsx(motion.div, {
        variants: {
          hidden: { opacity: 0, x: 500 },
          visible: { opacity: 1, x: 0 },
        },
        transition: { duration: 0.5, ease: "easeOut", delay: 0.4 },
        initial: "hidden",
        animate: a,
        style: {
          minWidth: "100%",
          height: "100%",
          display: "flex",
          alignItems: "center",
          justifyContent: "center",
        },
        children: s,
      }),
    })
  );
};
var lottie$1 = { exports: {} };
(function (module, exports) {
  typeof navigator < "u" &&
    (function (s, e) {
      module.exports = e();
    })(commonjsGlobal, function () {
      var svgNS = "http://www.w3.org/2000/svg",
        locationHref = "",
        _useWebWorker = !1,
        initialDefaultFrame = -999999,
        setWebWorker = function (e) {
          _useWebWorker = !!e;
        },
        getWebWorker = function () {
          return _useWebWorker;
        },
        setLocationHref = function (e) {
          locationHref = e;
        },
        getLocationHref = function () {
          return locationHref;
        };
      function createTag(s) {
        return document.createElement(s);
      }
      function extendPrototype(s, e) {
        var o,
          a = s.length,
          c;
        for (o = 0; o < a; o += 1) {
          c = s[o].prototype;
          for (var d in c)
            Object.prototype.hasOwnProperty.call(c, d) &&
              (e.prototype[d] = c[d]);
        }
      }
      function getDescriptor(s, e) {
        return Object.getOwnPropertyDescriptor(s, e);
      }
      function createProxyFunction(s) {
        function e() {}
        return (e.prototype = s), e;
      }
      var audioControllerFactory = (function () {
          function s(e) {
            (this.audios = []),
              (this.audioFactory = e),
              (this._volume = 1),
              (this._isMuted = !1);
          }
          return (
            (s.prototype = {
              addAudio: function (o) {
                this.audios.push(o);
              },
              pause: function () {
                var o,
                  a = this.audios.length;
                for (o = 0; o < a; o += 1) this.audios[o].pause();
              },
              resume: function () {
                var o,
                  a = this.audios.length;
                for (o = 0; o < a; o += 1) this.audios[o].resume();
              },
              setRate: function (o) {
                var a,
                  c = this.audios.length;
                for (a = 0; a < c; a += 1) this.audios[a].setRate(o);
              },
              createAudio: function (o) {
                return this.audioFactory
                  ? this.audioFactory(o)
                  : window.Howl
                  ? new window.Howl({ src: [o] })
                  : {
                      isPlaying: !1,
                      play: function () {
                        this.isPlaying = !0;
                      },
                      seek: function () {
                        this.isPlaying = !1;
                      },
                      playing: function () {},
                      rate: function () {},
                      setVolume: function () {},
                    };
              },
              setAudioFactory: function (o) {
                this.audioFactory = o;
              },
              setVolume: function (o) {
                (this._volume = o), this._updateVolume();
              },
              mute: function () {
                (this._isMuted = !0), this._updateVolume();
              },
              unmute: function () {
                (this._isMuted = !1), this._updateVolume();
              },
              getVolume: function () {
                return this._volume;
              },
              _updateVolume: function () {
                var o,
                  a = this.audios.length;
                for (o = 0; o < a; o += 1)
                  this.audios[o].volume(this._volume * (this._isMuted ? 0 : 1));
              },
            }),
            function () {
              return new s();
            }
          );
        })(),
        createTypedArray = (function () {
          function s(o, a) {
            var c = 0,
              d = [],
              g;
            switch (o) {
              case "int16":
              case "uint8c":
                g = 1;
                break;
              default:
                g = 1.1;
                break;
            }
            for (c = 0; c < a; c += 1) d.push(g);
            return d;
          }
          function e(o, a) {
            return o === "float32"
              ? new Float32Array(a)
              : o === "int16"
              ? new Int16Array(a)
              : o === "uint8c"
              ? new Uint8ClampedArray(a)
              : s(o, a);
          }
          return typeof Uint8ClampedArray == "function" &&
            typeof Float32Array == "function"
            ? e
            : s;
        })();
      function createSizedArray(s) {
        return Array.apply(null, { length: s });
      }
      function _typeof$6(s) {
        "@babel/helpers - typeof";
        return (
          typeof Symbol == "function" && typeof Symbol.iterator == "symbol"
            ? (_typeof$6 = function (o) {
                return typeof o;
              })
            : (_typeof$6 = function (o) {
                return o &&
                  typeof Symbol == "function" &&
                  o.constructor === Symbol &&
                  o !== Symbol.prototype
                  ? "symbol"
                  : typeof o;
              }),
          _typeof$6(s)
        );
      }
      var subframeEnabled = !0,
        expressionsPlugin = null,
        expressionsInterfaces = null,
        idPrefix$1 = "",
        isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent),
        bmPow = Math.pow,
        bmSqrt = Math.sqrt,
        bmFloor = Math.floor,
        bmMax = Math.max,
        bmMin = Math.min,
        BMMath = {};
      (function () {
        var s = [
            "abs",
            "acos",
            "acosh",
            "asin",
            "asinh",
            "atan",
            "atanh",
            "atan2",
            "ceil",
            "cbrt",
            "expm1",
            "clz32",
            "cos",
            "cosh",
            "exp",
            "floor",
            "fround",
            "hypot",
            "imul",
            "log",
            "log1p",
            "log2",
            "log10",
            "max",
            "min",
            "pow",
            "random",
            "round",
            "sign",
            "sin",
            "sinh",
            "sqrt",
            "tan",
            "tanh",
            "trunc",
            "E",
            "LN10",
            "LN2",
            "LOG10E",
            "LOG2E",
            "PI",
            "SQRT1_2",
            "SQRT2",
          ],
          e,
          o = s.length;
        for (e = 0; e < o; e += 1) BMMath[s[e]] = Math[s[e]];
      })(),
        (BMMath.random = Math.random),
        (BMMath.abs = function (s) {
          var e = _typeof$6(s);
          if (e === "object" && s.length) {
            var o = createSizedArray(s.length),
              a,
              c = s.length;
            for (a = 0; a < c; a += 1) o[a] = Math.abs(s[a]);
            return o;
          }
          return Math.abs(s);
        });
      var defaultCurveSegments = 150,
        degToRads = Math.PI / 180,
        roundCorner = 0.5519;
      function styleDiv(s) {
        (s.style.position = "absolute"),
          (s.style.top = 0),
          (s.style.left = 0),
          (s.style.display = "block"),
          (s.style.transformOrigin = "0 0"),
          (s.style.webkitTransformOrigin = "0 0"),
          (s.style.backfaceVisibility = "visible"),
          (s.style.webkitBackfaceVisibility = "visible"),
          (s.style.transformStyle = "preserve-3d"),
          (s.style.webkitTransformStyle = "preserve-3d"),
          (s.style.mozTransformStyle = "preserve-3d");
      }
      function BMEnterFrameEvent(s, e, o, a) {
        (this.type = s),
          (this.currentTime = e),
          (this.totalTime = o),
          (this.direction = a < 0 ? -1 : 1);
      }
      function BMCompleteEvent(s, e) {
        (this.type = s), (this.direction = e < 0 ? -1 : 1);
      }
      function BMCompleteLoopEvent(s, e, o, a) {
        (this.type = s),
          (this.currentLoop = o),
          (this.totalLoops = e),
          (this.direction = a < 0 ? -1 : 1);
      }
      function BMSegmentStartEvent(s, e, o) {
        (this.type = s), (this.firstFrame = e), (this.totalFrames = o);
      }
      function BMDestroyEvent(s, e) {
        (this.type = s), (this.target = e);
      }
      function BMRenderFrameErrorEvent(s, e) {
        (this.type = "renderFrameError"),
          (this.nativeError = s),
          (this.currentTime = e);
      }
      function BMConfigErrorEvent(s) {
        (this.type = "configError"), (this.nativeError = s);
      }
      var createElementID = (function () {
        var s = 0;
        return function () {
          return (s += 1), idPrefix$1 + "__lottie_element_" + s;
        };
      })();
      function HSVtoRGB(s, e, o) {
        var a, c, d, g, _, b, j, $;
        switch (
          ((g = Math.floor(s * 6)),
          (_ = s * 6 - g),
          (b = o * (1 - e)),
          (j = o * (1 - _ * e)),
          ($ = o * (1 - (1 - _) * e)),
          g % 6)
        ) {
          case 0:
            (a = o), (c = $), (d = b);
            break;
          case 1:
            (a = j), (c = o), (d = b);
            break;
          case 2:
            (a = b), (c = o), (d = $);
            break;
          case 3:
            (a = b), (c = j), (d = o);
            break;
          case 4:
            (a = $), (c = b), (d = o);
            break;
          case 5:
            (a = o), (c = b), (d = j);
            break;
        }
        return [a, c, d];
      }
      function RGBtoHSV(s, e, o) {
        var a = Math.max(s, e, o),
          c = Math.min(s, e, o),
          d = a - c,
          g,
          _ = a === 0 ? 0 : d / a,
          b = a / 255;
        switch (a) {
          case c:
            g = 0;
            break;
          case s:
            (g = e - o + d * (e < o ? 6 : 0)), (g /= 6 * d);
            break;
          case e:
            (g = o - s + d * 2), (g /= 6 * d);
            break;
          case o:
            (g = s - e + d * 4), (g /= 6 * d);
            break;
        }
        return [g, _, b];
      }
      function addSaturationToRGB(s, e) {
        var o = RGBtoHSV(s[0] * 255, s[1] * 255, s[2] * 255);
        return (
          (o[1] += e),
          o[1] > 1 ? (o[1] = 1) : o[1] <= 0 && (o[1] = 0),
          HSVtoRGB(o[0], o[1], o[2])
        );
      }
      function addBrightnessToRGB(s, e) {
        var o = RGBtoHSV(s[0] * 255, s[1] * 255, s[2] * 255);
        return (
          (o[2] += e),
          o[2] > 1 ? (o[2] = 1) : o[2] < 0 && (o[2] = 0),
          HSVtoRGB(o[0], o[1], o[2])
        );
      }
      function addHueToRGB(s, e) {
        var o = RGBtoHSV(s[0] * 255, s[1] * 255, s[2] * 255);
        return (
          (o[0] += e / 360),
          o[0] > 1 ? (o[0] -= 1) : o[0] < 0 && (o[0] += 1),
          HSVtoRGB(o[0], o[1], o[2])
        );
      }
      var rgbToHex = (function () {
          var s = [],
            e,
            o;
          for (e = 0; e < 256; e += 1)
            (o = e.toString(16)), (s[e] = o.length === 1 ? "0" + o : o);
          return function (a, c, d) {
            return (
              a < 0 && (a = 0),
              c < 0 && (c = 0),
              d < 0 && (d = 0),
              "#" + s[a] + s[c] + s[d]
            );
          };
        })(),
        setSubframeEnabled = function (e) {
          subframeEnabled = !!e;
        },
        getSubframeEnabled = function () {
          return subframeEnabled;
        },
        setExpressionsPlugin = function (e) {
          expressionsPlugin = e;
        },
        getExpressionsPlugin = function () {
          return expressionsPlugin;
        },
        setExpressionInterfaces = function (e) {
          expressionsInterfaces = e;
        },
        getExpressionInterfaces = function () {
          return expressionsInterfaces;
        },
        setDefaultCurveSegments = function (e) {
          defaultCurveSegments = e;
        },
        getDefaultCurveSegments = function () {
          return defaultCurveSegments;
        },
        setIdPrefix = function (e) {
          idPrefix$1 = e;
        };
      function createNS(s) {
        return document.createElementNS(svgNS, s);
      }
      function _typeof$5(s) {
        "@babel/helpers - typeof";
        return (
          typeof Symbol == "function" && typeof Symbol.iterator == "symbol"
            ? (_typeof$5 = function (o) {
                return typeof o;
              })
            : (_typeof$5 = function (o) {
                return o &&
                  typeof Symbol == "function" &&
                  o.constructor === Symbol &&
                  o !== Symbol.prototype
                  ? "symbol"
                  : typeof o;
              }),
          _typeof$5(s)
        );
      }
      var dataManager = (function () {
          var s = 1,
            e = [],
            o,
            a,
            c = {
              onmessage: function () {},
              postMessage: function (rt) {
                o({ data: rt });
              },
            },
            d = {
              postMessage: function (rt) {
                c.onmessage({ data: rt });
              },
            };
          function g(et) {
            if (window.Worker && window.Blob && getWebWorker()) {
              var rt = new Blob(
                  ["var _workerSelf = self; self.onmessage = ", et.toString()],
                  { type: "text/javascript" }
                ),
                st = URL.createObjectURL(rt);
              return new Worker(st);
            }
            return (o = et), c;
          }
          function _() {
            a ||
              ((a = g(function (rt) {
                function st() {
                  function ct(Lt, Et) {
                    var bt,
                      mt,
                      vt = Lt.length,
                      Ct,
                      Tt,
                      Dt,
                      Wt;
                    for (mt = 0; mt < vt; mt += 1)
                      if (((bt = Lt[mt]), "ks" in bt && !bt.completed)) {
                        if (((bt.completed = !0), bt.hasMask)) {
                          var Pt = bt.masksProperties;
                          for (Tt = Pt.length, Ct = 0; Ct < Tt; Ct += 1)
                            if (Pt[Ct].pt.k.i) pt(Pt[Ct].pt.k);
                            else
                              for (
                                Wt = Pt[Ct].pt.k.length, Dt = 0;
                                Dt < Wt;
                                Dt += 1
                              )
                                Pt[Ct].pt.k[Dt].s && pt(Pt[Ct].pt.k[Dt].s[0]),
                                  Pt[Ct].pt.k[Dt].e && pt(Pt[Ct].pt.k[Dt].e[0]);
                        }
                        bt.ty === 0
                          ? ((bt.layers = ot(bt.refId, Et)), ct(bt.layers, Et))
                          : bt.ty === 4
                          ? ut(bt.shapes)
                          : bt.ty === 5 && Ft(bt);
                      }
                  }
                  function it(Lt, Et) {
                    if (Lt) {
                      var bt = 0,
                        mt = Lt.length;
                      for (bt = 0; bt < mt; bt += 1)
                        Lt[bt].t === 1 &&
                          ((Lt[bt].data.layers = ot(Lt[bt].data.refId, Et)),
                          ct(Lt[bt].data.layers, Et));
                    }
                  }
                  function lt(Lt, Et) {
                    for (var bt = 0, mt = Et.length; bt < mt; ) {
                      if (Et[bt].id === Lt) return Et[bt];
                      bt += 1;
                    }
                    return null;
                  }
                  function ot(Lt, Et) {
                    var bt = lt(Lt, Et);
                    return bt
                      ? bt.layers.__used
                        ? JSON.parse(JSON.stringify(bt.layers))
                        : ((bt.layers.__used = !0), bt.layers)
                      : null;
                  }
                  function ut(Lt) {
                    var Et,
                      bt = Lt.length,
                      mt,
                      vt;
                    for (Et = bt - 1; Et >= 0; Et -= 1)
                      if (Lt[Et].ty === "sh")
                        if (Lt[Et].ks.k.i) pt(Lt[Et].ks.k);
                        else
                          for (
                            vt = Lt[Et].ks.k.length, mt = 0;
                            mt < vt;
                            mt += 1
                          )
                            Lt[Et].ks.k[mt].s && pt(Lt[Et].ks.k[mt].s[0]),
                              Lt[Et].ks.k[mt].e && pt(Lt[Et].ks.k[mt].e[0]);
                      else Lt[Et].ty === "gr" && ut(Lt[Et].it);
                  }
                  function pt(Lt) {
                    var Et,
                      bt = Lt.i.length;
                    for (Et = 0; Et < bt; Et += 1)
                      (Lt.i[Et][0] += Lt.v[Et][0]),
                        (Lt.i[Et][1] += Lt.v[Et][1]),
                        (Lt.o[Et][0] += Lt.v[Et][0]),
                        (Lt.o[Et][1] += Lt.v[Et][1]);
                  }
                  function ft(Lt, Et) {
                    var bt = Et ? Et.split(".") : [100, 100, 100];
                    return Lt[0] > bt[0]
                      ? !0
                      : bt[0] > Lt[0]
                      ? !1
                      : Lt[1] > bt[1]
                      ? !0
                      : bt[1] > Lt[1]
                      ? !1
                      : Lt[2] > bt[2]
                      ? !0
                      : bt[2] > Lt[2]
                      ? !1
                      : null;
                  }
                  var gt = (function () {
                      var Lt = [4, 4, 14];
                      function Et(mt) {
                        var vt = mt.t.d;
                        mt.t.d = { k: [{ s: vt, t: 0 }] };
                      }
                      function bt(mt) {
                        var vt,
                          Ct = mt.length;
                        for (vt = 0; vt < Ct; vt += 1)
                          mt[vt].ty === 5 && Et(mt[vt]);
                      }
                      return function (mt) {
                        if (ft(Lt, mt.v) && (bt(mt.layers), mt.assets)) {
                          var vt,
                            Ct = mt.assets.length;
                          for (vt = 0; vt < Ct; vt += 1)
                            mt.assets[vt].layers && bt(mt.assets[vt].layers);
                        }
                      };
                    })(),
                    xt = (function () {
                      var Lt = [4, 7, 99];
                      return function (Et) {
                        if (Et.chars && !ft(Lt, Et.v)) {
                          var bt,
                            mt = Et.chars.length;
                          for (bt = 0; bt < mt; bt += 1) {
                            var vt = Et.chars[bt];
                            vt.data &&
                              vt.data.shapes &&
                              (ut(vt.data.shapes),
                              (vt.data.ip = 0),
                              (vt.data.op = 99999),
                              (vt.data.st = 0),
                              (vt.data.sr = 1),
                              (vt.data.ks = {
                                p: { k: [0, 0], a: 0 },
                                s: { k: [100, 100], a: 0 },
                                a: { k: [0, 0], a: 0 },
                                r: { k: 0, a: 0 },
                                o: { k: 100, a: 0 },
                              }),
                              Et.chars[bt].t ||
                                (vt.data.shapes.push({ ty: "no" }),
                                vt.data.shapes[0].it.push({
                                  p: { k: [0, 0], a: 0 },
                                  s: { k: [100, 100], a: 0 },
                                  a: { k: [0, 0], a: 0 },
                                  r: { k: 0, a: 0 },
                                  o: { k: 100, a: 0 },
                                  sk: { k: 0, a: 0 },
                                  sa: { k: 0, a: 0 },
                                  ty: "tr",
                                })));
                          }
                        }
                      };
                    })(),
                    _t = (function () {
                      var Lt = [5, 7, 15];
                      function Et(mt) {
                        var vt = mt.t.p;
                        typeof vt.a == "number" && (vt.a = { a: 0, k: vt.a }),
                          typeof vt.p == "number" && (vt.p = { a: 0, k: vt.p }),
                          typeof vt.r == "number" && (vt.r = { a: 0, k: vt.r });
                      }
                      function bt(mt) {
                        var vt,
                          Ct = mt.length;
                        for (vt = 0; vt < Ct; vt += 1)
                          mt[vt].ty === 5 && Et(mt[vt]);
                      }
                      return function (mt) {
                        if (ft(Lt, mt.v) && (bt(mt.layers), mt.assets)) {
                          var vt,
                            Ct = mt.assets.length;
                          for (vt = 0; vt < Ct; vt += 1)
                            mt.assets[vt].layers && bt(mt.assets[vt].layers);
                        }
                      };
                    })(),
                    St = (function () {
                      var Lt = [4, 1, 9];
                      function Et(mt) {
                        var vt,
                          Ct = mt.length,
                          Tt,
                          Dt;
                        for (vt = 0; vt < Ct; vt += 1)
                          if (mt[vt].ty === "gr") Et(mt[vt].it);
                          else if (mt[vt].ty === "fl" || mt[vt].ty === "st")
                            if (mt[vt].c.k && mt[vt].c.k[0].i)
                              for (
                                Dt = mt[vt].c.k.length, Tt = 0;
                                Tt < Dt;
                                Tt += 1
                              )
                                mt[vt].c.k[Tt].s &&
                                  ((mt[vt].c.k[Tt].s[0] /= 255),
                                  (mt[vt].c.k[Tt].s[1] /= 255),
                                  (mt[vt].c.k[Tt].s[2] /= 255),
                                  (mt[vt].c.k[Tt].s[3] /= 255)),
                                  mt[vt].c.k[Tt].e &&
                                    ((mt[vt].c.k[Tt].e[0] /= 255),
                                    (mt[vt].c.k[Tt].e[1] /= 255),
                                    (mt[vt].c.k[Tt].e[2] /= 255),
                                    (mt[vt].c.k[Tt].e[3] /= 255));
                            else
                              (mt[vt].c.k[0] /= 255),
                                (mt[vt].c.k[1] /= 255),
                                (mt[vt].c.k[2] /= 255),
                                (mt[vt].c.k[3] /= 255);
                      }
                      function bt(mt) {
                        var vt,
                          Ct = mt.length;
                        for (vt = 0; vt < Ct; vt += 1)
                          mt[vt].ty === 4 && Et(mt[vt].shapes);
                      }
                      return function (mt) {
                        if (ft(Lt, mt.v) && (bt(mt.layers), mt.assets)) {
                          var vt,
                            Ct = mt.assets.length;
                          for (vt = 0; vt < Ct; vt += 1)
                            mt.assets[vt].layers && bt(mt.assets[vt].layers);
                        }
                      };
                    })(),
                    Mt = (function () {
                      var Lt = [4, 4, 18];
                      function Et(mt) {
                        var vt,
                          Ct = mt.length,
                          Tt,
                          Dt;
                        for (vt = Ct - 1; vt >= 0; vt -= 1)
                          if (mt[vt].ty === "sh")
                            if (mt[vt].ks.k.i) mt[vt].ks.k.c = mt[vt].closed;
                            else
                              for (
                                Dt = mt[vt].ks.k.length, Tt = 0;
                                Tt < Dt;
                                Tt += 1
                              )
                                mt[vt].ks.k[Tt].s &&
                                  (mt[vt].ks.k[Tt].s[0].c = mt[vt].closed),
                                  mt[vt].ks.k[Tt].e &&
                                    (mt[vt].ks.k[Tt].e[0].c = mt[vt].closed);
                          else mt[vt].ty === "gr" && Et(mt[vt].it);
                      }
                      function bt(mt) {
                        var vt,
                          Ct,
                          Tt = mt.length,
                          Dt,
                          Wt,
                          Pt,
                          Jt;
                        for (Ct = 0; Ct < Tt; Ct += 1) {
                          if (((vt = mt[Ct]), vt.hasMask)) {
                            var Gt = vt.masksProperties;
                            for (Wt = Gt.length, Dt = 0; Dt < Wt; Dt += 1)
                              if (Gt[Dt].pt.k.i) Gt[Dt].pt.k.c = Gt[Dt].cl;
                              else
                                for (
                                  Jt = Gt[Dt].pt.k.length, Pt = 0;
                                  Pt < Jt;
                                  Pt += 1
                                )
                                  Gt[Dt].pt.k[Pt].s &&
                                    (Gt[Dt].pt.k[Pt].s[0].c = Gt[Dt].cl),
                                    Gt[Dt].pt.k[Pt].e &&
                                      (Gt[Dt].pt.k[Pt].e[0].c = Gt[Dt].cl);
                          }
                          vt.ty === 4 && Et(vt.shapes);
                        }
                      }
                      return function (mt) {
                        if (ft(Lt, mt.v) && (bt(mt.layers), mt.assets)) {
                          var vt,
                            Ct = mt.assets.length;
                          for (vt = 0; vt < Ct; vt += 1)
                            mt.assets[vt].layers && bt(mt.assets[vt].layers);
                        }
                      };
                    })();
                  function Rt(Lt) {
                    Lt.__complete ||
                      (St(Lt),
                      gt(Lt),
                      xt(Lt),
                      _t(Lt),
                      Mt(Lt),
                      ct(Lt.layers, Lt.assets),
                      it(Lt.chars, Lt.assets),
                      (Lt.__complete = !0));
                  }
                  function Ft(Lt) {
                    Lt.t.a.length === 0 && "m" in Lt.t.p;
                  }
                  var Ot = {};
                  return (
                    (Ot.completeData = Rt),
                    (Ot.checkColors = St),
                    (Ot.checkChars = xt),
                    (Ot.checkPathProperties = _t),
                    (Ot.checkShapes = Mt),
                    (Ot.completeLayers = ct),
                    Ot
                  );
                }
                if (
                  (d.dataManager || (d.dataManager = st()),
                  d.assetLoader ||
                    (d.assetLoader = (function () {
                      function ct(lt) {
                        var ot = lt.getResponseHeader("content-type");
                        return (ot &&
                          lt.responseType === "json" &&
                          ot.indexOf("json") !== -1) ||
                          (lt.response && _typeof$5(lt.response) === "object")
                          ? lt.response
                          : lt.response && typeof lt.response == "string"
                          ? JSON.parse(lt.response)
                          : lt.responseText
                          ? JSON.parse(lt.responseText)
                          : null;
                      }
                      function it(lt, ot, ut, pt) {
                        var ft,
                          gt = new XMLHttpRequest();
                        try {
                          gt.responseType = "json";
                        } catch {}
                        gt.onreadystatechange = function () {
                          if (gt.readyState === 4)
                            if (gt.status === 200) (ft = ct(gt)), ut(ft);
                            else
                              try {
                                (ft = ct(gt)), ut(ft);
                              } catch (xt) {
                                pt && pt(xt);
                              }
                        };
                        try {
                          gt.open(["G", "E", "T"].join(""), lt, !0);
                        } catch {
                          gt.open(["G", "E", "T"].join(""), ot + "/" + lt, !0);
                        }
                        gt.send();
                      }
                      return { load: it };
                    })()),
                  rt.data.type === "loadAnimation")
                )
                  d.assetLoader.load(
                    rt.data.path,
                    rt.data.fullPath,
                    function (ct) {
                      d.dataManager.completeData(ct),
                        d.postMessage({
                          id: rt.data.id,
                          payload: ct,
                          status: "success",
                        });
                    },
                    function () {
                      d.postMessage({ id: rt.data.id, status: "error" });
                    }
                  );
                else if (rt.data.type === "complete") {
                  var at = rt.data.animation;
                  d.dataManager.completeData(at),
                    d.postMessage({
                      id: rt.data.id,
                      payload: at,
                      status: "success",
                    });
                } else
                  rt.data.type === "loadData" &&
                    d.assetLoader.load(
                      rt.data.path,
                      rt.data.fullPath,
                      function (ct) {
                        d.postMessage({
                          id: rt.data.id,
                          payload: ct,
                          status: "success",
                        });
                      },
                      function () {
                        d.postMessage({ id: rt.data.id, status: "error" });
                      }
                    );
              })),
              (a.onmessage = function (et) {
                var rt = et.data,
                  st = rt.id,
                  at = e[st];
                (e[st] = null),
                  rt.status === "success"
                    ? at.onComplete(rt.payload)
                    : at.onError && at.onError();
              }));
          }
          function b(et, rt) {
            s += 1;
            var st = "processId_" + s;
            return (e[st] = { onComplete: et, onError: rt }), st;
          }
          function j(et, rt, st) {
            _();
            var at = b(rt, st);
            a.postMessage({
              type: "loadAnimation",
              path: et,
              fullPath: window.location.origin + window.location.pathname,
              id: at,
            });
          }
          function $(et, rt, st) {
            _();
            var at = b(rt, st);
            a.postMessage({
              type: "loadData",
              path: et,
              fullPath: window.location.origin + window.location.pathname,
              id: at,
            });
          }
          function _e(et, rt, st) {
            _();
            var at = b(rt, st);
            a.postMessage({ type: "complete", animation: et, id: at });
          }
          return { loadAnimation: j, loadData: $, completeAnimation: _e };
        })(),
        ImagePreloader = (function () {
          var s = (function () {
            var it = createTag("canvas");
            (it.width = 1), (it.height = 1);
            var lt = it.getContext("2d");
            return (
              (lt.fillStyle = "rgba(0,0,0,0)"), lt.fillRect(0, 0, 1, 1), it
            );
          })();
          function e() {
            (this.loadedAssets += 1),
              this.loadedAssets === this.totalImages &&
                this.loadedFootagesCount === this.totalFootages &&
                this.imagesLoadedCb &&
                this.imagesLoadedCb(null);
          }
          function o() {
            (this.loadedFootagesCount += 1),
              this.loadedAssets === this.totalImages &&
                this.loadedFootagesCount === this.totalFootages &&
                this.imagesLoadedCb &&
                this.imagesLoadedCb(null);
          }
          function a(it, lt, ot) {
            var ut = "";
            if (it.e) ut = it.p;
            else if (lt) {
              var pt = it.p;
              pt.indexOf("images/") !== -1 && (pt = pt.split("/")[1]),
                (ut = lt + pt);
            } else (ut = ot), (ut += it.u ? it.u : ""), (ut += it.p);
            return ut;
          }
          function c(it) {
            var lt = 0,
              ot = setInterval(
                function () {
                  var ut = it.getBBox();
                  (ut.width || lt > 500) &&
                    (this._imageLoaded(), clearInterval(ot)),
                    (lt += 1);
                }.bind(this),
                50
              );
          }
          function d(it) {
            var lt = a(it, this.assetsPath, this.path),
              ot = createNS("image");
            isSafari
              ? this.testImageLoaded(ot)
              : ot.addEventListener("load", this._imageLoaded, !1),
              ot.addEventListener(
                "error",
                function () {
                  (ut.img = s), this._imageLoaded();
                }.bind(this),
                !1
              ),
              ot.setAttributeNS("http://www.w3.org/1999/xlink", "href", lt),
              this._elementHelper.append
                ? this._elementHelper.append(ot)
                : this._elementHelper.appendChild(ot);
            var ut = { img: ot, assetData: it };
            return ut;
          }
          function g(it) {
            var lt = a(it, this.assetsPath, this.path),
              ot = createTag("img");
            (ot.crossOrigin = "anonymous"),
              ot.addEventListener("load", this._imageLoaded, !1),
              ot.addEventListener(
                "error",
                function () {
                  (ut.img = s), this._imageLoaded();
                }.bind(this),
                !1
              ),
              (ot.src = lt);
            var ut = { img: ot, assetData: it };
            return ut;
          }
          function _(it) {
            var lt = { assetData: it },
              ot = a(it, this.assetsPath, this.path);
            return (
              dataManager.loadData(
                ot,
                function (ut) {
                  (lt.img = ut), this._footageLoaded();
                }.bind(this),
                function () {
                  (lt.img = {}), this._footageLoaded();
                }.bind(this)
              ),
              lt
            );
          }
          function b(it, lt) {
            this.imagesLoadedCb = lt;
            var ot,
              ut = it.length;
            for (ot = 0; ot < ut; ot += 1)
              it[ot].layers ||
                (!it[ot].t || it[ot].t === "seq"
                  ? ((this.totalImages += 1),
                    this.images.push(this._createImageData(it[ot])))
                  : it[ot].t === 3 &&
                    ((this.totalFootages += 1),
                    this.images.push(this.createFootageData(it[ot]))));
          }
          function j(it) {
            this.path = it || "";
          }
          function $(it) {
            this.assetsPath = it || "";
          }
          function _e(it) {
            for (var lt = 0, ot = this.images.length; lt < ot; ) {
              if (this.images[lt].assetData === it) return this.images[lt].img;
              lt += 1;
            }
            return null;
          }
          function et() {
            (this.imagesLoadedCb = null), (this.images.length = 0);
          }
          function rt() {
            return this.totalImages === this.loadedAssets;
          }
          function st() {
            return this.totalFootages === this.loadedFootagesCount;
          }
          function at(it, lt) {
            it === "svg"
              ? ((this._elementHelper = lt),
                (this._createImageData = this.createImageData.bind(this)))
              : (this._createImageData = this.createImgData.bind(this));
          }
          function ct() {
            (this._imageLoaded = e.bind(this)),
              (this._footageLoaded = o.bind(this)),
              (this.testImageLoaded = c.bind(this)),
              (this.createFootageData = _.bind(this)),
              (this.assetsPath = ""),
              (this.path = ""),
              (this.totalImages = 0),
              (this.totalFootages = 0),
              (this.loadedAssets = 0),
              (this.loadedFootagesCount = 0),
              (this.imagesLoadedCb = null),
              (this.images = []);
          }
          return (
            (ct.prototype = {
              loadAssets: b,
              setAssetsPath: $,
              setPath: j,
              loadedImages: rt,
              loadedFootages: st,
              destroy: et,
              getAsset: _e,
              createImgData: g,
              createImageData: d,
              imageLoaded: e,
              footageLoaded: o,
              setCacheType: at,
            }),
            ct
          );
        })();
      function BaseEvent() {}
      BaseEvent.prototype = {
        triggerEvent: function (e, o) {
          if (this._cbs[e])
            for (var a = this._cbs[e], c = 0; c < a.length; c += 1) a[c](o);
        },
        addEventListener: function (e, o) {
          return (
            this._cbs[e] || (this._cbs[e] = []),
            this._cbs[e].push(o),
            function () {
              this.removeEventListener(e, o);
            }.bind(this)
          );
        },
        removeEventListener: function (e, o) {
          if (!o) this._cbs[e] = null;
          else if (this._cbs[e]) {
            for (var a = 0, c = this._cbs[e].length; a < c; )
              this._cbs[e][a] === o &&
                (this._cbs[e].splice(a, 1), (a -= 1), (c -= 1)),
                (a += 1);
            this._cbs[e].length || (this._cbs[e] = null);
          }
        },
      };
      var markerParser = (function () {
          function s(e) {
            for (
              var o = e.split(`\r
`),
                a = {},
                c,
                d = 0,
                g = 0;
              g < o.length;
              g += 1
            )
              (c = o[g].split(":")),
                c.length === 2 && ((a[c[0]] = c[1].trim()), (d += 1));
            if (d === 0) throw new Error();
            return a;
          }
          return function (e) {
            for (var o = [], a = 0; a < e.length; a += 1) {
              var c = e[a],
                d = { time: c.tm, duration: c.dr };
              try {
                d.payload = JSON.parse(e[a].cm);
              } catch {
                try {
                  d.payload = s(e[a].cm);
                } catch {
                  d.payload = { name: e[a].cm };
                }
              }
              o.push(d);
            }
            return o;
          };
        })(),
        ProjectInterface = (function () {
          function s(e) {
            this.compositions.push(e);
          }
          return function () {
            function e(o) {
              for (var a = 0, c = this.compositions.length; a < c; ) {
                if (
                  this.compositions[a].data &&
                  this.compositions[a].data.nm === o
                )
                  return (
                    this.compositions[a].prepareFrame &&
                      this.compositions[a].data.xt &&
                      this.compositions[a].prepareFrame(this.currentFrame),
                    this.compositions[a].compInterface
                  );
                a += 1;
              }
              return null;
            }
            return (
              (e.compositions = []),
              (e.currentFrame = 0),
              (e.registerComposition = s),
              e
            );
          };
        })(),
        renderers = {},
        registerRenderer = function (e, o) {
          renderers[e] = o;
        };
      function getRenderer(s) {
        return renderers[s];
      }
      function getRegisteredRenderer() {
        if (renderers.canvas) return "canvas";
        for (var s in renderers) if (renderers[s]) return s;
        return "";
      }
      function _typeof$4(s) {
        "@babel/helpers - typeof";
        return (
          typeof Symbol == "function" && typeof Symbol.iterator == "symbol"
            ? (_typeof$4 = function (o) {
                return typeof o;
              })
            : (_typeof$4 = function (o) {
                return o &&
                  typeof Symbol == "function" &&
                  o.constructor === Symbol &&
                  o !== Symbol.prototype
                  ? "symbol"
                  : typeof o;
              }),
          _typeof$4(s)
        );
      }
      var AnimationItem = function () {
        (this._cbs = []),
          (this.name = ""),
          (this.path = ""),
          (this.isLoaded = !1),
          (this.currentFrame = 0),
          (this.currentRawFrame = 0),
          (this.firstFrame = 0),
          (this.totalFrames = 0),
          (this.frameRate = 0),
          (this.frameMult = 0),
          (this.playSpeed = 1),
          (this.playDirection = 1),
          (this.playCount = 0),
          (this.animationData = {}),
          (this.assets = []),
          (this.isPaused = !0),
          (this.autoplay = !1),
          (this.loop = !0),
          (this.renderer = null),
          (this.animationID = createElementID()),
          (this.assetsPath = ""),
          (this.timeCompleted = 0),
          (this.segmentPos = 0),
          (this.isSubframeEnabled = getSubframeEnabled()),
          (this.segments = []),
          (this._idle = !0),
          (this._completedLoop = !1),
          (this.projectInterface = ProjectInterface()),
          (this.imagePreloader = new ImagePreloader()),
          (this.audioController = audioControllerFactory()),
          (this.markers = []),
          (this.configAnimation = this.configAnimation.bind(this)),
          (this.onSetupError = this.onSetupError.bind(this)),
          (this.onSegmentComplete = this.onSegmentComplete.bind(this)),
          (this.drawnFrameEvent = new BMEnterFrameEvent("drawnFrame", 0, 0, 0)),
          (this.expressionsPlugin = getExpressionsPlugin());
      };
      extendPrototype([BaseEvent], AnimationItem),
        (AnimationItem.prototype.setParams = function (s) {
          (s.wrapper || s.container) &&
            (this.wrapper = s.wrapper || s.container);
          var e = "svg";
          s.animType ? (e = s.animType) : s.renderer && (e = s.renderer);
          var o = getRenderer(e);
          (this.renderer = new o(this, s.rendererSettings)),
            this.imagePreloader.setCacheType(e, this.renderer.globalData.defs),
            this.renderer.setProjectInterface(this.projectInterface),
            (this.animType = e),
            s.loop === "" ||
            s.loop === null ||
            s.loop === void 0 ||
            s.loop === !0
              ? (this.loop = !0)
              : s.loop === !1
              ? (this.loop = !1)
              : (this.loop = parseInt(s.loop, 10)),
            (this.autoplay = "autoplay" in s ? s.autoplay : !0),
            (this.name = s.name ? s.name : ""),
            (this.autoloadSegments = Object.prototype.hasOwnProperty.call(
              s,
              "autoloadSegments"
            )
              ? s.autoloadSegments
              : !0),
            (this.assetsPath = s.assetsPath),
            (this.initialSegment = s.initialSegment),
            s.audioFactory &&
              this.audioController.setAudioFactory(s.audioFactory),
            s.animationData
              ? this.setupAnimation(s.animationData)
              : s.path &&
                (s.path.lastIndexOf("\\") !== -1
                  ? (this.path = s.path.substr(0, s.path.lastIndexOf("\\") + 1))
                  : (this.path = s.path.substr(0, s.path.lastIndexOf("/") + 1)),
                (this.fileName = s.path.substr(s.path.lastIndexOf("/") + 1)),
                (this.fileName = this.fileName.substr(
                  0,
                  this.fileName.lastIndexOf(".json")
                )),
                dataManager.loadAnimation(
                  s.path,
                  this.configAnimation,
                  this.onSetupError
                ));
        }),
        (AnimationItem.prototype.onSetupError = function () {
          this.trigger("data_failed");
        }),
        (AnimationItem.prototype.setupAnimation = function (s) {
          dataManager.completeAnimation(s, this.configAnimation);
        }),
        (AnimationItem.prototype.setData = function (s, e) {
          e && _typeof$4(e) !== "object" && (e = JSON.parse(e));
          var o = { wrapper: s, animationData: e },
            a = s.attributes;
          (o.path = a.getNamedItem("data-animation-path")
            ? a.getNamedItem("data-animation-path").value
            : a.getNamedItem("data-bm-path")
            ? a.getNamedItem("data-bm-path").value
            : a.getNamedItem("bm-path")
            ? a.getNamedItem("bm-path").value
            : ""),
            (o.animType = a.getNamedItem("data-anim-type")
              ? a.getNamedItem("data-anim-type").value
              : a.getNamedItem("data-bm-type")
              ? a.getNamedItem("data-bm-type").value
              : a.getNamedItem("bm-type")
              ? a.getNamedItem("bm-type").value
              : a.getNamedItem("data-bm-renderer")
              ? a.getNamedItem("data-bm-renderer").value
              : a.getNamedItem("bm-renderer")
              ? a.getNamedItem("bm-renderer").value
              : getRegisteredRenderer() || "canvas");
          var c = a.getNamedItem("data-anim-loop")
            ? a.getNamedItem("data-anim-loop").value
            : a.getNamedItem("data-bm-loop")
            ? a.getNamedItem("data-bm-loop").value
            : a.getNamedItem("bm-loop")
            ? a.getNamedItem("bm-loop").value
            : "";
          c === "false"
            ? (o.loop = !1)
            : c === "true"
            ? (o.loop = !0)
            : c !== "" && (o.loop = parseInt(c, 10));
          var d = a.getNamedItem("data-anim-autoplay")
            ? a.getNamedItem("data-anim-autoplay").value
            : a.getNamedItem("data-bm-autoplay")
            ? a.getNamedItem("data-bm-autoplay").value
            : a.getNamedItem("bm-autoplay")
            ? a.getNamedItem("bm-autoplay").value
            : !0;
          (o.autoplay = d !== "false"),
            (o.name = a.getNamedItem("data-name")
              ? a.getNamedItem("data-name").value
              : a.getNamedItem("data-bm-name")
              ? a.getNamedItem("data-bm-name").value
              : a.getNamedItem("bm-name")
              ? a.getNamedItem("bm-name").value
              : "");
          var g = a.getNamedItem("data-anim-prerender")
            ? a.getNamedItem("data-anim-prerender").value
            : a.getNamedItem("data-bm-prerender")
            ? a.getNamedItem("data-bm-prerender").value
            : a.getNamedItem("bm-prerender")
            ? a.getNamedItem("bm-prerender").value
            : "";
          g === "false" && (o.prerender = !1),
            o.path ? this.setParams(o) : this.trigger("destroy");
        }),
        (AnimationItem.prototype.includeLayers = function (s) {
          s.op > this.animationData.op &&
            ((this.animationData.op = s.op),
            (this.totalFrames = Math.floor(s.op - this.animationData.ip)));
          var e = this.animationData.layers,
            o,
            a = e.length,
            c = s.layers,
            d,
            g = c.length;
          for (d = 0; d < g; d += 1)
            for (o = 0; o < a; ) {
              if (e[o].id === c[d].id) {
                e[o] = c[d];
                break;
              }
              o += 1;
            }
          if (
            ((s.chars || s.fonts) &&
              (this.renderer.globalData.fontManager.addChars(s.chars),
              this.renderer.globalData.fontManager.addFonts(
                s.fonts,
                this.renderer.globalData.defs
              )),
            s.assets)
          )
            for (a = s.assets.length, o = 0; o < a; o += 1)
              this.animationData.assets.push(s.assets[o]);
          (this.animationData.__complete = !1),
            dataManager.completeAnimation(
              this.animationData,
              this.onSegmentComplete
            );
        }),
        (AnimationItem.prototype.onSegmentComplete = function (s) {
          this.animationData = s;
          var e = getExpressionsPlugin();
          e && e.initExpressions(this), this.loadNextSegment();
        }),
        (AnimationItem.prototype.loadNextSegment = function () {
          var s = this.animationData.segments;
          if (!s || s.length === 0 || !this.autoloadSegments) {
            this.trigger("data_ready"), (this.timeCompleted = this.totalFrames);
            return;
          }
          var e = s.shift();
          this.timeCompleted = e.time * this.frameRate;
          var o = this.path + this.fileName + "_" + this.segmentPos + ".json";
          (this.segmentPos += 1),
            dataManager.loadData(
              o,
              this.includeLayers.bind(this),
              function () {
                this.trigger("data_failed");
              }.bind(this)
            );
        }),
        (AnimationItem.prototype.loadSegments = function () {
          var s = this.animationData.segments;
          s || (this.timeCompleted = this.totalFrames), this.loadNextSegment();
        }),
        (AnimationItem.prototype.imagesLoaded = function () {
          this.trigger("loaded_images"), this.checkLoaded();
        }),
        (AnimationItem.prototype.preloadImages = function () {
          this.imagePreloader.setAssetsPath(this.assetsPath),
            this.imagePreloader.setPath(this.path),
            this.imagePreloader.loadAssets(
              this.animationData.assets,
              this.imagesLoaded.bind(this)
            );
        }),
        (AnimationItem.prototype.configAnimation = function (s) {
          if (this.renderer)
            try {
              (this.animationData = s),
                this.initialSegment
                  ? ((this.totalFrames = Math.floor(
                      this.initialSegment[1] - this.initialSegment[0]
                    )),
                    (this.firstFrame = Math.round(this.initialSegment[0])))
                  : ((this.totalFrames = Math.floor(
                      this.animationData.op - this.animationData.ip
                    )),
                    (this.firstFrame = Math.round(this.animationData.ip))),
                this.renderer.configAnimation(s),
                s.assets || (s.assets = []),
                (this.assets = this.animationData.assets),
                (this.frameRate = this.animationData.fr),
                (this.frameMult = this.animationData.fr / 1e3),
                this.renderer.searchExtraCompositions(s.assets),
                (this.markers = markerParser(s.markers || [])),
                this.trigger("config_ready"),
                this.preloadImages(),
                this.loadSegments(),
                this.updaFrameModifier(),
                this.waitForFontsLoaded(),
                this.isPaused && this.audioController.pause();
            } catch (e) {
              this.triggerConfigError(e);
            }
        }),
        (AnimationItem.prototype.waitForFontsLoaded = function () {
          this.renderer &&
            (this.renderer.globalData.fontManager.isLoaded
              ? this.checkLoaded()
              : setTimeout(this.waitForFontsLoaded.bind(this), 20));
        }),
        (AnimationItem.prototype.checkLoaded = function () {
          if (
            !this.isLoaded &&
            this.renderer.globalData.fontManager.isLoaded &&
            (this.imagePreloader.loadedImages() ||
              this.renderer.rendererType !== "canvas") &&
            this.imagePreloader.loadedFootages()
          ) {
            this.isLoaded = !0;
            var s = getExpressionsPlugin();
            s && s.initExpressions(this),
              this.renderer.initItems(),
              setTimeout(
                function () {
                  this.trigger("DOMLoaded");
                }.bind(this),
                0
              ),
              this.gotoFrame(),
              this.autoplay && this.play();
          }
        }),
        (AnimationItem.prototype.resize = function (s, e) {
          var o = typeof s == "number" ? s : void 0,
            a = typeof e == "number" ? e : void 0;
          this.renderer.updateContainerSize(o, a);
        }),
        (AnimationItem.prototype.setSubframe = function (s) {
          this.isSubframeEnabled = !!s;
        }),
        (AnimationItem.prototype.gotoFrame = function () {
          (this.currentFrame = this.isSubframeEnabled
            ? this.currentRawFrame
            : ~~this.currentRawFrame),
            this.timeCompleted !== this.totalFrames &&
              this.currentFrame > this.timeCompleted &&
              (this.currentFrame = this.timeCompleted),
            this.trigger("enterFrame"),
            this.renderFrame(),
            this.trigger("drawnFrame");
        }),
        (AnimationItem.prototype.renderFrame = function () {
          if (!(this.isLoaded === !1 || !this.renderer))
            try {
              this.expressionsPlugin && this.expressionsPlugin.resetFrame(),
                this.renderer.renderFrame(this.currentFrame + this.firstFrame);
            } catch (s) {
              this.triggerRenderFrameError(s);
            }
        }),
        (AnimationItem.prototype.play = function (s) {
          (s && this.name !== s) ||
            (this.isPaused === !0 &&
              ((this.isPaused = !1),
              this.trigger("_play"),
              this.audioController.resume(),
              this._idle && ((this._idle = !1), this.trigger("_active"))));
        }),
        (AnimationItem.prototype.pause = function (s) {
          (s && this.name !== s) ||
            (this.isPaused === !1 &&
              ((this.isPaused = !0),
              this.trigger("_pause"),
              (this._idle = !0),
              this.trigger("_idle"),
              this.audioController.pause()));
        }),
        (AnimationItem.prototype.togglePause = function (s) {
          (s && this.name !== s) ||
            (this.isPaused === !0 ? this.play() : this.pause());
        }),
        (AnimationItem.prototype.stop = function (s) {
          (s && this.name !== s) ||
            (this.pause(),
            (this.playCount = 0),
            (this._completedLoop = !1),
            this.setCurrentRawFrameValue(0));
        }),
        (AnimationItem.prototype.getMarkerData = function (s) {
          for (var e, o = 0; o < this.markers.length; o += 1)
            if (((e = this.markers[o]), e.payload && e.payload.name === s))
              return e;
          return null;
        }),
        (AnimationItem.prototype.goToAndStop = function (s, e, o) {
          if (!(o && this.name !== o)) {
            var a = Number(s);
            if (isNaN(a)) {
              var c = this.getMarkerData(s);
              c && this.goToAndStop(c.time, !0);
            } else
              e
                ? this.setCurrentRawFrameValue(s)
                : this.setCurrentRawFrameValue(s * this.frameModifier);
            this.pause();
          }
        }),
        (AnimationItem.prototype.goToAndPlay = function (s, e, o) {
          if (!(o && this.name !== o)) {
            var a = Number(s);
            if (isNaN(a)) {
              var c = this.getMarkerData(s);
              c &&
                (c.duration
                  ? this.playSegments([c.time, c.time + c.duration], !0)
                  : this.goToAndStop(c.time, !0));
            } else this.goToAndStop(a, e, o);
            this.play();
          }
        }),
        (AnimationItem.prototype.advanceTime = function (s) {
          if (!(this.isPaused === !0 || this.isLoaded === !1)) {
            var e = this.currentRawFrame + s * this.frameModifier,
              o = !1;
            e >= this.totalFrames - 1 && this.frameModifier > 0
              ? !this.loop || this.playCount === this.loop
                ? this.checkSegments(
                    e > this.totalFrames ? e % this.totalFrames : 0
                  ) || ((o = !0), (e = this.totalFrames - 1))
                : e >= this.totalFrames
                ? ((this.playCount += 1),
                  this.checkSegments(e % this.totalFrames) ||
                    (this.setCurrentRawFrameValue(e % this.totalFrames),
                    (this._completedLoop = !0),
                    this.trigger("loopComplete")))
                : this.setCurrentRawFrameValue(e)
              : e < 0
              ? this.checkSegments(e % this.totalFrames) ||
                (this.loop && !(this.playCount-- <= 0 && this.loop !== !0)
                  ? (this.setCurrentRawFrameValue(
                      this.totalFrames + (e % this.totalFrames)
                    ),
                    this._completedLoop
                      ? this.trigger("loopComplete")
                      : (this._completedLoop = !0))
                  : ((o = !0), (e = 0)))
              : this.setCurrentRawFrameValue(e),
              o &&
                (this.setCurrentRawFrameValue(e),
                this.pause(),
                this.trigger("complete"));
          }
        }),
        (AnimationItem.prototype.adjustSegment = function (s, e) {
          (this.playCount = 0),
            s[1] < s[0]
              ? (this.frameModifier > 0 &&
                  (this.playSpeed < 0
                    ? this.setSpeed(-this.playSpeed)
                    : this.setDirection(-1)),
                (this.totalFrames = s[0] - s[1]),
                (this.timeCompleted = this.totalFrames),
                (this.firstFrame = s[1]),
                this.setCurrentRawFrameValue(this.totalFrames - 0.001 - e))
              : s[1] > s[0] &&
                (this.frameModifier < 0 &&
                  (this.playSpeed < 0
                    ? this.setSpeed(-this.playSpeed)
                    : this.setDirection(1)),
                (this.totalFrames = s[1] - s[0]),
                (this.timeCompleted = this.totalFrames),
                (this.firstFrame = s[0]),
                this.setCurrentRawFrameValue(0.001 + e)),
            this.trigger("segmentStart");
        }),
        (AnimationItem.prototype.setSegment = function (s, e) {
          var o = -1;
          this.isPaused &&
            (this.currentRawFrame + this.firstFrame < s
              ? (o = s)
              : this.currentRawFrame + this.firstFrame > e && (o = e - s)),
            (this.firstFrame = s),
            (this.totalFrames = e - s),
            (this.timeCompleted = this.totalFrames),
            o !== -1 && this.goToAndStop(o, !0);
        }),
        (AnimationItem.prototype.playSegments = function (s, e) {
          if ((e && (this.segments.length = 0), _typeof$4(s[0]) === "object")) {
            var o,
              a = s.length;
            for (o = 0; o < a; o += 1) this.segments.push(s[o]);
          } else this.segments.push(s);
          this.segments.length &&
            e &&
            this.adjustSegment(this.segments.shift(), 0),
            this.isPaused && this.play();
        }),
        (AnimationItem.prototype.resetSegments = function (s) {
          (this.segments.length = 0),
            this.segments.push([this.animationData.ip, this.animationData.op]),
            s && this.checkSegments(0);
        }),
        (AnimationItem.prototype.checkSegments = function (s) {
          return this.segments.length
            ? (this.adjustSegment(this.segments.shift(), s), !0)
            : !1;
        }),
        (AnimationItem.prototype.destroy = function (s) {
          (s && this.name !== s) ||
            !this.renderer ||
            (this.renderer.destroy(),
            this.imagePreloader.destroy(),
            this.trigger("destroy"),
            (this._cbs = null),
            (this.onEnterFrame = null),
            (this.onLoopComplete = null),
            (this.onComplete = null),
            (this.onSegmentStart = null),
            (this.onDestroy = null),
            (this.renderer = null),
            (this.expressionsPlugin = null),
            (this.imagePreloader = null),
            (this.projectInterface = null));
        }),
        (AnimationItem.prototype.setCurrentRawFrameValue = function (s) {
          (this.currentRawFrame = s), this.gotoFrame();
        }),
        (AnimationItem.prototype.setSpeed = function (s) {
          (this.playSpeed = s), this.updaFrameModifier();
        }),
        (AnimationItem.prototype.setDirection = function (s) {
          (this.playDirection = s < 0 ? -1 : 1), this.updaFrameModifier();
        }),
        (AnimationItem.prototype.setLoop = function (s) {
          this.loop = s;
        }),
        (AnimationItem.prototype.setVolume = function (s, e) {
          (e && this.name !== e) || this.audioController.setVolume(s);
        }),
        (AnimationItem.prototype.getVolume = function () {
          return this.audioController.getVolume();
        }),
        (AnimationItem.prototype.mute = function (s) {
          (s && this.name !== s) || this.audioController.mute();
        }),
        (AnimationItem.prototype.unmute = function (s) {
          (s && this.name !== s) || this.audioController.unmute();
        }),
        (AnimationItem.prototype.updaFrameModifier = function () {
          (this.frameModifier =
            this.frameMult * this.playSpeed * this.playDirection),
            this.audioController.setRate(this.playSpeed * this.playDirection);
        }),
        (AnimationItem.prototype.getPath = function () {
          return this.path;
        }),
        (AnimationItem.prototype.getAssetsPath = function (s) {
          var e = "";
          if (s.e) e = s.p;
          else if (this.assetsPath) {
            var o = s.p;
            o.indexOf("images/") !== -1 && (o = o.split("/")[1]),
              (e = this.assetsPath + o);
          } else (e = this.path), (e += s.u ? s.u : ""), (e += s.p);
          return e;
        }),
        (AnimationItem.prototype.getAssetData = function (s) {
          for (var e = 0, o = this.assets.length; e < o; ) {
            if (s === this.assets[e].id) return this.assets[e];
            e += 1;
          }
          return null;
        }),
        (AnimationItem.prototype.hide = function () {
          this.renderer.hide();
        }),
        (AnimationItem.prototype.show = function () {
          this.renderer.show();
        }),
        (AnimationItem.prototype.getDuration = function (s) {
          return s ? this.totalFrames : this.totalFrames / this.frameRate;
        }),
        (AnimationItem.prototype.updateDocumentData = function (s, e, o) {
          try {
            var a = this.renderer.getElementByPath(s);
            a.updateDocumentData(e, o);
          } catch {}
        }),
        (AnimationItem.prototype.trigger = function (s) {
          if (this._cbs && this._cbs[s])
            switch (s) {
              case "enterFrame":
                this.triggerEvent(
                  s,
                  new BMEnterFrameEvent(
                    s,
                    this.currentFrame,
                    this.totalFrames,
                    this.frameModifier
                  )
                );
                break;
              case "drawnFrame":
                (this.drawnFrameEvent.currentTime = this.currentFrame),
                  (this.drawnFrameEvent.totalTime = this.totalFrames),
                  (this.drawnFrameEvent.direction = this.frameModifier),
                  this.triggerEvent(s, this.drawnFrameEvent);
                break;
              case "loopComplete":
                this.triggerEvent(
                  s,
                  new BMCompleteLoopEvent(
                    s,
                    this.loop,
                    this.playCount,
                    this.frameMult
                  )
                );
                break;
              case "complete":
                this.triggerEvent(s, new BMCompleteEvent(s, this.frameMult));
                break;
              case "segmentStart":
                this.triggerEvent(
                  s,
                  new BMSegmentStartEvent(s, this.firstFrame, this.totalFrames)
                );
                break;
              case "destroy":
                this.triggerEvent(s, new BMDestroyEvent(s, this));
                break;
              default:
                this.triggerEvent(s);
            }
          s === "enterFrame" &&
            this.onEnterFrame &&
            this.onEnterFrame.call(
              this,
              new BMEnterFrameEvent(
                s,
                this.currentFrame,
                this.totalFrames,
                this.frameMult
              )
            ),
            s === "loopComplete" &&
              this.onLoopComplete &&
              this.onLoopComplete.call(
                this,
                new BMCompleteLoopEvent(
                  s,
                  this.loop,
                  this.playCount,
                  this.frameMult
                )
              ),
            s === "complete" &&
              this.onComplete &&
              this.onComplete.call(
                this,
                new BMCompleteEvent(s, this.frameMult)
              ),
            s === "segmentStart" &&
              this.onSegmentStart &&
              this.onSegmentStart.call(
                this,
                new BMSegmentStartEvent(s, this.firstFrame, this.totalFrames)
              ),
            s === "destroy" &&
              this.onDestroy &&
              this.onDestroy.call(this, new BMDestroyEvent(s, this));
        }),
        (AnimationItem.prototype.triggerRenderFrameError = function (s) {
          var e = new BMRenderFrameErrorEvent(s, this.currentFrame);
          this.triggerEvent("error", e),
            this.onError && this.onError.call(this, e);
        }),
        (AnimationItem.prototype.triggerConfigError = function (s) {
          var e = new BMConfigErrorEvent(s, this.currentFrame);
          this.triggerEvent("error", e),
            this.onError && this.onError.call(this, e);
        });
      var animationManager = (function () {
          var s = {},
            e = [],
            o = 0,
            a = 0,
            c = 0,
            d = !0,
            g = !1;
          function _(Et) {
            for (var bt = 0, mt = Et.target; bt < a; )
              e[bt].animation === mt &&
                (e.splice(bt, 1), (bt -= 1), (a -= 1), mt.isPaused || _e()),
                (bt += 1);
          }
          function b(Et, bt) {
            if (!Et) return null;
            for (var mt = 0; mt < a; ) {
              if (e[mt].elem === Et && e[mt].elem !== null)
                return e[mt].animation;
              mt += 1;
            }
            var vt = new AnimationItem();
            return et(vt, Et), vt.setData(Et, bt), vt;
          }
          function j() {
            var Et,
              bt = e.length,
              mt = [];
            for (Et = 0; Et < bt; Et += 1) mt.push(e[Et].animation);
            return mt;
          }
          function $() {
            (c += 1), St();
          }
          function _e() {
            c -= 1;
          }
          function et(Et, bt) {
            Et.addEventListener("destroy", _),
              Et.addEventListener("_active", $),
              Et.addEventListener("_idle", _e),
              e.push({ elem: bt, animation: Et }),
              (a += 1);
          }
          function rt(Et) {
            var bt = new AnimationItem();
            return et(bt, null), bt.setParams(Et), bt;
          }
          function st(Et, bt) {
            var mt;
            for (mt = 0; mt < a; mt += 1) e[mt].animation.setSpeed(Et, bt);
          }
          function at(Et, bt) {
            var mt;
            for (mt = 0; mt < a; mt += 1) e[mt].animation.setDirection(Et, bt);
          }
          function ct(Et) {
            var bt;
            for (bt = 0; bt < a; bt += 1) e[bt].animation.play(Et);
          }
          function it(Et) {
            var bt = Et - o,
              mt;
            for (mt = 0; mt < a; mt += 1) e[mt].animation.advanceTime(bt);
            (o = Et), c && !g ? window.requestAnimationFrame(it) : (d = !0);
          }
          function lt(Et) {
            (o = Et), window.requestAnimationFrame(it);
          }
          function ot(Et) {
            var bt;
            for (bt = 0; bt < a; bt += 1) e[bt].animation.pause(Et);
          }
          function ut(Et, bt, mt) {
            var vt;
            for (vt = 0; vt < a; vt += 1)
              e[vt].animation.goToAndStop(Et, bt, mt);
          }
          function pt(Et) {
            var bt;
            for (bt = 0; bt < a; bt += 1) e[bt].animation.stop(Et);
          }
          function ft(Et) {
            var bt;
            for (bt = 0; bt < a; bt += 1) e[bt].animation.togglePause(Et);
          }
          function gt(Et) {
            var bt;
            for (bt = a - 1; bt >= 0; bt -= 1) e[bt].animation.destroy(Et);
          }
          function xt(Et, bt, mt) {
            var vt = [].concat(
                [].slice.call(document.getElementsByClassName("lottie")),
                [].slice.call(document.getElementsByClassName("bodymovin"))
              ),
              Ct,
              Tt = vt.length;
            for (Ct = 0; Ct < Tt; Ct += 1)
              mt && vt[Ct].setAttribute("data-bm-type", mt), b(vt[Ct], Et);
            if (bt && Tt === 0) {
              mt || (mt = "svg");
              var Dt = document.getElementsByTagName("body")[0];
              Dt.innerText = "";
              var Wt = createTag("div");
              (Wt.style.width = "100%"),
                (Wt.style.height = "100%"),
                Wt.setAttribute("data-bm-type", mt),
                Dt.appendChild(Wt),
                b(Wt, Et);
            }
          }
          function _t() {
            var Et;
            for (Et = 0; Et < a; Et += 1) e[Et].animation.resize();
          }
          function St() {
            !g && c && d && (window.requestAnimationFrame(lt), (d = !1));
          }
          function Mt() {
            g = !0;
          }
          function Rt() {
            (g = !1), St();
          }
          function Ft(Et, bt) {
            var mt;
            for (mt = 0; mt < a; mt += 1) e[mt].animation.setVolume(Et, bt);
          }
          function Ot(Et) {
            var bt;
            for (bt = 0; bt < a; bt += 1) e[bt].animation.mute(Et);
          }
          function Lt(Et) {
            var bt;
            for (bt = 0; bt < a; bt += 1) e[bt].animation.unmute(Et);
          }
          return (
            (s.registerAnimation = b),
            (s.loadAnimation = rt),
            (s.setSpeed = st),
            (s.setDirection = at),
            (s.play = ct),
            (s.pause = ot),
            (s.stop = pt),
            (s.togglePause = ft),
            (s.searchAnimations = xt),
            (s.resize = _t),
            (s.goToAndStop = ut),
            (s.destroy = gt),
            (s.freeze = Mt),
            (s.unfreeze = Rt),
            (s.setVolume = Ft),
            (s.mute = Ot),
            (s.unmute = Lt),
            (s.getRegisteredAnimations = j),
            s
          );
        })(),
        BezierFactory = (function () {
          var s = {};
          s.getBezierEasing = o;
          var e = {};
          function o(lt, ot, ut, pt, ft) {
            var gt =
              ft ||
              ("bez_" + lt + "_" + ot + "_" + ut + "_" + pt).replace(
                /\./g,
                "p"
              );
            if (e[gt]) return e[gt];
            var xt = new it([lt, ot, ut, pt]);
            return (e[gt] = xt), xt;
          }
          var a = 4,
            c = 0.001,
            d = 1e-7,
            g = 10,
            _ = 11,
            b = 1 / (_ - 1),
            j = typeof Float32Array == "function";
          function $(lt, ot) {
            return 1 - 3 * ot + 3 * lt;
          }
          function _e(lt, ot) {
            return 3 * ot - 6 * lt;
          }
          function et(lt) {
            return 3 * lt;
          }
          function rt(lt, ot, ut) {
            return (($(ot, ut) * lt + _e(ot, ut)) * lt + et(ot)) * lt;
          }
          function st(lt, ot, ut) {
            return 3 * $(ot, ut) * lt * lt + 2 * _e(ot, ut) * lt + et(ot);
          }
          function at(lt, ot, ut, pt, ft) {
            var gt,
              xt,
              _t = 0;
            do
              (xt = ot + (ut - ot) / 2),
                (gt = rt(xt, pt, ft) - lt),
                gt > 0 ? (ut = xt) : (ot = xt);
            while (Math.abs(gt) > d && ++_t < g);
            return xt;
          }
          function ct(lt, ot, ut, pt) {
            for (var ft = 0; ft < a; ++ft) {
              var gt = st(ot, ut, pt);
              if (gt === 0) return ot;
              var xt = rt(ot, ut, pt) - lt;
              ot -= xt / gt;
            }
            return ot;
          }
          function it(lt) {
            (this._p = lt),
              (this._mSampleValues = j ? new Float32Array(_) : new Array(_)),
              (this._precomputed = !1),
              (this.get = this.get.bind(this));
          }
          return (
            (it.prototype = {
              get: function (ot) {
                var ut = this._p[0],
                  pt = this._p[1],
                  ft = this._p[2],
                  gt = this._p[3];
                return (
                  this._precomputed || this._precompute(),
                  ut === pt && ft === gt
                    ? ot
                    : ot === 0
                    ? 0
                    : ot === 1
                    ? 1
                    : rt(this._getTForX(ot), pt, gt)
                );
              },
              _precompute: function () {
                var ot = this._p[0],
                  ut = this._p[1],
                  pt = this._p[2],
                  ft = this._p[3];
                (this._precomputed = !0),
                  (ot !== ut || pt !== ft) && this._calcSampleValues();
              },
              _calcSampleValues: function () {
                for (var ot = this._p[0], ut = this._p[2], pt = 0; pt < _; ++pt)
                  this._mSampleValues[pt] = rt(pt * b, ot, ut);
              },
              _getTForX: function (ot) {
                for (
                  var ut = this._p[0],
                    pt = this._p[2],
                    ft = this._mSampleValues,
                    gt = 0,
                    xt = 1,
                    _t = _ - 1;
                  xt !== _t && ft[xt] <= ot;
                  ++xt
                )
                  gt += b;
                --xt;
                var St = (ot - ft[xt]) / (ft[xt + 1] - ft[xt]),
                  Mt = gt + St * b,
                  Rt = st(Mt, ut, pt);
                return Rt >= c
                  ? ct(ot, Mt, ut, pt)
                  : Rt === 0
                  ? Mt
                  : at(ot, gt, gt + b, ut, pt);
              },
            }),
            s
          );
        })(),
        pooling = (function () {
          function s(e) {
            return e.concat(createSizedArray(e.length));
          }
          return { double: s };
        })(),
        poolFactory = (function () {
          return function (s, e, o) {
            var a = 0,
              c = s,
              d = createSizedArray(c),
              g = { newElement: _, release: b };
            function _() {
              var j;
              return a ? ((a -= 1), (j = d[a])) : (j = e()), j;
            }
            function b(j) {
              a === c && ((d = pooling.double(d)), (c *= 2)),
                o && o(j),
                (d[a] = j),
                (a += 1);
            }
            return g;
          };
        })(),
        bezierLengthPool = (function () {
          function s() {
            return {
              addedLength: 0,
              percents: createTypedArray("float32", getDefaultCurveSegments()),
              lengths: createTypedArray("float32", getDefaultCurveSegments()),
            };
          }
          return poolFactory(8, s);
        })(),
        segmentsLengthPool = (function () {
          function s() {
            return { lengths: [], totalLength: 0 };
          }
          function e(o) {
            var a,
              c = o.lengths.length;
            for (a = 0; a < c; a += 1) bezierLengthPool.release(o.lengths[a]);
            o.lengths.length = 0;
          }
          return poolFactory(8, s, e);
        })();
      function bezFunction() {
        var s = Math;
        function e(et, rt, st, at, ct, it) {
          var lt = et * at + rt * ct + st * it - ct * at - it * et - st * rt;
          return lt > -0.001 && lt < 0.001;
        }
        function o(et, rt, st, at, ct, it, lt, ot, ut) {
          if (st === 0 && it === 0 && ut === 0)
            return e(et, rt, at, ct, lt, ot);
          var pt = s.sqrt(
              s.pow(at - et, 2) + s.pow(ct - rt, 2) + s.pow(it - st, 2)
            ),
            ft = s.sqrt(
              s.pow(lt - et, 2) + s.pow(ot - rt, 2) + s.pow(ut - st, 2)
            ),
            gt = s.sqrt(
              s.pow(lt - at, 2) + s.pow(ot - ct, 2) + s.pow(ut - it, 2)
            ),
            xt;
          return (
            pt > ft
              ? pt > gt
                ? (xt = pt - ft - gt)
                : (xt = gt - ft - pt)
              : gt > ft
              ? (xt = gt - ft - pt)
              : (xt = ft - pt - gt),
            xt > -1e-4 && xt < 1e-4
          );
        }
        var a = (function () {
          return function (et, rt, st, at) {
            var ct = getDefaultCurveSegments(),
              it,
              lt,
              ot,
              ut,
              pt,
              ft = 0,
              gt,
              xt = [],
              _t = [],
              St = bezierLengthPool.newElement();
            for (ot = st.length, it = 0; it < ct; it += 1) {
              for (pt = it / (ct - 1), gt = 0, lt = 0; lt < ot; lt += 1)
                (ut =
                  bmPow(1 - pt, 3) * et[lt] +
                  3 * bmPow(1 - pt, 2) * pt * st[lt] +
                  3 * (1 - pt) * bmPow(pt, 2) * at[lt] +
                  bmPow(pt, 3) * rt[lt]),
                  (xt[lt] = ut),
                  _t[lt] !== null && (gt += bmPow(xt[lt] - _t[lt], 2)),
                  (_t[lt] = xt[lt]);
              gt && ((gt = bmSqrt(gt)), (ft += gt)),
                (St.percents[it] = pt),
                (St.lengths[it] = ft);
            }
            return (St.addedLength = ft), St;
          };
        })();
        function c(et) {
          var rt = segmentsLengthPool.newElement(),
            st = et.c,
            at = et.v,
            ct = et.o,
            it = et.i,
            lt,
            ot = et._length,
            ut = rt.lengths,
            pt = 0;
          for (lt = 0; lt < ot - 1; lt += 1)
            (ut[lt] = a(at[lt], at[lt + 1], ct[lt], it[lt + 1])),
              (pt += ut[lt].addedLength);
          return (
            st &&
              ot &&
              ((ut[lt] = a(at[lt], at[0], ct[lt], it[0])),
              (pt += ut[lt].addedLength)),
            (rt.totalLength = pt),
            rt
          );
        }
        function d(et) {
          (this.segmentLength = 0), (this.points = new Array(et));
        }
        function g(et, rt) {
          (this.partialLength = et), (this.point = rt);
        }
        var _ = (function () {
          var et = {};
          return function (rt, st, at, ct) {
            var it = (
              rt[0] +
              "_" +
              rt[1] +
              "_" +
              st[0] +
              "_" +
              st[1] +
              "_" +
              at[0] +
              "_" +
              at[1] +
              "_" +
              ct[0] +
              "_" +
              ct[1]
            ).replace(/\./g, "p");
            if (!et[it]) {
              var lt = getDefaultCurveSegments(),
                ot,
                ut,
                pt,
                ft,
                gt,
                xt = 0,
                _t,
                St,
                Mt = null;
              rt.length === 2 &&
                (rt[0] !== st[0] || rt[1] !== st[1]) &&
                e(rt[0], rt[1], st[0], st[1], rt[0] + at[0], rt[1] + at[1]) &&
                e(rt[0], rt[1], st[0], st[1], st[0] + ct[0], st[1] + ct[1]) &&
                (lt = 2);
              var Rt = new d(lt);
              for (pt = at.length, ot = 0; ot < lt; ot += 1) {
                for (
                  St = createSizedArray(pt), gt = ot / (lt - 1), _t = 0, ut = 0;
                  ut < pt;
                  ut += 1
                )
                  (ft =
                    bmPow(1 - gt, 3) * rt[ut] +
                    3 * bmPow(1 - gt, 2) * gt * (rt[ut] + at[ut]) +
                    3 * (1 - gt) * bmPow(gt, 2) * (st[ut] + ct[ut]) +
                    bmPow(gt, 3) * st[ut]),
                    (St[ut] = ft),
                    Mt !== null && (_t += bmPow(St[ut] - Mt[ut], 2));
                (_t = bmSqrt(_t)),
                  (xt += _t),
                  (Rt.points[ot] = new g(_t, St)),
                  (Mt = St);
              }
              (Rt.segmentLength = xt), (et[it] = Rt);
            }
            return et[it];
          };
        })();
        function b(et, rt) {
          var st = rt.percents,
            at = rt.lengths,
            ct = st.length,
            it = bmFloor((ct - 1) * et),
            lt = et * rt.addedLength,
            ot = 0;
          if (it === ct - 1 || it === 0 || lt === at[it]) return st[it];
          for (var ut = at[it] > lt ? -1 : 1, pt = !0; pt; )
            if (
              (at[it] <= lt && at[it + 1] > lt
                ? ((ot = (lt - at[it]) / (at[it + 1] - at[it])), (pt = !1))
                : (it += ut),
              it < 0 || it >= ct - 1)
            ) {
              if (it === ct - 1) return st[it];
              pt = !1;
            }
          return st[it] + (st[it + 1] - st[it]) * ot;
        }
        function j(et, rt, st, at, ct, it) {
          var lt = b(ct, it),
            ot = 1 - lt,
            ut =
              s.round(
                (ot * ot * ot * et[0] +
                  (lt * ot * ot + ot * lt * ot + ot * ot * lt) * st[0] +
                  (lt * lt * ot + ot * lt * lt + lt * ot * lt) * at[0] +
                  lt * lt * lt * rt[0]) *
                  1e3
              ) / 1e3,
            pt =
              s.round(
                (ot * ot * ot * et[1] +
                  (lt * ot * ot + ot * lt * ot + ot * ot * lt) * st[1] +
                  (lt * lt * ot + ot * lt * lt + lt * ot * lt) * at[1] +
                  lt * lt * lt * rt[1]) *
                  1e3
              ) / 1e3;
          return [ut, pt];
        }
        var $ = createTypedArray("float32", 8);
        function _e(et, rt, st, at, ct, it, lt) {
          ct < 0 ? (ct = 0) : ct > 1 && (ct = 1);
          var ot = b(ct, lt);
          it = it > 1 ? 1 : it;
          var ut = b(it, lt),
            pt,
            ft = et.length,
            gt = 1 - ot,
            xt = 1 - ut,
            _t = gt * gt * gt,
            St = ot * gt * gt * 3,
            Mt = ot * ot * gt * 3,
            Rt = ot * ot * ot,
            Ft = gt * gt * xt,
            Ot = ot * gt * xt + gt * ot * xt + gt * gt * ut,
            Lt = ot * ot * xt + gt * ot * ut + ot * gt * ut,
            Et = ot * ot * ut,
            bt = gt * xt * xt,
            mt = ot * xt * xt + gt * ut * xt + gt * xt * ut,
            vt = ot * ut * xt + gt * ut * ut + ot * xt * ut,
            Ct = ot * ut * ut,
            Tt = xt * xt * xt,
            Dt = ut * xt * xt + xt * ut * xt + xt * xt * ut,
            Wt = ut * ut * xt + xt * ut * ut + ut * xt * ut,
            Pt = ut * ut * ut;
          for (pt = 0; pt < ft; pt += 1)
            ($[pt * 4] =
              s.round(
                (_t * et[pt] + St * st[pt] + Mt * at[pt] + Rt * rt[pt]) * 1e3
              ) / 1e3),
              ($[pt * 4 + 1] =
                s.round(
                  (Ft * et[pt] + Ot * st[pt] + Lt * at[pt] + Et * rt[pt]) * 1e3
                ) / 1e3),
              ($[pt * 4 + 2] =
                s.round(
                  (bt * et[pt] + mt * st[pt] + vt * at[pt] + Ct * rt[pt]) * 1e3
                ) / 1e3),
              ($[pt * 4 + 3] =
                s.round(
                  (Tt * et[pt] + Dt * st[pt] + Wt * at[pt] + Pt * rt[pt]) * 1e3
                ) / 1e3);
          return $;
        }
        return {
          getSegmentsLength: c,
          getNewSegment: _e,
          getPointInSegment: j,
          buildBezierData: _,
          pointOnLine2D: e,
          pointOnLine3D: o,
        };
      }
      var bez = bezFunction(),
        initFrame = initialDefaultFrame,
        mathAbs = Math.abs;
      function interpolateValue(s, e) {
        var o = this.offsetTime,
          a;
        this.propType === "multidimensional" &&
          (a = createTypedArray("float32", this.pv.length));
        for (
          var c = e.lastIndex,
            d = c,
            g = this.keyframes.length - 1,
            _ = !0,
            b,
            j,
            $;
          _;

        ) {
          if (
            ((b = this.keyframes[d]),
            (j = this.keyframes[d + 1]),
            d === g - 1 && s >= j.t - o)
          ) {
            b.h && (b = j), (c = 0);
            break;
          }
          if (j.t - o > s) {
            c = d;
            break;
          }
          d < g - 1 ? (d += 1) : ((c = 0), (_ = !1));
        }
        $ = this.keyframesMetadata[d] || {};
        var _e,
          et,
          rt,
          st,
          at,
          ct,
          it = j.t - o,
          lt = b.t - o,
          ot;
        if (b.to) {
          $.bezierData ||
            ($.bezierData = bez.buildBezierData(b.s, j.s || b.e, b.to, b.ti));
          var ut = $.bezierData;
          if (s >= it || s < lt) {
            var pt = s >= it ? ut.points.length - 1 : 0;
            for (et = ut.points[pt].point.length, _e = 0; _e < et; _e += 1)
              a[_e] = ut.points[pt].point[_e];
          } else {
            $.__fnct
              ? (ct = $.__fnct)
              : ((ct = BezierFactory.getBezierEasing(
                  b.o.x,
                  b.o.y,
                  b.i.x,
                  b.i.y,
                  b.n
                ).get),
                ($.__fnct = ct)),
              (rt = ct((s - lt) / (it - lt)));
            var ft = ut.segmentLength * rt,
              gt,
              xt =
                e.lastFrame < s && e._lastKeyframeIndex === d
                  ? e._lastAddedLength
                  : 0;
            for (
              at =
                e.lastFrame < s && e._lastKeyframeIndex === d
                  ? e._lastPoint
                  : 0,
                _ = !0,
                st = ut.points.length;
              _;

            ) {
              if (
                ((xt += ut.points[at].partialLength),
                ft === 0 || rt === 0 || at === ut.points.length - 1)
              ) {
                for (et = ut.points[at].point.length, _e = 0; _e < et; _e += 1)
                  a[_e] = ut.points[at].point[_e];
                break;
              } else if (
                ft >= xt &&
                ft < xt + ut.points[at + 1].partialLength
              ) {
                for (
                  gt = (ft - xt) / ut.points[at + 1].partialLength,
                    et = ut.points[at].point.length,
                    _e = 0;
                  _e < et;
                  _e += 1
                )
                  a[_e] =
                    ut.points[at].point[_e] +
                    (ut.points[at + 1].point[_e] - ut.points[at].point[_e]) *
                      gt;
                break;
              }
              at < st - 1 ? (at += 1) : (_ = !1);
            }
            (e._lastPoint = at),
              (e._lastAddedLength = xt - ut.points[at].partialLength),
              (e._lastKeyframeIndex = d);
          }
        } else {
          var _t, St, Mt, Rt, Ft;
          if (((g = b.s.length), (ot = j.s || b.e), this.sh && b.h !== 1))
            if (s >= it) (a[0] = ot[0]), (a[1] = ot[1]), (a[2] = ot[2]);
            else if (s <= lt) (a[0] = b.s[0]), (a[1] = b.s[1]), (a[2] = b.s[2]);
            else {
              var Ot = createQuaternion(b.s),
                Lt = createQuaternion(ot),
                Et = (s - lt) / (it - lt);
              quaternionToEuler(a, slerp(Ot, Lt, Et));
            }
          else
            for (d = 0; d < g; d += 1)
              b.h !== 1 &&
                (s >= it
                  ? (rt = 1)
                  : s < lt
                  ? (rt = 0)
                  : (b.o.x.constructor === Array
                      ? ($.__fnct || ($.__fnct = []),
                        $.__fnct[d]
                          ? (ct = $.__fnct[d])
                          : ((_t = b.o.x[d] === void 0 ? b.o.x[0] : b.o.x[d]),
                            (St = b.o.y[d] === void 0 ? b.o.y[0] : b.o.y[d]),
                            (Mt = b.i.x[d] === void 0 ? b.i.x[0] : b.i.x[d]),
                            (Rt = b.i.y[d] === void 0 ? b.i.y[0] : b.i.y[d]),
                            (ct = BezierFactory.getBezierEasing(
                              _t,
                              St,
                              Mt,
                              Rt
                            ).get),
                            ($.__fnct[d] = ct)))
                      : $.__fnct
                      ? (ct = $.__fnct)
                      : ((_t = b.o.x),
                        (St = b.o.y),
                        (Mt = b.i.x),
                        (Rt = b.i.y),
                        (ct = BezierFactory.getBezierEasing(
                          _t,
                          St,
                          Mt,
                          Rt
                        ).get),
                        (b.keyframeMetadata = ct)),
                    (rt = ct((s - lt) / (it - lt))))),
                (ot = j.s || b.e),
                (Ft = b.h === 1 ? b.s[d] : b.s[d] + (ot[d] - b.s[d]) * rt),
                this.propType === "multidimensional" ? (a[d] = Ft) : (a = Ft);
        }
        return (e.lastIndex = c), a;
      }
      function slerp(s, e, o) {
        var a = [],
          c = s[0],
          d = s[1],
          g = s[2],
          _ = s[3],
          b = e[0],
          j = e[1],
          $ = e[2],
          _e = e[3],
          et,
          rt,
          st,
          at,
          ct;
        return (
          (rt = c * b + d * j + g * $ + _ * _e),
          rt < 0 && ((rt = -rt), (b = -b), (j = -j), ($ = -$), (_e = -_e)),
          1 - rt > 1e-6
            ? ((et = Math.acos(rt)),
              (st = Math.sin(et)),
              (at = Math.sin((1 - o) * et) / st),
              (ct = Math.sin(o * et) / st))
            : ((at = 1 - o), (ct = o)),
          (a[0] = at * c + ct * b),
          (a[1] = at * d + ct * j),
          (a[2] = at * g + ct * $),
          (a[3] = at * _ + ct * _e),
          a
        );
      }
      function quaternionToEuler(s, e) {
        var o = e[0],
          a = e[1],
          c = e[2],
          d = e[3],
          g = Math.atan2(2 * a * d - 2 * o * c, 1 - 2 * a * a - 2 * c * c),
          _ = Math.asin(2 * o * a + 2 * c * d),
          b = Math.atan2(2 * o * d - 2 * a * c, 1 - 2 * o * o - 2 * c * c);
        (s[0] = g / degToRads), (s[1] = _ / degToRads), (s[2] = b / degToRads);
      }
      function createQuaternion(s) {
        var e = s[0] * degToRads,
          o = s[1] * degToRads,
          a = s[2] * degToRads,
          c = Math.cos(e / 2),
          d = Math.cos(o / 2),
          g = Math.cos(a / 2),
          _ = Math.sin(e / 2),
          b = Math.sin(o / 2),
          j = Math.sin(a / 2),
          $ = c * d * g - _ * b * j,
          _e = _ * b * g + c * d * j,
          et = _ * d * g + c * b * j,
          rt = c * b * g - _ * d * j;
        return [_e, et, rt, $];
      }
      function getValueAtCurrentTime() {
        var s = this.comp.renderedFrame - this.offsetTime,
          e = this.keyframes[0].t - this.offsetTime,
          o = this.keyframes[this.keyframes.length - 1].t - this.offsetTime;
        if (
          !(
            s === this._caching.lastFrame ||
            (this._caching.lastFrame !== initFrame &&
              ((this._caching.lastFrame >= o && s >= o) ||
                (this._caching.lastFrame < e && s < e)))
          )
        ) {
          this._caching.lastFrame >= s &&
            ((this._caching._lastKeyframeIndex = -1),
            (this._caching.lastIndex = 0));
          var a = this.interpolateValue(s, this._caching);
          this.pv = a;
        }
        return (this._caching.lastFrame = s), this.pv;
      }
      function setVValue(s) {
        var e;
        if (this.propType === "unidimensional")
          (e = s * this.mult),
            mathAbs(this.v - e) > 1e-5 && ((this.v = e), (this._mdf = !0));
        else
          for (var o = 0, a = this.v.length; o < a; )
            (e = s[o] * this.mult),
              mathAbs(this.v[o] - e) > 1e-5 &&
                ((this.v[o] = e), (this._mdf = !0)),
              (o += 1);
      }
      function processEffectsSequence() {
        if (
          !(
            this.elem.globalData.frameId === this.frameId ||
            !this.effectsSequence.length
          )
        ) {
          if (this.lock) {
            this.setVValue(this.pv);
            return;
          }
          (this.lock = !0), (this._mdf = this._isFirstFrame);
          var s,
            e = this.effectsSequence.length,
            o = this.kf ? this.pv : this.data.k;
          for (s = 0; s < e; s += 1) o = this.effectsSequence[s](o);
          this.setVValue(o),
            (this._isFirstFrame = !1),
            (this.lock = !1),
            (this.frameId = this.elem.globalData.frameId);
        }
      }
      function addEffect(s) {
        this.effectsSequence.push(s), this.container.addDynamicProperty(this);
      }
      function ValueProperty(s, e, o, a) {
        (this.propType = "unidimensional"),
          (this.mult = o || 1),
          (this.data = e),
          (this.v = o ? e.k * o : e.k),
          (this.pv = e.k),
          (this._mdf = !1),
          (this.elem = s),
          (this.container = a),
          (this.comp = s.comp),
          (this.k = !1),
          (this.kf = !1),
          (this.vel = 0),
          (this.effectsSequence = []),
          (this._isFirstFrame = !0),
          (this.getValue = processEffectsSequence),
          (this.setVValue = setVValue),
          (this.addEffect = addEffect);
      }
      function MultiDimensionalProperty(s, e, o, a) {
        (this.propType = "multidimensional"),
          (this.mult = o || 1),
          (this.data = e),
          (this._mdf = !1),
          (this.elem = s),
          (this.container = a),
          (this.comp = s.comp),
          (this.k = !1),
          (this.kf = !1),
          (this.frameId = -1);
        var c,
          d = e.k.length;
        for (
          this.v = createTypedArray("float32", d),
            this.pv = createTypedArray("float32", d),
            this.vel = createTypedArray("float32", d),
            c = 0;
          c < d;
          c += 1
        )
          (this.v[c] = e.k[c] * this.mult), (this.pv[c] = e.k[c]);
        (this._isFirstFrame = !0),
          (this.effectsSequence = []),
          (this.getValue = processEffectsSequence),
          (this.setVValue = setVValue),
          (this.addEffect = addEffect);
      }
      function KeyframedValueProperty(s, e, o, a) {
        (this.propType = "unidimensional"),
          (this.keyframes = e.k),
          (this.keyframesMetadata = []),
          (this.offsetTime = s.data.st),
          (this.frameId = -1),
          (this._caching = {
            lastFrame: initFrame,
            lastIndex: 0,
            value: 0,
            _lastKeyframeIndex: -1,
          }),
          (this.k = !0),
          (this.kf = !0),
          (this.data = e),
          (this.mult = o || 1),
          (this.elem = s),
          (this.container = a),
          (this.comp = s.comp),
          (this.v = initFrame),
          (this.pv = initFrame),
          (this._isFirstFrame = !0),
          (this.getValue = processEffectsSequence),
          (this.setVValue = setVValue),
          (this.interpolateValue = interpolateValue),
          (this.effectsSequence = [getValueAtCurrentTime.bind(this)]),
          (this.addEffect = addEffect);
      }
      function KeyframedMultidimensionalProperty(s, e, o, a) {
        this.propType = "multidimensional";
        var c,
          d = e.k.length,
          g,
          _,
          b,
          j;
        for (c = 0; c < d - 1; c += 1)
          e.k[c].to &&
            e.k[c].s &&
            e.k[c + 1] &&
            e.k[c + 1].s &&
            ((g = e.k[c].s),
            (_ = e.k[c + 1].s),
            (b = e.k[c].to),
            (j = e.k[c].ti),
            ((g.length === 2 &&
              !(g[0] === _[0] && g[1] === _[1]) &&
              bez.pointOnLine2D(
                g[0],
                g[1],
                _[0],
                _[1],
                g[0] + b[0],
                g[1] + b[1]
              ) &&
              bez.pointOnLine2D(
                g[0],
                g[1],
                _[0],
                _[1],
                _[0] + j[0],
                _[1] + j[1]
              )) ||
              (g.length === 3 &&
                !(g[0] === _[0] && g[1] === _[1] && g[2] === _[2]) &&
                bez.pointOnLine3D(
                  g[0],
                  g[1],
                  g[2],
                  _[0],
                  _[1],
                  _[2],
                  g[0] + b[0],
                  g[1] + b[1],
                  g[2] + b[2]
                ) &&
                bez.pointOnLine3D(
                  g[0],
                  g[1],
                  g[2],
                  _[0],
                  _[1],
                  _[2],
                  _[0] + j[0],
                  _[1] + j[1],
                  _[2] + j[2]
                ))) &&
              ((e.k[c].to = null), (e.k[c].ti = null)),
            g[0] === _[0] &&
              g[1] === _[1] &&
              b[0] === 0 &&
              b[1] === 0 &&
              j[0] === 0 &&
              j[1] === 0 &&
              (g.length === 2 || (g[2] === _[2] && b[2] === 0 && j[2] === 0)) &&
              ((e.k[c].to = null), (e.k[c].ti = null)));
        (this.effectsSequence = [getValueAtCurrentTime.bind(this)]),
          (this.data = e),
          (this.keyframes = e.k),
          (this.keyframesMetadata = []),
          (this.offsetTime = s.data.st),
          (this.k = !0),
          (this.kf = !0),
          (this._isFirstFrame = !0),
          (this.mult = o || 1),
          (this.elem = s),
          (this.container = a),
          (this.comp = s.comp),
          (this.getValue = processEffectsSequence),
          (this.setVValue = setVValue),
          (this.interpolateValue = interpolateValue),
          (this.frameId = -1);
        var $ = e.k[0].s.length;
        for (
          this.v = createTypedArray("float32", $),
            this.pv = createTypedArray("float32", $),
            c = 0;
          c < $;
          c += 1
        )
          (this.v[c] = initFrame), (this.pv[c] = initFrame);
        (this._caching = {
          lastFrame: initFrame,
          lastIndex: 0,
          value: createTypedArray("float32", $),
        }),
          (this.addEffect = addEffect);
      }
      var PropertyFactory = (function () {
        function s(o, a, c, d, g) {
          a.sid && (a = o.globalData.slotManager.getProp(a));
          var _;
          if (!a.k.length) _ = new ValueProperty(o, a, d, g);
          else if (typeof a.k[0] == "number")
            _ = new MultiDimensionalProperty(o, a, d, g);
          else
            switch (c) {
              case 0:
                _ = new KeyframedValueProperty(o, a, d, g);
                break;
              case 1:
                _ = new KeyframedMultidimensionalProperty(o, a, d, g);
                break;
            }
          return _.effectsSequence.length && g.addDynamicProperty(_), _;
        }
        var e = { getProp: s };
        return e;
      })();
      function DynamicPropertyContainer() {}
      DynamicPropertyContainer.prototype = {
        addDynamicProperty: function (e) {
          this.dynamicProperties.indexOf(e) === -1 &&
            (this.dynamicProperties.push(e),
            this.container.addDynamicProperty(this),
            (this._isAnimated = !0));
        },
        iterateDynamicProperties: function () {
          this._mdf = !1;
          var e,
            o = this.dynamicProperties.length;
          for (e = 0; e < o; e += 1)
            this.dynamicProperties[e].getValue(),
              this.dynamicProperties[e]._mdf && (this._mdf = !0);
        },
        initDynamicPropertyContainer: function (e) {
          (this.container = e),
            (this.dynamicProperties = []),
            (this._mdf = !1),
            (this._isAnimated = !1);
        },
      };
      var pointPool = (function () {
        function s() {
          return createTypedArray("float32", 2);
        }
        return poolFactory(8, s);
      })();
      function ShapePath() {
        (this.c = !1),
          (this._length = 0),
          (this._maxLength = 8),
          (this.v = createSizedArray(this._maxLength)),
          (this.o = createSizedArray(this._maxLength)),
          (this.i = createSizedArray(this._maxLength));
      }
      (ShapePath.prototype.setPathData = function (s, e) {
        (this.c = s), this.setLength(e);
        for (var o = 0; o < e; )
          (this.v[o] = pointPool.newElement()),
            (this.o[o] = pointPool.newElement()),
            (this.i[o] = pointPool.newElement()),
            (o += 1);
      }),
        (ShapePath.prototype.setLength = function (s) {
          for (; this._maxLength < s; ) this.doubleArrayLength();
          this._length = s;
        }),
        (ShapePath.prototype.doubleArrayLength = function () {
          (this.v = this.v.concat(createSizedArray(this._maxLength))),
            (this.i = this.i.concat(createSizedArray(this._maxLength))),
            (this.o = this.o.concat(createSizedArray(this._maxLength))),
            (this._maxLength *= 2);
        }),
        (ShapePath.prototype.setXYAt = function (s, e, o, a, c) {
          var d;
          switch (
            ((this._length = Math.max(this._length, a + 1)),
            this._length >= this._maxLength && this.doubleArrayLength(),
            o)
          ) {
            case "v":
              d = this.v;
              break;
            case "i":
              d = this.i;
              break;
            case "o":
              d = this.o;
              break;
            default:
              d = [];
              break;
          }
          (!d[a] || (d[a] && !c)) && (d[a] = pointPool.newElement()),
            (d[a][0] = s),
            (d[a][1] = e);
        }),
        (ShapePath.prototype.setTripleAt = function (s, e, o, a, c, d, g, _) {
          this.setXYAt(s, e, "v", g, _),
            this.setXYAt(o, a, "o", g, _),
            this.setXYAt(c, d, "i", g, _);
        }),
        (ShapePath.prototype.reverse = function () {
          var s = new ShapePath();
          s.setPathData(this.c, this._length);
          var e = this.v,
            o = this.o,
            a = this.i,
            c = 0;
          this.c &&
            (s.setTripleAt(
              e[0][0],
              e[0][1],
              a[0][0],
              a[0][1],
              o[0][0],
              o[0][1],
              0,
              !1
            ),
            (c = 1));
          var d = this._length - 1,
            g = this._length,
            _;
          for (_ = c; _ < g; _ += 1)
            s.setTripleAt(
              e[d][0],
              e[d][1],
              a[d][0],
              a[d][1],
              o[d][0],
              o[d][1],
              _,
              !1
            ),
              (d -= 1);
          return s;
        }),
        (ShapePath.prototype.length = function () {
          return this._length;
        });
      var shapePool = (function () {
        function s() {
          return new ShapePath();
        }
        function e(c) {
          var d = c._length,
            g;
          for (g = 0; g < d; g += 1)
            pointPool.release(c.v[g]),
              pointPool.release(c.i[g]),
              pointPool.release(c.o[g]),
              (c.v[g] = null),
              (c.i[g] = null),
              (c.o[g] = null);
          (c._length = 0), (c.c = !1);
        }
        function o(c) {
          var d = a.newElement(),
            g,
            _ = c._length === void 0 ? c.v.length : c._length;
          for (d.setLength(_), d.c = c.c, g = 0; g < _; g += 1)
            d.setTripleAt(
              c.v[g][0],
              c.v[g][1],
              c.o[g][0],
              c.o[g][1],
              c.i[g][0],
              c.i[g][1],
              g
            );
          return d;
        }
        var a = poolFactory(4, s, e);
        return (a.clone = o), a;
      })();
      function ShapeCollection() {
        (this._length = 0),
          (this._maxLength = 4),
          (this.shapes = createSizedArray(this._maxLength));
      }
      (ShapeCollection.prototype.addShape = function (s) {
        this._length === this._maxLength &&
          ((this.shapes = this.shapes.concat(
            createSizedArray(this._maxLength)
          )),
          (this._maxLength *= 2)),
          (this.shapes[this._length] = s),
          (this._length += 1);
      }),
        (ShapeCollection.prototype.releaseShapes = function () {
          var s;
          for (s = 0; s < this._length; s += 1)
            shapePool.release(this.shapes[s]);
          this._length = 0;
        });
      var shapeCollectionPool = (function () {
          var s = { newShapeCollection: c, release: d },
            e = 0,
            o = 4,
            a = createSizedArray(o);
          function c() {
            var g;
            return e ? ((e -= 1), (g = a[e])) : (g = new ShapeCollection()), g;
          }
          function d(g) {
            var _,
              b = g._length;
            for (_ = 0; _ < b; _ += 1) shapePool.release(g.shapes[_]);
            (g._length = 0),
              e === o && ((a = pooling.double(a)), (o *= 2)),
              (a[e] = g),
              (e += 1);
          }
          return s;
        })(),
        ShapePropertyFactory = (function () {
          var s = -999999;
          function e(it, lt, ot) {
            var ut = ot.lastIndex,
              pt,
              ft,
              gt,
              xt,
              _t,
              St,
              Mt,
              Rt,
              Ft,
              Ot = this.keyframes;
            if (it < Ot[0].t - this.offsetTime)
              (pt = Ot[0].s[0]), (gt = !0), (ut = 0);
            else if (it >= Ot[Ot.length - 1].t - this.offsetTime)
              (pt = Ot[Ot.length - 1].s
                ? Ot[Ot.length - 1].s[0]
                : Ot[Ot.length - 2].e[0]),
                (gt = !0);
            else {
              for (
                var Lt = ut, Et = Ot.length - 1, bt = !0, mt, vt, Ct;
                bt &&
                ((mt = Ot[Lt]),
                (vt = Ot[Lt + 1]),
                !(vt.t - this.offsetTime > it));

              )
                Lt < Et - 1 ? (Lt += 1) : (bt = !1);
              if (
                ((Ct = this.keyframesMetadata[Lt] || {}),
                (gt = mt.h === 1),
                (ut = Lt),
                !gt)
              ) {
                if (it >= vt.t - this.offsetTime) Rt = 1;
                else if (it < mt.t - this.offsetTime) Rt = 0;
                else {
                  var Tt;
                  Ct.__fnct
                    ? (Tt = Ct.__fnct)
                    : ((Tt = BezierFactory.getBezierEasing(
                        mt.o.x,
                        mt.o.y,
                        mt.i.x,
                        mt.i.y
                      ).get),
                      (Ct.__fnct = Tt)),
                    (Rt = Tt(
                      (it - (mt.t - this.offsetTime)) /
                        (vt.t - this.offsetTime - (mt.t - this.offsetTime))
                    ));
                }
                ft = vt.s ? vt.s[0] : mt.e[0];
              }
              pt = mt.s[0];
            }
            for (
              St = lt._length, Mt = pt.i[0].length, ot.lastIndex = ut, xt = 0;
              xt < St;
              xt += 1
            )
              for (_t = 0; _t < Mt; _t += 1)
                (Ft = gt
                  ? pt.i[xt][_t]
                  : pt.i[xt][_t] + (ft.i[xt][_t] - pt.i[xt][_t]) * Rt),
                  (lt.i[xt][_t] = Ft),
                  (Ft = gt
                    ? pt.o[xt][_t]
                    : pt.o[xt][_t] + (ft.o[xt][_t] - pt.o[xt][_t]) * Rt),
                  (lt.o[xt][_t] = Ft),
                  (Ft = gt
                    ? pt.v[xt][_t]
                    : pt.v[xt][_t] + (ft.v[xt][_t] - pt.v[xt][_t]) * Rt),
                  (lt.v[xt][_t] = Ft);
          }
          function o() {
            var it = this.comp.renderedFrame - this.offsetTime,
              lt = this.keyframes[0].t - this.offsetTime,
              ot =
                this.keyframes[this.keyframes.length - 1].t - this.offsetTime,
              ut = this._caching.lastFrame;
            return (
              (ut !== s && ((ut < lt && it < lt) || (ut > ot && it > ot))) ||
                ((this._caching.lastIndex =
                  ut < it ? this._caching.lastIndex : 0),
                this.interpolateShape(it, this.pv, this._caching)),
              (this._caching.lastFrame = it),
              this.pv
            );
          }
          function a() {
            this.paths = this.localShapeCollection;
          }
          function c(it, lt) {
            if (it._length !== lt._length || it.c !== lt.c) return !1;
            var ot,
              ut = it._length;
            for (ot = 0; ot < ut; ot += 1)
              if (
                it.v[ot][0] !== lt.v[ot][0] ||
                it.v[ot][1] !== lt.v[ot][1] ||
                it.o[ot][0] !== lt.o[ot][0] ||
                it.o[ot][1] !== lt.o[ot][1] ||
                it.i[ot][0] !== lt.i[ot][0] ||
                it.i[ot][1] !== lt.i[ot][1]
              )
                return !1;
            return !0;
          }
          function d(it) {
            c(this.v, it) ||
              ((this.v = shapePool.clone(it)),
              this.localShapeCollection.releaseShapes(),
              this.localShapeCollection.addShape(this.v),
              (this._mdf = !0),
              (this.paths = this.localShapeCollection));
          }
          function g() {
            if (this.elem.globalData.frameId !== this.frameId) {
              if (!this.effectsSequence.length) {
                this._mdf = !1;
                return;
              }
              if (this.lock) {
                this.setVValue(this.pv);
                return;
              }
              (this.lock = !0), (this._mdf = !1);
              var it;
              this.kf
                ? (it = this.pv)
                : this.data.ks
                ? (it = this.data.ks.k)
                : (it = this.data.pt.k);
              var lt,
                ot = this.effectsSequence.length;
              for (lt = 0; lt < ot; lt += 1) it = this.effectsSequence[lt](it);
              this.setVValue(it),
                (this.lock = !1),
                (this.frameId = this.elem.globalData.frameId);
            }
          }
          function _(it, lt, ot) {
            (this.propType = "shape"),
              (this.comp = it.comp),
              (this.container = it),
              (this.elem = it),
              (this.data = lt),
              (this.k = !1),
              (this.kf = !1),
              (this._mdf = !1);
            var ut = ot === 3 ? lt.pt.k : lt.ks.k;
            (this.v = shapePool.clone(ut)),
              (this.pv = shapePool.clone(this.v)),
              (this.localShapeCollection =
                shapeCollectionPool.newShapeCollection()),
              (this.paths = this.localShapeCollection),
              this.paths.addShape(this.v),
              (this.reset = a),
              (this.effectsSequence = []);
          }
          function b(it) {
            this.effectsSequence.push(it),
              this.container.addDynamicProperty(this);
          }
          (_.prototype.interpolateShape = e),
            (_.prototype.getValue = g),
            (_.prototype.setVValue = d),
            (_.prototype.addEffect = b);
          function j(it, lt, ot) {
            (this.propType = "shape"),
              (this.comp = it.comp),
              (this.elem = it),
              (this.container = it),
              (this.offsetTime = it.data.st),
              (this.keyframes = ot === 3 ? lt.pt.k : lt.ks.k),
              (this.keyframesMetadata = []),
              (this.k = !0),
              (this.kf = !0);
            var ut = this.keyframes[0].s[0].i.length;
            (this.v = shapePool.newElement()),
              this.v.setPathData(this.keyframes[0].s[0].c, ut),
              (this.pv = shapePool.clone(this.v)),
              (this.localShapeCollection =
                shapeCollectionPool.newShapeCollection()),
              (this.paths = this.localShapeCollection),
              this.paths.addShape(this.v),
              (this.lastFrame = s),
              (this.reset = a),
              (this._caching = { lastFrame: s, lastIndex: 0 }),
              (this.effectsSequence = [o.bind(this)]);
          }
          (j.prototype.getValue = g),
            (j.prototype.interpolateShape = e),
            (j.prototype.setVValue = d),
            (j.prototype.addEffect = b);
          var $ = (function () {
              var it = roundCorner;
              function lt(ot, ut) {
                (this.v = shapePool.newElement()),
                  this.v.setPathData(!0, 4),
                  (this.localShapeCollection =
                    shapeCollectionPool.newShapeCollection()),
                  (this.paths = this.localShapeCollection),
                  this.localShapeCollection.addShape(this.v),
                  (this.d = ut.d),
                  (this.elem = ot),
                  (this.comp = ot.comp),
                  (this.frameId = -1),
                  this.initDynamicPropertyContainer(ot),
                  (this.p = PropertyFactory.getProp(ot, ut.p, 1, 0, this)),
                  (this.s = PropertyFactory.getProp(ot, ut.s, 1, 0, this)),
                  this.dynamicProperties.length
                    ? (this.k = !0)
                    : ((this.k = !1), this.convertEllToPath());
              }
              return (
                (lt.prototype = {
                  reset: a,
                  getValue: function () {
                    this.elem.globalData.frameId !== this.frameId &&
                      ((this.frameId = this.elem.globalData.frameId),
                      this.iterateDynamicProperties(),
                      this._mdf && this.convertEllToPath());
                  },
                  convertEllToPath: function () {
                    var ut = this.p.v[0],
                      pt = this.p.v[1],
                      ft = this.s.v[0] / 2,
                      gt = this.s.v[1] / 2,
                      xt = this.d !== 3,
                      _t = this.v;
                    (_t.v[0][0] = ut),
                      (_t.v[0][1] = pt - gt),
                      (_t.v[1][0] = xt ? ut + ft : ut - ft),
                      (_t.v[1][1] = pt),
                      (_t.v[2][0] = ut),
                      (_t.v[2][1] = pt + gt),
                      (_t.v[3][0] = xt ? ut - ft : ut + ft),
                      (_t.v[3][1] = pt),
                      (_t.i[0][0] = xt ? ut - ft * it : ut + ft * it),
                      (_t.i[0][1] = pt - gt),
                      (_t.i[1][0] = xt ? ut + ft : ut - ft),
                      (_t.i[1][1] = pt - gt * it),
                      (_t.i[2][0] = xt ? ut + ft * it : ut - ft * it),
                      (_t.i[2][1] = pt + gt),
                      (_t.i[3][0] = xt ? ut - ft : ut + ft),
                      (_t.i[3][1] = pt + gt * it),
                      (_t.o[0][0] = xt ? ut + ft * it : ut - ft * it),
                      (_t.o[0][1] = pt - gt),
                      (_t.o[1][0] = xt ? ut + ft : ut - ft),
                      (_t.o[1][1] = pt + gt * it),
                      (_t.o[2][0] = xt ? ut - ft * it : ut + ft * it),
                      (_t.o[2][1] = pt + gt),
                      (_t.o[3][0] = xt ? ut - ft : ut + ft),
                      (_t.o[3][1] = pt - gt * it);
                  },
                }),
                extendPrototype([DynamicPropertyContainer], lt),
                lt
              );
            })(),
            _e = (function () {
              function it(lt, ot) {
                (this.v = shapePool.newElement()),
                  this.v.setPathData(!0, 0),
                  (this.elem = lt),
                  (this.comp = lt.comp),
                  (this.data = ot),
                  (this.frameId = -1),
                  (this.d = ot.d),
                  this.initDynamicPropertyContainer(lt),
                  ot.sy === 1
                    ? ((this.ir = PropertyFactory.getProp(
                        lt,
                        ot.ir,
                        0,
                        0,
                        this
                      )),
                      (this.is = PropertyFactory.getProp(
                        lt,
                        ot.is,
                        0,
                        0.01,
                        this
                      )),
                      (this.convertToPath = this.convertStarToPath))
                    : (this.convertToPath = this.convertPolygonToPath),
                  (this.pt = PropertyFactory.getProp(lt, ot.pt, 0, 0, this)),
                  (this.p = PropertyFactory.getProp(lt, ot.p, 1, 0, this)),
                  (this.r = PropertyFactory.getProp(
                    lt,
                    ot.r,
                    0,
                    degToRads,
                    this
                  )),
                  (this.or = PropertyFactory.getProp(lt, ot.or, 0, 0, this)),
                  (this.os = PropertyFactory.getProp(lt, ot.os, 0, 0.01, this)),
                  (this.localShapeCollection =
                    shapeCollectionPool.newShapeCollection()),
                  this.localShapeCollection.addShape(this.v),
                  (this.paths = this.localShapeCollection),
                  this.dynamicProperties.length
                    ? (this.k = !0)
                    : ((this.k = !1), this.convertToPath());
              }
              return (
                (it.prototype = {
                  reset: a,
                  getValue: function () {
                    this.elem.globalData.frameId !== this.frameId &&
                      ((this.frameId = this.elem.globalData.frameId),
                      this.iterateDynamicProperties(),
                      this._mdf && this.convertToPath());
                  },
                  convertStarToPath: function () {
                    var ot = Math.floor(this.pt.v) * 2,
                      ut = (Math.PI * 2) / ot,
                      pt = !0,
                      ft = this.or.v,
                      gt = this.ir.v,
                      xt = this.os.v,
                      _t = this.is.v,
                      St = (2 * Math.PI * ft) / (ot * 2),
                      Mt = (2 * Math.PI * gt) / (ot * 2),
                      Rt,
                      Ft,
                      Ot,
                      Lt,
                      Et = -Math.PI / 2;
                    Et += this.r.v;
                    var bt = this.data.d === 3 ? -1 : 1;
                    for (this.v._length = 0, Rt = 0; Rt < ot; Rt += 1) {
                      (Ft = pt ? ft : gt),
                        (Ot = pt ? xt : _t),
                        (Lt = pt ? St : Mt);
                      var mt = Ft * Math.cos(Et),
                        vt = Ft * Math.sin(Et),
                        Ct =
                          mt === 0 && vt === 0
                            ? 0
                            : vt / Math.sqrt(mt * mt + vt * vt),
                        Tt =
                          mt === 0 && vt === 0
                            ? 0
                            : -mt / Math.sqrt(mt * mt + vt * vt);
                      (mt += +this.p.v[0]),
                        (vt += +this.p.v[1]),
                        this.v.setTripleAt(
                          mt,
                          vt,
                          mt - Ct * Lt * Ot * bt,
                          vt - Tt * Lt * Ot * bt,
                          mt + Ct * Lt * Ot * bt,
                          vt + Tt * Lt * Ot * bt,
                          Rt,
                          !0
                        ),
                        (pt = !pt),
                        (Et += ut * bt);
                    }
                  },
                  convertPolygonToPath: function () {
                    var ot = Math.floor(this.pt.v),
                      ut = (Math.PI * 2) / ot,
                      pt = this.or.v,
                      ft = this.os.v,
                      gt = (2 * Math.PI * pt) / (ot * 4),
                      xt,
                      _t = -Math.PI * 0.5,
                      St = this.data.d === 3 ? -1 : 1;
                    for (
                      _t += this.r.v, this.v._length = 0, xt = 0;
                      xt < ot;
                      xt += 1
                    ) {
                      var Mt = pt * Math.cos(_t),
                        Rt = pt * Math.sin(_t),
                        Ft =
                          Mt === 0 && Rt === 0
                            ? 0
                            : Rt / Math.sqrt(Mt * Mt + Rt * Rt),
                        Ot =
                          Mt === 0 && Rt === 0
                            ? 0
                            : -Mt / Math.sqrt(Mt * Mt + Rt * Rt);
                      (Mt += +this.p.v[0]),
                        (Rt += +this.p.v[1]),
                        this.v.setTripleAt(
                          Mt,
                          Rt,
                          Mt - Ft * gt * ft * St,
                          Rt - Ot * gt * ft * St,
                          Mt + Ft * gt * ft * St,
                          Rt + Ot * gt * ft * St,
                          xt,
                          !0
                        ),
                        (_t += ut * St);
                    }
                    (this.paths.length = 0), (this.paths[0] = this.v);
                  },
                }),
                extendPrototype([DynamicPropertyContainer], it),
                it
              );
            })(),
            et = (function () {
              function it(lt, ot) {
                (this.v = shapePool.newElement()),
                  (this.v.c = !0),
                  (this.localShapeCollection =
                    shapeCollectionPool.newShapeCollection()),
                  this.localShapeCollection.addShape(this.v),
                  (this.paths = this.localShapeCollection),
                  (this.elem = lt),
                  (this.comp = lt.comp),
                  (this.frameId = -1),
                  (this.d = ot.d),
                  this.initDynamicPropertyContainer(lt),
                  (this.p = PropertyFactory.getProp(lt, ot.p, 1, 0, this)),
                  (this.s = PropertyFactory.getProp(lt, ot.s, 1, 0, this)),
                  (this.r = PropertyFactory.getProp(lt, ot.r, 0, 0, this)),
                  this.dynamicProperties.length
                    ? (this.k = !0)
                    : ((this.k = !1), this.convertRectToPath());
              }
              return (
                (it.prototype = {
                  convertRectToPath: function () {
                    var ot = this.p.v[0],
                      ut = this.p.v[1],
                      pt = this.s.v[0] / 2,
                      ft = this.s.v[1] / 2,
                      gt = bmMin(pt, ft, this.r.v),
                      xt = gt * (1 - roundCorner);
                    (this.v._length = 0),
                      this.d === 2 || this.d === 1
                        ? (this.v.setTripleAt(
                            ot + pt,
                            ut - ft + gt,
                            ot + pt,
                            ut - ft + gt,
                            ot + pt,
                            ut - ft + xt,
                            0,
                            !0
                          ),
                          this.v.setTripleAt(
                            ot + pt,
                            ut + ft - gt,
                            ot + pt,
                            ut + ft - xt,
                            ot + pt,
                            ut + ft - gt,
                            1,
                            !0
                          ),
                          gt !== 0
                            ? (this.v.setTripleAt(
                                ot + pt - gt,
                                ut + ft,
                                ot + pt - gt,
                                ut + ft,
                                ot + pt - xt,
                                ut + ft,
                                2,
                                !0
                              ),
                              this.v.setTripleAt(
                                ot - pt + gt,
                                ut + ft,
                                ot - pt + xt,
                                ut + ft,
                                ot - pt + gt,
                                ut + ft,
                                3,
                                !0
                              ),
                              this.v.setTripleAt(
                                ot - pt,
                                ut + ft - gt,
                                ot - pt,
                                ut + ft - gt,
                                ot - pt,
                                ut + ft - xt,
                                4,
                                !0
                              ),
                              this.v.setTripleAt(
                                ot - pt,
                                ut - ft + gt,
                                ot - pt,
                                ut - ft + xt,
                                ot - pt,
                                ut - ft + gt,
                                5,
                                !0
                              ),
                              this.v.setTripleAt(
                                ot - pt + gt,
                                ut - ft,
                                ot - pt + gt,
                                ut - ft,
                                ot - pt + xt,
                                ut - ft,
                                6,
                                !0
                              ),
                              this.v.setTripleAt(
                                ot + pt - gt,
                                ut - ft,
                                ot + pt - xt,
                                ut - ft,
                                ot + pt - gt,
                                ut - ft,
                                7,
                                !0
                              ))
                            : (this.v.setTripleAt(
                                ot - pt,
                                ut + ft,
                                ot - pt + xt,
                                ut + ft,
                                ot - pt,
                                ut + ft,
                                2
                              ),
                              this.v.setTripleAt(
                                ot - pt,
                                ut - ft,
                                ot - pt,
                                ut - ft + xt,
                                ot - pt,
                                ut - ft,
                                3
                              )))
                        : (this.v.setTripleAt(
                            ot + pt,
                            ut - ft + gt,
                            ot + pt,
                            ut - ft + xt,
                            ot + pt,
                            ut - ft + gt,
                            0,
                            !0
                          ),
                          gt !== 0
                            ? (this.v.setTripleAt(
                                ot + pt - gt,
                                ut - ft,
                                ot + pt - gt,
                                ut - ft,
                                ot + pt - xt,
                                ut - ft,
                                1,
                                !0
                              ),
                              this.v.setTripleAt(
                                ot - pt + gt,
                                ut - ft,
                                ot - pt + xt,
                                ut - ft,
                                ot - pt + gt,
                                ut - ft,
                                2,
                                !0
                              ),
                              this.v.setTripleAt(
                                ot - pt,
                                ut - ft + gt,
                                ot - pt,
                                ut - ft + gt,
                                ot - pt,
                                ut - ft + xt,
                                3,
                                !0
                              ),
                              this.v.setTripleAt(
                                ot - pt,
                                ut + ft - gt,
                                ot - pt,
                                ut + ft - xt,
                                ot - pt,
                                ut + ft - gt,
                                4,
                                !0
                              ),
                              this.v.setTripleAt(
                                ot - pt + gt,
                                ut + ft,
                                ot - pt + gt,
                                ut + ft,
                                ot - pt + xt,
                                ut + ft,
                                5,
                                !0
                              ),
                              this.v.setTripleAt(
                                ot + pt - gt,
                                ut + ft,
                                ot + pt - xt,
                                ut + ft,
                                ot + pt - gt,
                                ut + ft,
                                6,
                                !0
                              ),
                              this.v.setTripleAt(
                                ot + pt,
                                ut + ft - gt,
                                ot + pt,
                                ut + ft - gt,
                                ot + pt,
                                ut + ft - xt,
                                7,
                                !0
                              ))
                            : (this.v.setTripleAt(
                                ot - pt,
                                ut - ft,
                                ot - pt + xt,
                                ut - ft,
                                ot - pt,
                                ut - ft,
                                1,
                                !0
                              ),
                              this.v.setTripleAt(
                                ot - pt,
                                ut + ft,
                                ot - pt,
                                ut + ft - xt,
                                ot - pt,
                                ut + ft,
                                2,
                                !0
                              ),
                              this.v.setTripleAt(
                                ot + pt,
                                ut + ft,
                                ot + pt - xt,
                                ut + ft,
                                ot + pt,
                                ut + ft,
                                3,
                                !0
                              )));
                  },
                  getValue: function () {
                    this.elem.globalData.frameId !== this.frameId &&
                      ((this.frameId = this.elem.globalData.frameId),
                      this.iterateDynamicProperties(),
                      this._mdf && this.convertRectToPath());
                  },
                  reset: a,
                }),
                extendPrototype([DynamicPropertyContainer], it),
                it
              );
            })();
          function rt(it, lt, ot) {
            var ut;
            if (ot === 3 || ot === 4) {
              var pt = ot === 3 ? lt.pt : lt.ks,
                ft = pt.k;
              ft.length ? (ut = new j(it, lt, ot)) : (ut = new _(it, lt, ot));
            } else
              ot === 5
                ? (ut = new et(it, lt))
                : ot === 6
                ? (ut = new $(it, lt))
                : ot === 7 && (ut = new _e(it, lt));
            return ut.k && it.addDynamicProperty(ut), ut;
          }
          function st() {
            return _;
          }
          function at() {
            return j;
          }
          var ct = {};
          return (
            (ct.getShapeProp = rt),
            (ct.getConstructorFunction = st),
            (ct.getKeyframedConstructorFunction = at),
            ct
          );
        })();
      /*!
 Transformation Matrix v2.0
 (c) Epistemex 2014-2015
 www.epistemex.com
 By Ken Fyrstenberg
 Contributions by leeoniya.
 License: MIT, header required.
 */ var Matrix = (function () {
        var s = Math.cos,
          e = Math.sin,
          o = Math.tan,
          a = Math.round;
        function c() {
          return (
            (this.props[0] = 1),
            (this.props[1] = 0),
            (this.props[2] = 0),
            (this.props[3] = 0),
            (this.props[4] = 0),
            (this.props[5] = 1),
            (this.props[6] = 0),
            (this.props[7] = 0),
            (this.props[8] = 0),
            (this.props[9] = 0),
            (this.props[10] = 1),
            (this.props[11] = 0),
            (this.props[12] = 0),
            (this.props[13] = 0),
            (this.props[14] = 0),
            (this.props[15] = 1),
            this
          );
        }
        function d(mt) {
          if (mt === 0) return this;
          var vt = s(mt),
            Ct = e(mt);
          return this._t(vt, -Ct, 0, 0, Ct, vt, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
        }
        function g(mt) {
          if (mt === 0) return this;
          var vt = s(mt),
            Ct = e(mt);
          return this._t(1, 0, 0, 0, 0, vt, -Ct, 0, 0, Ct, vt, 0, 0, 0, 0, 1);
        }
        function _(mt) {
          if (mt === 0) return this;
          var vt = s(mt),
            Ct = e(mt);
          return this._t(vt, 0, Ct, 0, 0, 1, 0, 0, -Ct, 0, vt, 0, 0, 0, 0, 1);
        }
        function b(mt) {
          if (mt === 0) return this;
          var vt = s(mt),
            Ct = e(mt);
          return this._t(vt, -Ct, 0, 0, Ct, vt, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
        }
        function j(mt, vt) {
          return this._t(1, vt, mt, 1, 0, 0);
        }
        function $(mt, vt) {
          return this.shear(o(mt), o(vt));
        }
        function _e(mt, vt) {
          var Ct = s(vt),
            Tt = e(vt);
          return this._t(Ct, Tt, 0, 0, -Tt, Ct, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)
            ._t(1, 0, 0, 0, o(mt), 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)
            ._t(Ct, -Tt, 0, 0, Tt, Ct, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
        }
        function et(mt, vt, Ct) {
          return (
            !Ct && Ct !== 0 && (Ct = 1),
            mt === 1 && vt === 1 && Ct === 1
              ? this
              : this._t(mt, 0, 0, 0, 0, vt, 0, 0, 0, 0, Ct, 0, 0, 0, 0, 1)
          );
        }
        function rt(
          mt,
          vt,
          Ct,
          Tt,
          Dt,
          Wt,
          Pt,
          Jt,
          Gt,
          en,
          _n,
          Tn,
          fn,
          pn,
          Bt,
          qt
        ) {
          return (
            (this.props[0] = mt),
            (this.props[1] = vt),
            (this.props[2] = Ct),
            (this.props[3] = Tt),
            (this.props[4] = Dt),
            (this.props[5] = Wt),
            (this.props[6] = Pt),
            (this.props[7] = Jt),
            (this.props[8] = Gt),
            (this.props[9] = en),
            (this.props[10] = _n),
            (this.props[11] = Tn),
            (this.props[12] = fn),
            (this.props[13] = pn),
            (this.props[14] = Bt),
            (this.props[15] = qt),
            this
          );
        }
        function st(mt, vt, Ct) {
          return (
            (Ct = Ct || 0),
            mt !== 0 || vt !== 0 || Ct !== 0
              ? this._t(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, mt, vt, Ct, 1)
              : this
          );
        }
        function at(
          mt,
          vt,
          Ct,
          Tt,
          Dt,
          Wt,
          Pt,
          Jt,
          Gt,
          en,
          _n,
          Tn,
          fn,
          pn,
          Bt,
          qt
        ) {
          var $t = this.props;
          if (
            mt === 1 &&
            vt === 0 &&
            Ct === 0 &&
            Tt === 0 &&
            Dt === 0 &&
            Wt === 1 &&
            Pt === 0 &&
            Jt === 0 &&
            Gt === 0 &&
            en === 0 &&
            _n === 1 &&
            Tn === 0
          )
            return (
              ($t[12] = $t[12] * mt + $t[15] * fn),
              ($t[13] = $t[13] * Wt + $t[15] * pn),
              ($t[14] = $t[14] * _n + $t[15] * Bt),
              ($t[15] *= qt),
              (this._identityCalculated = !1),
              this
            );
          var yn = $t[0],
            nn = $t[1],
            Pn = $t[2],
            xn = $t[3],
            An = $t[4],
            kt = $t[5],
            wt = $t[6],
            Kt = $t[7],
            on = $t[8],
            sn = $t[9],
            cn = $t[10],
            bn = $t[11],
            vn = $t[12],
            wn = $t[13],
            zn = $t[14],
            gn = $t[15];
          return (
            ($t[0] = yn * mt + nn * Dt + Pn * Gt + xn * fn),
            ($t[1] = yn * vt + nn * Wt + Pn * en + xn * pn),
            ($t[2] = yn * Ct + nn * Pt + Pn * _n + xn * Bt),
            ($t[3] = yn * Tt + nn * Jt + Pn * Tn + xn * qt),
            ($t[4] = An * mt + kt * Dt + wt * Gt + Kt * fn),
            ($t[5] = An * vt + kt * Wt + wt * en + Kt * pn),
            ($t[6] = An * Ct + kt * Pt + wt * _n + Kt * Bt),
            ($t[7] = An * Tt + kt * Jt + wt * Tn + Kt * qt),
            ($t[8] = on * mt + sn * Dt + cn * Gt + bn * fn),
            ($t[9] = on * vt + sn * Wt + cn * en + bn * pn),
            ($t[10] = on * Ct + sn * Pt + cn * _n + bn * Bt),
            ($t[11] = on * Tt + sn * Jt + cn * Tn + bn * qt),
            ($t[12] = vn * mt + wn * Dt + zn * Gt + gn * fn),
            ($t[13] = vn * vt + wn * Wt + zn * en + gn * pn),
            ($t[14] = vn * Ct + wn * Pt + zn * _n + gn * Bt),
            ($t[15] = vn * Tt + wn * Jt + zn * Tn + gn * qt),
            (this._identityCalculated = !1),
            this
          );
        }
        function ct(mt) {
          var vt = mt.props;
          return this.transform(
            vt[0],
            vt[1],
            vt[2],
            vt[3],
            vt[4],
            vt[5],
            vt[6],
            vt[7],
            vt[8],
            vt[9],
            vt[10],
            vt[11],
            vt[12],
            vt[13],
            vt[14],
            vt[15]
          );
        }
        function it() {
          return (
            this._identityCalculated ||
              ((this._identity = !(
                this.props[0] !== 1 ||
                this.props[1] !== 0 ||
                this.props[2] !== 0 ||
                this.props[3] !== 0 ||
                this.props[4] !== 0 ||
                this.props[5] !== 1 ||
                this.props[6] !== 0 ||
                this.props[7] !== 0 ||
                this.props[8] !== 0 ||
                this.props[9] !== 0 ||
                this.props[10] !== 1 ||
                this.props[11] !== 0 ||
                this.props[12] !== 0 ||
                this.props[13] !== 0 ||
                this.props[14] !== 0 ||
                this.props[15] !== 1
              )),
              (this._identityCalculated = !0)),
            this._identity
          );
        }
        function lt(mt) {
          for (var vt = 0; vt < 16; ) {
            if (mt.props[vt] !== this.props[vt]) return !1;
            vt += 1;
          }
          return !0;
        }
        function ot(mt) {
          var vt;
          for (vt = 0; vt < 16; vt += 1) mt.props[vt] = this.props[vt];
          return mt;
        }
        function ut(mt) {
          var vt;
          for (vt = 0; vt < 16; vt += 1) this.props[vt] = mt[vt];
        }
        function pt(mt, vt, Ct) {
          return {
            x:
              mt * this.props[0] +
              vt * this.props[4] +
              Ct * this.props[8] +
              this.props[12],
            y:
              mt * this.props[1] +
              vt * this.props[5] +
              Ct * this.props[9] +
              this.props[13],
            z:
              mt * this.props[2] +
              vt * this.props[6] +
              Ct * this.props[10] +
              this.props[14],
          };
        }
        function ft(mt, vt, Ct) {
          return (
            mt * this.props[0] +
            vt * this.props[4] +
            Ct * this.props[8] +
            this.props[12]
          );
        }
        function gt(mt, vt, Ct) {
          return (
            mt * this.props[1] +
            vt * this.props[5] +
            Ct * this.props[9] +
            this.props[13]
          );
        }
        function xt(mt, vt, Ct) {
          return (
            mt * this.props[2] +
            vt * this.props[6] +
            Ct * this.props[10] +
            this.props[14]
          );
        }
        function _t() {
          var mt =
              this.props[0] * this.props[5] - this.props[1] * this.props[4],
            vt = this.props[5] / mt,
            Ct = -this.props[1] / mt,
            Tt = -this.props[4] / mt,
            Dt = this.props[0] / mt,
            Wt =
              (this.props[4] * this.props[13] -
                this.props[5] * this.props[12]) /
              mt,
            Pt =
              -(
                this.props[0] * this.props[13] -
                this.props[1] * this.props[12]
              ) / mt,
            Jt = new Matrix();
          return (
            (Jt.props[0] = vt),
            (Jt.props[1] = Ct),
            (Jt.props[4] = Tt),
            (Jt.props[5] = Dt),
            (Jt.props[12] = Wt),
            (Jt.props[13] = Pt),
            Jt
          );
        }
        function St(mt) {
          var vt = this.getInverseMatrix();
          return vt.applyToPointArray(mt[0], mt[1], mt[2] || 0);
        }
        function Mt(mt) {
          var vt,
            Ct = mt.length,
            Tt = [];
          for (vt = 0; vt < Ct; vt += 1) Tt[vt] = St(mt[vt]);
          return Tt;
        }
        function Rt(mt, vt, Ct) {
          var Tt = createTypedArray("float32", 6);
          if (this.isIdentity())
            (Tt[0] = mt[0]),
              (Tt[1] = mt[1]),
              (Tt[2] = vt[0]),
              (Tt[3] = vt[1]),
              (Tt[4] = Ct[0]),
              (Tt[5] = Ct[1]);
          else {
            var Dt = this.props[0],
              Wt = this.props[1],
              Pt = this.props[4],
              Jt = this.props[5],
              Gt = this.props[12],
              en = this.props[13];
            (Tt[0] = mt[0] * Dt + mt[1] * Pt + Gt),
              (Tt[1] = mt[0] * Wt + mt[1] * Jt + en),
              (Tt[2] = vt[0] * Dt + vt[1] * Pt + Gt),
              (Tt[3] = vt[0] * Wt + vt[1] * Jt + en),
              (Tt[4] = Ct[0] * Dt + Ct[1] * Pt + Gt),
              (Tt[5] = Ct[0] * Wt + Ct[1] * Jt + en);
          }
          return Tt;
        }
        function Ft(mt, vt, Ct) {
          var Tt;
          return (
            this.isIdentity()
              ? (Tt = [mt, vt, Ct])
              : (Tt = [
                  mt * this.props[0] +
                    vt * this.props[4] +
                    Ct * this.props[8] +
                    this.props[12],
                  mt * this.props[1] +
                    vt * this.props[5] +
                    Ct * this.props[9] +
                    this.props[13],
                  mt * this.props[2] +
                    vt * this.props[6] +
                    Ct * this.props[10] +
                    this.props[14],
                ]),
            Tt
          );
        }
        function Ot(mt, vt) {
          if (this.isIdentity()) return mt + "," + vt;
          var Ct = this.props;
          return (
            Math.round((mt * Ct[0] + vt * Ct[4] + Ct[12]) * 100) / 100 +
            "," +
            Math.round((mt * Ct[1] + vt * Ct[5] + Ct[13]) * 100) / 100
          );
        }
        function Lt() {
          for (
            var mt = 0, vt = this.props, Ct = "matrix3d(", Tt = 1e4;
            mt < 16;

          )
            (Ct += a(vt[mt] * Tt) / Tt),
              (Ct += mt === 15 ? ")" : ","),
              (mt += 1);
          return Ct;
        }
        function Et(mt) {
          var vt = 1e4;
          return (mt < 1e-6 && mt > 0) || (mt > -1e-6 && mt < 0)
            ? a(mt * vt) / vt
            : mt;
        }
        function bt() {
          var mt = this.props,
            vt = Et(mt[0]),
            Ct = Et(mt[1]),
            Tt = Et(mt[4]),
            Dt = Et(mt[5]),
            Wt = Et(mt[12]),
            Pt = Et(mt[13]);
          return (
            "matrix(" +
            vt +
            "," +
            Ct +
            "," +
            Tt +
            "," +
            Dt +
            "," +
            Wt +
            "," +
            Pt +
            ")"
          );
        }
        return function () {
          (this.reset = c),
            (this.rotate = d),
            (this.rotateX = g),
            (this.rotateY = _),
            (this.rotateZ = b),
            (this.skew = $),
            (this.skewFromAxis = _e),
            (this.shear = j),
            (this.scale = et),
            (this.setTransform = rt),
            (this.translate = st),
            (this.transform = at),
            (this.multiply = ct),
            (this.applyToPoint = pt),
            (this.applyToX = ft),
            (this.applyToY = gt),
            (this.applyToZ = xt),
            (this.applyToPointArray = Ft),
            (this.applyToTriplePoints = Rt),
            (this.applyToPointStringified = Ot),
            (this.toCSS = Lt),
            (this.to2dCSS = bt),
            (this.clone = ot),
            (this.cloneFromProps = ut),
            (this.equals = lt),
            (this.inversePoints = Mt),
            (this.inversePoint = St),
            (this.getInverseMatrix = _t),
            (this._t = this.transform),
            (this.isIdentity = it),
            (this._identity = !0),
            (this._identityCalculated = !1),
            (this.props = createTypedArray("float32", 16)),
            this.reset();
        };
      })();
      function _typeof$3(s) {
        "@babel/helpers - typeof";
        return (
          typeof Symbol == "function" && typeof Symbol.iterator == "symbol"
            ? (_typeof$3 = function (o) {
                return typeof o;
              })
            : (_typeof$3 = function (o) {
                return o &&
                  typeof Symbol == "function" &&
                  o.constructor === Symbol &&
                  o !== Symbol.prototype
                  ? "symbol"
                  : typeof o;
              }),
          _typeof$3(s)
        );
      }
      var lottie = {};
      function setLocation(s) {
        setLocationHref(s);
      }
      function searchAnimations() {
        animationManager.searchAnimations();
      }
      function setSubframeRendering(s) {
        setSubframeEnabled(s);
      }
      function setPrefix(s) {
        setIdPrefix(s);
      }
      function loadAnimation(s) {
        return animationManager.loadAnimation(s);
      }
      function setQuality(s) {
        if (typeof s == "string")
          switch (s) {
            case "high":
              setDefaultCurveSegments(200);
              break;
            default:
            case "medium":
              setDefaultCurveSegments(50);
              break;
            case "low":
              setDefaultCurveSegments(10);
              break;
          }
        else !isNaN(s) && s > 1 && setDefaultCurveSegments(s);
      }
      function inBrowser() {
        return typeof navigator < "u";
      }
      function installPlugin(s, e) {
        s === "expressions" && setExpressionsPlugin(e);
      }
      function getFactory(s) {
        switch (s) {
          case "propertyFactory":
            return PropertyFactory;
          case "shapePropertyFactory":
            return ShapePropertyFactory;
          case "matrix":
            return Matrix;
          default:
            return null;
        }
      }
      (lottie.play = animationManager.play),
        (lottie.pause = animationManager.pause),
        (lottie.setLocationHref = setLocation),
        (lottie.togglePause = animationManager.togglePause),
        (lottie.setSpeed = animationManager.setSpeed),
        (lottie.setDirection = animationManager.setDirection),
        (lottie.stop = animationManager.stop),
        (lottie.searchAnimations = searchAnimations),
        (lottie.registerAnimation = animationManager.registerAnimation),
        (lottie.loadAnimation = loadAnimation),
        (lottie.setSubframeRendering = setSubframeRendering),
        (lottie.resize = animationManager.resize),
        (lottie.goToAndStop = animationManager.goToAndStop),
        (lottie.destroy = animationManager.destroy),
        (lottie.setQuality = setQuality),
        (lottie.inBrowser = inBrowser),
        (lottie.installPlugin = installPlugin),
        (lottie.freeze = animationManager.freeze),
        (lottie.unfreeze = animationManager.unfreeze),
        (lottie.setVolume = animationManager.setVolume),
        (lottie.mute = animationManager.mute),
        (lottie.unmute = animationManager.unmute),
        (lottie.getRegisteredAnimations =
          animationManager.getRegisteredAnimations),
        (lottie.useWebWorker = setWebWorker),
        (lottie.setIDPrefix = setPrefix),
        (lottie.__getFactory = getFactory),
        (lottie.version = "5.12.2");
      function checkReady() {
        document.readyState === "complete" &&
          (clearInterval(readyStateCheckInterval), searchAnimations());
      }
      function getQueryVariable(s) {
        for (var e = queryString.split("&"), o = 0; o < e.length; o += 1) {
          var a = e[o].split("=");
          if (decodeURIComponent(a[0]) == s) return decodeURIComponent(a[1]);
        }
        return null;
      }
      var queryString = "";
      {
        var scripts = document.getElementsByTagName("script"),
          index = scripts.length - 1,
          myScript = scripts[index] || { src: "" };
        (queryString = myScript.src
          ? myScript.src.replace(/^[^\?]+\??/, "")
          : ""),
          getQueryVariable("renderer");
      }
      var readyStateCheckInterval = setInterval(checkReady, 100);
      try {
        _typeof$3(exports) !== "object" && (window.bodymovin = lottie);
      } catch (s) {}
      var ShapeModifiers = (function () {
        var s = {},
          e = {};
        (s.registerModifier = o), (s.getModifier = a);
        function o(c, d) {
          e[c] || (e[c] = d);
        }
        function a(c, d, g) {
          return new e[c](d, g);
        }
        return s;
      })();
      function ShapeModifier() {}
      (ShapeModifier.prototype.initModifierProperties = function () {}),
        (ShapeModifier.prototype.addShapeToModifier = function () {}),
        (ShapeModifier.prototype.addShape = function (s) {
          if (!this.closed) {
            s.sh.container.addDynamicProperty(s.sh);
            var e = {
              shape: s.sh,
              data: s,
              localShapeCollection: shapeCollectionPool.newShapeCollection(),
            };
            this.shapes.push(e),
              this.addShapeToModifier(e),
              this._isAnimated && s.setAsAnimated();
          }
        }),
        (ShapeModifier.prototype.init = function (s, e) {
          (this.shapes = []),
            (this.elem = s),
            this.initDynamicPropertyContainer(s),
            this.initModifierProperties(s, e),
            (this.frameId = initialDefaultFrame),
            (this.closed = !1),
            (this.k = !1),
            this.dynamicProperties.length ? (this.k = !0) : this.getValue(!0);
        }),
        (ShapeModifier.prototype.processKeys = function () {
          this.elem.globalData.frameId !== this.frameId &&
            ((this.frameId = this.elem.globalData.frameId),
            this.iterateDynamicProperties());
        }),
        extendPrototype([DynamicPropertyContainer], ShapeModifier);
      function TrimModifier() {}
      extendPrototype([ShapeModifier], TrimModifier),
        (TrimModifier.prototype.initModifierProperties = function (s, e) {
          (this.s = PropertyFactory.getProp(s, e.s, 0, 0.01, this)),
            (this.e = PropertyFactory.getProp(s, e.e, 0, 0.01, this)),
            (this.o = PropertyFactory.getProp(s, e.o, 0, 0, this)),
            (this.sValue = 0),
            (this.eValue = 0),
            (this.getValue = this.processKeys),
            (this.m = e.m),
            (this._isAnimated =
              !!this.s.effectsSequence.length ||
              !!this.e.effectsSequence.length ||
              !!this.o.effectsSequence.length);
        }),
        (TrimModifier.prototype.addShapeToModifier = function (s) {
          s.pathsData = [];
        }),
        (TrimModifier.prototype.calculateShapeEdges = function (s, e, o, a, c) {
          var d = [];
          e <= 1
            ? d.push({ s, e })
            : s >= 1
            ? d.push({ s: s - 1, e: e - 1 })
            : (d.push({ s, e: 1 }), d.push({ s: 0, e: e - 1 }));
          var g = [],
            _,
            b = d.length,
            j;
          for (_ = 0; _ < b; _ += 1)
            if (((j = d[_]), !(j.e * c < a || j.s * c > a + o))) {
              var $, _e;
              j.s * c <= a ? ($ = 0) : ($ = (j.s * c - a) / o),
                j.e * c >= a + o ? (_e = 1) : (_e = (j.e * c - a) / o),
                g.push([$, _e]);
            }
          return g.length || g.push([0, 0]), g;
        }),
        (TrimModifier.prototype.releasePathsData = function (s) {
          var e,
            o = s.length;
          for (e = 0; e < o; e += 1) segmentsLengthPool.release(s[e]);
          return (s.length = 0), s;
        }),
        (TrimModifier.prototype.processShapes = function (s) {
          var e, o;
          if (this._mdf || s) {
            var a = (this.o.v % 360) / 360;
            if (
              (a < 0 && (a += 1),
              this.s.v > 1
                ? (e = 1 + a)
                : this.s.v < 0
                ? (e = 0 + a)
                : (e = this.s.v + a),
              this.e.v > 1
                ? (o = 1 + a)
                : this.e.v < 0
                ? (o = 0 + a)
                : (o = this.e.v + a),
              e > o)
            ) {
              var c = e;
              (e = o), (o = c);
            }
            (e = Math.round(e * 1e4) * 1e-4),
              (o = Math.round(o * 1e4) * 1e-4),
              (this.sValue = e),
              (this.eValue = o);
          } else (e = this.sValue), (o = this.eValue);
          var d,
            g,
            _ = this.shapes.length,
            b,
            j,
            $,
            _e,
            et,
            rt = 0;
          if (o === e)
            for (g = 0; g < _; g += 1)
              this.shapes[g].localShapeCollection.releaseShapes(),
                (this.shapes[g].shape._mdf = !0),
                (this.shapes[g].shape.paths =
                  this.shapes[g].localShapeCollection),
                this._mdf && (this.shapes[g].pathsData.length = 0);
          else if ((o === 1 && e === 0) || (o === 0 && e === 1)) {
            if (this._mdf)
              for (g = 0; g < _; g += 1)
                (this.shapes[g].pathsData.length = 0),
                  (this.shapes[g].shape._mdf = !0);
          } else {
            var st = [],
              at,
              ct;
            for (g = 0; g < _; g += 1)
              if (
                ((at = this.shapes[g]),
                !at.shape._mdf && !this._mdf && !s && this.m !== 2)
              )
                at.shape.paths = at.localShapeCollection;
              else {
                if (
                  ((d = at.shape.paths),
                  (j = d._length),
                  (et = 0),
                  !at.shape._mdf && at.pathsData.length)
                )
                  et = at.totalShapeLength;
                else {
                  for (
                    $ = this.releasePathsData(at.pathsData), b = 0;
                    b < j;
                    b += 1
                  )
                    (_e = bez.getSegmentsLength(d.shapes[b])),
                      $.push(_e),
                      (et += _e.totalLength);
                  (at.totalShapeLength = et), (at.pathsData = $);
                }
                (rt += et), (at.shape._mdf = !0);
              }
            var it = e,
              lt = o,
              ot = 0,
              ut;
            for (g = _ - 1; g >= 0; g -= 1)
              if (((at = this.shapes[g]), at.shape._mdf)) {
                for (
                  ct = at.localShapeCollection,
                    ct.releaseShapes(),
                    this.m === 2 && _ > 1
                      ? ((ut = this.calculateShapeEdges(
                          e,
                          o,
                          at.totalShapeLength,
                          ot,
                          rt
                        )),
                        (ot += at.totalShapeLength))
                      : (ut = [[it, lt]]),
                    j = ut.length,
                    b = 0;
                  b < j;
                  b += 1
                ) {
                  (it = ut[b][0]),
                    (lt = ut[b][1]),
                    (st.length = 0),
                    lt <= 1
                      ? st.push({
                          s: at.totalShapeLength * it,
                          e: at.totalShapeLength * lt,
                        })
                      : it >= 1
                      ? st.push({
                          s: at.totalShapeLength * (it - 1),
                          e: at.totalShapeLength * (lt - 1),
                        })
                      : (st.push({
                          s: at.totalShapeLength * it,
                          e: at.totalShapeLength,
                        }),
                        st.push({ s: 0, e: at.totalShapeLength * (lt - 1) }));
                  var pt = this.addShapes(at, st[0]);
                  if (st[0].s !== st[0].e) {
                    if (st.length > 1) {
                      var ft =
                        at.shape.paths.shapes[at.shape.paths._length - 1];
                      if (ft.c) {
                        var gt = pt.pop();
                        this.addPaths(pt, ct),
                          (pt = this.addShapes(at, st[1], gt));
                      } else
                        this.addPaths(pt, ct), (pt = this.addShapes(at, st[1]));
                    }
                    this.addPaths(pt, ct);
                  }
                }
                at.shape.paths = ct;
              }
          }
        }),
        (TrimModifier.prototype.addPaths = function (s, e) {
          var o,
            a = s.length;
          for (o = 0; o < a; o += 1) e.addShape(s[o]);
        }),
        (TrimModifier.prototype.addSegment = function (s, e, o, a, c, d, g) {
          c.setXYAt(e[0], e[1], "o", d),
            c.setXYAt(o[0], o[1], "i", d + 1),
            g && c.setXYAt(s[0], s[1], "v", d),
            c.setXYAt(a[0], a[1], "v", d + 1);
        }),
        (TrimModifier.prototype.addSegmentFromArray = function (s, e, o, a) {
          e.setXYAt(s[1], s[5], "o", o),
            e.setXYAt(s[2], s[6], "i", o + 1),
            a && e.setXYAt(s[0], s[4], "v", o),
            e.setXYAt(s[3], s[7], "v", o + 1);
        }),
        (TrimModifier.prototype.addShapes = function (s, e, o) {
          var a = s.pathsData,
            c = s.shape.paths.shapes,
            d,
            g = s.shape.paths._length,
            _,
            b,
            j = 0,
            $,
            _e,
            et,
            rt,
            st = [],
            at,
            ct = !0;
          for (
            o
              ? ((_e = o._length), (at = o._length))
              : ((o = shapePool.newElement()), (_e = 0), (at = 0)),
              st.push(o),
              d = 0;
            d < g;
            d += 1
          ) {
            for (
              et = a[d].lengths,
                o.c = c[d].c,
                b = c[d].c ? et.length : et.length + 1,
                _ = 1;
              _ < b;
              _ += 1
            )
              if ((($ = et[_ - 1]), j + $.addedLength < e.s))
                (j += $.addedLength), (o.c = !1);
              else if (j > e.e) {
                o.c = !1;
                break;
              } else
                e.s <= j && e.e >= j + $.addedLength
                  ? (this.addSegment(
                      c[d].v[_ - 1],
                      c[d].o[_ - 1],
                      c[d].i[_],
                      c[d].v[_],
                      o,
                      _e,
                      ct
                    ),
                    (ct = !1))
                  : ((rt = bez.getNewSegment(
                      c[d].v[_ - 1],
                      c[d].v[_],
                      c[d].o[_ - 1],
                      c[d].i[_],
                      (e.s - j) / $.addedLength,
                      (e.e - j) / $.addedLength,
                      et[_ - 1]
                    )),
                    this.addSegmentFromArray(rt, o, _e, ct),
                    (ct = !1),
                    (o.c = !1)),
                  (j += $.addedLength),
                  (_e += 1);
            if (c[d].c && et.length) {
              if ((($ = et[_ - 1]), j <= e.e)) {
                var it = et[_ - 1].addedLength;
                e.s <= j && e.e >= j + it
                  ? (this.addSegment(
                      c[d].v[_ - 1],
                      c[d].o[_ - 1],
                      c[d].i[0],
                      c[d].v[0],
                      o,
                      _e,
                      ct
                    ),
                    (ct = !1))
                  : ((rt = bez.getNewSegment(
                      c[d].v[_ - 1],
                      c[d].v[0],
                      c[d].o[_ - 1],
                      c[d].i[0],
                      (e.s - j) / it,
                      (e.e - j) / it,
                      et[_ - 1]
                    )),
                    this.addSegmentFromArray(rt, o, _e, ct),
                    (ct = !1),
                    (o.c = !1));
              } else o.c = !1;
              (j += $.addedLength), (_e += 1);
            }
            if (
              (o._length &&
                (o.setXYAt(o.v[at][0], o.v[at][1], "i", at),
                o.setXYAt(
                  o.v[o._length - 1][0],
                  o.v[o._length - 1][1],
                  "o",
                  o._length - 1
                )),
              j > e.e)
            )
              break;
            d < g - 1 &&
              ((o = shapePool.newElement()), (ct = !0), st.push(o), (_e = 0));
          }
          return st;
        });
      function PuckerAndBloatModifier() {}
      extendPrototype([ShapeModifier], PuckerAndBloatModifier),
        (PuckerAndBloatModifier.prototype.initModifierProperties = function (
          s,
          e
        ) {
          (this.getValue = this.processKeys),
            (this.amount = PropertyFactory.getProp(s, e.a, 0, null, this)),
            (this._isAnimated = !!this.amount.effectsSequence.length);
        }),
        (PuckerAndBloatModifier.prototype.processPath = function (s, e) {
          var o = e / 100,
            a = [0, 0],
            c = s._length,
            d = 0;
          for (d = 0; d < c; d += 1) (a[0] += s.v[d][0]), (a[1] += s.v[d][1]);
          (a[0] /= c), (a[1] /= c);
          var g = shapePool.newElement();
          g.c = s.c;
          var _, b, j, $, _e, et;
          for (d = 0; d < c; d += 1)
            (_ = s.v[d][0] + (a[0] - s.v[d][0]) * o),
              (b = s.v[d][1] + (a[1] - s.v[d][1]) * o),
              (j = s.o[d][0] + (a[0] - s.o[d][0]) * -o),
              ($ = s.o[d][1] + (a[1] - s.o[d][1]) * -o),
              (_e = s.i[d][0] + (a[0] - s.i[d][0]) * -o),
              (et = s.i[d][1] + (a[1] - s.i[d][1]) * -o),
              g.setTripleAt(_, b, j, $, _e, et, d);
          return g;
        }),
        (PuckerAndBloatModifier.prototype.processShapes = function (s) {
          var e,
            o,
            a = this.shapes.length,
            c,
            d,
            g = this.amount.v;
          if (g !== 0) {
            var _, b;
            for (o = 0; o < a; o += 1) {
              if (
                ((_ = this.shapes[o]),
                (b = _.localShapeCollection),
                !(!_.shape._mdf && !this._mdf && !s))
              )
                for (
                  b.releaseShapes(),
                    _.shape._mdf = !0,
                    e = _.shape.paths.shapes,
                    d = _.shape.paths._length,
                    c = 0;
                  c < d;
                  c += 1
                )
                  b.addShape(this.processPath(e[c], g));
              _.shape.paths = _.localShapeCollection;
            }
          }
          this.dynamicProperties.length || (this._mdf = !1);
        });
      var TransformPropertyFactory = (function () {
        var s = [0, 0];
        function e(b) {
          var j = this._mdf;
          this.iterateDynamicProperties(),
            (this._mdf = this._mdf || j),
            this.a && b.translate(-this.a.v[0], -this.a.v[1], this.a.v[2]),
            this.s && b.scale(this.s.v[0], this.s.v[1], this.s.v[2]),
            this.sk && b.skewFromAxis(-this.sk.v, this.sa.v),
            this.r
              ? b.rotate(-this.r.v)
              : b
                  .rotateZ(-this.rz.v)
                  .rotateY(this.ry.v)
                  .rotateX(this.rx.v)
                  .rotateZ(-this.or.v[2])
                  .rotateY(this.or.v[1])
                  .rotateX(this.or.v[0]),
            this.data.p.s
              ? this.data.p.z
                ? b.translate(this.px.v, this.py.v, -this.pz.v)
                : b.translate(this.px.v, this.py.v, 0)
              : b.translate(this.p.v[0], this.p.v[1], -this.p.v[2]);
        }
        function o(b) {
          if (this.elem.globalData.frameId !== this.frameId) {
            if (
              (this._isDirty &&
                (this.precalculateMatrix(), (this._isDirty = !1)),
              this.iterateDynamicProperties(),
              this._mdf || b)
            ) {
              var j;
              if (
                (this.v.cloneFromProps(this.pre.props),
                this.appliedTransformations < 1 &&
                  this.v.translate(-this.a.v[0], -this.a.v[1], this.a.v[2]),
                this.appliedTransformations < 2 &&
                  this.v.scale(this.s.v[0], this.s.v[1], this.s.v[2]),
                this.sk &&
                  this.appliedTransformations < 3 &&
                  this.v.skewFromAxis(-this.sk.v, this.sa.v),
                this.r && this.appliedTransformations < 4
                  ? this.v.rotate(-this.r.v)
                  : !this.r &&
                    this.appliedTransformations < 4 &&
                    this.v
                      .rotateZ(-this.rz.v)
                      .rotateY(this.ry.v)
                      .rotateX(this.rx.v)
                      .rotateZ(-this.or.v[2])
                      .rotateY(this.or.v[1])
                      .rotateX(this.or.v[0]),
                this.autoOriented)
              ) {
                var $, _e;
                if (
                  ((j = this.elem.globalData.frameRate),
                  this.p && this.p.keyframes && this.p.getValueAtTime)
                )
                  this.p._caching.lastFrame + this.p.offsetTime <=
                  this.p.keyframes[0].t
                    ? (($ = this.p.getValueAtTime(
                        (this.p.keyframes[0].t + 0.01) / j,
                        0
                      )),
                      (_e = this.p.getValueAtTime(
                        this.p.keyframes[0].t / j,
                        0
                      )))
                    : this.p._caching.lastFrame + this.p.offsetTime >=
                      this.p.keyframes[this.p.keyframes.length - 1].t
                    ? (($ = this.p.getValueAtTime(
                        this.p.keyframes[this.p.keyframes.length - 1].t / j,
                        0
                      )),
                      (_e = this.p.getValueAtTime(
                        (this.p.keyframes[this.p.keyframes.length - 1].t -
                          0.05) /
                          j,
                        0
                      )))
                    : (($ = this.p.pv),
                      (_e = this.p.getValueAtTime(
                        (this.p._caching.lastFrame + this.p.offsetTime - 0.01) /
                          j,
                        this.p.offsetTime
                      )));
                else if (
                  this.px &&
                  this.px.keyframes &&
                  this.py.keyframes &&
                  this.px.getValueAtTime &&
                  this.py.getValueAtTime
                ) {
                  ($ = []), (_e = []);
                  var et = this.px,
                    rt = this.py;
                  et._caching.lastFrame + et.offsetTime <= et.keyframes[0].t
                    ? (($[0] = et.getValueAtTime(
                        (et.keyframes[0].t + 0.01) / j,
                        0
                      )),
                      ($[1] = rt.getValueAtTime(
                        (rt.keyframes[0].t + 0.01) / j,
                        0
                      )),
                      (_e[0] = et.getValueAtTime(et.keyframes[0].t / j, 0)),
                      (_e[1] = rt.getValueAtTime(rt.keyframes[0].t / j, 0)))
                    : et._caching.lastFrame + et.offsetTime >=
                      et.keyframes[et.keyframes.length - 1].t
                    ? (($[0] = et.getValueAtTime(
                        et.keyframes[et.keyframes.length - 1].t / j,
                        0
                      )),
                      ($[1] = rt.getValueAtTime(
                        rt.keyframes[rt.keyframes.length - 1].t / j,
                        0
                      )),
                      (_e[0] = et.getValueAtTime(
                        (et.keyframes[et.keyframes.length - 1].t - 0.01) / j,
                        0
                      )),
                      (_e[1] = rt.getValueAtTime(
                        (rt.keyframes[rt.keyframes.length - 1].t - 0.01) / j,
                        0
                      )))
                    : (($ = [et.pv, rt.pv]),
                      (_e[0] = et.getValueAtTime(
                        (et._caching.lastFrame + et.offsetTime - 0.01) / j,
                        et.offsetTime
                      )),
                      (_e[1] = rt.getValueAtTime(
                        (rt._caching.lastFrame + rt.offsetTime - 0.01) / j,
                        rt.offsetTime
                      )));
                } else (_e = s), ($ = _e);
                this.v.rotate(-Math.atan2($[1] - _e[1], $[0] - _e[0]));
              }
              this.data.p && this.data.p.s
                ? this.data.p.z
                  ? this.v.translate(this.px.v, this.py.v, -this.pz.v)
                  : this.v.translate(this.px.v, this.py.v, 0)
                : this.v.translate(this.p.v[0], this.p.v[1], -this.p.v[2]);
            }
            this.frameId = this.elem.globalData.frameId;
          }
        }
        function a() {
          if (
            ((this.appliedTransformations = 0),
            this.pre.reset(),
            !this.a.effectsSequence.length)
          )
            this.pre.translate(-this.a.v[0], -this.a.v[1], this.a.v[2]),
              (this.appliedTransformations = 1);
          else return;
          if (!this.s.effectsSequence.length)
            this.pre.scale(this.s.v[0], this.s.v[1], this.s.v[2]),
              (this.appliedTransformations = 2);
          else return;
          if (this.sk)
            if (
              !this.sk.effectsSequence.length &&
              !this.sa.effectsSequence.length
            )
              this.pre.skewFromAxis(-this.sk.v, this.sa.v),
                (this.appliedTransformations = 3);
            else return;
          this.r
            ? this.r.effectsSequence.length ||
              (this.pre.rotate(-this.r.v), (this.appliedTransformations = 4))
            : !this.rz.effectsSequence.length &&
              !this.ry.effectsSequence.length &&
              !this.rx.effectsSequence.length &&
              !this.or.effectsSequence.length &&
              (this.pre
                .rotateZ(-this.rz.v)
                .rotateY(this.ry.v)
                .rotateX(this.rx.v)
                .rotateZ(-this.or.v[2])
                .rotateY(this.or.v[1])
                .rotateX(this.or.v[0]),
              (this.appliedTransformations = 4));
        }
        function c() {}
        function d(b) {
          this._addDynamicProperty(b),
            this.elem.addDynamicProperty(b),
            (this._isDirty = !0);
        }
        function g(b, j, $) {
          if (
            ((this.elem = b),
            (this.frameId = -1),
            (this.propType = "transform"),
            (this.data = j),
            (this.v = new Matrix()),
            (this.pre = new Matrix()),
            (this.appliedTransformations = 0),
            this.initDynamicPropertyContainer($ || b),
            j.p && j.p.s
              ? ((this.px = PropertyFactory.getProp(b, j.p.x, 0, 0, this)),
                (this.py = PropertyFactory.getProp(b, j.p.y, 0, 0, this)),
                j.p.z &&
                  (this.pz = PropertyFactory.getProp(b, j.p.z, 0, 0, this)))
              : (this.p = PropertyFactory.getProp(
                  b,
                  j.p || { k: [0, 0, 0] },
                  1,
                  0,
                  this
                )),
            j.rx)
          ) {
            if (
              ((this.rx = PropertyFactory.getProp(b, j.rx, 0, degToRads, this)),
              (this.ry = PropertyFactory.getProp(b, j.ry, 0, degToRads, this)),
              (this.rz = PropertyFactory.getProp(b, j.rz, 0, degToRads, this)),
              j.or.k[0].ti)
            ) {
              var _e,
                et = j.or.k.length;
              for (_e = 0; _e < et; _e += 1)
                (j.or.k[_e].to = null), (j.or.k[_e].ti = null);
            }
            (this.or = PropertyFactory.getProp(b, j.or, 1, degToRads, this)),
              (this.or.sh = !0);
          } else
            this.r = PropertyFactory.getProp(
              b,
              j.r || { k: 0 },
              0,
              degToRads,
              this
            );
          j.sk &&
            ((this.sk = PropertyFactory.getProp(b, j.sk, 0, degToRads, this)),
            (this.sa = PropertyFactory.getProp(b, j.sa, 0, degToRads, this))),
            (this.a = PropertyFactory.getProp(
              b,
              j.a || { k: [0, 0, 0] },
              1,
              0,
              this
            )),
            (this.s = PropertyFactory.getProp(
              b,
              j.s || { k: [100, 100, 100] },
              1,
              0.01,
              this
            )),
            j.o
              ? (this.o = PropertyFactory.getProp(b, j.o, 0, 0.01, b))
              : (this.o = { _mdf: !1, v: 1 }),
            (this._isDirty = !0),
            this.dynamicProperties.length || this.getValue(!0);
        }
        (g.prototype = {
          applyToMatrix: e,
          getValue: o,
          precalculateMatrix: a,
          autoOrient: c,
        }),
          extendPrototype([DynamicPropertyContainer], g),
          (g.prototype.addDynamicProperty = d),
          (g.prototype._addDynamicProperty =
            DynamicPropertyContainer.prototype.addDynamicProperty);
        function _(b, j, $) {
          return new g(b, j, $);
        }
        return { getTransformProperty: _ };
      })();
      function RepeaterModifier() {}
      extendPrototype([ShapeModifier], RepeaterModifier),
        (RepeaterModifier.prototype.initModifierProperties = function (s, e) {
          (this.getValue = this.processKeys),
            (this.c = PropertyFactory.getProp(s, e.c, 0, null, this)),
            (this.o = PropertyFactory.getProp(s, e.o, 0, null, this)),
            (this.tr = TransformPropertyFactory.getTransformProperty(
              s,
              e.tr,
              this
            )),
            (this.so = PropertyFactory.getProp(s, e.tr.so, 0, 0.01, this)),
            (this.eo = PropertyFactory.getProp(s, e.tr.eo, 0, 0.01, this)),
            (this.data = e),
            this.dynamicProperties.length || this.getValue(!0),
            (this._isAnimated = !!this.dynamicProperties.length),
            (this.pMatrix = new Matrix()),
            (this.rMatrix = new Matrix()),
            (this.sMatrix = new Matrix()),
            (this.tMatrix = new Matrix()),
            (this.matrix = new Matrix());
        }),
        (RepeaterModifier.prototype.applyTransforms = function (
          s,
          e,
          o,
          a,
          c,
          d
        ) {
          var g = d ? -1 : 1,
            _ = a.s.v[0] + (1 - a.s.v[0]) * (1 - c),
            b = a.s.v[1] + (1 - a.s.v[1]) * (1 - c);
          s.translate(a.p.v[0] * g * c, a.p.v[1] * g * c, a.p.v[2]),
            e.translate(-a.a.v[0], -a.a.v[1], a.a.v[2]),
            e.rotate(-a.r.v * g * c),
            e.translate(a.a.v[0], a.a.v[1], a.a.v[2]),
            o.translate(-a.a.v[0], -a.a.v[1], a.a.v[2]),
            o.scale(d ? 1 / _ : _, d ? 1 / b : b),
            o.translate(a.a.v[0], a.a.v[1], a.a.v[2]);
        }),
        (RepeaterModifier.prototype.init = function (s, e, o, a) {
          for (
            this.elem = s,
              this.arr = e,
              this.pos = o,
              this.elemsData = a,
              this._currentCopies = 0,
              this._elements = [],
              this._groups = [],
              this.frameId = -1,
              this.initDynamicPropertyContainer(s),
              this.initModifierProperties(s, e[o]);
            o > 0;

          )
            (o -= 1), this._elements.unshift(e[o]);
          this.dynamicProperties.length ? (this.k = !0) : this.getValue(!0);
        }),
        (RepeaterModifier.prototype.resetElements = function (s) {
          var e,
            o = s.length;
          for (e = 0; e < o; e += 1)
            (s[e]._processed = !1),
              s[e].ty === "gr" && this.resetElements(s[e].it);
        }),
        (RepeaterModifier.prototype.cloneElements = function (s) {
          var e = JSON.parse(JSON.stringify(s));
          return this.resetElements(e), e;
        }),
        (RepeaterModifier.prototype.changeGroupRender = function (s, e) {
          var o,
            a = s.length;
          for (o = 0; o < a; o += 1)
            (s[o]._render = e),
              s[o].ty === "gr" && this.changeGroupRender(s[o].it, e);
        }),
        (RepeaterModifier.prototype.processShapes = function (s) {
          var e,
            o,
            a,
            c,
            d,
            g = !1;
          if (this._mdf || s) {
            var _ = Math.ceil(this.c.v);
            if (this._groups.length < _) {
              for (; this._groups.length < _; ) {
                var b = { it: this.cloneElements(this._elements), ty: "gr" };
                b.it.push({
                  a: { a: 0, ix: 1, k: [0, 0] },
                  nm: "Transform",
                  o: { a: 0, ix: 7, k: 100 },
                  p: { a: 0, ix: 2, k: [0, 0] },
                  r: {
                    a: 1,
                    ix: 6,
                    k: [
                      { s: 0, e: 0, t: 0 },
                      { s: 0, e: 0, t: 1 },
                    ],
                  },
                  s: { a: 0, ix: 3, k: [100, 100] },
                  sa: { a: 0, ix: 5, k: 0 },
                  sk: { a: 0, ix: 4, k: 0 },
                  ty: "tr",
                }),
                  this.arr.splice(0, 0, b),
                  this._groups.splice(0, 0, b),
                  (this._currentCopies += 1);
              }
              this.elem.reloadShapes(), (g = !0);
            }
            d = 0;
            var j;
            for (a = 0; a <= this._groups.length - 1; a += 1) {
              if (
                ((j = d < _),
                (this._groups[a]._render = j),
                this.changeGroupRender(this._groups[a].it, j),
                !j)
              ) {
                var $ = this.elemsData[a].it,
                  _e = $[$.length - 1];
                _e.transform.op.v !== 0
                  ? ((_e.transform.op._mdf = !0), (_e.transform.op.v = 0))
                  : (_e.transform.op._mdf = !1);
              }
              d += 1;
            }
            this._currentCopies = _;
            var et = this.o.v,
              rt = et % 1,
              st = et > 0 ? Math.floor(et) : Math.ceil(et),
              at = this.pMatrix.props,
              ct = this.rMatrix.props,
              it = this.sMatrix.props;
            this.pMatrix.reset(),
              this.rMatrix.reset(),
              this.sMatrix.reset(),
              this.tMatrix.reset(),
              this.matrix.reset();
            var lt = 0;
            if (et > 0) {
              for (; lt < st; )
                this.applyTransforms(
                  this.pMatrix,
                  this.rMatrix,
                  this.sMatrix,
                  this.tr,
                  1,
                  !1
                ),
                  (lt += 1);
              rt &&
                (this.applyTransforms(
                  this.pMatrix,
                  this.rMatrix,
                  this.sMatrix,
                  this.tr,
                  rt,
                  !1
                ),
                (lt += rt));
            } else if (et < 0) {
              for (; lt > st; )
                this.applyTransforms(
                  this.pMatrix,
                  this.rMatrix,
                  this.sMatrix,
                  this.tr,
                  1,
                  !0
                ),
                  (lt -= 1);
              rt &&
                (this.applyTransforms(
                  this.pMatrix,
                  this.rMatrix,
                  this.sMatrix,
                  this.tr,
                  -rt,
                  !0
                ),
                (lt -= rt));
            }
            (a = this.data.m === 1 ? 0 : this._currentCopies - 1),
              (c = this.data.m === 1 ? 1 : -1),
              (d = this._currentCopies);
            for (var ot, ut; d; ) {
              if (
                ((e = this.elemsData[a].it),
                (o = e[e.length - 1].transform.mProps.v.props),
                (ut = o.length),
                (e[e.length - 1].transform.mProps._mdf = !0),
                (e[e.length - 1].transform.op._mdf = !0),
                (e[e.length - 1].transform.op.v =
                  this._currentCopies === 1
                    ? this.so.v
                    : this.so.v +
                      (this.eo.v - this.so.v) *
                        (a / (this._currentCopies - 1))),
                lt !== 0)
              ) {
                for (
                  ((a !== 0 && c === 1) ||
                    (a !== this._currentCopies - 1 && c === -1)) &&
                    this.applyTransforms(
                      this.pMatrix,
                      this.rMatrix,
                      this.sMatrix,
                      this.tr,
                      1,
                      !1
                    ),
                    this.matrix.transform(
                      ct[0],
                      ct[1],
                      ct[2],
                      ct[3],
                      ct[4],
                      ct[5],
                      ct[6],
                      ct[7],
                      ct[8],
                      ct[9],
                      ct[10],
                      ct[11],
                      ct[12],
                      ct[13],
                      ct[14],
                      ct[15]
                    ),
                    this.matrix.transform(
                      it[0],
                      it[1],
                      it[2],
                      it[3],
                      it[4],
                      it[5],
                      it[6],
                      it[7],
                      it[8],
                      it[9],
                      it[10],
                      it[11],
                      it[12],
                      it[13],
                      it[14],
                      it[15]
                    ),
                    this.matrix.transform(
                      at[0],
                      at[1],
                      at[2],
                      at[3],
                      at[4],
                      at[5],
                      at[6],
                      at[7],
                      at[8],
                      at[9],
                      at[10],
                      at[11],
                      at[12],
                      at[13],
                      at[14],
                      at[15]
                    ),
                    ot = 0;
                  ot < ut;
                  ot += 1
                )
                  o[ot] = this.matrix.props[ot];
                this.matrix.reset();
              } else
                for (this.matrix.reset(), ot = 0; ot < ut; ot += 1)
                  o[ot] = this.matrix.props[ot];
              (lt += 1), (d -= 1), (a += c);
            }
          } else
            for (d = this._currentCopies, a = 0, c = 1; d; )
              (e = this.elemsData[a].it),
                (o = e[e.length - 1].transform.mProps.v.props),
                (e[e.length - 1].transform.mProps._mdf = !1),
                (e[e.length - 1].transform.op._mdf = !1),
                (d -= 1),
                (a += c);
          return g;
        }),
        (RepeaterModifier.prototype.addShape = function () {});
      function RoundCornersModifier() {}
      extendPrototype([ShapeModifier], RoundCornersModifier),
        (RoundCornersModifier.prototype.initModifierProperties = function (
          s,
          e
        ) {
          (this.getValue = this.processKeys),
            (this.rd = PropertyFactory.getProp(s, e.r, 0, null, this)),
            (this._isAnimated = !!this.rd.effectsSequence.length);
        }),
        (RoundCornersModifier.prototype.processPath = function (s, e) {
          var o = shapePool.newElement();
          o.c = s.c;
          var a,
            c = s._length,
            d,
            g,
            _,
            b,
            j,
            $,
            _e = 0,
            et,
            rt,
            st,
            at,
            ct,
            it;
          for (a = 0; a < c; a += 1)
            (d = s.v[a]),
              (_ = s.o[a]),
              (g = s.i[a]),
              d[0] === _[0] && d[1] === _[1] && d[0] === g[0] && d[1] === g[1]
                ? (a === 0 || a === c - 1) && !s.c
                  ? (o.setTripleAt(d[0], d[1], _[0], _[1], g[0], g[1], _e),
                    (_e += 1))
                  : (a === 0 ? (b = s.v[c - 1]) : (b = s.v[a - 1]),
                    (j = Math.sqrt(
                      Math.pow(d[0] - b[0], 2) + Math.pow(d[1] - b[1], 2)
                    )),
                    ($ = j ? Math.min(j / 2, e) / j : 0),
                    (ct = d[0] + (b[0] - d[0]) * $),
                    (et = ct),
                    (it = d[1] - (d[1] - b[1]) * $),
                    (rt = it),
                    (st = et - (et - d[0]) * roundCorner),
                    (at = rt - (rt - d[1]) * roundCorner),
                    o.setTripleAt(et, rt, st, at, ct, it, _e),
                    (_e += 1),
                    a === c - 1 ? (b = s.v[0]) : (b = s.v[a + 1]),
                    (j = Math.sqrt(
                      Math.pow(d[0] - b[0], 2) + Math.pow(d[1] - b[1], 2)
                    )),
                    ($ = j ? Math.min(j / 2, e) / j : 0),
                    (st = d[0] + (b[0] - d[0]) * $),
                    (et = st),
                    (at = d[1] + (b[1] - d[1]) * $),
                    (rt = at),
                    (ct = et - (et - d[0]) * roundCorner),
                    (it = rt - (rt - d[1]) * roundCorner),
                    o.setTripleAt(et, rt, st, at, ct, it, _e),
                    (_e += 1))
                : (o.setTripleAt(
                    s.v[a][0],
                    s.v[a][1],
                    s.o[a][0],
                    s.o[a][1],
                    s.i[a][0],
                    s.i[a][1],
                    _e
                  ),
                  (_e += 1));
          return o;
        }),
        (RoundCornersModifier.prototype.processShapes = function (s) {
          var e,
            o,
            a = this.shapes.length,
            c,
            d,
            g = this.rd.v;
          if (g !== 0) {
            var _, b;
            for (o = 0; o < a; o += 1) {
              if (
                ((_ = this.shapes[o]),
                (b = _.localShapeCollection),
                !(!_.shape._mdf && !this._mdf && !s))
              )
                for (
                  b.releaseShapes(),
                    _.shape._mdf = !0,
                    e = _.shape.paths.shapes,
                    d = _.shape.paths._length,
                    c = 0;
                  c < d;
                  c += 1
                )
                  b.addShape(this.processPath(e[c], g));
              _.shape.paths = _.localShapeCollection;
            }
          }
          this.dynamicProperties.length || (this._mdf = !1);
        });
      function floatEqual(s, e) {
        return Math.abs(s - e) * 1e5 <= Math.min(Math.abs(s), Math.abs(e));
      }
      function floatZero(s) {
        return Math.abs(s) <= 1e-5;
      }
      function lerp(s, e, o) {
        return s * (1 - o) + e * o;
      }
      function lerpPoint(s, e, o) {
        return [lerp(s[0], e[0], o), lerp(s[1], e[1], o)];
      }
      function quadRoots(s, e, o) {
        if (s === 0) return [];
        var a = e * e - 4 * s * o;
        if (a < 0) return [];
        var c = -e / (2 * s);
        if (a === 0) return [c];
        var d = Math.sqrt(a) / (2 * s);
        return [c - d, c + d];
      }
      function polynomialCoefficients(s, e, o, a) {
        return [
          -s + 3 * e - 3 * o + a,
          3 * s - 6 * e + 3 * o,
          -3 * s + 3 * e,
          s,
        ];
      }
      function singlePoint(s) {
        return new PolynomialBezier(s, s, s, s, !1);
      }
      function PolynomialBezier(s, e, o, a, c) {
        c && pointEqual(s, e) && (e = lerpPoint(s, a, 1 / 3)),
          c && pointEqual(o, a) && (o = lerpPoint(s, a, 2 / 3));
        var d = polynomialCoefficients(s[0], e[0], o[0], a[0]),
          g = polynomialCoefficients(s[1], e[1], o[1], a[1]);
        (this.a = [d[0], g[0]]),
          (this.b = [d[1], g[1]]),
          (this.c = [d[2], g[2]]),
          (this.d = [d[3], g[3]]),
          (this.points = [s, e, o, a]);
      }
      (PolynomialBezier.prototype.point = function (s) {
        return [
          ((this.a[0] * s + this.b[0]) * s + this.c[0]) * s + this.d[0],
          ((this.a[1] * s + this.b[1]) * s + this.c[1]) * s + this.d[1],
        ];
      }),
        (PolynomialBezier.prototype.derivative = function (s) {
          return [
            (3 * s * this.a[0] + 2 * this.b[0]) * s + this.c[0],
            (3 * s * this.a[1] + 2 * this.b[1]) * s + this.c[1],
          ];
        }),
        (PolynomialBezier.prototype.tangentAngle = function (s) {
          var e = this.derivative(s);
          return Math.atan2(e[1], e[0]);
        }),
        (PolynomialBezier.prototype.normalAngle = function (s) {
          var e = this.derivative(s);
          return Math.atan2(e[0], e[1]);
        }),
        (PolynomialBezier.prototype.inflectionPoints = function () {
          var s = this.a[1] * this.b[0] - this.a[0] * this.b[1];
          if (floatZero(s)) return [];
          var e = (-0.5 * (this.a[1] * this.c[0] - this.a[0] * this.c[1])) / s,
            o =
              e * e -
              ((1 / 3) * (this.b[1] * this.c[0] - this.b[0] * this.c[1])) / s;
          if (o < 0) return [];
          var a = Math.sqrt(o);
          return floatZero(a)
            ? a > 0 && a < 1
              ? [e]
              : []
            : [e - a, e + a].filter(function (c) {
                return c > 0 && c < 1;
              });
        }),
        (PolynomialBezier.prototype.split = function (s) {
          if (s <= 0) return [singlePoint(this.points[0]), this];
          if (s >= 1)
            return [this, singlePoint(this.points[this.points.length - 1])];
          var e = lerpPoint(this.points[0], this.points[1], s),
            o = lerpPoint(this.points[1], this.points[2], s),
            a = lerpPoint(this.points[2], this.points[3], s),
            c = lerpPoint(e, o, s),
            d = lerpPoint(o, a, s),
            g = lerpPoint(c, d, s);
          return [
            new PolynomialBezier(this.points[0], e, c, g, !0),
            new PolynomialBezier(g, d, a, this.points[3], !0),
          ];
        });
      function extrema(s, e) {
        var o = s.points[0][e],
          a = s.points[s.points.length - 1][e];
        if (o > a) {
          var c = a;
          (a = o), (o = c);
        }
        for (
          var d = quadRoots(3 * s.a[e], 2 * s.b[e], s.c[e]), g = 0;
          g < d.length;
          g += 1
        )
          if (d[g] > 0 && d[g] < 1) {
            var _ = s.point(d[g])[e];
            _ < o ? (o = _) : _ > a && (a = _);
          }
        return { min: o, max: a };
      }
      (PolynomialBezier.prototype.bounds = function () {
        return { x: extrema(this, 0), y: extrema(this, 1) };
      }),
        (PolynomialBezier.prototype.boundingBox = function () {
          var s = this.bounds();
          return {
            left: s.x.min,
            right: s.x.max,
            top: s.y.min,
            bottom: s.y.max,
            width: s.x.max - s.x.min,
            height: s.y.max - s.y.min,
            cx: (s.x.max + s.x.min) / 2,
            cy: (s.y.max + s.y.min) / 2,
          };
        });
      function intersectData(s, e, o) {
        var a = s.boundingBox();
        return {
          cx: a.cx,
          cy: a.cy,
          width: a.width,
          height: a.height,
          bez: s,
          t: (e + o) / 2,
          t1: e,
          t2: o,
        };
      }
      function splitData(s) {
        var e = s.bez.split(0.5);
        return [intersectData(e[0], s.t1, s.t), intersectData(e[1], s.t, s.t2)];
      }
      function boxIntersect(s, e) {
        return (
          Math.abs(s.cx - e.cx) * 2 < s.width + e.width &&
          Math.abs(s.cy - e.cy) * 2 < s.height + e.height
        );
      }
      function intersectsImpl(s, e, o, a, c, d) {
        if (boxIntersect(s, e)) {
          if (
            o >= d ||
            (s.width <= a && s.height <= a && e.width <= a && e.height <= a)
          ) {
            c.push([s.t, e.t]);
            return;
          }
          var g = splitData(s),
            _ = splitData(e);
          intersectsImpl(g[0], _[0], o + 1, a, c, d),
            intersectsImpl(g[0], _[1], o + 1, a, c, d),
            intersectsImpl(g[1], _[0], o + 1, a, c, d),
            intersectsImpl(g[1], _[1], o + 1, a, c, d);
        }
      }
      (PolynomialBezier.prototype.intersections = function (s, e, o) {
        e === void 0 && (e = 2), o === void 0 && (o = 7);
        var a = [];
        return (
          intersectsImpl(
            intersectData(this, 0, 1),
            intersectData(s, 0, 1),
            0,
            e,
            a,
            o
          ),
          a
        );
      }),
        (PolynomialBezier.shapeSegment = function (s, e) {
          var o = (e + 1) % s.length();
          return new PolynomialBezier(s.v[e], s.o[e], s.i[o], s.v[o], !0);
        }),
        (PolynomialBezier.shapeSegmentInverted = function (s, e) {
          var o = (e + 1) % s.length();
          return new PolynomialBezier(s.v[o], s.i[o], s.o[e], s.v[e], !0);
        });
      function crossProduct(s, e) {
        return [
          s[1] * e[2] - s[2] * e[1],
          s[2] * e[0] - s[0] * e[2],
          s[0] * e[1] - s[1] * e[0],
        ];
      }
      function lineIntersection(s, e, o, a) {
        var c = [s[0], s[1], 1],
          d = [e[0], e[1], 1],
          g = [o[0], o[1], 1],
          _ = [a[0], a[1], 1],
          b = crossProduct(crossProduct(c, d), crossProduct(g, _));
        return floatZero(b[2]) ? null : [b[0] / b[2], b[1] / b[2]];
      }
      function polarOffset(s, e, o) {
        return [s[0] + Math.cos(e) * o, s[1] - Math.sin(e) * o];
      }
      function pointDistance(s, e) {
        return Math.hypot(s[0] - e[0], s[1] - e[1]);
      }
      function pointEqual(s, e) {
        return floatEqual(s[0], e[0]) && floatEqual(s[1], e[1]);
      }
      function ZigZagModifier() {}
      extendPrototype([ShapeModifier], ZigZagModifier),
        (ZigZagModifier.prototype.initModifierProperties = function (s, e) {
          (this.getValue = this.processKeys),
            (this.amplitude = PropertyFactory.getProp(s, e.s, 0, null, this)),
            (this.frequency = PropertyFactory.getProp(s, e.r, 0, null, this)),
            (this.pointsType = PropertyFactory.getProp(s, e.pt, 0, null, this)),
            (this._isAnimated =
              this.amplitude.effectsSequence.length !== 0 ||
              this.frequency.effectsSequence.length !== 0 ||
              this.pointsType.effectsSequence.length !== 0);
        });
      function setPoint(s, e, o, a, c, d, g) {
        var _ = o - Math.PI / 2,
          b = o + Math.PI / 2,
          j = e[0] + Math.cos(o) * a * c,
          $ = e[1] - Math.sin(o) * a * c;
        s.setTripleAt(
          j,
          $,
          j + Math.cos(_) * d,
          $ - Math.sin(_) * d,
          j + Math.cos(b) * g,
          $ - Math.sin(b) * g,
          s.length()
        );
      }
      function getPerpendicularVector(s, e) {
        var o = [e[0] - s[0], e[1] - s[1]],
          a = -Math.PI * 0.5,
          c = [
            Math.cos(a) * o[0] - Math.sin(a) * o[1],
            Math.sin(a) * o[0] + Math.cos(a) * o[1],
          ];
        return c;
      }
      function getProjectingAngle(s, e) {
        var o = e === 0 ? s.length() - 1 : e - 1,
          a = (e + 1) % s.length(),
          c = s.v[o],
          d = s.v[a],
          g = getPerpendicularVector(c, d);
        return Math.atan2(0, 1) - Math.atan2(g[1], g[0]);
      }
      function zigZagCorner(s, e, o, a, c, d, g) {
        var _ = getProjectingAngle(e, o),
          b = e.v[o % e._length],
          j = e.v[o === 0 ? e._length - 1 : o - 1],
          $ = e.v[(o + 1) % e._length],
          _e =
            d === 2
              ? Math.sqrt(Math.pow(b[0] - j[0], 2) + Math.pow(b[1] - j[1], 2))
              : 0,
          et =
            d === 2
              ? Math.sqrt(Math.pow(b[0] - $[0], 2) + Math.pow(b[1] - $[1], 2))
              : 0;
        setPoint(
          s,
          e.v[o % e._length],
          _,
          g,
          a,
          et / ((c + 1) * 2),
          _e / ((c + 1) * 2)
        );
      }
      function zigZagSegment(s, e, o, a, c, d) {
        for (var g = 0; g < a; g += 1) {
          var _ = (g + 1) / (a + 1),
            b =
              c === 2
                ? Math.sqrt(
                    Math.pow(e.points[3][0] - e.points[0][0], 2) +
                      Math.pow(e.points[3][1] - e.points[0][1], 2)
                  )
                : 0,
            j = e.normalAngle(_),
            $ = e.point(_);
          setPoint(s, $, j, d, o, b / ((a + 1) * 2), b / ((a + 1) * 2)),
            (d = -d);
        }
        return d;
      }
      (ZigZagModifier.prototype.processPath = function (s, e, o, a) {
        var c = s._length,
          d = shapePool.newElement();
        if (((d.c = s.c), s.c || (c -= 1), c === 0)) return d;
        var g = -1,
          _ = PolynomialBezier.shapeSegment(s, 0);
        zigZagCorner(d, s, 0, e, o, a, g);
        for (var b = 0; b < c; b += 1)
          (g = zigZagSegment(d, _, e, o, a, -g)),
            b === c - 1 && !s.c
              ? (_ = null)
              : (_ = PolynomialBezier.shapeSegment(s, (b + 1) % c)),
            zigZagCorner(d, s, b + 1, e, o, a, g);
        return d;
      }),
        (ZigZagModifier.prototype.processShapes = function (s) {
          var e,
            o,
            a = this.shapes.length,
            c,
            d,
            g = this.amplitude.v,
            _ = Math.max(0, Math.round(this.frequency.v)),
            b = this.pointsType.v;
          if (g !== 0) {
            var j, $;
            for (o = 0; o < a; o += 1) {
              if (
                ((j = this.shapes[o]),
                ($ = j.localShapeCollection),
                !(!j.shape._mdf && !this._mdf && !s))
              )
                for (
                  $.releaseShapes(),
                    j.shape._mdf = !0,
                    e = j.shape.paths.shapes,
                    d = j.shape.paths._length,
                    c = 0;
                  c < d;
                  c += 1
                )
                  $.addShape(this.processPath(e[c], g, _, b));
              j.shape.paths = j.localShapeCollection;
            }
          }
          this.dynamicProperties.length || (this._mdf = !1);
        });
      function linearOffset(s, e, o) {
        var a = Math.atan2(e[0] - s[0], e[1] - s[1]);
        return [polarOffset(s, a, o), polarOffset(e, a, o)];
      }
      function offsetSegment(s, e) {
        var o, a, c, d, g, _, b;
        (b = linearOffset(s.points[0], s.points[1], e)),
          (o = b[0]),
          (a = b[1]),
          (b = linearOffset(s.points[1], s.points[2], e)),
          (c = b[0]),
          (d = b[1]),
          (b = linearOffset(s.points[2], s.points[3], e)),
          (g = b[0]),
          (_ = b[1]);
        var j = lineIntersection(o, a, c, d);
        j === null && (j = a);
        var $ = lineIntersection(g, _, c, d);
        return $ === null && ($ = g), new PolynomialBezier(o, j, $, _);
      }
      function joinLines(s, e, o, a, c) {
        var d = e.points[3],
          g = o.points[0];
        if (a === 3 || pointEqual(d, g)) return d;
        if (a === 2) {
          var _ = -e.tangentAngle(1),
            b = -o.tangentAngle(0) + Math.PI,
            j = lineIntersection(
              d,
              polarOffset(d, _ + Math.PI / 2, 100),
              g,
              polarOffset(g, _ + Math.PI / 2, 100)
            ),
            $ = j ? pointDistance(j, d) : pointDistance(d, g) / 2,
            _e = polarOffset(d, _, 2 * $ * roundCorner);
          return (
            s.setXYAt(_e[0], _e[1], "o", s.length() - 1),
            (_e = polarOffset(g, b, 2 * $ * roundCorner)),
            s.setTripleAt(g[0], g[1], g[0], g[1], _e[0], _e[1], s.length()),
            g
          );
        }
        var et = pointEqual(d, e.points[2]) ? e.points[0] : e.points[2],
          rt = pointEqual(g, o.points[1]) ? o.points[3] : o.points[1],
          st = lineIntersection(et, d, g, rt);
        return st && pointDistance(st, d) < c
          ? (s.setTripleAt(
              st[0],
              st[1],
              st[0],
              st[1],
              st[0],
              st[1],
              s.length()
            ),
            st)
          : d;
      }
      function getIntersection(s, e) {
        var o = s.intersections(e);
        return (
          o.length && floatEqual(o[0][0], 1) && o.shift(),
          o.length ? o[0] : null
        );
      }
      function pruneSegmentIntersection(s, e) {
        var o = s.slice(),
          a = e.slice(),
          c = getIntersection(s[s.length - 1], e[0]);
        return (
          c &&
            ((o[s.length - 1] = s[s.length - 1].split(c[0])[0]),
            (a[0] = e[0].split(c[1])[1])),
          s.length > 1 &&
          e.length > 1 &&
          ((c = getIntersection(s[0], e[e.length - 1])), c)
            ? [[s[0].split(c[0])[0]], [e[e.length - 1].split(c[1])[1]]]
            : [o, a]
        );
      }
      function pruneIntersections(s) {
        for (var e, o = 1; o < s.length; o += 1)
          (e = pruneSegmentIntersection(s[o - 1], s[o])),
            (s[o - 1] = e[0]),
            (s[o] = e[1]);
        return (
          s.length > 1 &&
            ((e = pruneSegmentIntersection(s[s.length - 1], s[0])),
            (s[s.length - 1] = e[0]),
            (s[0] = e[1])),
          s
        );
      }
      function offsetSegmentSplit(s, e) {
        var o = s.inflectionPoints(),
          a,
          c,
          d,
          g;
        if (o.length === 0) return [offsetSegment(s, e)];
        if (o.length === 1 || floatEqual(o[1], 1))
          return (
            (d = s.split(o[0])),
            (a = d[0]),
            (c = d[1]),
            [offsetSegment(a, e), offsetSegment(c, e)]
          );
        (d = s.split(o[0])), (a = d[0]);
        var _ = (o[1] - o[0]) / (1 - o[0]);
        return (
          (d = d[1].split(_)),
          (g = d[0]),
          (c = d[1]),
          [offsetSegment(a, e), offsetSegment(g, e), offsetSegment(c, e)]
        );
      }
      function OffsetPathModifier() {}
      extendPrototype([ShapeModifier], OffsetPathModifier),
        (OffsetPathModifier.prototype.initModifierProperties = function (s, e) {
          (this.getValue = this.processKeys),
            (this.amount = PropertyFactory.getProp(s, e.a, 0, null, this)),
            (this.miterLimit = PropertyFactory.getProp(s, e.ml, 0, null, this)),
            (this.lineJoin = e.lj),
            (this._isAnimated = this.amount.effectsSequence.length !== 0);
        }),
        (OffsetPathModifier.prototype.processPath = function (s, e, o, a) {
          var c = shapePool.newElement();
          c.c = s.c;
          var d = s.length();
          s.c || (d -= 1);
          var g,
            _,
            b,
            j = [];
          for (g = 0; g < d; g += 1)
            (b = PolynomialBezier.shapeSegment(s, g)),
              j.push(offsetSegmentSplit(b, e));
          if (!s.c)
            for (g = d - 1; g >= 0; g -= 1)
              (b = PolynomialBezier.shapeSegmentInverted(s, g)),
                j.push(offsetSegmentSplit(b, e));
          j = pruneIntersections(j);
          var $ = null,
            _e = null;
          for (g = 0; g < j.length; g += 1) {
            var et = j[g];
            for (
              _e && ($ = joinLines(c, _e, et[0], o, a)),
                _e = et[et.length - 1],
                _ = 0;
              _ < et.length;
              _ += 1
            )
              (b = et[_]),
                $ && pointEqual(b.points[0], $)
                  ? c.setXYAt(
                      b.points[1][0],
                      b.points[1][1],
                      "o",
                      c.length() - 1
                    )
                  : c.setTripleAt(
                      b.points[0][0],
                      b.points[0][1],
                      b.points[1][0],
                      b.points[1][1],
                      b.points[0][0],
                      b.points[0][1],
                      c.length()
                    ),
                c.setTripleAt(
                  b.points[3][0],
                  b.points[3][1],
                  b.points[3][0],
                  b.points[3][1],
                  b.points[2][0],
                  b.points[2][1],
                  c.length()
                ),
                ($ = b.points[3]);
          }
          return j.length && joinLines(c, _e, j[0][0], o, a), c;
        }),
        (OffsetPathModifier.prototype.processShapes = function (s) {
          var e,
            o,
            a = this.shapes.length,
            c,
            d,
            g = this.amount.v,
            _ = this.miterLimit.v,
            b = this.lineJoin;
          if (g !== 0) {
            var j, $;
            for (o = 0; o < a; o += 1) {
              if (
                ((j = this.shapes[o]),
                ($ = j.localShapeCollection),
                !(!j.shape._mdf && !this._mdf && !s))
              )
                for (
                  $.releaseShapes(),
                    j.shape._mdf = !0,
                    e = j.shape.paths.shapes,
                    d = j.shape.paths._length,
                    c = 0;
                  c < d;
                  c += 1
                )
                  $.addShape(this.processPath(e[c], g, b, _));
              j.shape.paths = j.localShapeCollection;
            }
          }
          this.dynamicProperties.length || (this._mdf = !1);
        });
      function getFontProperties(s) {
        for (
          var e = s.fStyle ? s.fStyle.split(" ") : [],
            o = "normal",
            a = "normal",
            c = e.length,
            d,
            g = 0;
          g < c;
          g += 1
        )
          switch (((d = e[g].toLowerCase()), d)) {
            case "italic":
              a = "italic";
              break;
            case "bold":
              o = "700";
              break;
            case "black":
              o = "900";
              break;
            case "medium":
              o = "500";
              break;
            case "regular":
            case "normal":
              o = "400";
              break;
            case "light":
            case "thin":
              o = "200";
              break;
          }
        return { style: a, weight: s.fWeight || o };
      }
      var FontManager = (function () {
        var s = 5e3,
          e = { w: 0, size: 0, shapes: [], data: { shapes: [] } },
          o = [];
        o = o.concat([
          2304, 2305, 2306, 2307, 2362, 2363, 2364, 2364, 2366, 2367, 2368,
          2369, 2370, 2371, 2372, 2373, 2374, 2375, 2376, 2377, 2378, 2379,
          2380, 2381, 2382, 2383, 2387, 2388, 2389, 2390, 2391, 2402, 2403,
        ]);
        var a = 127988,
          c = 917631,
          d = 917601,
          g = 917626,
          _ = 65039,
          b = 8205,
          j = 127462,
          $ = 127487,
          _e = ["d83cdffb", "d83cdffc", "d83cdffd", "d83cdffe", "d83cdfff"];
        function et(Et) {
          var bt = Et.split(","),
            mt,
            vt = bt.length,
            Ct = [];
          for (mt = 0; mt < vt; mt += 1)
            bt[mt] !== "sans-serif" &&
              bt[mt] !== "monospace" &&
              Ct.push(bt[mt]);
          return Ct.join(",");
        }
        function rt(Et, bt) {
          var mt = createTag("span");
          mt.setAttribute("aria-hidden", !0), (mt.style.fontFamily = bt);
          var vt = createTag("span");
          (vt.innerText = "giItT1WQy@!-/#"),
            (mt.style.position = "absolute"),
            (mt.style.left = "-10000px"),
            (mt.style.top = "-10000px"),
            (mt.style.fontSize = "300px"),
            (mt.style.fontVariant = "normal"),
            (mt.style.fontStyle = "normal"),
            (mt.style.fontWeight = "normal"),
            (mt.style.letterSpacing = "0"),
            mt.appendChild(vt),
            document.body.appendChild(mt);
          var Ct = vt.offsetWidth;
          return (
            (vt.style.fontFamily = et(Et) + ", " + bt),
            { node: vt, w: Ct, parent: mt }
          );
        }
        function st() {
          var Et,
            bt = this.fonts.length,
            mt,
            vt,
            Ct = bt;
          for (Et = 0; Et < bt; Et += 1)
            this.fonts[Et].loaded
              ? (Ct -= 1)
              : this.fonts[Et].fOrigin === "n" || this.fonts[Et].origin === 0
              ? (this.fonts[Et].loaded = !0)
              : ((mt = this.fonts[Et].monoCase.node),
                (vt = this.fonts[Et].monoCase.w),
                mt.offsetWidth !== vt
                  ? ((Ct -= 1), (this.fonts[Et].loaded = !0))
                  : ((mt = this.fonts[Et].sansCase.node),
                    (vt = this.fonts[Et].sansCase.w),
                    mt.offsetWidth !== vt &&
                      ((Ct -= 1), (this.fonts[Et].loaded = !0))),
                this.fonts[Et].loaded &&
                  (this.fonts[Et].sansCase.parent.parentNode.removeChild(
                    this.fonts[Et].sansCase.parent
                  ),
                  this.fonts[Et].monoCase.parent.parentNode.removeChild(
                    this.fonts[Et].monoCase.parent
                  )));
          Ct !== 0 && Date.now() - this.initTime < s
            ? setTimeout(this.checkLoadedFontsBinded, 20)
            : setTimeout(this.setIsLoadedBinded, 10);
        }
        function at(Et, bt) {
          var mt = document.body && bt ? "svg" : "canvas",
            vt,
            Ct = getFontProperties(Et);
          if (mt === "svg") {
            var Tt = createNS("text");
            (Tt.style.fontSize = "100px"),
              Tt.setAttribute("font-family", Et.fFamily),
              Tt.setAttribute("font-style", Ct.style),
              Tt.setAttribute("font-weight", Ct.weight),
              (Tt.textContent = "1"),
              Et.fClass
                ? ((Tt.style.fontFamily = "inherit"),
                  Tt.setAttribute("class", Et.fClass))
                : (Tt.style.fontFamily = Et.fFamily),
              bt.appendChild(Tt),
              (vt = Tt);
          } else {
            var Dt = new OffscreenCanvas(500, 500).getContext("2d");
            (Dt.font = Ct.style + " " + Ct.weight + " 100px " + Et.fFamily),
              (vt = Dt);
          }
          function Wt(Pt) {
            return mt === "svg"
              ? ((vt.textContent = Pt), vt.getComputedTextLength())
              : vt.measureText(Pt).width;
          }
          return { measureText: Wt };
        }
        function ct(Et, bt) {
          if (!Et) {
            this.isLoaded = !0;
            return;
          }
          if (this.chars) {
            (this.isLoaded = !0), (this.fonts = Et.list);
            return;
          }
          if (!document.body) {
            (this.isLoaded = !0),
              Et.list.forEach(function (_n) {
                (_n.helper = at(_n)), (_n.cache = {});
              }),
              (this.fonts = Et.list);
            return;
          }
          var mt = Et.list,
            vt,
            Ct = mt.length,
            Tt = Ct;
          for (vt = 0; vt < Ct; vt += 1) {
            var Dt = !0,
              Wt,
              Pt;
            if (
              ((mt[vt].loaded = !1),
              (mt[vt].monoCase = rt(mt[vt].fFamily, "monospace")),
              (mt[vt].sansCase = rt(mt[vt].fFamily, "sans-serif")),
              !mt[vt].fPath)
            )
              (mt[vt].loaded = !0), (Tt -= 1);
            else if (mt[vt].fOrigin === "p" || mt[vt].origin === 3) {
              if (
                ((Wt = document.querySelectorAll(
                  'style[f-forigin="p"][f-family="' +
                    mt[vt].fFamily +
                    '"], style[f-origin="3"][f-family="' +
                    mt[vt].fFamily +
                    '"]'
                )),
                Wt.length > 0 && (Dt = !1),
                Dt)
              ) {
                var Jt = createTag("style");
                Jt.setAttribute("f-forigin", mt[vt].fOrigin),
                  Jt.setAttribute("f-origin", mt[vt].origin),
                  Jt.setAttribute("f-family", mt[vt].fFamily),
                  (Jt.type = "text/css"),
                  (Jt.innerText =
                    "@font-face {font-family: " +
                    mt[vt].fFamily +
                    "; font-style: normal; src: url('" +
                    mt[vt].fPath +
                    "');}"),
                  bt.appendChild(Jt);
              }
            } else if (mt[vt].fOrigin === "g" || mt[vt].origin === 1) {
              for (
                Wt = document.querySelectorAll(
                  'link[f-forigin="g"], link[f-origin="1"]'
                ),
                  Pt = 0;
                Pt < Wt.length;
                Pt += 1
              )
                Wt[Pt].href.indexOf(mt[vt].fPath) !== -1 && (Dt = !1);
              if (Dt) {
                var Gt = createTag("link");
                Gt.setAttribute("f-forigin", mt[vt].fOrigin),
                  Gt.setAttribute("f-origin", mt[vt].origin),
                  (Gt.type = "text/css"),
                  (Gt.rel = "stylesheet"),
                  (Gt.href = mt[vt].fPath),
                  document.body.appendChild(Gt);
              }
            } else if (mt[vt].fOrigin === "t" || mt[vt].origin === 2) {
              for (
                Wt = document.querySelectorAll(
                  'script[f-forigin="t"], script[f-origin="2"]'
                ),
                  Pt = 0;
                Pt < Wt.length;
                Pt += 1
              )
                mt[vt].fPath === Wt[Pt].src && (Dt = !1);
              if (Dt) {
                var en = createTag("link");
                en.setAttribute("f-forigin", mt[vt].fOrigin),
                  en.setAttribute("f-origin", mt[vt].origin),
                  en.setAttribute("rel", "stylesheet"),
                  en.setAttribute("href", mt[vt].fPath),
                  bt.appendChild(en);
              }
            }
            (mt[vt].helper = at(mt[vt], bt)),
              (mt[vt].cache = {}),
              this.fonts.push(mt[vt]);
          }
          Tt === 0
            ? (this.isLoaded = !0)
            : setTimeout(this.checkLoadedFonts.bind(this), 100);
        }
        function it(Et) {
          if (Et) {
            this.chars || (this.chars = []);
            var bt,
              mt = Et.length,
              vt,
              Ct = this.chars.length,
              Tt;
            for (bt = 0; bt < mt; bt += 1) {
              for (vt = 0, Tt = !1; vt < Ct; )
                this.chars[vt].style === Et[bt].style &&
                  this.chars[vt].fFamily === Et[bt].fFamily &&
                  this.chars[vt].ch === Et[bt].ch &&
                  (Tt = !0),
                  (vt += 1);
              Tt || (this.chars.push(Et[bt]), (Ct += 1));
            }
          }
        }
        function lt(Et, bt, mt) {
          for (var vt = 0, Ct = this.chars.length; vt < Ct; ) {
            if (
              this.chars[vt].ch === Et &&
              this.chars[vt].style === bt &&
              this.chars[vt].fFamily === mt
            )
              return this.chars[vt];
            vt += 1;
          }
          return (
            ((typeof Et == "string" && Et.charCodeAt(0) !== 13) || !Et) &&
              console &&
              console.warn &&
              !this._warned &&
              ((this._warned = !0),
              console.warn(
                "Missing character from exported characters list: ",
                Et,
                bt,
                mt
              )),
            e
          );
        }
        function ot(Et, bt, mt) {
          var vt = this.getFontByName(bt),
            Ct = Et;
          if (!vt.cache[Ct]) {
            var Tt = vt.helper;
            if (Et === " ") {
              var Dt = Tt.measureText("|" + Et + "|"),
                Wt = Tt.measureText("||");
              vt.cache[Ct] = (Dt - Wt) / 100;
            } else vt.cache[Ct] = Tt.measureText(Et) / 100;
          }
          return vt.cache[Ct] * mt;
        }
        function ut(Et) {
          for (var bt = 0, mt = this.fonts.length; bt < mt; ) {
            if (this.fonts[bt].fName === Et) return this.fonts[bt];
            bt += 1;
          }
          return this.fonts[0];
        }
        function pt(Et) {
          var bt = 0,
            mt = Et.charCodeAt(0);
          if (mt >= 55296 && mt <= 56319) {
            var vt = Et.charCodeAt(1);
            vt >= 56320 &&
              vt <= 57343 &&
              (bt = (mt - 55296) * 1024 + vt - 56320 + 65536);
          }
          return bt;
        }
        function ft(Et, bt) {
          var mt = Et.toString(16) + bt.toString(16);
          return _e.indexOf(mt) !== -1;
        }
        function gt(Et) {
          return Et === b;
        }
        function xt(Et) {
          return Et === _;
        }
        function _t(Et) {
          var bt = pt(Et);
          return bt >= j && bt <= $;
        }
        function St(Et) {
          return _t(Et.substr(0, 2)) && _t(Et.substr(2, 2));
        }
        function Mt(Et) {
          return o.indexOf(Et) !== -1;
        }
        function Rt(Et, bt) {
          var mt = pt(Et.substr(bt, 2));
          if (mt !== a) return !1;
          var vt = 0;
          for (bt += 2; vt < 5; ) {
            if (((mt = pt(Et.substr(bt, 2))), mt < d || mt > g)) return !1;
            (vt += 1), (bt += 2);
          }
          return pt(Et.substr(bt, 2)) === c;
        }
        function Ft() {
          this.isLoaded = !0;
        }
        var Ot = function () {
          (this.fonts = []),
            (this.chars = null),
            (this.typekitLoaded = 0),
            (this.isLoaded = !1),
            (this._warned = !1),
            (this.initTime = Date.now()),
            (this.setIsLoadedBinded = this.setIsLoaded.bind(this)),
            (this.checkLoadedFontsBinded = this.checkLoadedFonts.bind(this));
        };
        (Ot.isModifier = ft),
          (Ot.isZeroWidthJoiner = gt),
          (Ot.isFlagEmoji = St),
          (Ot.isRegionalCode = _t),
          (Ot.isCombinedCharacter = Mt),
          (Ot.isRegionalFlag = Rt),
          (Ot.isVariationSelector = xt),
          (Ot.BLACK_FLAG_CODE_POINT = a);
        var Lt = {
          addChars: it,
          addFonts: ct,
          getCharData: lt,
          getFontByName: ut,
          measureText: ot,
          checkLoadedFonts: st,
          setIsLoaded: Ft,
        };
        return (Ot.prototype = Lt), Ot;
      })();
      function SlotManager(s) {
        this.animationData = s;
      }
      SlotManager.prototype.getProp = function (s) {
        return this.animationData.slots && this.animationData.slots[s.sid]
          ? Object.assign(s, this.animationData.slots[s.sid].p)
          : s;
      };
      function slotFactory(s) {
        return new SlotManager(s);
      }
      function RenderableElement() {}
      RenderableElement.prototype = {
        initRenderable: function () {
          (this.isInRange = !1),
            (this.hidden = !1),
            (this.isTransparent = !1),
            (this.renderableComponents = []);
        },
        addRenderableComponent: function (e) {
          this.renderableComponents.indexOf(e) === -1 &&
            this.renderableComponents.push(e);
        },
        removeRenderableComponent: function (e) {
          this.renderableComponents.indexOf(e) !== -1 &&
            this.renderableComponents.splice(
              this.renderableComponents.indexOf(e),
              1
            );
        },
        prepareRenderableFrame: function (e) {
          this.checkLayerLimits(e);
        },
        checkTransparency: function () {
          this.finalTransform.mProp.o.v <= 0
            ? !this.isTransparent &&
              this.globalData.renderConfig.hideOnTransparent &&
              ((this.isTransparent = !0), this.hide())
            : this.isTransparent && ((this.isTransparent = !1), this.show());
        },
        checkLayerLimits: function (e) {
          this.data.ip - this.data.st <= e && this.data.op - this.data.st > e
            ? this.isInRange !== !0 &&
              ((this.globalData._mdf = !0),
              (this._mdf = !0),
              (this.isInRange = !0),
              this.show())
            : this.isInRange !== !1 &&
              ((this.globalData._mdf = !0), (this.isInRange = !1), this.hide());
        },
        renderRenderable: function () {
          var e,
            o = this.renderableComponents.length;
          for (e = 0; e < o; e += 1)
            this.renderableComponents[e].renderFrame(this._isFirstFrame);
        },
        sourceRectAtTime: function () {
          return { top: 0, left: 0, width: 100, height: 100 };
        },
        getLayerSize: function () {
          return this.data.ty === 5
            ? { w: this.data.textData.width, h: this.data.textData.height }
            : { w: this.data.width, h: this.data.height };
        },
      };
      var getBlendMode = (function () {
        var s = {
          0: "source-over",
          1: "multiply",
          2: "screen",
          3: "overlay",
          4: "darken",
          5: "lighten",
          6: "color-dodge",
          7: "color-burn",
          8: "hard-light",
          9: "soft-light",
          10: "difference",
          11: "exclusion",
          12: "hue",
          13: "saturation",
          14: "color",
          15: "luminosity",
        };
        return function (e) {
          return s[e] || "";
        };
      })();
      function SliderEffect(s, e, o) {
        this.p = PropertyFactory.getProp(e, s.v, 0, 0, o);
      }
      function AngleEffect(s, e, o) {
        this.p = PropertyFactory.getProp(e, s.v, 0, 0, o);
      }
      function ColorEffect(s, e, o) {
        this.p = PropertyFactory.getProp(e, s.v, 1, 0, o);
      }
      function PointEffect(s, e, o) {
        this.p = PropertyFactory.getProp(e, s.v, 1, 0, o);
      }
      function LayerIndexEffect(s, e, o) {
        this.p = PropertyFactory.getProp(e, s.v, 0, 0, o);
      }
      function MaskIndexEffect(s, e, o) {
        this.p = PropertyFactory.getProp(e, s.v, 0, 0, o);
      }
      function CheckboxEffect(s, e, o) {
        this.p = PropertyFactory.getProp(e, s.v, 0, 0, o);
      }
      function NoValueEffect() {
        this.p = {};
      }
      function EffectsManager(s, e) {
        var o = s.ef || [];
        this.effectElements = [];
        var a,
          c = o.length,
          d;
        for (a = 0; a < c; a += 1)
          (d = new GroupEffect(o[a], e)), this.effectElements.push(d);
      }
      function GroupEffect(s, e) {
        this.init(s, e);
      }
      extendPrototype([DynamicPropertyContainer], GroupEffect),
        (GroupEffect.prototype.getValue =
          GroupEffect.prototype.iterateDynamicProperties),
        (GroupEffect.prototype.init = function (s, e) {
          (this.data = s),
            (this.effectElements = []),
            this.initDynamicPropertyContainer(e);
          var o,
            a = this.data.ef.length,
            c,
            d = this.data.ef;
          for (o = 0; o < a; o += 1) {
            switch (((c = null), d[o].ty)) {
              case 0:
                c = new SliderEffect(d[o], e, this);
                break;
              case 1:
                c = new AngleEffect(d[o], e, this);
                break;
              case 2:
                c = new ColorEffect(d[o], e, this);
                break;
              case 3:
                c = new PointEffect(d[o], e, this);
                break;
              case 4:
              case 7:
                c = new CheckboxEffect(d[o], e, this);
                break;
              case 10:
                c = new LayerIndexEffect(d[o], e, this);
                break;
              case 11:
                c = new MaskIndexEffect(d[o], e, this);
                break;
              case 5:
                c = new EffectsManager(d[o], e);
                break;
              default:
                c = new NoValueEffect(d[o]);
                break;
            }
            c && this.effectElements.push(c);
          }
        });
      function BaseElement() {}
      BaseElement.prototype = {
        checkMasks: function () {
          if (!this.data.hasMask) return !1;
          for (var e = 0, o = this.data.masksProperties.length; e < o; ) {
            if (
              this.data.masksProperties[e].mode !== "n" &&
              this.data.masksProperties[e].cl !== !1
            )
              return !0;
            e += 1;
          }
          return !1;
        },
        initExpressions: function () {
          var e = getExpressionInterfaces();
          if (e) {
            var o = e("layer"),
              a = e("effects"),
              c = e("shape"),
              d = e("text"),
              g = e("comp");
            (this.layerInterface = o(this)),
              this.data.hasMask &&
                this.maskManager &&
                this.layerInterface.registerMaskInterface(this.maskManager);
            var _ = a.createEffectsInterface(this, this.layerInterface);
            this.layerInterface.registerEffectsInterface(_),
              this.data.ty === 0 || this.data.xt
                ? (this.compInterface = g(this))
                : this.data.ty === 4
                ? ((this.layerInterface.shapeInterface = c(
                    this.shapesData,
                    this.itemsData,
                    this.layerInterface
                  )),
                  (this.layerInterface.content =
                    this.layerInterface.shapeInterface))
                : this.data.ty === 5 &&
                  ((this.layerInterface.textInterface = d(this)),
                  (this.layerInterface.text =
                    this.layerInterface.textInterface));
          }
        },
        setBlendMode: function () {
          var e = getBlendMode(this.data.bm),
            o = this.baseElement || this.layerElement;
          o.style["mix-blend-mode"] = e;
        },
        initBaseData: function (e, o, a) {
          (this.globalData = o),
            (this.comp = a),
            (this.data = e),
            (this.layerId = createElementID()),
            this.data.sr || (this.data.sr = 1),
            (this.effectsManager = new EffectsManager(
              this.data,
              this,
              this.dynamicProperties
            ));
        },
        getType: function () {
          return this.type;
        },
        sourceRectAtTime: function () {},
      };
      function FrameElement() {}
      FrameElement.prototype = {
        initFrame: function () {
          (this._isFirstFrame = !1),
            (this.dynamicProperties = []),
            (this._mdf = !1);
        },
        prepareProperties: function (e, o) {
          var a,
            c = this.dynamicProperties.length;
          for (a = 0; a < c; a += 1)
            (o ||
              (this._isParent &&
                this.dynamicProperties[a].propType === "transform")) &&
              (this.dynamicProperties[a].getValue(),
              this.dynamicProperties[a]._mdf &&
                ((this.globalData._mdf = !0), (this._mdf = !0)));
        },
        addDynamicProperty: function (e) {
          this.dynamicProperties.indexOf(e) === -1 &&
            this.dynamicProperties.push(e);
        },
      };
      function FootageElement(s, e, o) {
        this.initFrame(),
          this.initRenderable(),
          (this.assetData = e.getAssetData(s.refId)),
          (this.footageData = e.imageLoader.getAsset(this.assetData)),
          this.initBaseData(s, e, o);
      }
      (FootageElement.prototype.prepareFrame = function () {}),
        extendPrototype(
          [RenderableElement, BaseElement, FrameElement],
          FootageElement
        ),
        (FootageElement.prototype.getBaseElement = function () {
          return null;
        }),
        (FootageElement.prototype.renderFrame = function () {}),
        (FootageElement.prototype.destroy = function () {}),
        (FootageElement.prototype.initExpressions = function () {
          var s = getExpressionInterfaces();
          if (s) {
            var e = s("footage");
            this.layerInterface = e(this);
          }
        }),
        (FootageElement.prototype.getFootageData = function () {
          return this.footageData;
        });
      function AudioElement(s, e, o) {
        this.initFrame(),
          this.initRenderable(),
          (this.assetData = e.getAssetData(s.refId)),
          this.initBaseData(s, e, o),
          (this._isPlaying = !1),
          (this._canPlay = !1);
        var a = this.globalData.getAssetsPath(this.assetData);
        (this.audio = this.globalData.audioController.createAudio(a)),
          (this._currentTime = 0),
          this.globalData.audioController.addAudio(this),
          (this._volumeMultiplier = 1),
          (this._volume = 1),
          (this._previousVolume = null),
          (this.tm = s.tm
            ? PropertyFactory.getProp(this, s.tm, 0, e.frameRate, this)
            : { _placeholder: !0 }),
          (this.lv = PropertyFactory.getProp(
            this,
            s.au && s.au.lv ? s.au.lv : { k: [100] },
            1,
            0.01,
            this
          ));
      }
      (AudioElement.prototype.prepareFrame = function (s) {
        if (
          (this.prepareRenderableFrame(s, !0),
          this.prepareProperties(s, !0),
          this.tm._placeholder)
        )
          this._currentTime = s / this.data.sr;
        else {
          var e = this.tm.v;
          this._currentTime = e;
        }
        this._volume = this.lv.v[0];
        var o = this._volume * this._volumeMultiplier;
        this._previousVolume !== o &&
          ((this._previousVolume = o), this.audio.volume(o));
      }),
        extendPrototype(
          [RenderableElement, BaseElement, FrameElement],
          AudioElement
        ),
        (AudioElement.prototype.renderFrame = function () {
          this.isInRange &&
            this._canPlay &&
            (this._isPlaying
              ? (!this.audio.playing() ||
                  Math.abs(
                    this._currentTime / this.globalData.frameRate -
                      this.audio.seek()
                  ) > 0.1) &&
                this.audio.seek(this._currentTime / this.globalData.frameRate)
              : (this.audio.play(),
                this.audio.seek(this._currentTime / this.globalData.frameRate),
                (this._isPlaying = !0)));
        }),
        (AudioElement.prototype.show = function () {}),
        (AudioElement.prototype.hide = function () {
          this.audio.pause(), (this._isPlaying = !1);
        }),
        (AudioElement.prototype.pause = function () {
          this.audio.pause(), (this._isPlaying = !1), (this._canPlay = !1);
        }),
        (AudioElement.prototype.resume = function () {
          this._canPlay = !0;
        }),
        (AudioElement.prototype.setRate = function (s) {
          this.audio.rate(s);
        }),
        (AudioElement.prototype.volume = function (s) {
          (this._volumeMultiplier = s),
            (this._previousVolume = s * this._volume),
            this.audio.volume(this._previousVolume);
        }),
        (AudioElement.prototype.getBaseElement = function () {
          return null;
        }),
        (AudioElement.prototype.destroy = function () {}),
        (AudioElement.prototype.sourceRectAtTime = function () {}),
        (AudioElement.prototype.initExpressions = function () {});
      function BaseRenderer() {}
      (BaseRenderer.prototype.checkLayers = function (s) {
        var e,
          o = this.layers.length,
          a;
        for (this.completeLayers = !0, e = o - 1; e >= 0; e -= 1)
          this.elements[e] ||
            ((a = this.layers[e]),
            a.ip - a.st <= s - this.layers[e].st &&
              a.op - a.st > s - this.layers[e].st &&
              this.buildItem(e)),
            (this.completeLayers = this.elements[e] ? this.completeLayers : !1);
        this.checkPendingElements();
      }),
        (BaseRenderer.prototype.createItem = function (s) {
          switch (s.ty) {
            case 2:
              return this.createImage(s);
            case 0:
              return this.createComp(s);
            case 1:
              return this.createSolid(s);
            case 3:
              return this.createNull(s);
            case 4:
              return this.createShape(s);
            case 5:
              return this.createText(s);
            case 6:
              return this.createAudio(s);
            case 13:
              return this.createCamera(s);
            case 15:
              return this.createFootage(s);
            default:
              return this.createNull(s);
          }
        }),
        (BaseRenderer.prototype.createCamera = function () {
          throw new Error("You're using a 3d camera. Try the html renderer.");
        }),
        (BaseRenderer.prototype.createAudio = function (s) {
          return new AudioElement(s, this.globalData, this);
        }),
        (BaseRenderer.prototype.createFootage = function (s) {
          return new FootageElement(s, this.globalData, this);
        }),
        (BaseRenderer.prototype.buildAllItems = function () {
          var s,
            e = this.layers.length;
          for (s = 0; s < e; s += 1) this.buildItem(s);
          this.checkPendingElements();
        }),
        (BaseRenderer.prototype.includeLayers = function (s) {
          this.completeLayers = !1;
          var e,
            o = s.length,
            a,
            c = this.layers.length;
          for (e = 0; e < o; e += 1)
            for (a = 0; a < c; ) {
              if (this.layers[a].id === s[e].id) {
                this.layers[a] = s[e];
                break;
              }
              a += 1;
            }
        }),
        (BaseRenderer.prototype.setProjectInterface = function (s) {
          this.globalData.projectInterface = s;
        }),
        (BaseRenderer.prototype.initItems = function () {
          this.globalData.progressiveLoad || this.buildAllItems();
        }),
        (BaseRenderer.prototype.buildElementParenting = function (s, e, o) {
          for (
            var a = this.elements, c = this.layers, d = 0, g = c.length;
            d < g;

          )
            c[d].ind == e &&
              (!a[d] || a[d] === !0
                ? (this.buildItem(d), this.addPendingElement(s))
                : (o.push(a[d]),
                  a[d].setAsParent(),
                  c[d].parent !== void 0
                    ? this.buildElementParenting(s, c[d].parent, o)
                    : s.setHierarchy(o))),
              (d += 1);
        }),
        (BaseRenderer.prototype.addPendingElement = function (s) {
          this.pendingElements.push(s);
        }),
        (BaseRenderer.prototype.searchExtraCompositions = function (s) {
          var e,
            o = s.length;
          for (e = 0; e < o; e += 1)
            if (s[e].xt) {
              var a = this.createComp(s[e]);
              a.initExpressions(),
                this.globalData.projectInterface.registerComposition(a);
            }
        }),
        (BaseRenderer.prototype.getElementById = function (s) {
          var e,
            o = this.elements.length;
          for (e = 0; e < o; e += 1)
            if (this.elements[e].data.ind === s) return this.elements[e];
          return null;
        }),
        (BaseRenderer.prototype.getElementByPath = function (s) {
          var e = s.shift(),
            o;
          if (typeof e == "number") o = this.elements[e];
          else {
            var a,
              c = this.elements.length;
            for (a = 0; a < c; a += 1)
              if (this.elements[a].data.nm === e) {
                o = this.elements[a];
                break;
              }
          }
          return s.length === 0 ? o : o.getElementByPath(s);
        }),
        (BaseRenderer.prototype.setupGlobalData = function (s, e) {
          (this.globalData.fontManager = new FontManager()),
            (this.globalData.slotManager = slotFactory(s)),
            this.globalData.fontManager.addChars(s.chars),
            this.globalData.fontManager.addFonts(s.fonts, e),
            (this.globalData.getAssetData =
              this.animationItem.getAssetData.bind(this.animationItem)),
            (this.globalData.getAssetsPath =
              this.animationItem.getAssetsPath.bind(this.animationItem)),
            (this.globalData.imageLoader = this.animationItem.imagePreloader),
            (this.globalData.audioController =
              this.animationItem.audioController),
            (this.globalData.frameId = 0),
            (this.globalData.frameRate = s.fr),
            (this.globalData.nm = s.nm),
            (this.globalData.compSize = { w: s.w, h: s.h });
        });
      var effectTypes = { TRANSFORM_EFFECT: "transformEFfect" };
      function TransformElement() {}
      TransformElement.prototype = {
        initTransform: function () {
          var e = new Matrix();
          (this.finalTransform = {
            mProp: this.data.ks
              ? TransformPropertyFactory.getTransformProperty(
                  this,
                  this.data.ks,
                  this
                )
              : { o: 0 },
            _matMdf: !1,
            _localMatMdf: !1,
            _opMdf: !1,
            mat: e,
            localMat: e,
            localOpacity: 1,
          }),
            this.data.ao && (this.finalTransform.mProp.autoOriented = !0),
            this.data.ty;
        },
        renderTransform: function () {
          if (
            ((this.finalTransform._opMdf =
              this.finalTransform.mProp.o._mdf || this._isFirstFrame),
            (this.finalTransform._matMdf =
              this.finalTransform.mProp._mdf || this._isFirstFrame),
            this.hierarchy)
          ) {
            var e,
              o = this.finalTransform.mat,
              a = 0,
              c = this.hierarchy.length;
            if (!this.finalTransform._matMdf)
              for (; a < c; ) {
                if (this.hierarchy[a].finalTransform.mProp._mdf) {
                  this.finalTransform._matMdf = !0;
                  break;
                }
                a += 1;
              }
            if (this.finalTransform._matMdf)
              for (
                e = this.finalTransform.mProp.v.props,
                  o.cloneFromProps(e),
                  a = 0;
                a < c;
                a += 1
              )
                o.multiply(this.hierarchy[a].finalTransform.mProp.v);
          }
          this.finalTransform._matMdf &&
            (this.finalTransform._localMatMdf = this.finalTransform._matMdf),
            this.finalTransform._opMdf &&
              (this.finalTransform.localOpacity =
                this.finalTransform.mProp.o.v);
        },
        renderLocalTransform: function () {
          if (this.localTransforms) {
            var e = 0,
              o = this.localTransforms.length;
            if (
              ((this.finalTransform._localMatMdf = this.finalTransform._matMdf),
              !this.finalTransform._localMatMdf || !this.finalTransform._opMdf)
            )
              for (; e < o; )
                this.localTransforms[e]._mdf &&
                  (this.finalTransform._localMatMdf = !0),
                  this.localTransforms[e]._opMdf &&
                    !this.finalTransform._opMdf &&
                    ((this.finalTransform.localOpacity =
                      this.finalTransform.mProp.o.v),
                    (this.finalTransform._opMdf = !0)),
                  (e += 1);
            if (this.finalTransform._localMatMdf) {
              var a = this.finalTransform.localMat;
              for (
                this.localTransforms[0].matrix.clone(a), e = 1;
                e < o;
                e += 1
              ) {
                var c = this.localTransforms[e].matrix;
                a.multiply(c);
              }
              a.multiply(this.finalTransform.mat);
            }
            if (this.finalTransform._opMdf) {
              var d = this.finalTransform.localOpacity;
              for (e = 0; e < o; e += 1)
                d *= this.localTransforms[e].opacity * 0.01;
              this.finalTransform.localOpacity = d;
            }
          }
        },
        searchEffectTransforms: function () {
          if (this.renderableEffectsManager) {
            var e = this.renderableEffectsManager.getEffects(
              effectTypes.TRANSFORM_EFFECT
            );
            if (e.length) {
              (this.localTransforms = []),
                (this.finalTransform.localMat = new Matrix());
              var o = 0,
                a = e.length;
              for (o = 0; o < a; o += 1) this.localTransforms.push(e[o]);
            }
          }
        },
        globalToLocal: function (e) {
          var o = [];
          o.push(this.finalTransform);
          for (var a = !0, c = this.comp; a; )
            c.finalTransform
              ? (c.data.hasMask && o.splice(0, 0, c.finalTransform),
                (c = c.comp))
              : (a = !1);
          var d,
            g = o.length,
            _;
          for (d = 0; d < g; d += 1)
            (_ = o[d].mat.applyToPointArray(0, 0, 0)),
              (e = [e[0] - _[0], e[1] - _[1], 0]);
          return e;
        },
        mHelper: new Matrix(),
      };
      function MaskElement(s, e, o) {
        (this.data = s),
          (this.element = e),
          (this.globalData = o),
          (this.storedData = []),
          (this.masksProperties = this.data.masksProperties || []),
          (this.maskElement = null);
        var a = this.globalData.defs,
          c,
          d = this.masksProperties ? this.masksProperties.length : 0;
        (this.viewData = createSizedArray(d)), (this.solidPath = "");
        var g,
          _ = this.masksProperties,
          b = 0,
          j = [],
          $,
          _e,
          et = createElementID(),
          rt,
          st,
          at,
          ct,
          it = "clipPath",
          lt = "clip-path";
        for (c = 0; c < d; c += 1)
          if (
            (((_[c].mode !== "a" && _[c].mode !== "n") ||
              _[c].inv ||
              _[c].o.k !== 100 ||
              _[c].o.x) &&
              ((it = "mask"), (lt = "mask")),
            (_[c].mode === "s" || _[c].mode === "i") && b === 0
              ? ((rt = createNS("rect")),
                rt.setAttribute("fill", "#ffffff"),
                rt.setAttribute("width", this.element.comp.data.w || 0),
                rt.setAttribute("height", this.element.comp.data.h || 0),
                j.push(rt))
              : (rt = null),
            (g = createNS("path")),
            _[c].mode === "n")
          )
            (this.viewData[c] = {
              op: PropertyFactory.getProp(
                this.element,
                _[c].o,
                0,
                0.01,
                this.element
              ),
              prop: ShapePropertyFactory.getShapeProp(this.element, _[c], 3),
              elem: g,
              lastPath: "",
            }),
              a.appendChild(g);
          else {
            (b += 1),
              g.setAttribute("fill", _[c].mode === "s" ? "#000000" : "#ffffff"),
              g.setAttribute("clip-rule", "nonzero");
            var ot;
            if (
              (_[c].x.k !== 0
                ? ((it = "mask"),
                  (lt = "mask"),
                  (ct = PropertyFactory.getProp(
                    this.element,
                    _[c].x,
                    0,
                    null,
                    this.element
                  )),
                  (ot = createElementID()),
                  (st = createNS("filter")),
                  st.setAttribute("id", ot),
                  (at = createNS("feMorphology")),
                  at.setAttribute("operator", "erode"),
                  at.setAttribute("in", "SourceGraphic"),
                  at.setAttribute("radius", "0"),
                  st.appendChild(at),
                  a.appendChild(st),
                  g.setAttribute(
                    "stroke",
                    _[c].mode === "s" ? "#000000" : "#ffffff"
                  ))
                : ((at = null), (ct = null)),
              (this.storedData[c] = {
                elem: g,
                x: ct,
                expan: at,
                lastPath: "",
                lastOperator: "",
                filterId: ot,
                lastRadius: 0,
              }),
              _[c].mode === "i")
            ) {
              _e = j.length;
              var ut = createNS("g");
              for ($ = 0; $ < _e; $ += 1) ut.appendChild(j[$]);
              var pt = createNS("mask");
              pt.setAttribute("mask-type", "alpha"),
                pt.setAttribute("id", et + "_" + b),
                pt.appendChild(g),
                a.appendChild(pt),
                ut.setAttribute(
                  "mask",
                  "url(" + getLocationHref() + "#" + et + "_" + b + ")"
                ),
                (j.length = 0),
                j.push(ut);
            } else j.push(g);
            _[c].inv &&
              !this.solidPath &&
              (this.solidPath = this.createLayerSolidPath()),
              (this.viewData[c] = {
                elem: g,
                lastPath: "",
                op: PropertyFactory.getProp(
                  this.element,
                  _[c].o,
                  0,
                  0.01,
                  this.element
                ),
                prop: ShapePropertyFactory.getShapeProp(this.element, _[c], 3),
                invRect: rt,
              }),
              this.viewData[c].prop.k ||
                this.drawPath(_[c], this.viewData[c].prop.v, this.viewData[c]);
          }
        for (
          this.maskElement = createNS(it), d = j.length, c = 0;
          c < d;
          c += 1
        )
          this.maskElement.appendChild(j[c]);
        b > 0 &&
          (this.maskElement.setAttribute("id", et),
          this.element.maskedElement.setAttribute(
            lt,
            "url(" + getLocationHref() + "#" + et + ")"
          ),
          a.appendChild(this.maskElement)),
          this.viewData.length && this.element.addRenderableComponent(this);
      }
      (MaskElement.prototype.getMaskProperty = function (s) {
        return this.viewData[s].prop;
      }),
        (MaskElement.prototype.renderFrame = function (s) {
          var e = this.element.finalTransform.mat,
            o,
            a = this.masksProperties.length;
          for (o = 0; o < a; o += 1)
            if (
              ((this.viewData[o].prop._mdf || s) &&
                this.drawPath(
                  this.masksProperties[o],
                  this.viewData[o].prop.v,
                  this.viewData[o]
                ),
              (this.viewData[o].op._mdf || s) &&
                this.viewData[o].elem.setAttribute(
                  "fill-opacity",
                  this.viewData[o].op.v
                ),
              this.masksProperties[o].mode !== "n" &&
                (this.viewData[o].invRect &&
                  (this.element.finalTransform.mProp._mdf || s) &&
                  this.viewData[o].invRect.setAttribute(
                    "transform",
                    e.getInverseMatrix().to2dCSS()
                  ),
                this.storedData[o].x && (this.storedData[o].x._mdf || s)))
            ) {
              var c = this.storedData[o].expan;
              this.storedData[o].x.v < 0
                ? (this.storedData[o].lastOperator !== "erode" &&
                    ((this.storedData[o].lastOperator = "erode"),
                    this.storedData[o].elem.setAttribute(
                      "filter",
                      "url(" +
                        getLocationHref() +
                        "#" +
                        this.storedData[o].filterId +
                        ")"
                    )),
                  c.setAttribute("radius", -this.storedData[o].x.v))
                : (this.storedData[o].lastOperator !== "dilate" &&
                    ((this.storedData[o].lastOperator = "dilate"),
                    this.storedData[o].elem.setAttribute("filter", null)),
                  this.storedData[o].elem.setAttribute(
                    "stroke-width",
                    this.storedData[o].x.v * 2
                  ));
            }
        }),
        (MaskElement.prototype.getMaskelement = function () {
          return this.maskElement;
        }),
        (MaskElement.prototype.createLayerSolidPath = function () {
          var s = "M0,0 ";
          return (
            (s += " h" + this.globalData.compSize.w),
            (s += " v" + this.globalData.compSize.h),
            (s += " h-" + this.globalData.compSize.w),
            (s += " v-" + this.globalData.compSize.h + " "),
            s
          );
        }),
        (MaskElement.prototype.drawPath = function (s, e, o) {
          var a = " M" + e.v[0][0] + "," + e.v[0][1],
            c,
            d;
          for (d = e._length, c = 1; c < d; c += 1)
            a +=
              " C" +
              e.o[c - 1][0] +
              "," +
              e.o[c - 1][1] +
              " " +
              e.i[c][0] +
              "," +
              e.i[c][1] +
              " " +
              e.v[c][0] +
              "," +
              e.v[c][1];
          if (
            (e.c &&
              d > 1 &&
              (a +=
                " C" +
                e.o[c - 1][0] +
                "," +
                e.o[c - 1][1] +
                " " +
                e.i[0][0] +
                "," +
                e.i[0][1] +
                " " +
                e.v[0][0] +
                "," +
                e.v[0][1]),
            o.lastPath !== a)
          ) {
            var g = "";
            o.elem &&
              (e.c && (g = s.inv ? this.solidPath + a : a),
              o.elem.setAttribute("d", g)),
              (o.lastPath = a);
          }
        }),
        (MaskElement.prototype.destroy = function () {
          (this.element = null),
            (this.globalData = null),
            (this.maskElement = null),
            (this.data = null),
            (this.masksProperties = null);
        });
      var filtersFactory = (function () {
          var s = {};
          (s.createFilter = e), (s.createAlphaToLuminanceFilter = o);
          function e(a, c) {
            var d = createNS("filter");
            return (
              d.setAttribute("id", a),
              c !== !0 &&
                (d.setAttribute("filterUnits", "objectBoundingBox"),
                d.setAttribute("x", "0%"),
                d.setAttribute("y", "0%"),
                d.setAttribute("width", "100%"),
                d.setAttribute("height", "100%")),
              d
            );
          }
          function o() {
            var a = createNS("feColorMatrix");
            return (
              a.setAttribute("type", "matrix"),
              a.setAttribute("color-interpolation-filters", "sRGB"),
              a.setAttribute(
                "values",
                "0 0 0 1 0  0 0 0 1 0  0 0 0 1 0  0 0 0 1 1"
              ),
              a
            );
          }
          return s;
        })(),
        featureSupport = (function () {
          var s = {
            maskType: !0,
            svgLumaHidden: !0,
            offscreenCanvas: typeof OffscreenCanvas < "u",
          };
          return (
            (/MSIE 10/i.test(navigator.userAgent) ||
              /MSIE 9/i.test(navigator.userAgent) ||
              /rv:11.0/i.test(navigator.userAgent) ||
              /Edge\/\d./i.test(navigator.userAgent)) &&
              (s.maskType = !1),
            /firefox/i.test(navigator.userAgent) && (s.svgLumaHidden = !1),
            s
          );
        })(),
        registeredEffects$1 = {},
        idPrefix = "filter_result_";
      function SVGEffects(s) {
        var e,
          o = "SourceGraphic",
          a = s.data.ef ? s.data.ef.length : 0,
          c = createElementID(),
          d = filtersFactory.createFilter(c, !0),
          g = 0;
        this.filters = [];
        var _;
        for (e = 0; e < a; e += 1) {
          _ = null;
          var b = s.data.ef[e].ty;
          if (registeredEffects$1[b]) {
            var j = registeredEffects$1[b].effect;
            (_ = new j(
              d,
              s.effectsManager.effectElements[e],
              s,
              idPrefix + g,
              o
            )),
              (o = idPrefix + g),
              registeredEffects$1[b].countsAsEffect && (g += 1);
          }
          _ && this.filters.push(_);
        }
        g &&
          (s.globalData.defs.appendChild(d),
          s.layerElement.setAttribute(
            "filter",
            "url(" + getLocationHref() + "#" + c + ")"
          )),
          this.filters.length && s.addRenderableComponent(this);
      }
      (SVGEffects.prototype.renderFrame = function (s) {
        var e,
          o = this.filters.length;
        for (e = 0; e < o; e += 1) this.filters[e].renderFrame(s);
      }),
        (SVGEffects.prototype.getEffects = function (s) {
          var e,
            o = this.filters.length,
            a = [];
          for (e = 0; e < o; e += 1)
            this.filters[e].type === s && a.push(this.filters[e]);
          return a;
        });
      function registerEffect$1(s, e, o) {
        registeredEffects$1[s] = { effect: e, countsAsEffect: o };
      }
      function SVGBaseElement() {}
      SVGBaseElement.prototype = {
        initRendererElement: function () {
          this.layerElement = createNS("g");
        },
        createContainerElements: function () {
          (this.matteElement = createNS("g")),
            (this.transformedElement = this.layerElement),
            (this.maskedElement = this.layerElement),
            (this._sizeChanged = !1);
          var e = null;
          if (this.data.td) {
            this.matteMasks = {};
            var o = createNS("g");
            o.setAttribute("id", this.layerId),
              o.appendChild(this.layerElement),
              (e = o),
              this.globalData.defs.appendChild(o);
          } else
            this.data.tt
              ? (this.matteElement.appendChild(this.layerElement),
                (e = this.matteElement),
                (this.baseElement = this.matteElement))
              : (this.baseElement = this.layerElement);
          if (
            (this.data.ln && this.layerElement.setAttribute("id", this.data.ln),
            this.data.cl &&
              this.layerElement.setAttribute("class", this.data.cl),
            this.data.ty === 0 && !this.data.hd)
          ) {
            var a = createNS("clipPath"),
              c = createNS("path");
            c.setAttribute(
              "d",
              "M0,0 L" +
                this.data.w +
                ",0 L" +
                this.data.w +
                "," +
                this.data.h +
                " L0," +
                this.data.h +
                "z"
            );
            var d = createElementID();
            if (
              (a.setAttribute("id", d),
              a.appendChild(c),
              this.globalData.defs.appendChild(a),
              this.checkMasks())
            ) {
              var g = createNS("g");
              g.setAttribute(
                "clip-path",
                "url(" + getLocationHref() + "#" + d + ")"
              ),
                g.appendChild(this.layerElement),
                (this.transformedElement = g),
                e
                  ? e.appendChild(this.transformedElement)
                  : (this.baseElement = this.transformedElement);
            } else
              this.layerElement.setAttribute(
                "clip-path",
                "url(" + getLocationHref() + "#" + d + ")"
              );
          }
          this.data.bm !== 0 && this.setBlendMode();
        },
        renderElement: function () {
          this.finalTransform._localMatMdf &&
            this.transformedElement.setAttribute(
              "transform",
              this.finalTransform.localMat.to2dCSS()
            ),
            this.finalTransform._opMdf &&
              this.transformedElement.setAttribute(
                "opacity",
                this.finalTransform.localOpacity
              );
        },
        destroyBaseElement: function () {
          (this.layerElement = null),
            (this.matteElement = null),
            this.maskManager.destroy();
        },
        getBaseElement: function () {
          return this.data.hd ? null : this.baseElement;
        },
        createRenderableComponents: function () {
          (this.maskManager = new MaskElement(
            this.data,
            this,
            this.globalData
          )),
            (this.renderableEffectsManager = new SVGEffects(this)),
            this.searchEffectTransforms();
        },
        getMatte: function (e) {
          if (
            (this.matteMasks || (this.matteMasks = {}), !this.matteMasks[e])
          ) {
            var o = this.layerId + "_" + e,
              a,
              c,
              d,
              g;
            if (e === 1 || e === 3) {
              var _ = createNS("mask");
              _.setAttribute("id", o),
                _.setAttribute("mask-type", e === 3 ? "luminance" : "alpha"),
                (d = createNS("use")),
                d.setAttributeNS(
                  "http://www.w3.org/1999/xlink",
                  "href",
                  "#" + this.layerId
                ),
                _.appendChild(d),
                this.globalData.defs.appendChild(_),
                !featureSupport.maskType &&
                  e === 1 &&
                  (_.setAttribute("mask-type", "luminance"),
                  (a = createElementID()),
                  (c = filtersFactory.createFilter(a)),
                  this.globalData.defs.appendChild(c),
                  c.appendChild(filtersFactory.createAlphaToLuminanceFilter()),
                  (g = createNS("g")),
                  g.appendChild(d),
                  _.appendChild(g),
                  g.setAttribute(
                    "filter",
                    "url(" + getLocationHref() + "#" + a + ")"
                  ));
            } else if (e === 2) {
              var b = createNS("mask");
              b.setAttribute("id", o), b.setAttribute("mask-type", "alpha");
              var j = createNS("g");
              b.appendChild(j),
                (a = createElementID()),
                (c = filtersFactory.createFilter(a));
              var $ = createNS("feComponentTransfer");
              $.setAttribute("in", "SourceGraphic"), c.appendChild($);
              var _e = createNS("feFuncA");
              _e.setAttribute("type", "table"),
                _e.setAttribute("tableValues", "1.0 0.0"),
                $.appendChild(_e),
                this.globalData.defs.appendChild(c);
              var et = createNS("rect");
              et.setAttribute("width", this.comp.data.w),
                et.setAttribute("height", this.comp.data.h),
                et.setAttribute("x", "0"),
                et.setAttribute("y", "0"),
                et.setAttribute("fill", "#ffffff"),
                et.setAttribute("opacity", "0"),
                j.setAttribute(
                  "filter",
                  "url(" + getLocationHref() + "#" + a + ")"
                ),
                j.appendChild(et),
                (d = createNS("use")),
                d.setAttributeNS(
                  "http://www.w3.org/1999/xlink",
                  "href",
                  "#" + this.layerId
                ),
                j.appendChild(d),
                featureSupport.maskType ||
                  (b.setAttribute("mask-type", "luminance"),
                  c.appendChild(filtersFactory.createAlphaToLuminanceFilter()),
                  (g = createNS("g")),
                  j.appendChild(et),
                  g.appendChild(this.layerElement),
                  j.appendChild(g)),
                this.globalData.defs.appendChild(b);
            }
            this.matteMasks[e] = o;
          }
          return this.matteMasks[e];
        },
        setMatte: function (e) {
          this.matteElement &&
            this.matteElement.setAttribute(
              "mask",
              "url(" + getLocationHref() + "#" + e + ")"
            );
        },
      };
      function HierarchyElement() {}
      HierarchyElement.prototype = {
        initHierarchy: function () {
          (this.hierarchy = []), (this._isParent = !1), this.checkParenting();
        },
        setHierarchy: function (e) {
          this.hierarchy = e;
        },
        setAsParent: function () {
          this._isParent = !0;
        },
        checkParenting: function () {
          this.data.parent !== void 0 &&
            this.comp.buildElementParenting(this, this.data.parent, []);
        },
      };
      function RenderableDOMElement() {}
      (function () {
        var s = {
          initElement: function (o, a, c) {
            this.initFrame(),
              this.initBaseData(o, a, c),
              this.initTransform(o, a, c),
              this.initHierarchy(),
              this.initRenderable(),
              this.initRendererElement(),
              this.createContainerElements(),
              this.createRenderableComponents(),
              this.createContent(),
              this.hide();
          },
          hide: function () {
            if (!this.hidden && (!this.isInRange || this.isTransparent)) {
              var o = this.baseElement || this.layerElement;
              (o.style.display = "none"), (this.hidden = !0);
            }
          },
          show: function () {
            if (this.isInRange && !this.isTransparent) {
              if (!this.data.hd) {
                var o = this.baseElement || this.layerElement;
                o.style.display = "block";
              }
              (this.hidden = !1), (this._isFirstFrame = !0);
            }
          },
          renderFrame: function () {
            this.data.hd ||
              this.hidden ||
              (this.renderTransform(),
              this.renderRenderable(),
              this.renderLocalTransform(),
              this.renderElement(),
              this.renderInnerContent(),
              this._isFirstFrame && (this._isFirstFrame = !1));
          },
          renderInnerContent: function () {},
          prepareFrame: function (o) {
            (this._mdf = !1),
              this.prepareRenderableFrame(o),
              this.prepareProperties(o, this.isInRange),
              this.checkTransparency();
          },
          destroy: function () {
            (this.innerElem = null), this.destroyBaseElement();
          },
        };
        extendPrototype(
          [RenderableElement, createProxyFunction(s)],
          RenderableDOMElement
        );
      })();
      function IImageElement(s, e, o) {
        (this.assetData = e.getAssetData(s.refId)),
          this.assetData &&
            this.assetData.sid &&
            (this.assetData = e.slotManager.getProp(this.assetData)),
          this.initElement(s, e, o),
          (this.sourceRect = {
            top: 0,
            left: 0,
            width: this.assetData.w,
            height: this.assetData.h,
          });
      }
      extendPrototype(
        [
          BaseElement,
          TransformElement,
          SVGBaseElement,
          HierarchyElement,
          FrameElement,
          RenderableDOMElement,
        ],
        IImageElement
      ),
        (IImageElement.prototype.createContent = function () {
          var s = this.globalData.getAssetsPath(this.assetData);
          (this.innerElem = createNS("image")),
            this.innerElem.setAttribute("width", this.assetData.w + "px"),
            this.innerElem.setAttribute("height", this.assetData.h + "px"),
            this.innerElem.setAttribute(
              "preserveAspectRatio",
              this.assetData.pr ||
                this.globalData.renderConfig.imagePreserveAspectRatio
            ),
            this.innerElem.setAttributeNS(
              "http://www.w3.org/1999/xlink",
              "href",
              s
            ),
            this.layerElement.appendChild(this.innerElem);
        }),
        (IImageElement.prototype.sourceRectAtTime = function () {
          return this.sourceRect;
        });
      function ProcessedElement(s, e) {
        (this.elem = s), (this.pos = e);
      }
      function IShapeElement() {}
      IShapeElement.prototype = {
        addShapeToModifiers: function (e) {
          var o,
            a = this.shapeModifiers.length;
          for (o = 0; o < a; o += 1) this.shapeModifiers[o].addShape(e);
        },
        isShapeInAnimatedModifiers: function (e) {
          for (var o = 0, a = this.shapeModifiers.length; o < a; )
            if (this.shapeModifiers[o].isAnimatedWithShape(e)) return !0;
          return !1;
        },
        renderModifiers: function () {
          if (this.shapeModifiers.length) {
            var e,
              o = this.shapes.length;
            for (e = 0; e < o; e += 1) this.shapes[e].sh.reset();
            o = this.shapeModifiers.length;
            var a;
            for (
              e = o - 1;
              e >= 0 &&
              ((a = this.shapeModifiers[e].processShapes(this._isFirstFrame)),
              !a);
              e -= 1
            );
          }
        },
        searchProcessedElement: function (e) {
          for (var o = this.processedElements, a = 0, c = o.length; a < c; ) {
            if (o[a].elem === e) return o[a].pos;
            a += 1;
          }
          return 0;
        },
        addProcessedElement: function (e, o) {
          for (var a = this.processedElements, c = a.length; c; )
            if (((c -= 1), a[c].elem === e)) {
              a[c].pos = o;
              return;
            }
          a.push(new ProcessedElement(e, o));
        },
        prepareFrame: function (e) {
          this.prepareRenderableFrame(e),
            this.prepareProperties(e, this.isInRange);
        },
      };
      var lineCapEnum = { 1: "butt", 2: "round", 3: "square" },
        lineJoinEnum = { 1: "miter", 2: "round", 3: "bevel" };
      function SVGShapeData(s, e, o) {
        (this.caches = []),
          (this.styles = []),
          (this.transformers = s),
          (this.lStr = ""),
          (this.sh = o),
          (this.lvl = e),
          (this._isAnimated = !!o.k);
        for (var a = 0, c = s.length; a < c; ) {
          if (s[a].mProps.dynamicProperties.length) {
            this._isAnimated = !0;
            break;
          }
          a += 1;
        }
      }
      SVGShapeData.prototype.setAsAnimated = function () {
        this._isAnimated = !0;
      };
      function SVGStyleData(s, e) {
        (this.data = s),
          (this.type = s.ty),
          (this.d = ""),
          (this.lvl = e),
          (this._mdf = !1),
          (this.closed = s.hd === !0),
          (this.pElem = createNS("path")),
          (this.msElem = null);
      }
      SVGStyleData.prototype.reset = function () {
        (this.d = ""), (this._mdf = !1);
      };
      function DashProperty(s, e, o, a) {
        (this.elem = s),
          (this.frameId = -1),
          (this.dataProps = createSizedArray(e.length)),
          (this.renderer = o),
          (this.k = !1),
          (this.dashStr = ""),
          (this.dashArray = createTypedArray(
            "float32",
            e.length ? e.length - 1 : 0
          )),
          (this.dashoffset = createTypedArray("float32", 1)),
          this.initDynamicPropertyContainer(a);
        var c,
          d = e.length || 0,
          g;
        for (c = 0; c < d; c += 1)
          (g = PropertyFactory.getProp(s, e[c].v, 0, 0, this)),
            (this.k = g.k || this.k),
            (this.dataProps[c] = { n: e[c].n, p: g });
        this.k || this.getValue(!0), (this._isAnimated = this.k);
      }
      (DashProperty.prototype.getValue = function (s) {
        if (
          !(this.elem.globalData.frameId === this.frameId && !s) &&
          ((this.frameId = this.elem.globalData.frameId),
          this.iterateDynamicProperties(),
          (this._mdf = this._mdf || s),
          this._mdf)
        ) {
          var e = 0,
            o = this.dataProps.length;
          for (
            this.renderer === "svg" && (this.dashStr = ""), e = 0;
            e < o;
            e += 1
          )
            this.dataProps[e].n !== "o"
              ? this.renderer === "svg"
                ? (this.dashStr += " " + this.dataProps[e].p.v)
                : (this.dashArray[e] = this.dataProps[e].p.v)
              : (this.dashoffset[0] = this.dataProps[e].p.v);
        }
      }),
        extendPrototype([DynamicPropertyContainer], DashProperty);
      function SVGStrokeStyleData(s, e, o) {
        this.initDynamicPropertyContainer(s),
          (this.getValue = this.iterateDynamicProperties),
          (this.o = PropertyFactory.getProp(s, e.o, 0, 0.01, this)),
          (this.w = PropertyFactory.getProp(s, e.w, 0, null, this)),
          (this.d = new DashProperty(s, e.d || {}, "svg", this)),
          (this.c = PropertyFactory.getProp(s, e.c, 1, 255, this)),
          (this.style = o),
          (this._isAnimated = !!this._isAnimated);
      }
      extendPrototype([DynamicPropertyContainer], SVGStrokeStyleData);
      function SVGFillStyleData(s, e, o) {
        this.initDynamicPropertyContainer(s),
          (this.getValue = this.iterateDynamicProperties),
          (this.o = PropertyFactory.getProp(s, e.o, 0, 0.01, this)),
          (this.c = PropertyFactory.getProp(s, e.c, 1, 255, this)),
          (this.style = o);
      }
      extendPrototype([DynamicPropertyContainer], SVGFillStyleData);
      function SVGNoStyleData(s, e, o) {
        this.initDynamicPropertyContainer(s),
          (this.getValue = this.iterateDynamicProperties),
          (this.style = o);
      }
      extendPrototype([DynamicPropertyContainer], SVGNoStyleData);
      function GradientProperty(s, e, o) {
        (this.data = e), (this.c = createTypedArray("uint8c", e.p * 4));
        var a = e.k.k[0].s
          ? e.k.k[0].s.length - e.p * 4
          : e.k.k.length - e.p * 4;
        (this.o = createTypedArray("float32", a)),
          (this._cmdf = !1),
          (this._omdf = !1),
          (this._collapsable = this.checkCollapsable()),
          (this._hasOpacity = a),
          this.initDynamicPropertyContainer(o),
          (this.prop = PropertyFactory.getProp(s, e.k, 1, null, this)),
          (this.k = this.prop.k),
          this.getValue(!0);
      }
      (GradientProperty.prototype.comparePoints = function (s, e) {
        for (var o = 0, a = this.o.length / 2, c; o < a; ) {
          if (((c = Math.abs(s[o * 4] - s[e * 4 + o * 2])), c > 0.01))
            return !1;
          o += 1;
        }
        return !0;
      }),
        (GradientProperty.prototype.checkCollapsable = function () {
          if (this.o.length / 2 !== this.c.length / 4) return !1;
          if (this.data.k.k[0].s)
            for (var s = 0, e = this.data.k.k.length; s < e; ) {
              if (!this.comparePoints(this.data.k.k[s].s, this.data.p))
                return !1;
              s += 1;
            }
          else if (!this.comparePoints(this.data.k.k, this.data.p)) return !1;
          return !0;
        }),
        (GradientProperty.prototype.getValue = function (s) {
          if (
            (this.prop.getValue(),
            (this._mdf = !1),
            (this._cmdf = !1),
            (this._omdf = !1),
            this.prop._mdf || s)
          ) {
            var e,
              o = this.data.p * 4,
              a,
              c;
            for (e = 0; e < o; e += 1)
              (a = e % 4 === 0 ? 100 : 255),
                (c = Math.round(this.prop.v[e] * a)),
                this.c[e] !== c && ((this.c[e] = c), (this._cmdf = !s));
            if (this.o.length)
              for (o = this.prop.v.length, e = this.data.p * 4; e < o; e += 1)
                (a = e % 2 === 0 ? 100 : 1),
                  (c =
                    e % 2 === 0
                      ? Math.round(this.prop.v[e] * 100)
                      : this.prop.v[e]),
                  this.o[e - this.data.p * 4] !== c &&
                    ((this.o[e - this.data.p * 4] = c), (this._omdf = !s));
            this._mdf = !s;
          }
        }),
        extendPrototype([DynamicPropertyContainer], GradientProperty);
      function SVGGradientFillStyleData(s, e, o) {
        this.initDynamicPropertyContainer(s),
          (this.getValue = this.iterateDynamicProperties),
          this.initGradientData(s, e, o);
      }
      (SVGGradientFillStyleData.prototype.initGradientData = function (
        s,
        e,
        o
      ) {
        (this.o = PropertyFactory.getProp(s, e.o, 0, 0.01, this)),
          (this.s = PropertyFactory.getProp(s, e.s, 1, null, this)),
          (this.e = PropertyFactory.getProp(s, e.e, 1, null, this)),
          (this.h = PropertyFactory.getProp(s, e.h || { k: 0 }, 0, 0.01, this)),
          (this.a = PropertyFactory.getProp(
            s,
            e.a || { k: 0 },
            0,
            degToRads,
            this
          )),
          (this.g = new GradientProperty(s, e.g, this)),
          (this.style = o),
          (this.stops = []),
          this.setGradientData(o.pElem, e),
          this.setGradientOpacity(e, o),
          (this._isAnimated = !!this._isAnimated);
      }),
        (SVGGradientFillStyleData.prototype.setGradientData = function (s, e) {
          var o = createElementID(),
            a = createNS(e.t === 1 ? "linearGradient" : "radialGradient");
          a.setAttribute("id", o),
            a.setAttribute("spreadMethod", "pad"),
            a.setAttribute("gradientUnits", "userSpaceOnUse");
          var c = [],
            d,
            g,
            _;
          for (_ = e.g.p * 4, g = 0; g < _; g += 4)
            (d = createNS("stop")), a.appendChild(d), c.push(d);
          s.setAttribute(
            e.ty === "gf" ? "fill" : "stroke",
            "url(" + getLocationHref() + "#" + o + ")"
          ),
            (this.gf = a),
            (this.cst = c);
        }),
        (SVGGradientFillStyleData.prototype.setGradientOpacity = function (
          s,
          e
        ) {
          if (this.g._hasOpacity && !this.g._collapsable) {
            var o,
              a,
              c,
              d = createNS("mask"),
              g = createNS("path");
            d.appendChild(g);
            var _ = createElementID(),
              b = createElementID();
            d.setAttribute("id", b);
            var j = createNS(s.t === 1 ? "linearGradient" : "radialGradient");
            j.setAttribute("id", _),
              j.setAttribute("spreadMethod", "pad"),
              j.setAttribute("gradientUnits", "userSpaceOnUse"),
              (c = s.g.k.k[0].s ? s.g.k.k[0].s.length : s.g.k.k.length);
            var $ = this.stops;
            for (a = s.g.p * 4; a < c; a += 2)
              (o = createNS("stop")),
                o.setAttribute("stop-color", "rgb(255,255,255)"),
                j.appendChild(o),
                $.push(o);
            g.setAttribute(
              s.ty === "gf" ? "fill" : "stroke",
              "url(" + getLocationHref() + "#" + _ + ")"
            ),
              s.ty === "gs" &&
                (g.setAttribute("stroke-linecap", lineCapEnum[s.lc || 2]),
                g.setAttribute("stroke-linejoin", lineJoinEnum[s.lj || 2]),
                s.lj === 1 && g.setAttribute("stroke-miterlimit", s.ml)),
              (this.of = j),
              (this.ms = d),
              (this.ost = $),
              (this.maskId = b),
              (e.msElem = g);
          }
        }),
        extendPrototype([DynamicPropertyContainer], SVGGradientFillStyleData);
      function SVGGradientStrokeStyleData(s, e, o) {
        this.initDynamicPropertyContainer(s),
          (this.getValue = this.iterateDynamicProperties),
          (this.w = PropertyFactory.getProp(s, e.w, 0, null, this)),
          (this.d = new DashProperty(s, e.d || {}, "svg", this)),
          this.initGradientData(s, e, o),
          (this._isAnimated = !!this._isAnimated);
      }
      extendPrototype(
        [SVGGradientFillStyleData, DynamicPropertyContainer],
        SVGGradientStrokeStyleData
      );
      function ShapeGroupData() {
        (this.it = []), (this.prevViewData = []), (this.gr = createNS("g"));
      }
      function SVGTransformData(s, e, o) {
        (this.transform = { mProps: s, op: e, container: o }),
          (this.elements = []),
          (this._isAnimated =
            this.transform.mProps.dynamicProperties.length ||
            this.transform.op.effectsSequence.length);
      }
      var buildShapeString = function (e, o, a, c) {
          if (o === 0) return "";
          var d = e.o,
            g = e.i,
            _ = e.v,
            b,
            j = " M" + c.applyToPointStringified(_[0][0], _[0][1]);
          for (b = 1; b < o; b += 1)
            j +=
              " C" +
              c.applyToPointStringified(d[b - 1][0], d[b - 1][1]) +
              " " +
              c.applyToPointStringified(g[b][0], g[b][1]) +
              " " +
              c.applyToPointStringified(_[b][0], _[b][1]);
          return (
            a &&
              o &&
              ((j +=
                " C" +
                c.applyToPointStringified(d[b - 1][0], d[b - 1][1]) +
                " " +
                c.applyToPointStringified(g[0][0], g[0][1]) +
                " " +
                c.applyToPointStringified(_[0][0], _[0][1])),
              (j += "z")),
            j
          );
        },
        SVGElementsRenderer = (function () {
          var s = new Matrix(),
            e = new Matrix(),
            o = { createRenderFunction: a };
          function a(_e) {
            switch (_e.ty) {
              case "fl":
                return _;
              case "gf":
                return j;
              case "gs":
                return b;
              case "st":
                return $;
              case "sh":
              case "el":
              case "rc":
              case "sr":
                return g;
              case "tr":
                return c;
              case "no":
                return d;
              default:
                return null;
            }
          }
          function c(_e, et, rt) {
            (rt || et.transform.op._mdf) &&
              et.transform.container.setAttribute("opacity", et.transform.op.v),
              (rt || et.transform.mProps._mdf) &&
                et.transform.container.setAttribute(
                  "transform",
                  et.transform.mProps.v.to2dCSS()
                );
          }
          function d() {}
          function g(_e, et, rt) {
            var st,
              at,
              ct,
              it,
              lt,
              ot,
              ut = et.styles.length,
              pt = et.lvl,
              ft,
              gt,
              xt,
              _t;
            for (ot = 0; ot < ut; ot += 1) {
              if (((it = et.sh._mdf || rt), et.styles[ot].lvl < pt)) {
                for (
                  gt = e.reset(),
                    xt = pt - et.styles[ot].lvl,
                    _t = et.transformers.length - 1;
                  !it && xt > 0;

                )
                  (it = et.transformers[_t].mProps._mdf || it),
                    (xt -= 1),
                    (_t -= 1);
                if (it)
                  for (
                    xt = pt - et.styles[ot].lvl,
                      _t = et.transformers.length - 1;
                    xt > 0;

                  )
                    gt.multiply(et.transformers[_t].mProps.v),
                      (xt -= 1),
                      (_t -= 1);
              } else gt = s;
              if (((ft = et.sh.paths), (at = ft._length), it)) {
                for (ct = "", st = 0; st < at; st += 1)
                  (lt = ft.shapes[st]),
                    lt &&
                      lt._length &&
                      (ct += buildShapeString(lt, lt._length, lt.c, gt));
                et.caches[ot] = ct;
              } else ct = et.caches[ot];
              (et.styles[ot].d += _e.hd === !0 ? "" : ct),
                (et.styles[ot]._mdf = it || et.styles[ot]._mdf);
            }
          }
          function _(_e, et, rt) {
            var st = et.style;
            (et.c._mdf || rt) &&
              st.pElem.setAttribute(
                "fill",
                "rgb(" +
                  bmFloor(et.c.v[0]) +
                  "," +
                  bmFloor(et.c.v[1]) +
                  "," +
                  bmFloor(et.c.v[2]) +
                  ")"
              ),
              (et.o._mdf || rt) &&
                st.pElem.setAttribute("fill-opacity", et.o.v);
          }
          function b(_e, et, rt) {
            j(_e, et, rt), $(_e, et, rt);
          }
          function j(_e, et, rt) {
            var st = et.gf,
              at = et.g._hasOpacity,
              ct = et.s.v,
              it = et.e.v;
            if (et.o._mdf || rt) {
              var lt = _e.ty === "gf" ? "fill-opacity" : "stroke-opacity";
              et.style.pElem.setAttribute(lt, et.o.v);
            }
            if (et.s._mdf || rt) {
              var ot = _e.t === 1 ? "x1" : "cx",
                ut = ot === "x1" ? "y1" : "cy";
              st.setAttribute(ot, ct[0]),
                st.setAttribute(ut, ct[1]),
                at &&
                  !et.g._collapsable &&
                  (et.of.setAttribute(ot, ct[0]),
                  et.of.setAttribute(ut, ct[1]));
            }
            var pt, ft, gt, xt;
            if (et.g._cmdf || rt) {
              pt = et.cst;
              var _t = et.g.c;
              for (gt = pt.length, ft = 0; ft < gt; ft += 1)
                (xt = pt[ft]),
                  xt.setAttribute("offset", _t[ft * 4] + "%"),
                  xt.setAttribute(
                    "stop-color",
                    "rgb(" +
                      _t[ft * 4 + 1] +
                      "," +
                      _t[ft * 4 + 2] +
                      "," +
                      _t[ft * 4 + 3] +
                      ")"
                  );
            }
            if (at && (et.g._omdf || rt)) {
              var St = et.g.o;
              for (
                et.g._collapsable ? (pt = et.cst) : (pt = et.ost),
                  gt = pt.length,
                  ft = 0;
                ft < gt;
                ft += 1
              )
                (xt = pt[ft]),
                  et.g._collapsable ||
                    xt.setAttribute("offset", St[ft * 2] + "%"),
                  xt.setAttribute("stop-opacity", St[ft * 2 + 1]);
            }
            if (_e.t === 1)
              (et.e._mdf || rt) &&
                (st.setAttribute("x2", it[0]),
                st.setAttribute("y2", it[1]),
                at &&
                  !et.g._collapsable &&
                  (et.of.setAttribute("x2", it[0]),
                  et.of.setAttribute("y2", it[1])));
            else {
              var Mt;
              if (
                ((et.s._mdf || et.e._mdf || rt) &&
                  ((Mt = Math.sqrt(
                    Math.pow(ct[0] - it[0], 2) + Math.pow(ct[1] - it[1], 2)
                  )),
                  st.setAttribute("r", Mt),
                  at && !et.g._collapsable && et.of.setAttribute("r", Mt)),
                et.e._mdf || et.h._mdf || et.a._mdf || rt)
              ) {
                Mt ||
                  (Mt = Math.sqrt(
                    Math.pow(ct[0] - it[0], 2) + Math.pow(ct[1] - it[1], 2)
                  ));
                var Rt = Math.atan2(it[1] - ct[1], it[0] - ct[0]),
                  Ft = et.h.v;
                Ft >= 1 ? (Ft = 0.99) : Ft <= -1 && (Ft = -0.99);
                var Ot = Mt * Ft,
                  Lt = Math.cos(Rt + et.a.v) * Ot + ct[0],
                  Et = Math.sin(Rt + et.a.v) * Ot + ct[1];
                st.setAttribute("fx", Lt),
                  st.setAttribute("fy", Et),
                  at &&
                    !et.g._collapsable &&
                    (et.of.setAttribute("fx", Lt),
                    et.of.setAttribute("fy", Et));
              }
            }
          }
          function $(_e, et, rt) {
            var st = et.style,
              at = et.d;
            at &&
              (at._mdf || rt) &&
              at.dashStr &&
              (st.pElem.setAttribute("stroke-dasharray", at.dashStr),
              st.pElem.setAttribute("stroke-dashoffset", at.dashoffset[0])),
              et.c &&
                (et.c._mdf || rt) &&
                st.pElem.setAttribute(
                  "stroke",
                  "rgb(" +
                    bmFloor(et.c.v[0]) +
                    "," +
                    bmFloor(et.c.v[1]) +
                    "," +
                    bmFloor(et.c.v[2]) +
                    ")"
                ),
              (et.o._mdf || rt) &&
                st.pElem.setAttribute("stroke-opacity", et.o.v),
              (et.w._mdf || rt) &&
                (st.pElem.setAttribute("stroke-width", et.w.v),
                st.msElem && st.msElem.setAttribute("stroke-width", et.w.v));
          }
          return o;
        })();
      function SVGShapeElement(s, e, o) {
        (this.shapes = []),
          (this.shapesData = s.shapes),
          (this.stylesList = []),
          (this.shapeModifiers = []),
          (this.itemsData = []),
          (this.processedElements = []),
          (this.animatedContents = []),
          this.initElement(s, e, o),
          (this.prevViewData = []);
      }
      extendPrototype(
        [
          BaseElement,
          TransformElement,
          SVGBaseElement,
          IShapeElement,
          HierarchyElement,
          FrameElement,
          RenderableDOMElement,
        ],
        SVGShapeElement
      ),
        (SVGShapeElement.prototype.initSecondaryElement = function () {}),
        (SVGShapeElement.prototype.identityMatrix = new Matrix()),
        (SVGShapeElement.prototype.buildExpressionInterface = function () {}),
        (SVGShapeElement.prototype.createContent = function () {
          this.searchShapes(
            this.shapesData,
            this.itemsData,
            this.prevViewData,
            this.layerElement,
            0,
            [],
            !0
          ),
            this.filterUniqueShapes();
        }),
        (SVGShapeElement.prototype.filterUniqueShapes = function () {
          var s,
            e = this.shapes.length,
            o,
            a,
            c = this.stylesList.length,
            d,
            g = [],
            _ = !1;
          for (a = 0; a < c; a += 1) {
            for (
              d = this.stylesList[a], _ = !1, g.length = 0, s = 0;
              s < e;
              s += 1
            )
              (o = this.shapes[s]),
                o.styles.indexOf(d) !== -1 &&
                  (g.push(o), (_ = o._isAnimated || _));
            g.length > 1 && _ && this.setShapesAsAnimated(g);
          }
        }),
        (SVGShapeElement.prototype.setShapesAsAnimated = function (s) {
          var e,
            o = s.length;
          for (e = 0; e < o; e += 1) s[e].setAsAnimated();
        }),
        (SVGShapeElement.prototype.createStyleElement = function (s, e) {
          var o,
            a = new SVGStyleData(s, e),
            c = a.pElem;
          if (s.ty === "st") o = new SVGStrokeStyleData(this, s, a);
          else if (s.ty === "fl") o = new SVGFillStyleData(this, s, a);
          else if (s.ty === "gf" || s.ty === "gs") {
            var d =
              s.ty === "gf"
                ? SVGGradientFillStyleData
                : SVGGradientStrokeStyleData;
            (o = new d(this, s, a)),
              this.globalData.defs.appendChild(o.gf),
              o.maskId &&
                (this.globalData.defs.appendChild(o.ms),
                this.globalData.defs.appendChild(o.of),
                c.setAttribute(
                  "mask",
                  "url(" + getLocationHref() + "#" + o.maskId + ")"
                ));
          } else s.ty === "no" && (o = new SVGNoStyleData(this, s, a));
          return (
            (s.ty === "st" || s.ty === "gs") &&
              (c.setAttribute("stroke-linecap", lineCapEnum[s.lc || 2]),
              c.setAttribute("stroke-linejoin", lineJoinEnum[s.lj || 2]),
              c.setAttribute("fill-opacity", "0"),
              s.lj === 1 && c.setAttribute("stroke-miterlimit", s.ml)),
            s.r === 2 && c.setAttribute("fill-rule", "evenodd"),
            s.ln && c.setAttribute("id", s.ln),
            s.cl && c.setAttribute("class", s.cl),
            s.bm && (c.style["mix-blend-mode"] = getBlendMode(s.bm)),
            this.stylesList.push(a),
            this.addToAnimatedContents(s, o),
            o
          );
        }),
        (SVGShapeElement.prototype.createGroupElement = function (s) {
          var e = new ShapeGroupData();
          return (
            s.ln && e.gr.setAttribute("id", s.ln),
            s.cl && e.gr.setAttribute("class", s.cl),
            s.bm && (e.gr.style["mix-blend-mode"] = getBlendMode(s.bm)),
            e
          );
        }),
        (SVGShapeElement.prototype.createTransformElement = function (s, e) {
          var o = TransformPropertyFactory.getTransformProperty(this, s, this),
            a = new SVGTransformData(o, o.o, e);
          return this.addToAnimatedContents(s, a), a;
        }),
        (SVGShapeElement.prototype.createShapeElement = function (s, e, o) {
          var a = 4;
          s.ty === "rc"
            ? (a = 5)
            : s.ty === "el"
            ? (a = 6)
            : s.ty === "sr" && (a = 7);
          var c = ShapePropertyFactory.getShapeProp(this, s, a, this),
            d = new SVGShapeData(e, o, c);
          return (
            this.shapes.push(d),
            this.addShapeToModifiers(d),
            this.addToAnimatedContents(s, d),
            d
          );
        }),
        (SVGShapeElement.prototype.addToAnimatedContents = function (s, e) {
          for (var o = 0, a = this.animatedContents.length; o < a; ) {
            if (this.animatedContents[o].element === e) return;
            o += 1;
          }
          this.animatedContents.push({
            fn: SVGElementsRenderer.createRenderFunction(s),
            element: e,
            data: s,
          });
        }),
        (SVGShapeElement.prototype.setElementStyles = function (s) {
          var e = s.styles,
            o,
            a = this.stylesList.length;
          for (o = 0; o < a; o += 1)
            this.stylesList[o].closed || e.push(this.stylesList[o]);
        }),
        (SVGShapeElement.prototype.reloadShapes = function () {
          this._isFirstFrame = !0;
          var s,
            e = this.itemsData.length;
          for (s = 0; s < e; s += 1) this.prevViewData[s] = this.itemsData[s];
          for (
            this.searchShapes(
              this.shapesData,
              this.itemsData,
              this.prevViewData,
              this.layerElement,
              0,
              [],
              !0
            ),
              this.filterUniqueShapes(),
              e = this.dynamicProperties.length,
              s = 0;
            s < e;
            s += 1
          )
            this.dynamicProperties[s].getValue();
          this.renderModifiers();
        }),
        (SVGShapeElement.prototype.searchShapes = function (
          s,
          e,
          o,
          a,
          c,
          d,
          g
        ) {
          var _ = [].concat(d),
            b,
            j = s.length - 1,
            $,
            _e,
            et = [],
            rt = [],
            st,
            at,
            ct;
          for (b = j; b >= 0; b -= 1) {
            if (
              ((ct = this.searchProcessedElement(s[b])),
              ct ? (e[b] = o[ct - 1]) : (s[b]._render = g),
              s[b].ty === "fl" ||
                s[b].ty === "st" ||
                s[b].ty === "gf" ||
                s[b].ty === "gs" ||
                s[b].ty === "no")
            )
              ct
                ? (e[b].style.closed = !1)
                : (e[b] = this.createStyleElement(s[b], c)),
                s[b]._render &&
                  e[b].style.pElem.parentNode !== a &&
                  a.appendChild(e[b].style.pElem),
                et.push(e[b].style);
            else if (s[b].ty === "gr") {
              if (!ct) e[b] = this.createGroupElement(s[b]);
              else
                for (_e = e[b].it.length, $ = 0; $ < _e; $ += 1)
                  e[b].prevViewData[$] = e[b].it[$];
              this.searchShapes(
                s[b].it,
                e[b].it,
                e[b].prevViewData,
                e[b].gr,
                c + 1,
                _,
                g
              ),
                s[b]._render &&
                  e[b].gr.parentNode !== a &&
                  a.appendChild(e[b].gr);
            } else
              s[b].ty === "tr"
                ? (ct || (e[b] = this.createTransformElement(s[b], a)),
                  (st = e[b].transform),
                  _.push(st))
                : s[b].ty === "sh" ||
                  s[b].ty === "rc" ||
                  s[b].ty === "el" ||
                  s[b].ty === "sr"
                ? (ct || (e[b] = this.createShapeElement(s[b], _, c)),
                  this.setElementStyles(e[b]))
                : s[b].ty === "tm" ||
                  s[b].ty === "rd" ||
                  s[b].ty === "ms" ||
                  s[b].ty === "pb" ||
                  s[b].ty === "zz" ||
                  s[b].ty === "op"
                ? (ct
                    ? ((at = e[b]), (at.closed = !1))
                    : ((at = ShapeModifiers.getModifier(s[b].ty)),
                      at.init(this, s[b]),
                      (e[b] = at),
                      this.shapeModifiers.push(at)),
                  rt.push(at))
                : s[b].ty === "rp" &&
                  (ct
                    ? ((at = e[b]), (at.closed = !0))
                    : ((at = ShapeModifiers.getModifier(s[b].ty)),
                      (e[b] = at),
                      at.init(this, s, b, e),
                      this.shapeModifiers.push(at),
                      (g = !1)),
                  rt.push(at));
            this.addProcessedElement(s[b], b + 1);
          }
          for (j = et.length, b = 0; b < j; b += 1) et[b].closed = !0;
          for (j = rt.length, b = 0; b < j; b += 1) rt[b].closed = !0;
        }),
        (SVGShapeElement.prototype.renderInnerContent = function () {
          this.renderModifiers();
          var s,
            e = this.stylesList.length;
          for (s = 0; s < e; s += 1) this.stylesList[s].reset();
          for (this.renderShape(), s = 0; s < e; s += 1)
            (this.stylesList[s]._mdf || this._isFirstFrame) &&
              (this.stylesList[s].msElem &&
                (this.stylesList[s].msElem.setAttribute(
                  "d",
                  this.stylesList[s].d
                ),
                (this.stylesList[s].d = "M0 0" + this.stylesList[s].d)),
              this.stylesList[s].pElem.setAttribute(
                "d",
                this.stylesList[s].d || "M0 0"
              ));
        }),
        (SVGShapeElement.prototype.renderShape = function () {
          var s,
            e = this.animatedContents.length,
            o;
          for (s = 0; s < e; s += 1)
            (o = this.animatedContents[s]),
              (this._isFirstFrame || o.element._isAnimated) &&
                o.data !== !0 &&
                o.fn(o.data, o.element, this._isFirstFrame);
        }),
        (SVGShapeElement.prototype.destroy = function () {
          this.destroyBaseElement(),
            (this.shapesData = null),
            (this.itemsData = null);
        });
      function LetterProps(s, e, o, a, c, d) {
        (this.o = s),
          (this.sw = e),
          (this.sc = o),
          (this.fc = a),
          (this.m = c),
          (this.p = d),
          (this._mdf = { o: !0, sw: !!e, sc: !!o, fc: !!a, m: !0, p: !0 });
      }
      LetterProps.prototype.update = function (s, e, o, a, c, d) {
        (this._mdf.o = !1),
          (this._mdf.sw = !1),
          (this._mdf.sc = !1),
          (this._mdf.fc = !1),
          (this._mdf.m = !1),
          (this._mdf.p = !1);
        var g = !1;
        return (
          this.o !== s && ((this.o = s), (this._mdf.o = !0), (g = !0)),
          this.sw !== e && ((this.sw = e), (this._mdf.sw = !0), (g = !0)),
          this.sc !== o && ((this.sc = o), (this._mdf.sc = !0), (g = !0)),
          this.fc !== a && ((this.fc = a), (this._mdf.fc = !0), (g = !0)),
          this.m !== c && ((this.m = c), (this._mdf.m = !0), (g = !0)),
          d.length &&
            (this.p[0] !== d[0] ||
              this.p[1] !== d[1] ||
              this.p[4] !== d[4] ||
              this.p[5] !== d[5] ||
              this.p[12] !== d[12] ||
              this.p[13] !== d[13]) &&
            ((this.p = d), (this._mdf.p = !0), (g = !0)),
          g
        );
      };
      function TextProperty(s, e) {
        (this._frameId = initialDefaultFrame),
          (this.pv = ""),
          (this.v = ""),
          (this.kf = !1),
          (this._isFirstFrame = !0),
          (this._mdf = !1),
          e.d && e.d.sid && (e.d = s.globalData.slotManager.getProp(e.d)),
          (this.data = e),
          (this.elem = s),
          (this.comp = this.elem.comp),
          (this.keysIndex = 0),
          (this.canResize = !1),
          (this.minimumFontSize = 1),
          (this.effectsSequence = []),
          (this.currentData = {
            ascent: 0,
            boxWidth: this.defaultBoxWidth,
            f: "",
            fStyle: "",
            fWeight: "",
            fc: "",
            j: "",
            justifyOffset: "",
            l: [],
            lh: 0,
            lineWidths: [],
            ls: "",
            of: "",
            s: "",
            sc: "",
            sw: 0,
            t: 0,
            tr: 0,
            sz: 0,
            ps: null,
            fillColorAnim: !1,
            strokeColorAnim: !1,
            strokeWidthAnim: !1,
            yOffset: 0,
            finalSize: 0,
            finalText: [],
            finalLineHeight: 0,
            __complete: !1,
          }),
          this.copyData(this.currentData, this.data.d.k[0].s),
          this.searchProperty() || this.completeTextData(this.currentData);
      }
      (TextProperty.prototype.defaultBoxWidth = [0, 0]),
        (TextProperty.prototype.copyData = function (s, e) {
          for (var o in e)
            Object.prototype.hasOwnProperty.call(e, o) && (s[o] = e[o]);
          return s;
        }),
        (TextProperty.prototype.setCurrentData = function (s) {
          s.__complete || this.completeTextData(s),
            (this.currentData = s),
            (this.currentData.boxWidth =
              this.currentData.boxWidth || this.defaultBoxWidth),
            (this._mdf = !0);
        }),
        (TextProperty.prototype.searchProperty = function () {
          return this.searchKeyframes();
        }),
        (TextProperty.prototype.searchKeyframes = function () {
          return (
            (this.kf = this.data.d.k.length > 1),
            this.kf && this.addEffect(this.getKeyframeValue.bind(this)),
            this.kf
          );
        }),
        (TextProperty.prototype.addEffect = function (s) {
          this.effectsSequence.push(s), this.elem.addDynamicProperty(this);
        }),
        (TextProperty.prototype.getValue = function (s) {
          if (
            !(
              (this.elem.globalData.frameId === this.frameId ||
                !this.effectsSequence.length) &&
              !s
            )
          ) {
            this.currentData.t = this.data.d.k[this.keysIndex].s.t;
            var e = this.currentData,
              o = this.keysIndex;
            if (this.lock) {
              this.setCurrentData(this.currentData);
              return;
            }
            (this.lock = !0), (this._mdf = !1);
            var a,
              c = this.effectsSequence.length,
              d = s || this.data.d.k[this.keysIndex].s;
            for (a = 0; a < c; a += 1)
              o !== this.keysIndex
                ? (d = this.effectsSequence[a](d, d.t))
                : (d = this.effectsSequence[a](this.currentData, d.t));
            e !== d && this.setCurrentData(d),
              (this.v = this.currentData),
              (this.pv = this.v),
              (this.lock = !1),
              (this.frameId = this.elem.globalData.frameId);
          }
        }),
        (TextProperty.prototype.getKeyframeValue = function () {
          for (
            var s = this.data.d.k,
              e = this.elem.comp.renderedFrame,
              o = 0,
              a = s.length;
            o <= a - 1 && !(o === a - 1 || s[o + 1].t > e);

          )
            o += 1;
          return (
            this.keysIndex !== o && (this.keysIndex = o),
            this.data.d.k[this.keysIndex].s
          );
        }),
        (TextProperty.prototype.buildFinalText = function (s) {
          for (
            var e = [], o = 0, a = s.length, c, d, g = !1, _ = !1, b = "";
            o < a;

          )
            (g = _),
              (_ = !1),
              (c = s.charCodeAt(o)),
              (b = s.charAt(o)),
              FontManager.isCombinedCharacter(c)
                ? (g = !0)
                : c >= 55296 && c <= 56319
                ? FontManager.isRegionalFlag(s, o)
                  ? (b = s.substr(o, 14))
                  : ((d = s.charCodeAt(o + 1)),
                    d >= 56320 &&
                      d <= 57343 &&
                      (FontManager.isModifier(c, d)
                        ? ((b = s.substr(o, 2)), (g = !0))
                        : FontManager.isFlagEmoji(s.substr(o, 4))
                        ? (b = s.substr(o, 4))
                        : (b = s.substr(o, 2))))
                : c > 56319
                ? ((d = s.charCodeAt(o + 1)),
                  FontManager.isVariationSelector(c) && (g = !0))
                : FontManager.isZeroWidthJoiner(c) && ((g = !0), (_ = !0)),
              g ? ((e[e.length - 1] += b), (g = !1)) : e.push(b),
              (o += b.length);
          return e;
        }),
        (TextProperty.prototype.completeTextData = function (s) {
          s.__complete = !0;
          var e = this.elem.globalData.fontManager,
            o = this.data,
            a = [],
            c,
            d,
            g,
            _ = 0,
            b,
            j = o.m.g,
            $ = 0,
            _e = 0,
            et = 0,
            rt = [],
            st = 0,
            at = 0,
            ct,
            it,
            lt = e.getFontByName(s.f),
            ot,
            ut = 0,
            pt = getFontProperties(lt);
          (s.fWeight = pt.weight),
            (s.fStyle = pt.style),
            (s.finalSize = s.s),
            (s.finalText = this.buildFinalText(s.t)),
            (d = s.finalText.length),
            (s.finalLineHeight = s.lh);
          var ft = (s.tr / 1e3) * s.finalSize,
            gt;
          if (s.sz)
            for (var xt = !0, _t = s.sz[0], St = s.sz[1], Mt, Rt; xt; ) {
              (Rt = this.buildFinalText(s.t)),
                (Mt = 0),
                (st = 0),
                (d = Rt.length),
                (ft = (s.tr / 1e3) * s.finalSize);
              var Ft = -1;
              for (c = 0; c < d; c += 1)
                (gt = Rt[c].charCodeAt(0)),
                  (g = !1),
                  Rt[c] === " "
                    ? (Ft = c)
                    : (gt === 13 || gt === 3) &&
                      ((st = 0),
                      (g = !0),
                      (Mt += s.finalLineHeight || s.finalSize * 1.2)),
                  e.chars
                    ? ((ot = e.getCharData(Rt[c], lt.fStyle, lt.fFamily)),
                      (ut = g ? 0 : (ot.w * s.finalSize) / 100))
                    : (ut = e.measureText(Rt[c], s.f, s.finalSize)),
                  st + ut > _t && Rt[c] !== " "
                    ? (Ft === -1 ? (d += 1) : (c = Ft),
                      (Mt += s.finalLineHeight || s.finalSize * 1.2),
                      Rt.splice(c, Ft === c ? 1 : 0, "\r"),
                      (Ft = -1),
                      (st = 0))
                    : ((st += ut), (st += ft));
              (Mt += (lt.ascent * s.finalSize) / 100),
                this.canResize && s.finalSize > this.minimumFontSize && St < Mt
                  ? ((s.finalSize -= 1),
                    (s.finalLineHeight = (s.finalSize * s.lh) / s.s))
                  : ((s.finalText = Rt), (d = s.finalText.length), (xt = !1));
            }
          (st = -ft), (ut = 0);
          var Ot = 0,
            Lt;
          for (c = 0; c < d; c += 1)
            if (
              ((g = !1),
              (Lt = s.finalText[c]),
              (gt = Lt.charCodeAt(0)),
              gt === 13 || gt === 3
                ? ((Ot = 0),
                  rt.push(st),
                  (at = st > at ? st : at),
                  (st = -2 * ft),
                  (b = ""),
                  (g = !0),
                  (et += 1))
                : (b = Lt),
              e.chars
                ? ((ot = e.getCharData(
                    Lt,
                    lt.fStyle,
                    e.getFontByName(s.f).fFamily
                  )),
                  (ut = g ? 0 : (ot.w * s.finalSize) / 100))
                : (ut = e.measureText(b, s.f, s.finalSize)),
              Lt === " " ? (Ot += ut + ft) : ((st += ut + ft + Ot), (Ot = 0)),
              a.push({
                l: ut,
                an: ut,
                add: $,
                n: g,
                anIndexes: [],
                val: b,
                line: et,
                animatorJustifyOffset: 0,
              }),
              j == 2)
            ) {
              if ((($ += ut), b === "" || b === " " || c === d - 1)) {
                for ((b === "" || b === " ") && ($ -= ut); _e <= c; )
                  (a[_e].an = $),
                    (a[_e].ind = _),
                    (a[_e].extra = ut),
                    (_e += 1);
                (_ += 1), ($ = 0);
              }
            } else if (j == 3) {
              if ((($ += ut), b === "" || c === d - 1)) {
                for (b === "" && ($ -= ut); _e <= c; )
                  (a[_e].an = $),
                    (a[_e].ind = _),
                    (a[_e].extra = ut),
                    (_e += 1);
                ($ = 0), (_ += 1);
              }
            } else (a[_].ind = _), (a[_].extra = 0), (_ += 1);
          if (((s.l = a), (at = st > at ? st : at), rt.push(st), s.sz))
            (s.boxWidth = s.sz[0]), (s.justifyOffset = 0);
          else
            switch (((s.boxWidth = at), s.j)) {
              case 1:
                s.justifyOffset = -s.boxWidth;
                break;
              case 2:
                s.justifyOffset = -s.boxWidth / 2;
                break;
              default:
                s.justifyOffset = 0;
            }
          s.lineWidths = rt;
          var Et = o.a,
            bt,
            mt;
          it = Et.length;
          var vt,
            Ct,
            Tt = [];
          for (ct = 0; ct < it; ct += 1) {
            for (
              bt = Et[ct],
                bt.a.sc && (s.strokeColorAnim = !0),
                bt.a.sw && (s.strokeWidthAnim = !0),
                (bt.a.fc || bt.a.fh || bt.a.fs || bt.a.fb) &&
                  (s.fillColorAnim = !0),
                Ct = 0,
                vt = bt.s.b,
                c = 0;
              c < d;
              c += 1
            )
              (mt = a[c]),
                (mt.anIndexes[ct] = Ct),
                ((vt == 1 && mt.val !== "") ||
                  (vt == 2 && mt.val !== "" && mt.val !== " ") ||
                  (vt == 3 && (mt.n || mt.val == " " || c == d - 1)) ||
                  (vt == 4 && (mt.n || c == d - 1))) &&
                  (bt.s.rn === 1 && Tt.push(Ct), (Ct += 1));
            o.a[ct].s.totalChars = Ct;
            var Dt = -1,
              Wt;
            if (bt.s.rn === 1)
              for (c = 0; c < d; c += 1)
                (mt = a[c]),
                  Dt != mt.anIndexes[ct] &&
                    ((Dt = mt.anIndexes[ct]),
                    (Wt = Tt.splice(
                      Math.floor(Math.random() * Tt.length),
                      1
                    )[0])),
                  (mt.anIndexes[ct] = Wt);
          }
          (s.yOffset = s.finalLineHeight || s.finalSize * 1.2),
            (s.ls = s.ls || 0),
            (s.ascent = (lt.ascent * s.finalSize) / 100);
        }),
        (TextProperty.prototype.updateDocumentData = function (s, e) {
          e = e === void 0 ? this.keysIndex : e;
          var o = this.copyData({}, this.data.d.k[e].s);
          (o = this.copyData(o, s)),
            (this.data.d.k[e].s = o),
            this.recalculate(e),
            this.setCurrentData(o),
            this.elem.addDynamicProperty(this);
        }),
        (TextProperty.prototype.recalculate = function (s) {
          var e = this.data.d.k[s].s;
          (e.__complete = !1),
            (this.keysIndex = 0),
            (this._isFirstFrame = !0),
            this.getValue(e);
        }),
        (TextProperty.prototype.canResizeFont = function (s) {
          (this.canResize = s),
            this.recalculate(this.keysIndex),
            this.elem.addDynamicProperty(this);
        }),
        (TextProperty.prototype.setMinimumFontSize = function (s) {
          (this.minimumFontSize = Math.floor(s) || 1),
            this.recalculate(this.keysIndex),
            this.elem.addDynamicProperty(this);
        });
      var TextSelectorProp = (function () {
        var s = Math.max,
          e = Math.min,
          o = Math.floor;
        function a(d, g) {
          (this._currentTextLength = -1),
            (this.k = !1),
            (this.data = g),
            (this.elem = d),
            (this.comp = d.comp),
            (this.finalS = 0),
            (this.finalE = 0),
            this.initDynamicPropertyContainer(d),
            (this.s = PropertyFactory.getProp(d, g.s || { k: 0 }, 0, 0, this)),
            "e" in g
              ? (this.e = PropertyFactory.getProp(d, g.e, 0, 0, this))
              : (this.e = { v: 100 }),
            (this.o = PropertyFactory.getProp(d, g.o || { k: 0 }, 0, 0, this)),
            (this.xe = PropertyFactory.getProp(
              d,
              g.xe || { k: 0 },
              0,
              0,
              this
            )),
            (this.ne = PropertyFactory.getProp(
              d,
              g.ne || { k: 0 },
              0,
              0,
              this
            )),
            (this.sm = PropertyFactory.getProp(
              d,
              g.sm || { k: 100 },
              0,
              0,
              this
            )),
            (this.a = PropertyFactory.getProp(d, g.a, 0, 0.01, this)),
            this.dynamicProperties.length || this.getValue();
        }
        (a.prototype = {
          getMult: function (g) {
            this._currentTextLength !==
              this.elem.textProperty.currentData.l.length && this.getValue();
            var _ = 0,
              b = 0,
              j = 1,
              $ = 1;
            this.ne.v > 0 ? (_ = this.ne.v / 100) : (b = -this.ne.v / 100),
              this.xe.v > 0
                ? (j = 1 - this.xe.v / 100)
                : ($ = 1 + this.xe.v / 100);
            var _e = BezierFactory.getBezierEasing(_, b, j, $).get,
              et = 0,
              rt = this.finalS,
              st = this.finalE,
              at = this.data.sh;
            if (at === 2)
              st === rt
                ? (et = g >= st ? 1 : 0)
                : (et = s(0, e(0.5 / (st - rt) + (g - rt) / (st - rt), 1))),
                (et = _e(et));
            else if (at === 3)
              st === rt
                ? (et = g >= st ? 0 : 1)
                : (et = 1 - s(0, e(0.5 / (st - rt) + (g - rt) / (st - rt), 1))),
                (et = _e(et));
            else if (at === 4)
              st === rt
                ? (et = 0)
                : ((et = s(0, e(0.5 / (st - rt) + (g - rt) / (st - rt), 1))),
                  et < 0.5 ? (et *= 2) : (et = 1 - 2 * (et - 0.5))),
                (et = _e(et));
            else if (at === 5) {
              if (st === rt) et = 0;
              else {
                var ct = st - rt;
                g = e(s(0, g + 0.5 - rt), st - rt);
                var it = -ct / 2 + g,
                  lt = ct / 2;
                et = Math.sqrt(1 - (it * it) / (lt * lt));
              }
              et = _e(et);
            } else
              at === 6
                ? (st === rt
                    ? (et = 0)
                    : ((g = e(s(0, g + 0.5 - rt), st - rt)),
                      (et =
                        (1 +
                          Math.cos(Math.PI + (Math.PI * 2 * g) / (st - rt))) /
                        2)),
                  (et = _e(et)))
                : (g >= o(rt) &&
                    (g - rt < 0
                      ? (et = s(0, e(e(st, 1) - (rt - g), 1)))
                      : (et = s(0, e(st - g, 1)))),
                  (et = _e(et)));
            if (this.sm.v !== 100) {
              var ot = this.sm.v * 0.01;
              ot === 0 && (ot = 1e-8);
              var ut = 0.5 - ot * 0.5;
              et < ut ? (et = 0) : ((et = (et - ut) / ot), et > 1 && (et = 1));
            }
            return et * this.a.v;
          },
          getValue: function (g) {
            this.iterateDynamicProperties(),
              (this._mdf = g || this._mdf),
              (this._currentTextLength =
                this.elem.textProperty.currentData.l.length || 0),
              g && this.data.r === 2 && (this.e.v = this._currentTextLength);
            var _ = this.data.r === 2 ? 1 : 100 / this.data.totalChars,
              b = this.o.v / _,
              j = this.s.v / _ + b,
              $ = this.e.v / _ + b;
            if (j > $) {
              var _e = j;
              (j = $), ($ = _e);
            }
            (this.finalS = j), (this.finalE = $);
          },
        }),
          extendPrototype([DynamicPropertyContainer], a);
        function c(d, g, _) {
          return new a(d, g);
        }
        return { getTextSelectorProp: c };
      })();
      function TextAnimatorDataProperty(s, e, o) {
        var a = { propType: !1 },
          c = PropertyFactory.getProp,
          d = e.a;
        (this.a = {
          r: d.r ? c(s, d.r, 0, degToRads, o) : a,
          rx: d.rx ? c(s, d.rx, 0, degToRads, o) : a,
          ry: d.ry ? c(s, d.ry, 0, degToRads, o) : a,
          sk: d.sk ? c(s, d.sk, 0, degToRads, o) : a,
          sa: d.sa ? c(s, d.sa, 0, degToRads, o) : a,
          s: d.s ? c(s, d.s, 1, 0.01, o) : a,
          a: d.a ? c(s, d.a, 1, 0, o) : a,
          o: d.o ? c(s, d.o, 0, 0.01, o) : a,
          p: d.p ? c(s, d.p, 1, 0, o) : a,
          sw: d.sw ? c(s, d.sw, 0, 0, o) : a,
          sc: d.sc ? c(s, d.sc, 1, 0, o) : a,
          fc: d.fc ? c(s, d.fc, 1, 0, o) : a,
          fh: d.fh ? c(s, d.fh, 0, 0, o) : a,
          fs: d.fs ? c(s, d.fs, 0, 0.01, o) : a,
          fb: d.fb ? c(s, d.fb, 0, 0.01, o) : a,
          t: d.t ? c(s, d.t, 0, 0, o) : a,
        }),
          (this.s = TextSelectorProp.getTextSelectorProp(s, e.s, o)),
          (this.s.t = e.s.t);
      }
      function TextAnimatorProperty(s, e, o) {
        (this._isFirstFrame = !0),
          (this._hasMaskedPath = !1),
          (this._frameId = -1),
          (this._textData = s),
          (this._renderType = e),
          (this._elem = o),
          (this._animatorsData = createSizedArray(this._textData.a.length)),
          (this._pathData = {}),
          (this._moreOptions = { alignment: {} }),
          (this.renderedLetters = []),
          (this.lettersChangedFlag = !1),
          this.initDynamicPropertyContainer(o);
      }
      (TextAnimatorProperty.prototype.searchProperties = function () {
        var s,
          e = this._textData.a.length,
          o,
          a = PropertyFactory.getProp;
        for (s = 0; s < e; s += 1)
          (o = this._textData.a[s]),
            (this._animatorsData[s] = new TextAnimatorDataProperty(
              this._elem,
              o,
              this
            ));
        this._textData.p && "m" in this._textData.p
          ? ((this._pathData = {
              a: a(this._elem, this._textData.p.a, 0, 0, this),
              f: a(this._elem, this._textData.p.f, 0, 0, this),
              l: a(this._elem, this._textData.p.l, 0, 0, this),
              r: a(this._elem, this._textData.p.r, 0, 0, this),
              p: a(this._elem, this._textData.p.p, 0, 0, this),
              m: this._elem.maskManager.getMaskProperty(this._textData.p.m),
            }),
            (this._hasMaskedPath = !0))
          : (this._hasMaskedPath = !1),
          (this._moreOptions.alignment = a(
            this._elem,
            this._textData.m.a,
            1,
            0,
            this
          ));
      }),
        (TextAnimatorProperty.prototype.getMeasures = function (s, e) {
          if (
            ((this.lettersChangedFlag = e),
            !(
              !this._mdf &&
              !this._isFirstFrame &&
              !e &&
              (!this._hasMaskedPath || !this._pathData.m._mdf)
            ))
          ) {
            this._isFirstFrame = !1;
            var o = this._moreOptions.alignment.v,
              a = this._animatorsData,
              c = this._textData,
              d = this.mHelper,
              g = this._renderType,
              _ = this.renderedLetters.length,
              b,
              j,
              $,
              _e,
              et = s.l,
              rt,
              st,
              at,
              ct,
              it,
              lt,
              ot,
              ut,
              pt,
              ft,
              gt,
              xt,
              _t,
              St,
              Mt;
            if (this._hasMaskedPath) {
              if (
                ((Mt = this._pathData.m),
                !this._pathData.n || this._pathData._mdf)
              ) {
                var Rt = Mt.v;
                this._pathData.r.v && (Rt = Rt.reverse()),
                  (rt = { tLength: 0, segments: [] }),
                  (_e = Rt._length - 1);
                var Ft;
                for (xt = 0, $ = 0; $ < _e; $ += 1)
                  (Ft = bez.buildBezierData(
                    Rt.v[$],
                    Rt.v[$ + 1],
                    [Rt.o[$][0] - Rt.v[$][0], Rt.o[$][1] - Rt.v[$][1]],
                    [
                      Rt.i[$ + 1][0] - Rt.v[$ + 1][0],
                      Rt.i[$ + 1][1] - Rt.v[$ + 1][1],
                    ]
                  )),
                    (rt.tLength += Ft.segmentLength),
                    rt.segments.push(Ft),
                    (xt += Ft.segmentLength);
                ($ = _e),
                  Mt.v.c &&
                    ((Ft = bez.buildBezierData(
                      Rt.v[$],
                      Rt.v[0],
                      [Rt.o[$][0] - Rt.v[$][0], Rt.o[$][1] - Rt.v[$][1]],
                      [Rt.i[0][0] - Rt.v[0][0], Rt.i[0][1] - Rt.v[0][1]]
                    )),
                    (rt.tLength += Ft.segmentLength),
                    rt.segments.push(Ft),
                    (xt += Ft.segmentLength)),
                  (this._pathData.pi = rt);
              }
              if (
                ((rt = this._pathData.pi),
                (st = this._pathData.f.v),
                (ot = 0),
                (lt = 1),
                (ct = 0),
                (it = !0),
                (ft = rt.segments),
                st < 0 && Mt.v.c)
              )
                for (
                  rt.tLength < Math.abs(st) &&
                    (st = -Math.abs(st) % rt.tLength),
                    ot = ft.length - 1,
                    pt = ft[ot].points,
                    lt = pt.length - 1;
                  st < 0;

                )
                  (st += pt[lt].partialLength),
                    (lt -= 1),
                    lt < 0 &&
                      ((ot -= 1), (pt = ft[ot].points), (lt = pt.length - 1));
              (pt = ft[ot].points),
                (ut = pt[lt - 1]),
                (at = pt[lt]),
                (gt = at.partialLength);
            }
            (_e = et.length), (b = 0), (j = 0);
            var Ot = s.finalSize * 1.2 * 0.714,
              Lt = !0,
              Et,
              bt,
              mt,
              vt,
              Ct;
            vt = a.length;
            var Tt,
              Dt = -1,
              Wt,
              Pt,
              Jt,
              Gt = st,
              en = ot,
              _n = lt,
              Tn = -1,
              fn,
              pn,
              Bt,
              qt,
              $t,
              yn,
              nn,
              Pn,
              xn = "",
              An = this.defaultPropsArray,
              kt;
            if (s.j === 2 || s.j === 1) {
              var wt = 0,
                Kt = 0,
                on = s.j === 2 ? -0.5 : -1,
                sn = 0,
                cn = !0;
              for ($ = 0; $ < _e; $ += 1)
                if (et[$].n) {
                  for (wt && (wt += Kt); sn < $; )
                    (et[sn].animatorJustifyOffset = wt), (sn += 1);
                  (wt = 0), (cn = !0);
                } else {
                  for (mt = 0; mt < vt; mt += 1)
                    (Et = a[mt].a),
                      Et.t.propType &&
                        (cn && s.j === 2 && (Kt += Et.t.v * on),
                        (bt = a[mt].s),
                        (Tt = bt.getMult(
                          et[$].anIndexes[mt],
                          c.a[mt].s.totalChars
                        )),
                        Tt.length
                          ? (wt += Et.t.v * Tt[0] * on)
                          : (wt += Et.t.v * Tt * on));
                  cn = !1;
                }
              for (wt && (wt += Kt); sn < $; )
                (et[sn].animatorJustifyOffset = wt), (sn += 1);
            }
            for ($ = 0; $ < _e; $ += 1) {
              if ((d.reset(), (fn = 1), et[$].n))
                (b = 0),
                  (j += s.yOffset),
                  (j += Lt ? 1 : 0),
                  (st = Gt),
                  (Lt = !1),
                  this._hasMaskedPath &&
                    ((ot = en),
                    (lt = _n),
                    (pt = ft[ot].points),
                    (ut = pt[lt - 1]),
                    (at = pt[lt]),
                    (gt = at.partialLength),
                    (ct = 0)),
                  (xn = ""),
                  (Pn = ""),
                  (yn = ""),
                  (kt = ""),
                  (An = this.defaultPropsArray);
              else {
                if (this._hasMaskedPath) {
                  if (Tn !== et[$].line) {
                    switch (s.j) {
                      case 1:
                        st += xt - s.lineWidths[et[$].line];
                        break;
                      case 2:
                        st += (xt - s.lineWidths[et[$].line]) / 2;
                        break;
                    }
                    Tn = et[$].line;
                  }
                  Dt !== et[$].ind &&
                    (et[Dt] && (st += et[Dt].extra),
                    (st += et[$].an / 2),
                    (Dt = et[$].ind)),
                    (st += o[0] * et[$].an * 0.005);
                  var bn = 0;
                  for (mt = 0; mt < vt; mt += 1)
                    (Et = a[mt].a),
                      Et.p.propType &&
                        ((bt = a[mt].s),
                        (Tt = bt.getMult(
                          et[$].anIndexes[mt],
                          c.a[mt].s.totalChars
                        )),
                        Tt.length
                          ? (bn += Et.p.v[0] * Tt[0])
                          : (bn += Et.p.v[0] * Tt)),
                      Et.a.propType &&
                        ((bt = a[mt].s),
                        (Tt = bt.getMult(
                          et[$].anIndexes[mt],
                          c.a[mt].s.totalChars
                        )),
                        Tt.length
                          ? (bn += Et.a.v[0] * Tt[0])
                          : (bn += Et.a.v[0] * Tt));
                  for (
                    it = !0,
                      this._pathData.a.v &&
                        ((st =
                          et[0].an * 0.5 +
                          ((xt -
                            this._pathData.f.v -
                            et[0].an * 0.5 -
                            et[et.length - 1].an * 0.5) *
                            Dt) /
                            (_e - 1)),
                        (st += this._pathData.f.v));
                    it;

                  )
                    ct + gt >= st + bn || !pt
                      ? ((_t = (st + bn - ct) / at.partialLength),
                        (Pt = ut.point[0] + (at.point[0] - ut.point[0]) * _t),
                        (Jt = ut.point[1] + (at.point[1] - ut.point[1]) * _t),
                        d.translate(
                          -o[0] * et[$].an * 0.005,
                          -(o[1] * Ot) * 0.01
                        ),
                        (it = !1))
                      : pt &&
                        ((ct += at.partialLength),
                        (lt += 1),
                        lt >= pt.length &&
                          ((lt = 0),
                          (ot += 1),
                          ft[ot]
                            ? (pt = ft[ot].points)
                            : Mt.v.c
                            ? ((lt = 0), (ot = 0), (pt = ft[ot].points))
                            : ((ct -= at.partialLength), (pt = null))),
                        pt &&
                          ((ut = at), (at = pt[lt]), (gt = at.partialLength)));
                  (Wt = et[$].an / 2 - et[$].add), d.translate(-Wt, 0, 0);
                } else
                  (Wt = et[$].an / 2 - et[$].add),
                    d.translate(-Wt, 0, 0),
                    d.translate(-o[0] * et[$].an * 0.005, -o[1] * Ot * 0.01, 0);
                for (mt = 0; mt < vt; mt += 1)
                  (Et = a[mt].a),
                    Et.t.propType &&
                      ((bt = a[mt].s),
                      (Tt = bt.getMult(
                        et[$].anIndexes[mt],
                        c.a[mt].s.totalChars
                      )),
                      (b !== 0 || s.j !== 0) &&
                        (this._hasMaskedPath
                          ? Tt.length
                            ? (st += Et.t.v * Tt[0])
                            : (st += Et.t.v * Tt)
                          : Tt.length
                          ? (b += Et.t.v * Tt[0])
                          : (b += Et.t.v * Tt)));
                for (
                  s.strokeWidthAnim && (Bt = s.sw || 0),
                    s.strokeColorAnim &&
                      (s.sc
                        ? (pn = [s.sc[0], s.sc[1], s.sc[2]])
                        : (pn = [0, 0, 0])),
                    s.fillColorAnim &&
                      s.fc &&
                      (qt = [s.fc[0], s.fc[1], s.fc[2]]),
                    mt = 0;
                  mt < vt;
                  mt += 1
                )
                  (Et = a[mt].a),
                    Et.a.propType &&
                      ((bt = a[mt].s),
                      (Tt = bt.getMult(
                        et[$].anIndexes[mt],
                        c.a[mt].s.totalChars
                      )),
                      Tt.length
                        ? d.translate(
                            -Et.a.v[0] * Tt[0],
                            -Et.a.v[1] * Tt[1],
                            Et.a.v[2] * Tt[2]
                          )
                        : d.translate(
                            -Et.a.v[0] * Tt,
                            -Et.a.v[1] * Tt,
                            Et.a.v[2] * Tt
                          ));
                for (mt = 0; mt < vt; mt += 1)
                  (Et = a[mt].a),
                    Et.s.propType &&
                      ((bt = a[mt].s),
                      (Tt = bt.getMult(
                        et[$].anIndexes[mt],
                        c.a[mt].s.totalChars
                      )),
                      Tt.length
                        ? d.scale(
                            1 + (Et.s.v[0] - 1) * Tt[0],
                            1 + (Et.s.v[1] - 1) * Tt[1],
                            1
                          )
                        : d.scale(
                            1 + (Et.s.v[0] - 1) * Tt,
                            1 + (Et.s.v[1] - 1) * Tt,
                            1
                          ));
                for (mt = 0; mt < vt; mt += 1) {
                  if (
                    ((Et = a[mt].a),
                    (bt = a[mt].s),
                    (Tt = bt.getMult(
                      et[$].anIndexes[mt],
                      c.a[mt].s.totalChars
                    )),
                    Et.sk.propType &&
                      (Tt.length
                        ? d.skewFromAxis(-Et.sk.v * Tt[0], Et.sa.v * Tt[1])
                        : d.skewFromAxis(-Et.sk.v * Tt, Et.sa.v * Tt)),
                    Et.r.propType &&
                      (Tt.length
                        ? d.rotateZ(-Et.r.v * Tt[2])
                        : d.rotateZ(-Et.r.v * Tt)),
                    Et.ry.propType &&
                      (Tt.length
                        ? d.rotateY(Et.ry.v * Tt[1])
                        : d.rotateY(Et.ry.v * Tt)),
                    Et.rx.propType &&
                      (Tt.length
                        ? d.rotateX(Et.rx.v * Tt[0])
                        : d.rotateX(Et.rx.v * Tt)),
                    Et.o.propType &&
                      (Tt.length
                        ? (fn += (Et.o.v * Tt[0] - fn) * Tt[0])
                        : (fn += (Et.o.v * Tt - fn) * Tt)),
                    s.strokeWidthAnim &&
                      Et.sw.propType &&
                      (Tt.length
                        ? (Bt += Et.sw.v * Tt[0])
                        : (Bt += Et.sw.v * Tt)),
                    s.strokeColorAnim && Et.sc.propType)
                  )
                    for ($t = 0; $t < 3; $t += 1)
                      Tt.length
                        ? (pn[$t] += (Et.sc.v[$t] - pn[$t]) * Tt[0])
                        : (pn[$t] += (Et.sc.v[$t] - pn[$t]) * Tt);
                  if (s.fillColorAnim && s.fc) {
                    if (Et.fc.propType)
                      for ($t = 0; $t < 3; $t += 1)
                        Tt.length
                          ? (qt[$t] += (Et.fc.v[$t] - qt[$t]) * Tt[0])
                          : (qt[$t] += (Et.fc.v[$t] - qt[$t]) * Tt);
                    Et.fh.propType &&
                      (Tt.length
                        ? (qt = addHueToRGB(qt, Et.fh.v * Tt[0]))
                        : (qt = addHueToRGB(qt, Et.fh.v * Tt))),
                      Et.fs.propType &&
                        (Tt.length
                          ? (qt = addSaturationToRGB(qt, Et.fs.v * Tt[0]))
                          : (qt = addSaturationToRGB(qt, Et.fs.v * Tt))),
                      Et.fb.propType &&
                        (Tt.length
                          ? (qt = addBrightnessToRGB(qt, Et.fb.v * Tt[0]))
                          : (qt = addBrightnessToRGB(qt, Et.fb.v * Tt)));
                  }
                }
                for (mt = 0; mt < vt; mt += 1)
                  (Et = a[mt].a),
                    Et.p.propType &&
                      ((bt = a[mt].s),
                      (Tt = bt.getMult(
                        et[$].anIndexes[mt],
                        c.a[mt].s.totalChars
                      )),
                      this._hasMaskedPath
                        ? Tt.length
                          ? d.translate(
                              0,
                              Et.p.v[1] * Tt[0],
                              -Et.p.v[2] * Tt[1]
                            )
                          : d.translate(0, Et.p.v[1] * Tt, -Et.p.v[2] * Tt)
                        : Tt.length
                        ? d.translate(
                            Et.p.v[0] * Tt[0],
                            Et.p.v[1] * Tt[1],
                            -Et.p.v[2] * Tt[2]
                          )
                        : d.translate(
                            Et.p.v[0] * Tt,
                            Et.p.v[1] * Tt,
                            -Et.p.v[2] * Tt
                          ));
                if (
                  (s.strokeWidthAnim && (yn = Bt < 0 ? 0 : Bt),
                  s.strokeColorAnim &&
                    (nn =
                      "rgb(" +
                      Math.round(pn[0] * 255) +
                      "," +
                      Math.round(pn[1] * 255) +
                      "," +
                      Math.round(pn[2] * 255) +
                      ")"),
                  s.fillColorAnim &&
                    s.fc &&
                    (Pn =
                      "rgb(" +
                      Math.round(qt[0] * 255) +
                      "," +
                      Math.round(qt[1] * 255) +
                      "," +
                      Math.round(qt[2] * 255) +
                      ")"),
                  this._hasMaskedPath)
                ) {
                  if (
                    (d.translate(0, -s.ls),
                    d.translate(0, o[1] * Ot * 0.01 + j, 0),
                    this._pathData.p.v)
                  ) {
                    St =
                      (at.point[1] - ut.point[1]) / (at.point[0] - ut.point[0]);
                    var vn = (Math.atan(St) * 180) / Math.PI;
                    at.point[0] < ut.point[0] && (vn += 180),
                      d.rotate((-vn * Math.PI) / 180);
                  }
                  d.translate(Pt, Jt, 0),
                    (st -= o[0] * et[$].an * 0.005),
                    et[$ + 1] &&
                      Dt !== et[$ + 1].ind &&
                      ((st += et[$].an / 2),
                      (st += s.tr * 0.001 * s.finalSize));
                } else {
                  switch (
                    (d.translate(b, j, 0),
                    s.ps && d.translate(s.ps[0], s.ps[1] + s.ascent, 0),
                    s.j)
                  ) {
                    case 1:
                      d.translate(
                        et[$].animatorJustifyOffset +
                          s.justifyOffset +
                          (s.boxWidth - s.lineWidths[et[$].line]),
                        0,
                        0
                      );
                      break;
                    case 2:
                      d.translate(
                        et[$].animatorJustifyOffset +
                          s.justifyOffset +
                          (s.boxWidth - s.lineWidths[et[$].line]) / 2,
                        0,
                        0
                      );
                      break;
                  }
                  d.translate(0, -s.ls),
                    d.translate(Wt, 0, 0),
                    d.translate(o[0] * et[$].an * 0.005, o[1] * Ot * 0.01, 0),
                    (b += et[$].l + s.tr * 0.001 * s.finalSize);
                }
                g === "html"
                  ? (xn = d.toCSS())
                  : g === "svg"
                  ? (xn = d.to2dCSS())
                  : (An = [
                      d.props[0],
                      d.props[1],
                      d.props[2],
                      d.props[3],
                      d.props[4],
                      d.props[5],
                      d.props[6],
                      d.props[7],
                      d.props[8],
                      d.props[9],
                      d.props[10],
                      d.props[11],
                      d.props[12],
                      d.props[13],
                      d.props[14],
                      d.props[15],
                    ]),
                  (kt = fn);
              }
              _ <= $
                ? ((Ct = new LetterProps(kt, yn, nn, Pn, xn, An)),
                  this.renderedLetters.push(Ct),
                  (_ += 1),
                  (this.lettersChangedFlag = !0))
                : ((Ct = this.renderedLetters[$]),
                  (this.lettersChangedFlag =
                    Ct.update(kt, yn, nn, Pn, xn, An) ||
                    this.lettersChangedFlag));
            }
          }
        }),
        (TextAnimatorProperty.prototype.getValue = function () {
          this._elem.globalData.frameId !== this._frameId &&
            ((this._frameId = this._elem.globalData.frameId),
            this.iterateDynamicProperties());
        }),
        (TextAnimatorProperty.prototype.mHelper = new Matrix()),
        (TextAnimatorProperty.prototype.defaultPropsArray = []),
        extendPrototype([DynamicPropertyContainer], TextAnimatorProperty);
      function ITextElement() {}
      (ITextElement.prototype.initElement = function (s, e, o) {
        (this.lettersChangedFlag = !0),
          this.initFrame(),
          this.initBaseData(s, e, o),
          (this.textProperty = new TextProperty(
            this,
            s.t,
            this.dynamicProperties
          )),
          (this.textAnimator = new TextAnimatorProperty(
            s.t,
            this.renderType,
            this
          )),
          this.initTransform(s, e, o),
          this.initHierarchy(),
          this.initRenderable(),
          this.initRendererElement(),
          this.createContainerElements(),
          this.createRenderableComponents(),
          this.createContent(),
          this.hide(),
          this.textAnimator.searchProperties(this.dynamicProperties);
      }),
        (ITextElement.prototype.prepareFrame = function (s) {
          (this._mdf = !1),
            this.prepareRenderableFrame(s),
            this.prepareProperties(s, this.isInRange);
        }),
        (ITextElement.prototype.createPathShape = function (s, e) {
          var o,
            a = e.length,
            c,
            d = "";
          for (o = 0; o < a; o += 1)
            e[o].ty === "sh" &&
              ((c = e[o].ks.k), (d += buildShapeString(c, c.i.length, !0, s)));
          return d;
        }),
        (ITextElement.prototype.updateDocumentData = function (s, e) {
          this.textProperty.updateDocumentData(s, e);
        }),
        (ITextElement.prototype.canResizeFont = function (s) {
          this.textProperty.canResizeFont(s);
        }),
        (ITextElement.prototype.setMinimumFontSize = function (s) {
          this.textProperty.setMinimumFontSize(s);
        }),
        (ITextElement.prototype.applyTextPropertiesToMatrix = function (
          s,
          e,
          o,
          a,
          c
        ) {
          switch (
            (s.ps && e.translate(s.ps[0], s.ps[1] + s.ascent, 0),
            e.translate(0, -s.ls, 0),
            s.j)
          ) {
            case 1:
              e.translate(
                s.justifyOffset + (s.boxWidth - s.lineWidths[o]),
                0,
                0
              );
              break;
            case 2:
              e.translate(
                s.justifyOffset + (s.boxWidth - s.lineWidths[o]) / 2,
                0,
                0
              );
              break;
          }
          e.translate(a, c, 0);
        }),
        (ITextElement.prototype.buildColor = function (s) {
          return (
            "rgb(" +
            Math.round(s[0] * 255) +
            "," +
            Math.round(s[1] * 255) +
            "," +
            Math.round(s[2] * 255) +
            ")"
          );
        }),
        (ITextElement.prototype.emptyProp = new LetterProps()),
        (ITextElement.prototype.destroy = function () {}),
        (ITextElement.prototype.validateText = function () {
          (this.textProperty._mdf || this.textProperty._isFirstFrame) &&
            (this.buildNewText(),
            (this.textProperty._isFirstFrame = !1),
            (this.textProperty._mdf = !1));
        });
      var emptyShapeData = { shapes: [] };
      function SVGTextLottieElement(s, e, o) {
        (this.textSpans = []),
          (this.renderType = "svg"),
          this.initElement(s, e, o);
      }
      extendPrototype(
        [
          BaseElement,
          TransformElement,
          SVGBaseElement,
          HierarchyElement,
          FrameElement,
          RenderableDOMElement,
          ITextElement,
        ],
        SVGTextLottieElement
      ),
        (SVGTextLottieElement.prototype.createContent = function () {
          this.data.singleShape &&
            !this.globalData.fontManager.chars &&
            (this.textContainer = createNS("text"));
        }),
        (SVGTextLottieElement.prototype.buildTextContents = function (s) {
          for (var e = 0, o = s.length, a = [], c = ""; e < o; )
            s[e] === "\r" || s[e] === "" ? (a.push(c), (c = "")) : (c += s[e]),
              (e += 1);
          return a.push(c), a;
        }),
        (SVGTextLottieElement.prototype.buildShapeData = function (s, e) {
          if (s.shapes && s.shapes.length) {
            var o = s.shapes[0];
            if (o.it) {
              var a = o.it[o.it.length - 1];
              a.s && ((a.s.k[0] = e), (a.s.k[1] = e));
            }
          }
          return s;
        }),
        (SVGTextLottieElement.prototype.buildNewText = function () {
          this.addDynamicProperty(this);
          var s,
            e,
            o = this.textProperty.currentData;
          (this.renderedLetters = createSizedArray(o ? o.l.length : 0)),
            o.fc
              ? this.layerElement.setAttribute("fill", this.buildColor(o.fc))
              : this.layerElement.setAttribute("fill", "rgba(0,0,0,0)"),
            o.sc &&
              (this.layerElement.setAttribute("stroke", this.buildColor(o.sc)),
              this.layerElement.setAttribute("stroke-width", o.sw)),
            this.layerElement.setAttribute("font-size", o.finalSize);
          var a = this.globalData.fontManager.getFontByName(o.f);
          if (a.fClass) this.layerElement.setAttribute("class", a.fClass);
          else {
            this.layerElement.setAttribute("font-family", a.fFamily);
            var c = o.fWeight,
              d = o.fStyle;
            this.layerElement.setAttribute("font-style", d),
              this.layerElement.setAttribute("font-weight", c);
          }
          this.layerElement.setAttribute("aria-label", o.t);
          var g = o.l || [],
            _ = !!this.globalData.fontManager.chars;
          e = g.length;
          var b,
            j = this.mHelper,
            $ = "",
            _e = this.data.singleShape,
            et = 0,
            rt = 0,
            st = !0,
            at = o.tr * 0.001 * o.finalSize;
          if (_e && !_ && !o.sz) {
            var ct = this.textContainer,
              it = "start";
            switch (o.j) {
              case 1:
                it = "end";
                break;
              case 2:
                it = "middle";
                break;
              default:
                it = "start";
                break;
            }
            ct.setAttribute("text-anchor", it),
              ct.setAttribute("letter-spacing", at);
            var lt = this.buildTextContents(o.finalText);
            for (
              e = lt.length, rt = o.ps ? o.ps[1] + o.ascent : 0, s = 0;
              s < e;
              s += 1
            )
              (b = this.textSpans[s].span || createNS("tspan")),
                (b.textContent = lt[s]),
                b.setAttribute("x", 0),
                b.setAttribute("y", rt),
                (b.style.display = "inherit"),
                ct.appendChild(b),
                this.textSpans[s] ||
                  (this.textSpans[s] = { span: null, glyph: null }),
                (this.textSpans[s].span = b),
                (rt += o.finalLineHeight);
            this.layerElement.appendChild(ct);
          } else {
            var ot = this.textSpans.length,
              ut;
            for (s = 0; s < e; s += 1) {
              if (
                (this.textSpans[s] ||
                  (this.textSpans[s] = {
                    span: null,
                    childSpan: null,
                    glyph: null,
                  }),
                !_ || !_e || s === 0)
              ) {
                if (
                  ((b =
                    ot > s
                      ? this.textSpans[s].span
                      : createNS(_ ? "g" : "text")),
                  ot <= s)
                ) {
                  if (
                    (b.setAttribute("stroke-linecap", "butt"),
                    b.setAttribute("stroke-linejoin", "round"),
                    b.setAttribute("stroke-miterlimit", "4"),
                    (this.textSpans[s].span = b),
                    _)
                  ) {
                    var pt = createNS("g");
                    b.appendChild(pt), (this.textSpans[s].childSpan = pt);
                  }
                  (this.textSpans[s].span = b),
                    this.layerElement.appendChild(b);
                }
                b.style.display = "inherit";
              }
              if (
                (j.reset(),
                _e &&
                  (g[s].n &&
                    ((et = -at),
                    (rt += o.yOffset),
                    (rt += st ? 1 : 0),
                    (st = !1)),
                  this.applyTextPropertiesToMatrix(o, j, g[s].line, et, rt),
                  (et += g[s].l || 0),
                  (et += at)),
                _)
              ) {
                ut = this.globalData.fontManager.getCharData(
                  o.finalText[s],
                  a.fStyle,
                  this.globalData.fontManager.getFontByName(o.f).fFamily
                );
                var ft;
                if (ut.t === 1)
                  ft = new SVGCompElement(ut.data, this.globalData, this);
                else {
                  var gt = emptyShapeData;
                  ut.data &&
                    ut.data.shapes &&
                    (gt = this.buildShapeData(ut.data, o.finalSize)),
                    (ft = new SVGShapeElement(gt, this.globalData, this));
                }
                if (this.textSpans[s].glyph) {
                  var xt = this.textSpans[s].glyph;
                  this.textSpans[s].childSpan.removeChild(xt.layerElement),
                    xt.destroy();
                }
                (this.textSpans[s].glyph = ft),
                  (ft._debug = !0),
                  ft.prepareFrame(0),
                  ft.renderFrame(),
                  this.textSpans[s].childSpan.appendChild(ft.layerElement),
                  ut.t === 1 &&
                    this.textSpans[s].childSpan.setAttribute(
                      "transform",
                      "scale(" +
                        o.finalSize / 100 +
                        "," +
                        o.finalSize / 100 +
                        ")"
                    );
              } else
                _e &&
                  b.setAttribute(
                    "transform",
                    "translate(" + j.props[12] + "," + j.props[13] + ")"
                  ),
                  (b.textContent = g[s].val),
                  b.setAttributeNS(
                    "http://www.w3.org/XML/1998/namespace",
                    "xml:space",
                    "preserve"
                  );
            }
            _e && b && b.setAttribute("d", $);
          }
          for (; s < this.textSpans.length; )
            (this.textSpans[s].span.style.display = "none"), (s += 1);
          this._sizeChanged = !0;
        }),
        (SVGTextLottieElement.prototype.sourceRectAtTime = function () {
          if (
            (this.prepareFrame(this.comp.renderedFrame - this.data.st),
            this.renderInnerContent(),
            this._sizeChanged)
          ) {
            this._sizeChanged = !1;
            var s = this.layerElement.getBBox();
            this.bbox = {
              top: s.y,
              left: s.x,
              width: s.width,
              height: s.height,
            };
          }
          return this.bbox;
        }),
        (SVGTextLottieElement.prototype.getValue = function () {
          var s,
            e = this.textSpans.length,
            o;
          for (
            this.renderedFrame = this.comp.renderedFrame, s = 0;
            s < e;
            s += 1
          )
            (o = this.textSpans[s].glyph),
              o &&
                (o.prepareFrame(this.comp.renderedFrame - this.data.st),
                o._mdf && (this._mdf = !0));
        }),
        (SVGTextLottieElement.prototype.renderInnerContent = function () {
          if (
            (this.validateText(),
            (!this.data.singleShape || this._mdf) &&
              (this.textAnimator.getMeasures(
                this.textProperty.currentData,
                this.lettersChangedFlag
              ),
              this.lettersChangedFlag || this.textAnimator.lettersChangedFlag))
          ) {
            this._sizeChanged = !0;
            var s,
              e,
              o = this.textAnimator.renderedLetters,
              a = this.textProperty.currentData.l;
            e = a.length;
            var c, d, g;
            for (s = 0; s < e; s += 1)
              a[s].n ||
                ((c = o[s]),
                (d = this.textSpans[s].span),
                (g = this.textSpans[s].glyph),
                g && g.renderFrame(),
                c._mdf.m && d.setAttribute("transform", c.m),
                c._mdf.o && d.setAttribute("opacity", c.o),
                c._mdf.sw && d.setAttribute("stroke-width", c.sw),
                c._mdf.sc && d.setAttribute("stroke", c.sc),
                c._mdf.fc && d.setAttribute("fill", c.fc));
          }
        });
      function ISolidElement(s, e, o) {
        this.initElement(s, e, o);
      }
      extendPrototype([IImageElement], ISolidElement),
        (ISolidElement.prototype.createContent = function () {
          var s = createNS("rect");
          s.setAttribute("width", this.data.sw),
            s.setAttribute("height", this.data.sh),
            s.setAttribute("fill", this.data.sc),
            this.layerElement.appendChild(s);
        });
      function NullElement(s, e, o) {
        this.initFrame(),
          this.initBaseData(s, e, o),
          this.initFrame(),
          this.initTransform(s, e, o),
          this.initHierarchy();
      }
      (NullElement.prototype.prepareFrame = function (s) {
        this.prepareProperties(s, !0);
      }),
        (NullElement.prototype.renderFrame = function () {}),
        (NullElement.prototype.getBaseElement = function () {
          return null;
        }),
        (NullElement.prototype.destroy = function () {}),
        (NullElement.prototype.sourceRectAtTime = function () {}),
        (NullElement.prototype.hide = function () {}),
        extendPrototype(
          [BaseElement, TransformElement, HierarchyElement, FrameElement],
          NullElement
        );
      function SVGRendererBase() {}
      extendPrototype([BaseRenderer], SVGRendererBase),
        (SVGRendererBase.prototype.createNull = function (s) {
          return new NullElement(s, this.globalData, this);
        }),
        (SVGRendererBase.prototype.createShape = function (s) {
          return new SVGShapeElement(s, this.globalData, this);
        }),
        (SVGRendererBase.prototype.createText = function (s) {
          return new SVGTextLottieElement(s, this.globalData, this);
        }),
        (SVGRendererBase.prototype.createImage = function (s) {
          return new IImageElement(s, this.globalData, this);
        }),
        (SVGRendererBase.prototype.createSolid = function (s) {
          return new ISolidElement(s, this.globalData, this);
        }),
        (SVGRendererBase.prototype.configAnimation = function (s) {
          this.svgElement.setAttribute("xmlns", "http://www.w3.org/2000/svg"),
            this.svgElement.setAttribute(
              "xmlns:xlink",
              "http://www.w3.org/1999/xlink"
            ),
            this.renderConfig.viewBoxSize
              ? this.svgElement.setAttribute(
                  "viewBox",
                  this.renderConfig.viewBoxSize
                )
              : this.svgElement.setAttribute(
                  "viewBox",
                  "0 0 " + s.w + " " + s.h
                ),
            this.renderConfig.viewBoxOnly ||
              (this.svgElement.setAttribute("width", s.w),
              this.svgElement.setAttribute("height", s.h),
              (this.svgElement.style.width = "100%"),
              (this.svgElement.style.height = "100%"),
              (this.svgElement.style.transform = "translate3d(0,0,0)"),
              (this.svgElement.style.contentVisibility =
                this.renderConfig.contentVisibility)),
            this.renderConfig.width &&
              this.svgElement.setAttribute("width", this.renderConfig.width),
            this.renderConfig.height &&
              this.svgElement.setAttribute("height", this.renderConfig.height),
            this.renderConfig.className &&
              this.svgElement.setAttribute(
                "class",
                this.renderConfig.className
              ),
            this.renderConfig.id &&
              this.svgElement.setAttribute("id", this.renderConfig.id),
            this.renderConfig.focusable !== void 0 &&
              this.svgElement.setAttribute(
                "focusable",
                this.renderConfig.focusable
              ),
            this.svgElement.setAttribute(
              "preserveAspectRatio",
              this.renderConfig.preserveAspectRatio
            ),
            this.animationItem.wrapper.appendChild(this.svgElement);
          var e = this.globalData.defs;
          this.setupGlobalData(s, e),
            (this.globalData.progressiveLoad =
              this.renderConfig.progressiveLoad),
            (this.data = s);
          var o = createNS("clipPath"),
            a = createNS("rect");
          a.setAttribute("width", s.w),
            a.setAttribute("height", s.h),
            a.setAttribute("x", 0),
            a.setAttribute("y", 0);
          var c = createElementID();
          o.setAttribute("id", c),
            o.appendChild(a),
            this.layerElement.setAttribute(
              "clip-path",
              "url(" + getLocationHref() + "#" + c + ")"
            ),
            e.appendChild(o),
            (this.layers = s.layers),
            (this.elements = createSizedArray(s.layers.length));
        }),
        (SVGRendererBase.prototype.destroy = function () {
          this.animationItem.wrapper &&
            (this.animationItem.wrapper.innerText = ""),
            (this.layerElement = null),
            (this.globalData.defs = null);
          var s,
            e = this.layers ? this.layers.length : 0;
          for (s = 0; s < e; s += 1)
            this.elements[s] &&
              this.elements[s].destroy &&
              this.elements[s].destroy();
          (this.elements.length = 0),
            (this.destroyed = !0),
            (this.animationItem = null);
        }),
        (SVGRendererBase.prototype.updateContainerSize = function () {}),
        (SVGRendererBase.prototype.findIndexByInd = function (s) {
          var e = 0,
            o = this.layers.length;
          for (e = 0; e < o; e += 1) if (this.layers[e].ind === s) return e;
          return -1;
        }),
        (SVGRendererBase.prototype.buildItem = function (s) {
          var e = this.elements;
          if (!(e[s] || this.layers[s].ty === 99)) {
            e[s] = !0;
            var o = this.createItem(this.layers[s]);
            if (
              ((e[s] = o),
              getExpressionsPlugin() &&
                (this.layers[s].ty === 0 &&
                  this.globalData.projectInterface.registerComposition(o),
                o.initExpressions()),
              this.appendElementInPos(o, s),
              this.layers[s].tt)
            ) {
              var a =
                "tp" in this.layers[s]
                  ? this.findIndexByInd(this.layers[s].tp)
                  : s - 1;
              if (a === -1) return;
              if (!this.elements[a] || this.elements[a] === !0)
                this.buildItem(a), this.addPendingElement(o);
              else {
                var c = e[a],
                  d = c.getMatte(this.layers[s].tt);
                o.setMatte(d);
              }
            }
          }
        }),
        (SVGRendererBase.prototype.checkPendingElements = function () {
          for (; this.pendingElements.length; ) {
            var s = this.pendingElements.pop();
            if ((s.checkParenting(), s.data.tt))
              for (var e = 0, o = this.elements.length; e < o; ) {
                if (this.elements[e] === s) {
                  var a =
                      "tp" in s.data ? this.findIndexByInd(s.data.tp) : e - 1,
                    c = this.elements[a],
                    d = c.getMatte(this.layers[e].tt);
                  s.setMatte(d);
                  break;
                }
                e += 1;
              }
          }
        }),
        (SVGRendererBase.prototype.renderFrame = function (s) {
          if (!(this.renderedFrame === s || this.destroyed)) {
            s === null ? (s = this.renderedFrame) : (this.renderedFrame = s),
              (this.globalData.frameNum = s),
              (this.globalData.frameId += 1),
              (this.globalData.projectInterface.currentFrame = s),
              (this.globalData._mdf = !1);
            var e,
              o = this.layers.length;
            for (
              this.completeLayers || this.checkLayers(s), e = o - 1;
              e >= 0;
              e -= 1
            )
              (this.completeLayers || this.elements[e]) &&
                this.elements[e].prepareFrame(s - this.layers[e].st);
            if (this.globalData._mdf)
              for (e = 0; e < o; e += 1)
                (this.completeLayers || this.elements[e]) &&
                  this.elements[e].renderFrame();
          }
        }),
        (SVGRendererBase.prototype.appendElementInPos = function (s, e) {
          var o = s.getBaseElement();
          if (o) {
            for (var a = 0, c; a < e; )
              this.elements[a] &&
                this.elements[a] !== !0 &&
                this.elements[a].getBaseElement() &&
                (c = this.elements[a].getBaseElement()),
                (a += 1);
            c
              ? this.layerElement.insertBefore(o, c)
              : this.layerElement.appendChild(o);
          }
        }),
        (SVGRendererBase.prototype.hide = function () {
          this.layerElement.style.display = "none";
        }),
        (SVGRendererBase.prototype.show = function () {
          this.layerElement.style.display = "block";
        });
      function ICompElement() {}
      extendPrototype(
        [
          BaseElement,
          TransformElement,
          HierarchyElement,
          FrameElement,
          RenderableDOMElement,
        ],
        ICompElement
      ),
        (ICompElement.prototype.initElement = function (s, e, o) {
          this.initFrame(),
            this.initBaseData(s, e, o),
            this.initTransform(s, e, o),
            this.initRenderable(),
            this.initHierarchy(),
            this.initRendererElement(),
            this.createContainerElements(),
            this.createRenderableComponents(),
            (this.data.xt || !e.progressiveLoad) && this.buildAllItems(),
            this.hide();
        }),
        (ICompElement.prototype.prepareFrame = function (s) {
          if (
            ((this._mdf = !1),
            this.prepareRenderableFrame(s),
            this.prepareProperties(s, this.isInRange),
            !(!this.isInRange && !this.data.xt))
          ) {
            if (this.tm._placeholder) this.renderedFrame = s / this.data.sr;
            else {
              var e = this.tm.v;
              e === this.data.op && (e = this.data.op - 1),
                (this.renderedFrame = e);
            }
            var o,
              a = this.elements.length;
            for (
              this.completeLayers || this.checkLayers(this.renderedFrame),
                o = a - 1;
              o >= 0;
              o -= 1
            )
              (this.completeLayers || this.elements[o]) &&
                (this.elements[o].prepareFrame(
                  this.renderedFrame - this.layers[o].st
                ),
                this.elements[o]._mdf && (this._mdf = !0));
          }
        }),
        (ICompElement.prototype.renderInnerContent = function () {
          var s,
            e = this.layers.length;
          for (s = 0; s < e; s += 1)
            (this.completeLayers || this.elements[s]) &&
              this.elements[s].renderFrame();
        }),
        (ICompElement.prototype.setElements = function (s) {
          this.elements = s;
        }),
        (ICompElement.prototype.getElements = function () {
          return this.elements;
        }),
        (ICompElement.prototype.destroyElements = function () {
          var s,
            e = this.layers.length;
          for (s = 0; s < e; s += 1)
            this.elements[s] && this.elements[s].destroy();
        }),
        (ICompElement.prototype.destroy = function () {
          this.destroyElements(), this.destroyBaseElement();
        });
      function SVGCompElement(s, e, o) {
        (this.layers = s.layers),
          (this.supports3d = !0),
          (this.completeLayers = !1),
          (this.pendingElements = []),
          (this.elements = this.layers
            ? createSizedArray(this.layers.length)
            : []),
          this.initElement(s, e, o),
          (this.tm = s.tm
            ? PropertyFactory.getProp(this, s.tm, 0, e.frameRate, this)
            : { _placeholder: !0 });
      }
      extendPrototype(
        [SVGRendererBase, ICompElement, SVGBaseElement],
        SVGCompElement
      ),
        (SVGCompElement.prototype.createComp = function (s) {
          return new SVGCompElement(s, this.globalData, this);
        });
      function SVGRenderer(s, e) {
        (this.animationItem = s),
          (this.layers = null),
          (this.renderedFrame = -1),
          (this.svgElement = createNS("svg"));
        var o = "";
        if (e && e.title) {
          var a = createNS("title"),
            c = createElementID();
          a.setAttribute("id", c),
            (a.textContent = e.title),
            this.svgElement.appendChild(a),
            (o += c);
        }
        if (e && e.description) {
          var d = createNS("desc"),
            g = createElementID();
          d.setAttribute("id", g),
            (d.textContent = e.description),
            this.svgElement.appendChild(d),
            (o += " " + g);
        }
        o && this.svgElement.setAttribute("aria-labelledby", o);
        var _ = createNS("defs");
        this.svgElement.appendChild(_);
        var b = createNS("g");
        this.svgElement.appendChild(b),
          (this.layerElement = b),
          (this.renderConfig = {
            preserveAspectRatio:
              (e && e.preserveAspectRatio) || "xMidYMid meet",
            imagePreserveAspectRatio:
              (e && e.imagePreserveAspectRatio) || "xMidYMid slice",
            contentVisibility: (e && e.contentVisibility) || "visible",
            progressiveLoad: (e && e.progressiveLoad) || !1,
            hideOnTransparent: !(e && e.hideOnTransparent === !1),
            viewBoxOnly: (e && e.viewBoxOnly) || !1,
            viewBoxSize: (e && e.viewBoxSize) || !1,
            className: (e && e.className) || "",
            id: (e && e.id) || "",
            focusable: e && e.focusable,
            filterSize: {
              width: (e && e.filterSize && e.filterSize.width) || "100%",
              height: (e && e.filterSize && e.filterSize.height) || "100%",
              x: (e && e.filterSize && e.filterSize.x) || "0%",
              y: (e && e.filterSize && e.filterSize.y) || "0%",
            },
            width: e && e.width,
            height: e && e.height,
            runExpressions:
              !e || e.runExpressions === void 0 || e.runExpressions,
          }),
          (this.globalData = {
            _mdf: !1,
            frameNum: -1,
            defs: _,
            renderConfig: this.renderConfig,
          }),
          (this.elements = []),
          (this.pendingElements = []),
          (this.destroyed = !1),
          (this.rendererType = "svg");
      }
      extendPrototype([SVGRendererBase], SVGRenderer),
        (SVGRenderer.prototype.createComp = function (s) {
          return new SVGCompElement(s, this.globalData, this);
        });
      function ShapeTransformManager() {
        (this.sequences = {}),
          (this.sequenceList = []),
          (this.transform_key_count = 0);
      }
      ShapeTransformManager.prototype = {
        addTransformSequence: function (e) {
          var o,
            a = e.length,
            c = "_";
          for (o = 0; o < a; o += 1) c += e[o].transform.key + "_";
          var d = this.sequences[c];
          return (
            d ||
              ((d = {
                transforms: [].concat(e),
                finalTransform: new Matrix(),
                _mdf: !1,
              }),
              (this.sequences[c] = d),
              this.sequenceList.push(d)),
            d
          );
        },
        processSequence: function (e, o) {
          for (var a = 0, c = e.transforms.length, d = o; a < c && !o; ) {
            if (e.transforms[a].transform.mProps._mdf) {
              d = !0;
              break;
            }
            a += 1;
          }
          if (d)
            for (e.finalTransform.reset(), a = c - 1; a >= 0; a -= 1)
              e.finalTransform.multiply(e.transforms[a].transform.mProps.v);
          e._mdf = d;
        },
        processSequences: function (e) {
          var o,
            a = this.sequenceList.length;
          for (o = 0; o < a; o += 1)
            this.processSequence(this.sequenceList[o], e);
        },
        getNewKey: function () {
          return (
            (this.transform_key_count += 1), "_" + this.transform_key_count
          );
        },
      };
      var lumaLoader = function () {
        var e = "__lottie_element_luma_buffer",
          o = null,
          a = null,
          c = null;
        function d() {
          var b = createNS("svg"),
            j = createNS("filter"),
            $ = createNS("feColorMatrix");
          return (
            j.setAttribute("id", e),
            $.setAttribute("type", "matrix"),
            $.setAttribute("color-interpolation-filters", "sRGB"),
            $.setAttribute(
              "values",
              "0.3, 0.3, 0.3, 0, 0, 0.3, 0.3, 0.3, 0, 0, 0.3, 0.3, 0.3, 0, 0, 0.3, 0.3, 0.3, 0, 0"
            ),
            j.appendChild($),
            b.appendChild(j),
            b.setAttribute("id", e + "_svg"),
            featureSupport.svgLumaHidden && (b.style.display = "none"),
            b
          );
        }
        function g() {
          o ||
            ((c = d()),
            document.body.appendChild(c),
            (o = createTag("canvas")),
            (a = o.getContext("2d")),
            (a.filter = "url(#" + e + ")"),
            (a.fillStyle = "rgba(0,0,0,0)"),
            a.fillRect(0, 0, 1, 1));
        }
        function _(b) {
          return (
            o || g(),
            (o.width = b.width),
            (o.height = b.height),
            (a.filter = "url(#" + e + ")"),
            o
          );
        }
        return { load: g, get: _ };
      };
      function createCanvas(s, e) {
        if (featureSupport.offscreenCanvas) return new OffscreenCanvas(s, e);
        var o = createTag("canvas");
        return (o.width = s), (o.height = e), o;
      }
      var assetLoader = (function () {
          return {
            loadLumaCanvas: lumaLoader.load,
            getLumaCanvas: lumaLoader.get,
            createCanvas,
          };
        })(),
        registeredEffects = {};
      function CVEffects(s) {
        var e,
          o = s.data.ef ? s.data.ef.length : 0;
        this.filters = [];
        var a;
        for (e = 0; e < o; e += 1) {
          a = null;
          var c = s.data.ef[e].ty;
          if (registeredEffects[c]) {
            var d = registeredEffects[c].effect;
            a = new d(s.effectsManager.effectElements[e], s);
          }
          a && this.filters.push(a);
        }
        this.filters.length && s.addRenderableComponent(this);
      }
      (CVEffects.prototype.renderFrame = function (s) {
        var e,
          o = this.filters.length;
        for (e = 0; e < o; e += 1) this.filters[e].renderFrame(s);
      }),
        (CVEffects.prototype.getEffects = function (s) {
          var e,
            o = this.filters.length,
            a = [];
          for (e = 0; e < o; e += 1)
            this.filters[e].type === s && a.push(this.filters[e]);
          return a;
        });
      function registerEffect(s, e) {
        registeredEffects[s] = { effect: e };
      }
      function CVMaskElement(s, e) {
        (this.data = s),
          (this.element = e),
          (this.masksProperties = this.data.masksProperties || []),
          (this.viewData = createSizedArray(this.masksProperties.length));
        var o,
          a = this.masksProperties.length,
          c = !1;
        for (o = 0; o < a; o += 1)
          this.masksProperties[o].mode !== "n" && (c = !0),
            (this.viewData[o] = ShapePropertyFactory.getShapeProp(
              this.element,
              this.masksProperties[o],
              3
            ));
        (this.hasMasks = c), c && this.element.addRenderableComponent(this);
      }
      (CVMaskElement.prototype.renderFrame = function () {
        if (this.hasMasks) {
          var s = this.element.finalTransform.mat,
            e = this.element.canvasContext,
            o,
            a = this.masksProperties.length,
            c,
            d,
            g;
          for (e.beginPath(), o = 0; o < a; o += 1)
            if (this.masksProperties[o].mode !== "n") {
              this.masksProperties[o].inv &&
                (e.moveTo(0, 0),
                e.lineTo(this.element.globalData.compSize.w, 0),
                e.lineTo(
                  this.element.globalData.compSize.w,
                  this.element.globalData.compSize.h
                ),
                e.lineTo(0, this.element.globalData.compSize.h),
                e.lineTo(0, 0)),
                (g = this.viewData[o].v),
                (c = s.applyToPointArray(g.v[0][0], g.v[0][1], 0)),
                e.moveTo(c[0], c[1]);
              var _,
                b = g._length;
              for (_ = 1; _ < b; _ += 1)
                (d = s.applyToTriplePoints(g.o[_ - 1], g.i[_], g.v[_])),
                  e.bezierCurveTo(d[0], d[1], d[2], d[3], d[4], d[5]);
              (d = s.applyToTriplePoints(g.o[_ - 1], g.i[0], g.v[0])),
                e.bezierCurveTo(d[0], d[1], d[2], d[3], d[4], d[5]);
            }
          this.element.globalData.renderer.save(!0), e.clip();
        }
      }),
        (CVMaskElement.prototype.getMaskProperty =
          MaskElement.prototype.getMaskProperty),
        (CVMaskElement.prototype.destroy = function () {
          this.element = null;
        });
      function CVBaseElement() {}
      var operationsMap = {
        1: "source-in",
        2: "source-out",
        3: "source-in",
        4: "source-out",
      };
      (CVBaseElement.prototype = {
        createElements: function () {},
        initRendererElement: function () {},
        createContainerElements: function () {
          if (this.data.tt >= 1) {
            this.buffers = [];
            var e = this.globalData.canvasContext,
              o = assetLoader.createCanvas(e.canvas.width, e.canvas.height);
            this.buffers.push(o);
            var a = assetLoader.createCanvas(e.canvas.width, e.canvas.height);
            this.buffers.push(a),
              this.data.tt >= 3 &&
                !document._isProxy &&
                assetLoader.loadLumaCanvas();
          }
          (this.canvasContext = this.globalData.canvasContext),
            (this.transformCanvas = this.globalData.transformCanvas),
            (this.renderableEffectsManager = new CVEffects(this)),
            this.searchEffectTransforms();
        },
        createContent: function () {},
        setBlendMode: function () {
          var e = this.globalData;
          if (e.blendMode !== this.data.bm) {
            e.blendMode = this.data.bm;
            var o = getBlendMode(this.data.bm);
            e.canvasContext.globalCompositeOperation = o;
          }
        },
        createRenderableComponents: function () {
          (this.maskManager = new CVMaskElement(this.data, this)),
            (this.transformEffects = this.renderableEffectsManager.getEffects(
              effectTypes.TRANSFORM_EFFECT
            ));
        },
        hideElement: function () {
          !this.hidden &&
            (!this.isInRange || this.isTransparent) &&
            (this.hidden = !0);
        },
        showElement: function () {
          this.isInRange &&
            !this.isTransparent &&
            ((this.hidden = !1),
            (this._isFirstFrame = !0),
            (this.maskManager._isFirstFrame = !0));
        },
        clearCanvas: function (e) {
          e.clearRect(
            this.transformCanvas.tx,
            this.transformCanvas.ty,
            this.transformCanvas.w * this.transformCanvas.sx,
            this.transformCanvas.h * this.transformCanvas.sy
          );
        },
        prepareLayer: function () {
          if (this.data.tt >= 1) {
            var e = this.buffers[0],
              o = e.getContext("2d");
            this.clearCanvas(o),
              o.drawImage(this.canvasContext.canvas, 0, 0),
              (this.currentTransform = this.canvasContext.getTransform()),
              this.canvasContext.setTransform(1, 0, 0, 1, 0, 0),
              this.clearCanvas(this.canvasContext),
              this.canvasContext.setTransform(this.currentTransform);
          }
        },
        exitLayer: function () {
          if (this.data.tt >= 1) {
            var e = this.buffers[1],
              o = e.getContext("2d");
            this.clearCanvas(o),
              o.drawImage(this.canvasContext.canvas, 0, 0),
              this.canvasContext.setTransform(1, 0, 0, 1, 0, 0),
              this.clearCanvas(this.canvasContext),
              this.canvasContext.setTransform(this.currentTransform);
            var a = this.comp.getElementById(
              "tp" in this.data ? this.data.tp : this.data.ind - 1
            );
            if (
              (a.renderFrame(!0),
              this.canvasContext.setTransform(1, 0, 0, 1, 0, 0),
              this.data.tt >= 3 && !document._isProxy)
            ) {
              var c = assetLoader.getLumaCanvas(this.canvasContext.canvas),
                d = c.getContext("2d");
              d.drawImage(this.canvasContext.canvas, 0, 0),
                this.clearCanvas(this.canvasContext),
                this.canvasContext.drawImage(c, 0, 0);
            }
            (this.canvasContext.globalCompositeOperation =
              operationsMap[this.data.tt]),
              this.canvasContext.drawImage(e, 0, 0),
              (this.canvasContext.globalCompositeOperation =
                "destination-over"),
              this.canvasContext.drawImage(this.buffers[0], 0, 0),
              this.canvasContext.setTransform(this.currentTransform),
              (this.canvasContext.globalCompositeOperation = "source-over");
          }
        },
        renderFrame: function (e) {
          if (!(this.hidden || this.data.hd) && !(this.data.td === 1 && !e)) {
            this.renderTransform(),
              this.renderRenderable(),
              this.renderLocalTransform(),
              this.setBlendMode();
            var o = this.data.ty === 0;
            this.prepareLayer(),
              this.globalData.renderer.save(o),
              this.globalData.renderer.ctxTransform(
                this.finalTransform.localMat.props
              ),
              this.globalData.renderer.ctxOpacity(
                this.finalTransform.localOpacity
              ),
              this.renderInnerContent(),
              this.globalData.renderer.restore(o),
              this.exitLayer(),
              this.maskManager.hasMasks && this.globalData.renderer.restore(!0),
              this._isFirstFrame && (this._isFirstFrame = !1);
          }
        },
        destroy: function () {
          (this.canvasContext = null),
            (this.data = null),
            (this.globalData = null),
            this.maskManager.destroy();
        },
        mHelper: new Matrix(),
      }),
        (CVBaseElement.prototype.hide = CVBaseElement.prototype.hideElement),
        (CVBaseElement.prototype.show = CVBaseElement.prototype.showElement);
      function CVShapeData(s, e, o, a) {
        (this.styledShapes = []), (this.tr = [0, 0, 0, 0, 0, 0]);
        var c = 4;
        e.ty === "rc"
          ? (c = 5)
          : e.ty === "el"
          ? (c = 6)
          : e.ty === "sr" && (c = 7),
          (this.sh = ShapePropertyFactory.getShapeProp(s, e, c, s));
        var d,
          g = o.length,
          _;
        for (d = 0; d < g; d += 1)
          o[d].closed ||
            ((_ = {
              transforms: a.addTransformSequence(o[d].transforms),
              trNodes: [],
            }),
            this.styledShapes.push(_),
            o[d].elements.push(_));
      }
      CVShapeData.prototype.setAsAnimated =
        SVGShapeData.prototype.setAsAnimated;
      function CVShapeElement(s, e, o) {
        (this.shapes = []),
          (this.shapesData = s.shapes),
          (this.stylesList = []),
          (this.itemsData = []),
          (this.prevViewData = []),
          (this.shapeModifiers = []),
          (this.processedElements = []),
          (this.transformsManager = new ShapeTransformManager()),
          this.initElement(s, e, o);
      }
      extendPrototype(
        [
          BaseElement,
          TransformElement,
          CVBaseElement,
          IShapeElement,
          HierarchyElement,
          FrameElement,
          RenderableElement,
        ],
        CVShapeElement
      ),
        (CVShapeElement.prototype.initElement =
          RenderableDOMElement.prototype.initElement),
        (CVShapeElement.prototype.transformHelper = { opacity: 1, _opMdf: !1 }),
        (CVShapeElement.prototype.dashResetter = []),
        (CVShapeElement.prototype.createContent = function () {
          this.searchShapes(
            this.shapesData,
            this.itemsData,
            this.prevViewData,
            !0,
            []
          );
        }),
        (CVShapeElement.prototype.createStyleElement = function (s, e) {
          var o = {
              data: s,
              type: s.ty,
              preTransforms: this.transformsManager.addTransformSequence(e),
              transforms: [],
              elements: [],
              closed: s.hd === !0,
            },
            a = {};
          if (
            (s.ty === "fl" || s.ty === "st"
              ? ((a.c = PropertyFactory.getProp(this, s.c, 1, 255, this)),
                a.c.k ||
                  (o.co =
                    "rgb(" +
                    bmFloor(a.c.v[0]) +
                    "," +
                    bmFloor(a.c.v[1]) +
                    "," +
                    bmFloor(a.c.v[2]) +
                    ")"))
              : (s.ty === "gf" || s.ty === "gs") &&
                ((a.s = PropertyFactory.getProp(this, s.s, 1, null, this)),
                (a.e = PropertyFactory.getProp(this, s.e, 1, null, this)),
                (a.h = PropertyFactory.getProp(
                  this,
                  s.h || { k: 0 },
                  0,
                  0.01,
                  this
                )),
                (a.a = PropertyFactory.getProp(
                  this,
                  s.a || { k: 0 },
                  0,
                  degToRads,
                  this
                )),
                (a.g = new GradientProperty(this, s.g, this))),
            (a.o = PropertyFactory.getProp(this, s.o, 0, 0.01, this)),
            s.ty === "st" || s.ty === "gs")
          ) {
            if (
              ((o.lc = lineCapEnum[s.lc || 2]),
              (o.lj = lineJoinEnum[s.lj || 2]),
              s.lj == 1 && (o.ml = s.ml),
              (a.w = PropertyFactory.getProp(this, s.w, 0, null, this)),
              a.w.k || (o.wi = a.w.v),
              s.d)
            ) {
              var c = new DashProperty(this, s.d, "canvas", this);
              (a.d = c),
                a.d.k || ((o.da = a.d.dashArray), (o.do = a.d.dashoffset[0]));
            }
          } else o.r = s.r === 2 ? "evenodd" : "nonzero";
          return this.stylesList.push(o), (a.style = o), a;
        }),
        (CVShapeElement.prototype.createGroupElement = function () {
          var s = { it: [], prevViewData: [] };
          return s;
        }),
        (CVShapeElement.prototype.createTransformElement = function (s) {
          var e = {
            transform: {
              opacity: 1,
              _opMdf: !1,
              key: this.transformsManager.getNewKey(),
              op: PropertyFactory.getProp(this, s.o, 0, 0.01, this),
              mProps: TransformPropertyFactory.getTransformProperty(
                this,
                s,
                this
              ),
            },
          };
          return e;
        }),
        (CVShapeElement.prototype.createShapeElement = function (s) {
          var e = new CVShapeData(
            this,
            s,
            this.stylesList,
            this.transformsManager
          );
          return this.shapes.push(e), this.addShapeToModifiers(e), e;
        }),
        (CVShapeElement.prototype.reloadShapes = function () {
          this._isFirstFrame = !0;
          var s,
            e = this.itemsData.length;
          for (s = 0; s < e; s += 1) this.prevViewData[s] = this.itemsData[s];
          for (
            this.searchShapes(
              this.shapesData,
              this.itemsData,
              this.prevViewData,
              !0,
              []
            ),
              e = this.dynamicProperties.length,
              s = 0;
            s < e;
            s += 1
          )
            this.dynamicProperties[s].getValue();
          this.renderModifiers(),
            this.transformsManager.processSequences(this._isFirstFrame);
        }),
        (CVShapeElement.prototype.addTransformToStyleList = function (s) {
          var e,
            o = this.stylesList.length;
          for (e = 0; e < o; e += 1)
            this.stylesList[e].closed || this.stylesList[e].transforms.push(s);
        }),
        (CVShapeElement.prototype.removeTransformFromStyleList = function () {
          var s,
            e = this.stylesList.length;
          for (s = 0; s < e; s += 1)
            this.stylesList[s].closed || this.stylesList[s].transforms.pop();
        }),
        (CVShapeElement.prototype.closeStyles = function (s) {
          var e,
            o = s.length;
          for (e = 0; e < o; e += 1) s[e].closed = !0;
        }),
        (CVShapeElement.prototype.searchShapes = function (s, e, o, a, c) {
          var d,
            g = s.length - 1,
            _,
            b,
            j = [],
            $ = [],
            _e,
            et,
            rt,
            st = [].concat(c);
          for (d = g; d >= 0; d -= 1) {
            if (
              ((_e = this.searchProcessedElement(s[d])),
              _e ? (e[d] = o[_e - 1]) : (s[d]._shouldRender = a),
              s[d].ty === "fl" ||
                s[d].ty === "st" ||
                s[d].ty === "gf" ||
                s[d].ty === "gs")
            )
              _e
                ? (e[d].style.closed = !1)
                : (e[d] = this.createStyleElement(s[d], st)),
                j.push(e[d].style);
            else if (s[d].ty === "gr") {
              if (!_e) e[d] = this.createGroupElement(s[d]);
              else
                for (b = e[d].it.length, _ = 0; _ < b; _ += 1)
                  e[d].prevViewData[_] = e[d].it[_];
              this.searchShapes(s[d].it, e[d].it, e[d].prevViewData, a, st);
            } else
              s[d].ty === "tr"
                ? (_e ||
                    ((rt = this.createTransformElement(s[d])), (e[d] = rt)),
                  st.push(e[d]),
                  this.addTransformToStyleList(e[d]))
                : s[d].ty === "sh" ||
                  s[d].ty === "rc" ||
                  s[d].ty === "el" ||
                  s[d].ty === "sr"
                ? _e || (e[d] = this.createShapeElement(s[d]))
                : s[d].ty === "tm" ||
                  s[d].ty === "rd" ||
                  s[d].ty === "pb" ||
                  s[d].ty === "zz" ||
                  s[d].ty === "op"
                ? (_e
                    ? ((et = e[d]), (et.closed = !1))
                    : ((et = ShapeModifiers.getModifier(s[d].ty)),
                      et.init(this, s[d]),
                      (e[d] = et),
                      this.shapeModifiers.push(et)),
                  $.push(et))
                : s[d].ty === "rp" &&
                  (_e
                    ? ((et = e[d]), (et.closed = !0))
                    : ((et = ShapeModifiers.getModifier(s[d].ty)),
                      (e[d] = et),
                      et.init(this, s, d, e),
                      this.shapeModifiers.push(et),
                      (a = !1)),
                  $.push(et));
            this.addProcessedElement(s[d], d + 1);
          }
          for (
            this.removeTransformFromStyleList(),
              this.closeStyles(j),
              g = $.length,
              d = 0;
            d < g;
            d += 1
          )
            $[d].closed = !0;
        }),
        (CVShapeElement.prototype.renderInnerContent = function () {
          (this.transformHelper.opacity = 1),
            (this.transformHelper._opMdf = !1),
            this.renderModifiers(),
            this.transformsManager.processSequences(this._isFirstFrame),
            this.renderShape(
              this.transformHelper,
              this.shapesData,
              this.itemsData,
              !0
            );
        }),
        (CVShapeElement.prototype.renderShapeTransform = function (s, e) {
          (s._opMdf || e.op._mdf || this._isFirstFrame) &&
            ((e.opacity = s.opacity), (e.opacity *= e.op.v), (e._opMdf = !0));
        }),
        (CVShapeElement.prototype.drawLayer = function () {
          var s,
            e = this.stylesList.length,
            o,
            a,
            c,
            d,
            g,
            _,
            b = this.globalData.renderer,
            j = this.globalData.canvasContext,
            $,
            _e;
          for (s = 0; s < e; s += 1)
            if (
              ((_e = this.stylesList[s]),
              ($ = _e.type),
              !(
                (($ === "st" || $ === "gs") && _e.wi === 0) ||
                !_e.data._shouldRender ||
                _e.coOp === 0 ||
                this.globalData.currentGlobalAlpha === 0
              ))
            ) {
              for (
                b.save(),
                  g = _e.elements,
                  $ === "st" || $ === "gs"
                    ? (b.ctxStrokeStyle($ === "st" ? _e.co : _e.grd),
                      b.ctxLineWidth(_e.wi),
                      b.ctxLineCap(_e.lc),
                      b.ctxLineJoin(_e.lj),
                      b.ctxMiterLimit(_e.ml || 0))
                    : b.ctxFillStyle($ === "fl" ? _e.co : _e.grd),
                  b.ctxOpacity(_e.coOp),
                  $ !== "st" && $ !== "gs" && j.beginPath(),
                  b.ctxTransform(_e.preTransforms.finalTransform.props),
                  a = g.length,
                  o = 0;
                o < a;
                o += 1
              ) {
                for (
                  ($ === "st" || $ === "gs") &&
                    (j.beginPath(),
                    _e.da &&
                      (j.setLineDash(_e.da), (j.lineDashOffset = _e.do))),
                    _ = g[o].trNodes,
                    d = _.length,
                    c = 0;
                  c < d;
                  c += 1
                )
                  _[c].t === "m"
                    ? j.moveTo(_[c].p[0], _[c].p[1])
                    : _[c].t === "c"
                    ? j.bezierCurveTo(
                        _[c].pts[0],
                        _[c].pts[1],
                        _[c].pts[2],
                        _[c].pts[3],
                        _[c].pts[4],
                        _[c].pts[5]
                      )
                    : j.closePath();
                ($ === "st" || $ === "gs") &&
                  (b.ctxStroke(), _e.da && j.setLineDash(this.dashResetter));
              }
              $ !== "st" &&
                $ !== "gs" &&
                this.globalData.renderer.ctxFill(_e.r),
                b.restore();
            }
        }),
        (CVShapeElement.prototype.renderShape = function (s, e, o, a) {
          var c,
            d = e.length - 1,
            g;
          for (g = s, c = d; c >= 0; c -= 1)
            e[c].ty === "tr"
              ? ((g = o[c].transform), this.renderShapeTransform(s, g))
              : e[c].ty === "sh" ||
                e[c].ty === "el" ||
                e[c].ty === "rc" ||
                e[c].ty === "sr"
              ? this.renderPath(e[c], o[c])
              : e[c].ty === "fl"
              ? this.renderFill(e[c], o[c], g)
              : e[c].ty === "st"
              ? this.renderStroke(e[c], o[c], g)
              : e[c].ty === "gf" || e[c].ty === "gs"
              ? this.renderGradientFill(e[c], o[c], g)
              : e[c].ty === "gr"
              ? this.renderShape(g, e[c].it, o[c].it)
              : e[c].ty;
          a && this.drawLayer();
        }),
        (CVShapeElement.prototype.renderStyledShape = function (s, e) {
          if (this._isFirstFrame || e._mdf || s.transforms._mdf) {
            var o = s.trNodes,
              a = e.paths,
              c,
              d,
              g,
              _ = a._length;
            o.length = 0;
            var b = s.transforms.finalTransform;
            for (g = 0; g < _; g += 1) {
              var j = a.shapes[g];
              if (j && j.v) {
                for (d = j._length, c = 1; c < d; c += 1)
                  c === 1 &&
                    o.push({
                      t: "m",
                      p: b.applyToPointArray(j.v[0][0], j.v[0][1], 0),
                    }),
                    o.push({
                      t: "c",
                      pts: b.applyToTriplePoints(j.o[c - 1], j.i[c], j.v[c]),
                    });
                d === 1 &&
                  o.push({
                    t: "m",
                    p: b.applyToPointArray(j.v[0][0], j.v[0][1], 0),
                  }),
                  j.c &&
                    d &&
                    (o.push({
                      t: "c",
                      pts: b.applyToTriplePoints(j.o[c - 1], j.i[0], j.v[0]),
                    }),
                    o.push({ t: "z" }));
              }
            }
            s.trNodes = o;
          }
        }),
        (CVShapeElement.prototype.renderPath = function (s, e) {
          if (s.hd !== !0 && s._shouldRender) {
            var o,
              a = e.styledShapes.length;
            for (o = 0; o < a; o += 1)
              this.renderStyledShape(e.styledShapes[o], e.sh);
          }
        }),
        (CVShapeElement.prototype.renderFill = function (s, e, o) {
          var a = e.style;
          (e.c._mdf || this._isFirstFrame) &&
            (a.co =
              "rgb(" +
              bmFloor(e.c.v[0]) +
              "," +
              bmFloor(e.c.v[1]) +
              "," +
              bmFloor(e.c.v[2]) +
              ")"),
            (e.o._mdf || o._opMdf || this._isFirstFrame) &&
              (a.coOp = e.o.v * o.opacity);
        }),
        (CVShapeElement.prototype.renderGradientFill = function (s, e, o) {
          var a = e.style,
            c;
          if (
            !a.grd ||
            e.g._mdf ||
            e.s._mdf ||
            e.e._mdf ||
            (s.t !== 1 && (e.h._mdf || e.a._mdf))
          ) {
            var d = this.globalData.canvasContext,
              g = e.s.v,
              _ = e.e.v;
            if (s.t === 1) c = d.createLinearGradient(g[0], g[1], _[0], _[1]);
            else {
              var b = Math.sqrt(
                  Math.pow(g[0] - _[0], 2) + Math.pow(g[1] - _[1], 2)
                ),
                j = Math.atan2(_[1] - g[1], _[0] - g[0]),
                $ = e.h.v;
              $ >= 1 ? ($ = 0.99) : $ <= -1 && ($ = -0.99);
              var _e = b * $,
                et = Math.cos(j + e.a.v) * _e + g[0],
                rt = Math.sin(j + e.a.v) * _e + g[1];
              c = d.createRadialGradient(et, rt, 0, g[0], g[1], b);
            }
            var st,
              at = s.g.p,
              ct = e.g.c,
              it = 1;
            for (st = 0; st < at; st += 1)
              e.g._hasOpacity && e.g._collapsable && (it = e.g.o[st * 2 + 1]),
                c.addColorStop(
                  ct[st * 4] / 100,
                  "rgba(" +
                    ct[st * 4 + 1] +
                    "," +
                    ct[st * 4 + 2] +
                    "," +
                    ct[st * 4 + 3] +
                    "," +
                    it +
                    ")"
                );
            a.grd = c;
          }
          a.coOp = e.o.v * o.opacity;
        }),
        (CVShapeElement.prototype.renderStroke = function (s, e, o) {
          var a = e.style,
            c = e.d;
          c &&
            (c._mdf || this._isFirstFrame) &&
            ((a.da = c.dashArray), (a.do = c.dashoffset[0])),
            (e.c._mdf || this._isFirstFrame) &&
              (a.co =
                "rgb(" +
                bmFloor(e.c.v[0]) +
                "," +
                bmFloor(e.c.v[1]) +
                "," +
                bmFloor(e.c.v[2]) +
                ")"),
            (e.o._mdf || o._opMdf || this._isFirstFrame) &&
              (a.coOp = e.o.v * o.opacity),
            (e.w._mdf || this._isFirstFrame) && (a.wi = e.w.v);
        }),
        (CVShapeElement.prototype.destroy = function () {
          (this.shapesData = null),
            (this.globalData = null),
            (this.canvasContext = null),
            (this.stylesList.length = 0),
            (this.itemsData.length = 0);
        });
      function CVTextElement(s, e, o) {
        (this.textSpans = []),
          (this.yOffset = 0),
          (this.fillColorAnim = !1),
          (this.strokeColorAnim = !1),
          (this.strokeWidthAnim = !1),
          (this.stroke = !1),
          (this.fill = !1),
          (this.justifyOffset = 0),
          (this.currentRender = null),
          (this.renderType = "canvas"),
          (this.values = {
            fill: "rgba(0,0,0,0)",
            stroke: "rgba(0,0,0,0)",
            sWidth: 0,
            fValue: "",
          }),
          this.initElement(s, e, o);
      }
      extendPrototype(
        [
          BaseElement,
          TransformElement,
          CVBaseElement,
          HierarchyElement,
          FrameElement,
          RenderableElement,
          ITextElement,
        ],
        CVTextElement
      ),
        (CVTextElement.prototype.tHelper =
          createTag("canvas").getContext("2d")),
        (CVTextElement.prototype.buildNewText = function () {
          var s = this.textProperty.currentData;
          this.renderedLetters = createSizedArray(s.l ? s.l.length : 0);
          var e = !1;
          s.fc
            ? ((e = !0), (this.values.fill = this.buildColor(s.fc)))
            : (this.values.fill = "rgba(0,0,0,0)"),
            (this.fill = e);
          var o = !1;
          s.sc &&
            ((o = !0),
            (this.values.stroke = this.buildColor(s.sc)),
            (this.values.sWidth = s.sw));
          var a = this.globalData.fontManager.getFontByName(s.f),
            c,
            d,
            g = s.l,
            _ = this.mHelper;
          (this.stroke = o),
            (this.values.fValue =
              s.finalSize +
              "px " +
              this.globalData.fontManager.getFontByName(s.f).fFamily),
            (d = s.finalText.length);
          var b,
            j,
            $,
            _e,
            et,
            rt,
            st,
            at,
            ct,
            it,
            lt = this.data.singleShape,
            ot = s.tr * 0.001 * s.finalSize,
            ut = 0,
            pt = 0,
            ft = !0,
            gt = 0;
          for (c = 0; c < d; c += 1) {
            (b = this.globalData.fontManager.getCharData(
              s.finalText[c],
              a.fStyle,
              this.globalData.fontManager.getFontByName(s.f).fFamily
            )),
              (j = (b && b.data) || {}),
              _.reset(),
              lt &&
                g[c].n &&
                ((ut = -ot), (pt += s.yOffset), (pt += ft ? 1 : 0), (ft = !1)),
              (et = j.shapes ? j.shapes[0].it : []),
              (st = et.length),
              _.scale(s.finalSize / 100, s.finalSize / 100),
              lt && this.applyTextPropertiesToMatrix(s, _, g[c].line, ut, pt),
              (ct = createSizedArray(st - 1));
            var xt = 0;
            for (rt = 0; rt < st; rt += 1)
              if (et[rt].ty === "sh") {
                for (
                  _e = et[rt].ks.k.i.length, at = et[rt].ks.k, it = [], $ = 1;
                  $ < _e;
                  $ += 1
                )
                  $ === 1 &&
                    it.push(
                      _.applyToX(at.v[0][0], at.v[0][1], 0),
                      _.applyToY(at.v[0][0], at.v[0][1], 0)
                    ),
                    it.push(
                      _.applyToX(at.o[$ - 1][0], at.o[$ - 1][1], 0),
                      _.applyToY(at.o[$ - 1][0], at.o[$ - 1][1], 0),
                      _.applyToX(at.i[$][0], at.i[$][1], 0),
                      _.applyToY(at.i[$][0], at.i[$][1], 0),
                      _.applyToX(at.v[$][0], at.v[$][1], 0),
                      _.applyToY(at.v[$][0], at.v[$][1], 0)
                    );
                it.push(
                  _.applyToX(at.o[$ - 1][0], at.o[$ - 1][1], 0),
                  _.applyToY(at.o[$ - 1][0], at.o[$ - 1][1], 0),
                  _.applyToX(at.i[0][0], at.i[0][1], 0),
                  _.applyToY(at.i[0][0], at.i[0][1], 0),
                  _.applyToX(at.v[0][0], at.v[0][1], 0),
                  _.applyToY(at.v[0][0], at.v[0][1], 0)
                ),
                  (ct[xt] = it),
                  (xt += 1);
              }
            lt && ((ut += g[c].l), (ut += ot)),
              this.textSpans[gt]
                ? (this.textSpans[gt].elem = ct)
                : (this.textSpans[gt] = { elem: ct }),
              (gt += 1);
          }
        }),
        (CVTextElement.prototype.renderInnerContent = function () {
          this.validateText();
          var s = this.canvasContext;
          (s.font = this.values.fValue),
            this.globalData.renderer.ctxLineCap("butt"),
            this.globalData.renderer.ctxLineJoin("miter"),
            this.globalData.renderer.ctxMiterLimit(4),
            this.data.singleShape ||
              this.textAnimator.getMeasures(
                this.textProperty.currentData,
                this.lettersChangedFlag
              );
          var e,
            o,
            a,
            c,
            d,
            g,
            _ = this.textAnimator.renderedLetters,
            b = this.textProperty.currentData.l;
          o = b.length;
          var j,
            $ = null,
            _e = null,
            et = null,
            rt,
            st,
            at = this.globalData.renderer;
          for (e = 0; e < o; e += 1)
            if (!b[e].n) {
              if (
                ((j = _[e]),
                j && (at.save(), at.ctxTransform(j.p), at.ctxOpacity(j.o)),
                this.fill)
              ) {
                for (
                  j && j.fc
                    ? $ !== j.fc && (at.ctxFillStyle(j.fc), ($ = j.fc))
                    : $ !== this.values.fill &&
                      (($ = this.values.fill),
                      at.ctxFillStyle(this.values.fill)),
                    rt = this.textSpans[e].elem,
                    c = rt.length,
                    this.globalData.canvasContext.beginPath(),
                    a = 0;
                  a < c;
                  a += 1
                )
                  for (
                    st = rt[a],
                      g = st.length,
                      this.globalData.canvasContext.moveTo(st[0], st[1]),
                      d = 2;
                    d < g;
                    d += 6
                  )
                    this.globalData.canvasContext.bezierCurveTo(
                      st[d],
                      st[d + 1],
                      st[d + 2],
                      st[d + 3],
                      st[d + 4],
                      st[d + 5]
                    );
                this.globalData.canvasContext.closePath(), at.ctxFill();
              }
              if (this.stroke) {
                for (
                  j && j.sw
                    ? et !== j.sw && ((et = j.sw), at.ctxLineWidth(j.sw))
                    : et !== this.values.sWidth &&
                      ((et = this.values.sWidth),
                      at.ctxLineWidth(this.values.sWidth)),
                    j && j.sc
                      ? _e !== j.sc && ((_e = j.sc), at.ctxStrokeStyle(j.sc))
                      : _e !== this.values.stroke &&
                        ((_e = this.values.stroke),
                        at.ctxStrokeStyle(this.values.stroke)),
                    rt = this.textSpans[e].elem,
                    c = rt.length,
                    this.globalData.canvasContext.beginPath(),
                    a = 0;
                  a < c;
                  a += 1
                )
                  for (
                    st = rt[a],
                      g = st.length,
                      this.globalData.canvasContext.moveTo(st[0], st[1]),
                      d = 2;
                    d < g;
                    d += 6
                  )
                    this.globalData.canvasContext.bezierCurveTo(
                      st[d],
                      st[d + 1],
                      st[d + 2],
                      st[d + 3],
                      st[d + 4],
                      st[d + 5]
                    );
                this.globalData.canvasContext.closePath(), at.ctxStroke();
              }
              j && this.globalData.renderer.restore();
            }
        });
      function CVImageElement(s, e, o) {
        (this.assetData = e.getAssetData(s.refId)),
          (this.img = e.imageLoader.getAsset(this.assetData)),
          this.initElement(s, e, o);
      }
      extendPrototype(
        [
          BaseElement,
          TransformElement,
          CVBaseElement,
          HierarchyElement,
          FrameElement,
          RenderableElement,
        ],
        CVImageElement
      ),
        (CVImageElement.prototype.initElement =
          SVGShapeElement.prototype.initElement),
        (CVImageElement.prototype.prepareFrame =
          IImageElement.prototype.prepareFrame),
        (CVImageElement.prototype.createContent = function () {
          if (
            this.img.width &&
            (this.assetData.w !== this.img.width ||
              this.assetData.h !== this.img.height)
          ) {
            var s = createTag("canvas");
            (s.width = this.assetData.w), (s.height = this.assetData.h);
            var e = s.getContext("2d"),
              o = this.img.width,
              a = this.img.height,
              c = o / a,
              d = this.assetData.w / this.assetData.h,
              g,
              _,
              b =
                this.assetData.pr ||
                this.globalData.renderConfig.imagePreserveAspectRatio;
            (c > d && b === "xMidYMid slice") ||
            (c < d && b !== "xMidYMid slice")
              ? ((_ = a), (g = _ * d))
              : ((g = o), (_ = g / d)),
              e.drawImage(
                this.img,
                (o - g) / 2,
                (a - _) / 2,
                g,
                _,
                0,
                0,
                this.assetData.w,
                this.assetData.h
              ),
              (this.img = s);
          }
        }),
        (CVImageElement.prototype.renderInnerContent = function () {
          this.canvasContext.drawImage(this.img, 0, 0);
        }),
        (CVImageElement.prototype.destroy = function () {
          this.img = null;
        });
      function CVSolidElement(s, e, o) {
        this.initElement(s, e, o);
      }
      extendPrototype(
        [
          BaseElement,
          TransformElement,
          CVBaseElement,
          HierarchyElement,
          FrameElement,
          RenderableElement,
        ],
        CVSolidElement
      ),
        (CVSolidElement.prototype.initElement =
          SVGShapeElement.prototype.initElement),
        (CVSolidElement.prototype.prepareFrame =
          IImageElement.prototype.prepareFrame),
        (CVSolidElement.prototype.renderInnerContent = function () {
          this.globalData.renderer.ctxFillStyle(this.data.sc),
            this.globalData.renderer.ctxFillRect(
              0,
              0,
              this.data.sw,
              this.data.sh
            );
        });
      function CanvasRendererBase() {}
      extendPrototype([BaseRenderer], CanvasRendererBase),
        (CanvasRendererBase.prototype.createShape = function (s) {
          return new CVShapeElement(s, this.globalData, this);
        }),
        (CanvasRendererBase.prototype.createText = function (s) {
          return new CVTextElement(s, this.globalData, this);
        }),
        (CanvasRendererBase.prototype.createImage = function (s) {
          return new CVImageElement(s, this.globalData, this);
        }),
        (CanvasRendererBase.prototype.createSolid = function (s) {
          return new CVSolidElement(s, this.globalData, this);
        }),
        (CanvasRendererBase.prototype.createNull =
          SVGRenderer.prototype.createNull),
        (CanvasRendererBase.prototype.ctxTransform = function (s) {
          (s[0] === 1 &&
            s[1] === 0 &&
            s[4] === 0 &&
            s[5] === 1 &&
            s[12] === 0 &&
            s[13] === 0) ||
            this.canvasContext.transform(s[0], s[1], s[4], s[5], s[12], s[13]);
        }),
        (CanvasRendererBase.prototype.ctxOpacity = function (s) {
          this.canvasContext.globalAlpha *= s < 0 ? 0 : s;
        }),
        (CanvasRendererBase.prototype.ctxFillStyle = function (s) {
          this.canvasContext.fillStyle = s;
        }),
        (CanvasRendererBase.prototype.ctxStrokeStyle = function (s) {
          this.canvasContext.strokeStyle = s;
        }),
        (CanvasRendererBase.prototype.ctxLineWidth = function (s) {
          this.canvasContext.lineWidth = s;
        }),
        (CanvasRendererBase.prototype.ctxLineCap = function (s) {
          this.canvasContext.lineCap = s;
        }),
        (CanvasRendererBase.prototype.ctxLineJoin = function (s) {
          this.canvasContext.lineJoin = s;
        }),
        (CanvasRendererBase.prototype.ctxMiterLimit = function (s) {
          this.canvasContext.miterLimit = s;
        }),
        (CanvasRendererBase.prototype.ctxFill = function (s) {
          this.canvasContext.fill(s);
        }),
        (CanvasRendererBase.prototype.ctxFillRect = function (s, e, o, a) {
          this.canvasContext.fillRect(s, e, o, a);
        }),
        (CanvasRendererBase.prototype.ctxStroke = function () {
          this.canvasContext.stroke();
        }),
        (CanvasRendererBase.prototype.reset = function () {
          if (!this.renderConfig.clearCanvas) {
            this.canvasContext.restore();
            return;
          }
          this.contextData.reset();
        }),
        (CanvasRendererBase.prototype.save = function () {
          this.canvasContext.save();
        }),
        (CanvasRendererBase.prototype.restore = function (s) {
          if (!this.renderConfig.clearCanvas) {
            this.canvasContext.restore();
            return;
          }
          s && (this.globalData.blendMode = "source-over"),
            this.contextData.restore(s);
        }),
        (CanvasRendererBase.prototype.configAnimation = function (s) {
          if (this.animationItem.wrapper) {
            this.animationItem.container = createTag("canvas");
            var e = this.animationItem.container.style;
            (e.width = "100%"), (e.height = "100%");
            var o = "0px 0px 0px";
            (e.transformOrigin = o),
              (e.mozTransformOrigin = o),
              (e.webkitTransformOrigin = o),
              (e["-webkit-transform"] = o),
              (e.contentVisibility = this.renderConfig.contentVisibility),
              this.animationItem.wrapper.appendChild(
                this.animationItem.container
              ),
              (this.canvasContext =
                this.animationItem.container.getContext("2d")),
              this.renderConfig.className &&
                this.animationItem.container.setAttribute(
                  "class",
                  this.renderConfig.className
                ),
              this.renderConfig.id &&
                this.animationItem.container.setAttribute(
                  "id",
                  this.renderConfig.id
                );
          } else this.canvasContext = this.renderConfig.context;
          this.contextData.setContext(this.canvasContext),
            (this.data = s),
            (this.layers = s.layers),
            (this.transformCanvas = {
              w: s.w,
              h: s.h,
              sx: 0,
              sy: 0,
              tx: 0,
              ty: 0,
            }),
            this.setupGlobalData(s, document.body),
            (this.globalData.canvasContext = this.canvasContext),
            (this.globalData.renderer = this),
            (this.globalData.isDashed = !1),
            (this.globalData.progressiveLoad =
              this.renderConfig.progressiveLoad),
            (this.globalData.transformCanvas = this.transformCanvas),
            (this.elements = createSizedArray(s.layers.length)),
            this.updateContainerSize();
        }),
        (CanvasRendererBase.prototype.updateContainerSize = function (s, e) {
          this.reset();
          var o, a;
          s
            ? ((o = s),
              (a = e),
              (this.canvasContext.canvas.width = o),
              (this.canvasContext.canvas.height = a))
            : (this.animationItem.wrapper && this.animationItem.container
                ? ((o = this.animationItem.wrapper.offsetWidth),
                  (a = this.animationItem.wrapper.offsetHeight))
                : ((o = this.canvasContext.canvas.width),
                  (a = this.canvasContext.canvas.height)),
              (this.canvasContext.canvas.width = o * this.renderConfig.dpr),
              (this.canvasContext.canvas.height = a * this.renderConfig.dpr));
          var c, d;
          if (
            this.renderConfig.preserveAspectRatio.indexOf("meet") !== -1 ||
            this.renderConfig.preserveAspectRatio.indexOf("slice") !== -1
          ) {
            var g = this.renderConfig.preserveAspectRatio.split(" "),
              _ = g[1] || "meet",
              b = g[0] || "xMidYMid",
              j = b.substr(0, 4),
              $ = b.substr(4);
            (c = o / a),
              (d = this.transformCanvas.w / this.transformCanvas.h),
              (d > c && _ === "meet") || (d < c && _ === "slice")
                ? ((this.transformCanvas.sx =
                    o / (this.transformCanvas.w / this.renderConfig.dpr)),
                  (this.transformCanvas.sy =
                    o / (this.transformCanvas.w / this.renderConfig.dpr)))
                : ((this.transformCanvas.sx =
                    a / (this.transformCanvas.h / this.renderConfig.dpr)),
                  (this.transformCanvas.sy =
                    a / (this.transformCanvas.h / this.renderConfig.dpr))),
              j === "xMid" &&
              ((d < c && _ === "meet") || (d > c && _ === "slice"))
                ? (this.transformCanvas.tx =
                    ((o -
                      this.transformCanvas.w * (a / this.transformCanvas.h)) /
                      2) *
                    this.renderConfig.dpr)
                : j === "xMax" &&
                  ((d < c && _ === "meet") || (d > c && _ === "slice"))
                ? (this.transformCanvas.tx =
                    (o -
                      this.transformCanvas.w * (a / this.transformCanvas.h)) *
                    this.renderConfig.dpr)
                : (this.transformCanvas.tx = 0),
              $ === "YMid" &&
              ((d > c && _ === "meet") || (d < c && _ === "slice"))
                ? (this.transformCanvas.ty =
                    ((a -
                      this.transformCanvas.h * (o / this.transformCanvas.w)) /
                      2) *
                    this.renderConfig.dpr)
                : $ === "YMax" &&
                  ((d > c && _ === "meet") || (d < c && _ === "slice"))
                ? (this.transformCanvas.ty =
                    (a -
                      this.transformCanvas.h * (o / this.transformCanvas.w)) *
                    this.renderConfig.dpr)
                : (this.transformCanvas.ty = 0);
          } else
            this.renderConfig.preserveAspectRatio === "none"
              ? ((this.transformCanvas.sx =
                  o / (this.transformCanvas.w / this.renderConfig.dpr)),
                (this.transformCanvas.sy =
                  a / (this.transformCanvas.h / this.renderConfig.dpr)),
                (this.transformCanvas.tx = 0),
                (this.transformCanvas.ty = 0))
              : ((this.transformCanvas.sx = this.renderConfig.dpr),
                (this.transformCanvas.sy = this.renderConfig.dpr),
                (this.transformCanvas.tx = 0),
                (this.transformCanvas.ty = 0));
          (this.transformCanvas.props = [
            this.transformCanvas.sx,
            0,
            0,
            0,
            0,
            this.transformCanvas.sy,
            0,
            0,
            0,
            0,
            1,
            0,
            this.transformCanvas.tx,
            this.transformCanvas.ty,
            0,
            1,
          ]),
            this.ctxTransform(this.transformCanvas.props),
            this.canvasContext.beginPath(),
            this.canvasContext.rect(
              0,
              0,
              this.transformCanvas.w,
              this.transformCanvas.h
            ),
            this.canvasContext.closePath(),
            this.canvasContext.clip(),
            this.renderFrame(this.renderedFrame, !0);
        }),
        (CanvasRendererBase.prototype.destroy = function () {
          this.renderConfig.clearCanvas &&
            this.animationItem.wrapper &&
            (this.animationItem.wrapper.innerText = "");
          var s,
            e = this.layers ? this.layers.length : 0;
          for (s = e - 1; s >= 0; s -= 1)
            this.elements[s] &&
              this.elements[s].destroy &&
              this.elements[s].destroy();
          (this.elements.length = 0),
            (this.globalData.canvasContext = null),
            (this.animationItem.container = null),
            (this.destroyed = !0);
        }),
        (CanvasRendererBase.prototype.renderFrame = function (s, e) {
          if (
            !(
              (this.renderedFrame === s &&
                this.renderConfig.clearCanvas === !0 &&
                !e) ||
              this.destroyed ||
              s === -1
            )
          ) {
            (this.renderedFrame = s),
              (this.globalData.frameNum = s - this.animationItem._isFirstFrame),
              (this.globalData.frameId += 1),
              (this.globalData._mdf = !this.renderConfig.clearCanvas || e),
              (this.globalData.projectInterface.currentFrame = s);
            var o,
              a = this.layers.length;
            for (
              this.completeLayers || this.checkLayers(s), o = a - 1;
              o >= 0;
              o -= 1
            )
              (this.completeLayers || this.elements[o]) &&
                this.elements[o].prepareFrame(s - this.layers[o].st);
            if (this.globalData._mdf) {
              for (
                this.renderConfig.clearCanvas === !0
                  ? this.canvasContext.clearRect(
                      0,
                      0,
                      this.transformCanvas.w,
                      this.transformCanvas.h
                    )
                  : this.save(),
                  o = a - 1;
                o >= 0;
                o -= 1
              )
                (this.completeLayers || this.elements[o]) &&
                  this.elements[o].renderFrame();
              this.renderConfig.clearCanvas !== !0 && this.restore();
            }
          }
        }),
        (CanvasRendererBase.prototype.buildItem = function (s) {
          var e = this.elements;
          if (!(e[s] || this.layers[s].ty === 99)) {
            var o = this.createItem(this.layers[s], this, this.globalData);
            (e[s] = o), o.initExpressions();
          }
        }),
        (CanvasRendererBase.prototype.checkPendingElements = function () {
          for (; this.pendingElements.length; ) {
            var s = this.pendingElements.pop();
            s.checkParenting();
          }
        }),
        (CanvasRendererBase.prototype.hide = function () {
          this.animationItem.container.style.display = "none";
        }),
        (CanvasRendererBase.prototype.show = function () {
          this.animationItem.container.style.display = "block";
        });
      function CanvasContext() {
        (this.opacity = -1),
          (this.transform = createTypedArray("float32", 16)),
          (this.fillStyle = ""),
          (this.strokeStyle = ""),
          (this.lineWidth = ""),
          (this.lineCap = ""),
          (this.lineJoin = ""),
          (this.miterLimit = ""),
          (this.id = Math.random());
      }
      function CVContextData() {
        (this.stack = []), (this.cArrPos = 0), (this.cTr = new Matrix());
        var s,
          e = 15;
        for (s = 0; s < e; s += 1) {
          var o = new CanvasContext();
          this.stack[s] = o;
        }
        (this._length = e),
          (this.nativeContext = null),
          (this.transformMat = new Matrix()),
          (this.currentOpacity = 1),
          (this.currentFillStyle = ""),
          (this.appliedFillStyle = ""),
          (this.currentStrokeStyle = ""),
          (this.appliedStrokeStyle = ""),
          (this.currentLineWidth = ""),
          (this.appliedLineWidth = ""),
          (this.currentLineCap = ""),
          (this.appliedLineCap = ""),
          (this.currentLineJoin = ""),
          (this.appliedLineJoin = ""),
          (this.appliedMiterLimit = ""),
          (this.currentMiterLimit = "");
      }
      (CVContextData.prototype.duplicate = function () {
        var s = this._length * 2,
          e = 0;
        for (e = this._length; e < s; e += 1)
          this.stack[e] = new CanvasContext();
        this._length = s;
      }),
        (CVContextData.prototype.reset = function () {
          (this.cArrPos = 0),
            this.cTr.reset(),
            (this.stack[this.cArrPos].opacity = 1);
        }),
        (CVContextData.prototype.restore = function (s) {
          this.cArrPos -= 1;
          var e = this.stack[this.cArrPos],
            o = e.transform,
            a,
            c = this.cTr.props;
          for (a = 0; a < 16; a += 1) c[a] = o[a];
          if (s) {
            this.nativeContext.restore();
            var d = this.stack[this.cArrPos + 1];
            (this.appliedFillStyle = d.fillStyle),
              (this.appliedStrokeStyle = d.strokeStyle),
              (this.appliedLineWidth = d.lineWidth),
              (this.appliedLineCap = d.lineCap),
              (this.appliedLineJoin = d.lineJoin),
              (this.appliedMiterLimit = d.miterLimit);
          }
          this.nativeContext.setTransform(o[0], o[1], o[4], o[5], o[12], o[13]),
            (s || (e.opacity !== -1 && this.currentOpacity !== e.opacity)) &&
              ((this.nativeContext.globalAlpha = e.opacity),
              (this.currentOpacity = e.opacity)),
            (this.currentFillStyle = e.fillStyle),
            (this.currentStrokeStyle = e.strokeStyle),
            (this.currentLineWidth = e.lineWidth),
            (this.currentLineCap = e.lineCap),
            (this.currentLineJoin = e.lineJoin),
            (this.currentMiterLimit = e.miterLimit);
        }),
        (CVContextData.prototype.save = function (s) {
          s && this.nativeContext.save();
          var e = this.cTr.props;
          this._length <= this.cArrPos && this.duplicate();
          var o = this.stack[this.cArrPos],
            a;
          for (a = 0; a < 16; a += 1) o.transform[a] = e[a];
          this.cArrPos += 1;
          var c = this.stack[this.cArrPos];
          (c.opacity = o.opacity),
            (c.fillStyle = o.fillStyle),
            (c.strokeStyle = o.strokeStyle),
            (c.lineWidth = o.lineWidth),
            (c.lineCap = o.lineCap),
            (c.lineJoin = o.lineJoin),
            (c.miterLimit = o.miterLimit);
        }),
        (CVContextData.prototype.setOpacity = function (s) {
          this.stack[this.cArrPos].opacity = s;
        }),
        (CVContextData.prototype.setContext = function (s) {
          this.nativeContext = s;
        }),
        (CVContextData.prototype.fillStyle = function (s) {
          this.stack[this.cArrPos].fillStyle !== s &&
            ((this.currentFillStyle = s),
            (this.stack[this.cArrPos].fillStyle = s));
        }),
        (CVContextData.prototype.strokeStyle = function (s) {
          this.stack[this.cArrPos].strokeStyle !== s &&
            ((this.currentStrokeStyle = s),
            (this.stack[this.cArrPos].strokeStyle = s));
        }),
        (CVContextData.prototype.lineWidth = function (s) {
          this.stack[this.cArrPos].lineWidth !== s &&
            ((this.currentLineWidth = s),
            (this.stack[this.cArrPos].lineWidth = s));
        }),
        (CVContextData.prototype.lineCap = function (s) {
          this.stack[this.cArrPos].lineCap !== s &&
            ((this.currentLineCap = s), (this.stack[this.cArrPos].lineCap = s));
        }),
        (CVContextData.prototype.lineJoin = function (s) {
          this.stack[this.cArrPos].lineJoin !== s &&
            ((this.currentLineJoin = s),
            (this.stack[this.cArrPos].lineJoin = s));
        }),
        (CVContextData.prototype.miterLimit = function (s) {
          this.stack[this.cArrPos].miterLimit !== s &&
            ((this.currentMiterLimit = s),
            (this.stack[this.cArrPos].miterLimit = s));
        }),
        (CVContextData.prototype.transform = function (s) {
          this.transformMat.cloneFromProps(s);
          var e = this.cTr;
          this.transformMat.multiply(e),
            e.cloneFromProps(this.transformMat.props);
          var o = e.props;
          this.nativeContext.setTransform(o[0], o[1], o[4], o[5], o[12], o[13]);
        }),
        (CVContextData.prototype.opacity = function (s) {
          var e = this.stack[this.cArrPos].opacity;
          (e *= s < 0 ? 0 : s),
            this.stack[this.cArrPos].opacity !== e &&
              (this.currentOpacity !== s &&
                ((this.nativeContext.globalAlpha = s),
                (this.currentOpacity = s)),
              (this.stack[this.cArrPos].opacity = e));
        }),
        (CVContextData.prototype.fill = function (s) {
          this.appliedFillStyle !== this.currentFillStyle &&
            ((this.appliedFillStyle = this.currentFillStyle),
            (this.nativeContext.fillStyle = this.appliedFillStyle)),
            this.nativeContext.fill(s);
        }),
        (CVContextData.prototype.fillRect = function (s, e, o, a) {
          this.appliedFillStyle !== this.currentFillStyle &&
            ((this.appliedFillStyle = this.currentFillStyle),
            (this.nativeContext.fillStyle = this.appliedFillStyle)),
            this.nativeContext.fillRect(s, e, o, a);
        }),
        (CVContextData.prototype.stroke = function () {
          this.appliedStrokeStyle !== this.currentStrokeStyle &&
            ((this.appliedStrokeStyle = this.currentStrokeStyle),
            (this.nativeContext.strokeStyle = this.appliedStrokeStyle)),
            this.appliedLineWidth !== this.currentLineWidth &&
              ((this.appliedLineWidth = this.currentLineWidth),
              (this.nativeContext.lineWidth = this.appliedLineWidth)),
            this.appliedLineCap !== this.currentLineCap &&
              ((this.appliedLineCap = this.currentLineCap),
              (this.nativeContext.lineCap = this.appliedLineCap)),
            this.appliedLineJoin !== this.currentLineJoin &&
              ((this.appliedLineJoin = this.currentLineJoin),
              (this.nativeContext.lineJoin = this.appliedLineJoin)),
            this.appliedMiterLimit !== this.currentMiterLimit &&
              ((this.appliedMiterLimit = this.currentMiterLimit),
              (this.nativeContext.miterLimit = this.appliedMiterLimit)),
            this.nativeContext.stroke();
        });
      function CVCompElement(s, e, o) {
        (this.completeLayers = !1),
          (this.layers = s.layers),
          (this.pendingElements = []),
          (this.elements = createSizedArray(this.layers.length)),
          this.initElement(s, e, o),
          (this.tm = s.tm
            ? PropertyFactory.getProp(this, s.tm, 0, e.frameRate, this)
            : { _placeholder: !0 });
      }
      extendPrototype(
        [CanvasRendererBase, ICompElement, CVBaseElement],
        CVCompElement
      ),
        (CVCompElement.prototype.renderInnerContent = function () {
          var s = this.canvasContext;
          s.beginPath(),
            s.moveTo(0, 0),
            s.lineTo(this.data.w, 0),
            s.lineTo(this.data.w, this.data.h),
            s.lineTo(0, this.data.h),
            s.lineTo(0, 0),
            s.clip();
          var e,
            o = this.layers.length;
          for (e = o - 1; e >= 0; e -= 1)
            (this.completeLayers || this.elements[e]) &&
              this.elements[e].renderFrame();
        }),
        (CVCompElement.prototype.destroy = function () {
          var s,
            e = this.layers.length;
          for (s = e - 1; s >= 0; s -= 1)
            this.elements[s] && this.elements[s].destroy();
          (this.layers = null), (this.elements = null);
        }),
        (CVCompElement.prototype.createComp = function (s) {
          return new CVCompElement(s, this.globalData, this);
        });
      function CanvasRenderer(s, e) {
        (this.animationItem = s),
          (this.renderConfig = {
            clearCanvas: e && e.clearCanvas !== void 0 ? e.clearCanvas : !0,
            context: (e && e.context) || null,
            progressiveLoad: (e && e.progressiveLoad) || !1,
            preserveAspectRatio:
              (e && e.preserveAspectRatio) || "xMidYMid meet",
            imagePreserveAspectRatio:
              (e && e.imagePreserveAspectRatio) || "xMidYMid slice",
            contentVisibility: (e && e.contentVisibility) || "visible",
            className: (e && e.className) || "",
            id: (e && e.id) || "",
            runExpressions:
              !e || e.runExpressions === void 0 || e.runExpressions,
          }),
          (this.renderConfig.dpr = (e && e.dpr) || 1),
          this.animationItem.wrapper &&
            (this.renderConfig.dpr =
              (e && e.dpr) || window.devicePixelRatio || 1),
          (this.renderedFrame = -1),
          (this.globalData = {
            frameNum: -1,
            _mdf: !1,
            renderConfig: this.renderConfig,
            currentGlobalAlpha: -1,
          }),
          (this.contextData = new CVContextData()),
          (this.elements = []),
          (this.pendingElements = []),
          (this.transformMat = new Matrix()),
          (this.completeLayers = !1),
          (this.rendererType = "canvas"),
          this.renderConfig.clearCanvas &&
            ((this.ctxTransform = this.contextData.transform.bind(
              this.contextData
            )),
            (this.ctxOpacity = this.contextData.opacity.bind(this.contextData)),
            (this.ctxFillStyle = this.contextData.fillStyle.bind(
              this.contextData
            )),
            (this.ctxStrokeStyle = this.contextData.strokeStyle.bind(
              this.contextData
            )),
            (this.ctxLineWidth = this.contextData.lineWidth.bind(
              this.contextData
            )),
            (this.ctxLineCap = this.contextData.lineCap.bind(this.contextData)),
            (this.ctxLineJoin = this.contextData.lineJoin.bind(
              this.contextData
            )),
            (this.ctxMiterLimit = this.contextData.miterLimit.bind(
              this.contextData
            )),
            (this.ctxFill = this.contextData.fill.bind(this.contextData)),
            (this.ctxFillRect = this.contextData.fillRect.bind(
              this.contextData
            )),
            (this.ctxStroke = this.contextData.stroke.bind(this.contextData)),
            (this.save = this.contextData.save.bind(this.contextData)));
      }
      extendPrototype([CanvasRendererBase], CanvasRenderer),
        (CanvasRenderer.prototype.createComp = function (s) {
          return new CVCompElement(s, this.globalData, this);
        });
      function HBaseElement() {}
      (HBaseElement.prototype = {
        checkBlendMode: function () {},
        initRendererElement: function () {
          (this.baseElement = createTag(this.data.tg || "div")),
            this.data.hasMask
              ? ((this.svgElement = createNS("svg")),
                (this.layerElement = createNS("g")),
                (this.maskedElement = this.layerElement),
                this.svgElement.appendChild(this.layerElement),
                this.baseElement.appendChild(this.svgElement))
              : (this.layerElement = this.baseElement),
            styleDiv(this.baseElement);
        },
        createContainerElements: function () {
          (this.renderableEffectsManager = new CVEffects(this)),
            (this.transformedElement = this.baseElement),
            (this.maskedElement = this.layerElement),
            this.data.ln && this.layerElement.setAttribute("id", this.data.ln),
            this.data.cl &&
              this.layerElement.setAttribute("class", this.data.cl),
            this.data.bm !== 0 && this.setBlendMode();
        },
        renderElement: function () {
          var e = this.transformedElement ? this.transformedElement.style : {};
          if (this.finalTransform._matMdf) {
            var o = this.finalTransform.mat.toCSS();
            (e.transform = o), (e.webkitTransform = o);
          }
          this.finalTransform._opMdf &&
            (e.opacity = this.finalTransform.mProp.o.v);
        },
        renderFrame: function () {
          this.data.hd ||
            this.hidden ||
            (this.renderTransform(),
            this.renderRenderable(),
            this.renderElement(),
            this.renderInnerContent(),
            this._isFirstFrame && (this._isFirstFrame = !1));
        },
        destroy: function () {
          (this.layerElement = null),
            (this.transformedElement = null),
            this.matteElement && (this.matteElement = null),
            this.maskManager &&
              (this.maskManager.destroy(), (this.maskManager = null));
        },
        createRenderableComponents: function () {
          this.maskManager = new MaskElement(this.data, this, this.globalData);
        },
        addEffects: function () {},
        setMatte: function () {},
      }),
        (HBaseElement.prototype.getBaseElement =
          SVGBaseElement.prototype.getBaseElement),
        (HBaseElement.prototype.destroyBaseElement =
          HBaseElement.prototype.destroy),
        (HBaseElement.prototype.buildElementParenting =
          BaseRenderer.prototype.buildElementParenting);
      function HSolidElement(s, e, o) {
        this.initElement(s, e, o);
      }
      extendPrototype(
        [
          BaseElement,
          TransformElement,
          HBaseElement,
          HierarchyElement,
          FrameElement,
          RenderableDOMElement,
        ],
        HSolidElement
      ),
        (HSolidElement.prototype.createContent = function () {
          var s;
          this.data.hasMask
            ? ((s = createNS("rect")),
              s.setAttribute("width", this.data.sw),
              s.setAttribute("height", this.data.sh),
              s.setAttribute("fill", this.data.sc),
              this.svgElement.setAttribute("width", this.data.sw),
              this.svgElement.setAttribute("height", this.data.sh))
            : ((s = createTag("div")),
              (s.style.width = this.data.sw + "px"),
              (s.style.height = this.data.sh + "px"),
              (s.style.backgroundColor = this.data.sc)),
            this.layerElement.appendChild(s);
        });
      function HShapeElement(s, e, o) {
        (this.shapes = []),
          (this.shapesData = s.shapes),
          (this.stylesList = []),
          (this.shapeModifiers = []),
          (this.itemsData = []),
          (this.processedElements = []),
          (this.animatedContents = []),
          (this.shapesContainer = createNS("g")),
          this.initElement(s, e, o),
          (this.prevViewData = []),
          (this.currentBBox = { x: 999999, y: -999999, h: 0, w: 0 });
      }
      extendPrototype(
        [
          BaseElement,
          TransformElement,
          HSolidElement,
          SVGShapeElement,
          HBaseElement,
          HierarchyElement,
          FrameElement,
          RenderableElement,
        ],
        HShapeElement
      ),
        (HShapeElement.prototype._renderShapeFrame =
          HShapeElement.prototype.renderInnerContent),
        (HShapeElement.prototype.createContent = function () {
          var s;
          if (((this.baseElement.style.fontSize = 0), this.data.hasMask))
            this.layerElement.appendChild(this.shapesContainer),
              (s = this.svgElement);
          else {
            s = createNS("svg");
            var e = this.comp.data ? this.comp.data : this.globalData.compSize;
            s.setAttribute("width", e.w),
              s.setAttribute("height", e.h),
              s.appendChild(this.shapesContainer),
              this.layerElement.appendChild(s);
          }
          this.searchShapes(
            this.shapesData,
            this.itemsData,
            this.prevViewData,
            this.shapesContainer,
            0,
            [],
            !0
          ),
            this.filterUniqueShapes(),
            (this.shapeCont = s);
        }),
        (HShapeElement.prototype.getTransformedPoint = function (s, e) {
          var o,
            a = s.length;
          for (o = 0; o < a; o += 1)
            e = s[o].mProps.v.applyToPointArray(e[0], e[1], 0);
          return e;
        }),
        (HShapeElement.prototype.calculateShapeBoundingBox = function (s, e) {
          var o = s.sh.v,
            a = s.transformers,
            c,
            d = o._length,
            g,
            _,
            b,
            j;
          if (!(d <= 1)) {
            for (c = 0; c < d - 1; c += 1)
              (g = this.getTransformedPoint(a, o.v[c])),
                (_ = this.getTransformedPoint(a, o.o[c])),
                (b = this.getTransformedPoint(a, o.i[c + 1])),
                (j = this.getTransformedPoint(a, o.v[c + 1])),
                this.checkBounds(g, _, b, j, e);
            o.c &&
              ((g = this.getTransformedPoint(a, o.v[c])),
              (_ = this.getTransformedPoint(a, o.o[c])),
              (b = this.getTransformedPoint(a, o.i[0])),
              (j = this.getTransformedPoint(a, o.v[0])),
              this.checkBounds(g, _, b, j, e));
          }
        }),
        (HShapeElement.prototype.checkBounds = function (s, e, o, a, c) {
          this.getBoundsOfCurve(s, e, o, a);
          var d = this.shapeBoundingBox;
          (c.x = bmMin(d.left, c.x)),
            (c.xMax = bmMax(d.right, c.xMax)),
            (c.y = bmMin(d.top, c.y)),
            (c.yMax = bmMax(d.bottom, c.yMax));
        }),
        (HShapeElement.prototype.shapeBoundingBox = {
          left: 0,
          right: 0,
          top: 0,
          bottom: 0,
        }),
        (HShapeElement.prototype.tempBoundingBox = {
          x: 0,
          xMax: 0,
          y: 0,
          yMax: 0,
          width: 0,
          height: 0,
        }),
        (HShapeElement.prototype.getBoundsOfCurve = function (s, e, o, a) {
          for (
            var c = [
                [s[0], a[0]],
                [s[1], a[1]],
              ],
              d,
              g,
              _,
              b,
              j,
              $,
              _e,
              et = 0;
            et < 2;
            ++et
          )
            (g = 6 * s[et] - 12 * e[et] + 6 * o[et]),
              (d = -3 * s[et] + 9 * e[et] - 9 * o[et] + 3 * a[et]),
              (_ = 3 * e[et] - 3 * s[et]),
              (g |= 0),
              (d |= 0),
              (_ |= 0),
              (d === 0 && g === 0) ||
                (d === 0
                  ? ((b = -_ / g),
                    b > 0 &&
                      b < 1 &&
                      c[et].push(this.calculateF(b, s, e, o, a, et)))
                  : ((j = g * g - 4 * _ * d),
                    j >= 0 &&
                      (($ = (-g + bmSqrt(j)) / (2 * d)),
                      $ > 0 &&
                        $ < 1 &&
                        c[et].push(this.calculateF($, s, e, o, a, et)),
                      (_e = (-g - bmSqrt(j)) / (2 * d)),
                      _e > 0 &&
                        _e < 1 &&
                        c[et].push(this.calculateF(_e, s, e, o, a, et)))));
          (this.shapeBoundingBox.left = bmMin.apply(null, c[0])),
            (this.shapeBoundingBox.top = bmMin.apply(null, c[1])),
            (this.shapeBoundingBox.right = bmMax.apply(null, c[0])),
            (this.shapeBoundingBox.bottom = bmMax.apply(null, c[1]));
        }),
        (HShapeElement.prototype.calculateF = function (s, e, o, a, c, d) {
          return (
            bmPow(1 - s, 3) * e[d] +
            3 * bmPow(1 - s, 2) * s * o[d] +
            3 * (1 - s) * bmPow(s, 2) * a[d] +
            bmPow(s, 3) * c[d]
          );
        }),
        (HShapeElement.prototype.calculateBoundingBox = function (s, e) {
          var o,
            a = s.length;
          for (o = 0; o < a; o += 1)
            s[o] && s[o].sh
              ? this.calculateShapeBoundingBox(s[o], e)
              : s[o] && s[o].it
              ? this.calculateBoundingBox(s[o].it, e)
              : s[o] &&
                s[o].style &&
                s[o].w &&
                this.expandStrokeBoundingBox(s[o].w, e);
        }),
        (HShapeElement.prototype.expandStrokeBoundingBox = function (s, e) {
          var o = 0;
          if (s.keyframes) {
            for (var a = 0; a < s.keyframes.length; a += 1) {
              var c = s.keyframes[a].s;
              c > o && (o = c);
            }
            o *= s.mult;
          } else o = s.v * s.mult;
          (e.x -= o), (e.xMax += o), (e.y -= o), (e.yMax += o);
        }),
        (HShapeElement.prototype.currentBoxContains = function (s) {
          return (
            this.currentBBox.x <= s.x &&
            this.currentBBox.y <= s.y &&
            this.currentBBox.width + this.currentBBox.x >= s.x + s.width &&
            this.currentBBox.height + this.currentBBox.y >= s.y + s.height
          );
        }),
        (HShapeElement.prototype.renderInnerContent = function () {
          if (
            (this._renderShapeFrame(),
            !this.hidden && (this._isFirstFrame || this._mdf))
          ) {
            var s = this.tempBoundingBox,
              e = 999999;
            if (
              ((s.x = e),
              (s.xMax = -e),
              (s.y = e),
              (s.yMax = -e),
              this.calculateBoundingBox(this.itemsData, s),
              (s.width = s.xMax < s.x ? 0 : s.xMax - s.x),
              (s.height = s.yMax < s.y ? 0 : s.yMax - s.y),
              this.currentBoxContains(s))
            )
              return;
            var o = !1;
            if (
              (this.currentBBox.w !== s.width &&
                ((this.currentBBox.w = s.width),
                this.shapeCont.setAttribute("width", s.width),
                (o = !0)),
              this.currentBBox.h !== s.height &&
                ((this.currentBBox.h = s.height),
                this.shapeCont.setAttribute("height", s.height),
                (o = !0)),
              o || this.currentBBox.x !== s.x || this.currentBBox.y !== s.y)
            ) {
              (this.currentBBox.w = s.width),
                (this.currentBBox.h = s.height),
                (this.currentBBox.x = s.x),
                (this.currentBBox.y = s.y),
                this.shapeCont.setAttribute(
                  "viewBox",
                  this.currentBBox.x +
                    " " +
                    this.currentBBox.y +
                    " " +
                    this.currentBBox.w +
                    " " +
                    this.currentBBox.h
                );
              var a = this.shapeCont.style,
                c =
                  "translate(" +
                  this.currentBBox.x +
                  "px," +
                  this.currentBBox.y +
                  "px)";
              (a.transform = c), (a.webkitTransform = c);
            }
          }
        });
      function HTextElement(s, e, o) {
        (this.textSpans = []),
          (this.textPaths = []),
          (this.currentBBox = { x: 999999, y: -999999, h: 0, w: 0 }),
          (this.renderType = "svg"),
          (this.isMasked = !1),
          this.initElement(s, e, o);
      }
      extendPrototype(
        [
          BaseElement,
          TransformElement,
          HBaseElement,
          HierarchyElement,
          FrameElement,
          RenderableDOMElement,
          ITextElement,
        ],
        HTextElement
      ),
        (HTextElement.prototype.createContent = function () {
          if (((this.isMasked = this.checkMasks()), this.isMasked)) {
            (this.renderType = "svg"),
              (this.compW = this.comp.data.w),
              (this.compH = this.comp.data.h),
              this.svgElement.setAttribute("width", this.compW),
              this.svgElement.setAttribute("height", this.compH);
            var s = createNS("g");
            this.maskedElement.appendChild(s), (this.innerElem = s);
          } else
            (this.renderType = "html"), (this.innerElem = this.layerElement);
          this.checkParenting();
        }),
        (HTextElement.prototype.buildNewText = function () {
          var s = this.textProperty.currentData;
          this.renderedLetters = createSizedArray(s.l ? s.l.length : 0);
          var e = this.innerElem.style,
            o = s.fc ? this.buildColor(s.fc) : "rgba(0,0,0,0)";
          (e.fill = o),
            (e.color = o),
            s.sc &&
              ((e.stroke = this.buildColor(s.sc)),
              (e.strokeWidth = s.sw + "px"));
          var a = this.globalData.fontManager.getFontByName(s.f);
          if (!this.globalData.fontManager.chars)
            if (
              ((e.fontSize = s.finalSize + "px"),
              (e.lineHeight = s.finalSize + "px"),
              a.fClass)
            )
              this.innerElem.className = a.fClass;
            else {
              e.fontFamily = a.fFamily;
              var c = s.fWeight,
                d = s.fStyle;
              (e.fontStyle = d), (e.fontWeight = c);
            }
          var g,
            _,
            b = s.l;
          _ = b.length;
          var j,
            $,
            _e,
            et = this.mHelper,
            rt,
            st = "",
            at = 0;
          for (g = 0; g < _; g += 1) {
            if (
              (this.globalData.fontManager.chars
                ? (this.textPaths[at]
                    ? (j = this.textPaths[at])
                    : ((j = createNS("path")),
                      j.setAttribute("stroke-linecap", lineCapEnum[1]),
                      j.setAttribute("stroke-linejoin", lineJoinEnum[2]),
                      j.setAttribute("stroke-miterlimit", "4")),
                  this.isMasked ||
                    (this.textSpans[at]
                      ? (($ = this.textSpans[at]), (_e = $.children[0]))
                      : (($ = createTag("div")),
                        ($.style.lineHeight = 0),
                        (_e = createNS("svg")),
                        _e.appendChild(j),
                        styleDiv($))))
                : this.isMasked
                ? (j = this.textPaths[at]
                    ? this.textPaths[at]
                    : createNS("text"))
                : this.textSpans[at]
                ? (($ = this.textSpans[at]), (j = this.textPaths[at]))
                : (($ = createTag("span")),
                  styleDiv($),
                  (j = createTag("span")),
                  styleDiv(j),
                  $.appendChild(j)),
              this.globalData.fontManager.chars)
            ) {
              var ct = this.globalData.fontManager.getCharData(
                  s.finalText[g],
                  a.fStyle,
                  this.globalData.fontManager.getFontByName(s.f).fFamily
                ),
                it;
              if (
                (ct ? (it = ct.data) : (it = null),
                et.reset(),
                it &&
                  it.shapes &&
                  it.shapes.length &&
                  ((rt = it.shapes[0].it),
                  et.scale(s.finalSize / 100, s.finalSize / 100),
                  (st = this.createPathShape(et, rt)),
                  j.setAttribute("d", st)),
                this.isMasked)
              )
                this.innerElem.appendChild(j);
              else {
                if ((this.innerElem.appendChild($), it && it.shapes)) {
                  document.body.appendChild(_e);
                  var lt = _e.getBBox();
                  _e.setAttribute("width", lt.width + 2),
                    _e.setAttribute("height", lt.height + 2),
                    _e.setAttribute(
                      "viewBox",
                      lt.x -
                        1 +
                        " " +
                        (lt.y - 1) +
                        " " +
                        (lt.width + 2) +
                        " " +
                        (lt.height + 2)
                    );
                  var ot = _e.style,
                    ut = "translate(" + (lt.x - 1) + "px," + (lt.y - 1) + "px)";
                  (ot.transform = ut),
                    (ot.webkitTransform = ut),
                    (b[g].yOffset = lt.y - 1);
                } else
                  _e.setAttribute("width", 1), _e.setAttribute("height", 1);
                $.appendChild(_e);
              }
            } else if (
              ((j.textContent = b[g].val),
              j.setAttributeNS(
                "http://www.w3.org/XML/1998/namespace",
                "xml:space",
                "preserve"
              ),
              this.isMasked)
            )
              this.innerElem.appendChild(j);
            else {
              this.innerElem.appendChild($);
              var pt = j.style,
                ft = "translate3d(0," + -s.finalSize / 1.2 + "px,0)";
              (pt.transform = ft), (pt.webkitTransform = ft);
            }
            this.isMasked ? (this.textSpans[at] = j) : (this.textSpans[at] = $),
              (this.textSpans[at].style.display = "block"),
              (this.textPaths[at] = j),
              (at += 1);
          }
          for (; at < this.textSpans.length; )
            (this.textSpans[at].style.display = "none"), (at += 1);
        }),
        (HTextElement.prototype.renderInnerContent = function () {
          this.validateText();
          var s;
          if (this.data.singleShape) {
            if (!this._isFirstFrame && !this.lettersChangedFlag) return;
            if (this.isMasked && this.finalTransform._matMdf) {
              this.svgElement.setAttribute(
                "viewBox",
                -this.finalTransform.mProp.p.v[0] +
                  " " +
                  -this.finalTransform.mProp.p.v[1] +
                  " " +
                  this.compW +
                  " " +
                  this.compH
              ),
                (s = this.svgElement.style);
              var e =
                "translate(" +
                -this.finalTransform.mProp.p.v[0] +
                "px," +
                -this.finalTransform.mProp.p.v[1] +
                "px)";
              (s.transform = e), (s.webkitTransform = e);
            }
          }
          if (
            (this.textAnimator.getMeasures(
              this.textProperty.currentData,
              this.lettersChangedFlag
            ),
            !(
              !this.lettersChangedFlag && !this.textAnimator.lettersChangedFlag
            ))
          ) {
            var o,
              a,
              c = 0,
              d = this.textAnimator.renderedLetters,
              g = this.textProperty.currentData.l;
            a = g.length;
            var _, b, j;
            for (o = 0; o < a; o += 1)
              g[o].n
                ? (c += 1)
                : ((b = this.textSpans[o]),
                  (j = this.textPaths[o]),
                  (_ = d[c]),
                  (c += 1),
                  _._mdf.m &&
                    (this.isMasked
                      ? b.setAttribute("transform", _.m)
                      : ((b.style.webkitTransform = _.m),
                        (b.style.transform = _.m))),
                  (b.style.opacity = _.o),
                  _.sw && _._mdf.sw && j.setAttribute("stroke-width", _.sw),
                  _.sc && _._mdf.sc && j.setAttribute("stroke", _.sc),
                  _.fc &&
                    _._mdf.fc &&
                    (j.setAttribute("fill", _.fc), (j.style.color = _.fc)));
            if (
              this.innerElem.getBBox &&
              !this.hidden &&
              (this._isFirstFrame || this._mdf)
            ) {
              var $ = this.innerElem.getBBox();
              this.currentBBox.w !== $.width &&
                ((this.currentBBox.w = $.width),
                this.svgElement.setAttribute("width", $.width)),
                this.currentBBox.h !== $.height &&
                  ((this.currentBBox.h = $.height),
                  this.svgElement.setAttribute("height", $.height));
              var _e = 1;
              if (
                this.currentBBox.w !== $.width + _e * 2 ||
                this.currentBBox.h !== $.height + _e * 2 ||
                this.currentBBox.x !== $.x - _e ||
                this.currentBBox.y !== $.y - _e
              ) {
                (this.currentBBox.w = $.width + _e * 2),
                  (this.currentBBox.h = $.height + _e * 2),
                  (this.currentBBox.x = $.x - _e),
                  (this.currentBBox.y = $.y - _e),
                  this.svgElement.setAttribute(
                    "viewBox",
                    this.currentBBox.x +
                      " " +
                      this.currentBBox.y +
                      " " +
                      this.currentBBox.w +
                      " " +
                      this.currentBBox.h
                  ),
                  (s = this.svgElement.style);
                var et =
                  "translate(" +
                  this.currentBBox.x +
                  "px," +
                  this.currentBBox.y +
                  "px)";
                (s.transform = et), (s.webkitTransform = et);
              }
            }
          }
        });
      function HCameraElement(s, e, o) {
        this.initFrame(), this.initBaseData(s, e, o), this.initHierarchy();
        var a = PropertyFactory.getProp;
        if (
          ((this.pe = a(this, s.pe, 0, 0, this)),
          s.ks.p.s
            ? ((this.px = a(this, s.ks.p.x, 1, 0, this)),
              (this.py = a(this, s.ks.p.y, 1, 0, this)),
              (this.pz = a(this, s.ks.p.z, 1, 0, this)))
            : (this.p = a(this, s.ks.p, 1, 0, this)),
          s.ks.a && (this.a = a(this, s.ks.a, 1, 0, this)),
          s.ks.or.k.length && s.ks.or.k[0].to)
        ) {
          var c,
            d = s.ks.or.k.length;
          for (c = 0; c < d; c += 1)
            (s.ks.or.k[c].to = null), (s.ks.or.k[c].ti = null);
        }
        (this.or = a(this, s.ks.or, 1, degToRads, this)),
          (this.or.sh = !0),
          (this.rx = a(this, s.ks.rx, 0, degToRads, this)),
          (this.ry = a(this, s.ks.ry, 0, degToRads, this)),
          (this.rz = a(this, s.ks.rz, 0, degToRads, this)),
          (this.mat = new Matrix()),
          (this._prevMat = new Matrix()),
          (this._isFirstFrame = !0),
          (this.finalTransform = { mProp: this });
      }
      extendPrototype(
        [BaseElement, FrameElement, HierarchyElement],
        HCameraElement
      ),
        (HCameraElement.prototype.setup = function () {
          var s,
            e = this.comp.threeDElements.length,
            o,
            a,
            c;
          for (s = 0; s < e; s += 1)
            if (((o = this.comp.threeDElements[s]), o.type === "3d")) {
              (a = o.perspectiveElem.style), (c = o.container.style);
              var d = this.pe.v + "px",
                g = "0px 0px 0px",
                _ = "matrix3d(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1)";
              (a.perspective = d),
                (a.webkitPerspective = d),
                (c.transformOrigin = g),
                (c.mozTransformOrigin = g),
                (c.webkitTransformOrigin = g),
                (a.transform = _),
                (a.webkitTransform = _);
            }
        }),
        (HCameraElement.prototype.createElements = function () {}),
        (HCameraElement.prototype.hide = function () {}),
        (HCameraElement.prototype.renderFrame = function () {
          var s = this._isFirstFrame,
            e,
            o;
          if (this.hierarchy)
            for (o = this.hierarchy.length, e = 0; e < o; e += 1)
              s = this.hierarchy[e].finalTransform.mProp._mdf || s;
          if (
            s ||
            this.pe._mdf ||
            (this.p && this.p._mdf) ||
            (this.px && (this.px._mdf || this.py._mdf || this.pz._mdf)) ||
            this.rx._mdf ||
            this.ry._mdf ||
            this.rz._mdf ||
            this.or._mdf ||
            (this.a && this.a._mdf)
          ) {
            if ((this.mat.reset(), this.hierarchy))
              for (o = this.hierarchy.length - 1, e = o; e >= 0; e -= 1) {
                var a = this.hierarchy[e].finalTransform.mProp;
                this.mat.translate(-a.p.v[0], -a.p.v[1], a.p.v[2]),
                  this.mat
                    .rotateX(-a.or.v[0])
                    .rotateY(-a.or.v[1])
                    .rotateZ(a.or.v[2]),
                  this.mat.rotateX(-a.rx.v).rotateY(-a.ry.v).rotateZ(a.rz.v),
                  this.mat.scale(1 / a.s.v[0], 1 / a.s.v[1], 1 / a.s.v[2]),
                  this.mat.translate(a.a.v[0], a.a.v[1], a.a.v[2]);
              }
            if (
              (this.p
                ? this.mat.translate(-this.p.v[0], -this.p.v[1], this.p.v[2])
                : this.mat.translate(-this.px.v, -this.py.v, this.pz.v),
              this.a)
            ) {
              var c;
              this.p
                ? (c = [
                    this.p.v[0] - this.a.v[0],
                    this.p.v[1] - this.a.v[1],
                    this.p.v[2] - this.a.v[2],
                  ])
                : (c = [
                    this.px.v - this.a.v[0],
                    this.py.v - this.a.v[1],
                    this.pz.v - this.a.v[2],
                  ]);
              var d = Math.sqrt(
                  Math.pow(c[0], 2) + Math.pow(c[1], 2) + Math.pow(c[2], 2)
                ),
                g = [c[0] / d, c[1] / d, c[2] / d],
                _ = Math.sqrt(g[2] * g[2] + g[0] * g[0]),
                b = Math.atan2(g[1], _),
                j = Math.atan2(g[0], -g[2]);
              this.mat.rotateY(j).rotateX(-b);
            }
            this.mat.rotateX(-this.rx.v).rotateY(-this.ry.v).rotateZ(this.rz.v),
              this.mat
                .rotateX(-this.or.v[0])
                .rotateY(-this.or.v[1])
                .rotateZ(this.or.v[2]),
              this.mat.translate(
                this.globalData.compSize.w / 2,
                this.globalData.compSize.h / 2,
                0
              ),
              this.mat.translate(0, 0, this.pe.v);
            var $ = !this._prevMat.equals(this.mat);
            if (($ || this.pe._mdf) && this.comp.threeDElements) {
              o = this.comp.threeDElements.length;
              var _e, et, rt;
              for (e = 0; e < o; e += 1)
                if (((_e = this.comp.threeDElements[e]), _e.type === "3d")) {
                  if ($) {
                    var st = this.mat.toCSS();
                    (rt = _e.container.style),
                      (rt.transform = st),
                      (rt.webkitTransform = st);
                  }
                  this.pe._mdf &&
                    ((et = _e.perspectiveElem.style),
                    (et.perspective = this.pe.v + "px"),
                    (et.webkitPerspective = this.pe.v + "px"));
                }
              this.mat.clone(this._prevMat);
            }
          }
          this._isFirstFrame = !1;
        }),
        (HCameraElement.prototype.prepareFrame = function (s) {
          this.prepareProperties(s, !0);
        }),
        (HCameraElement.prototype.destroy = function () {}),
        (HCameraElement.prototype.getBaseElement = function () {
          return null;
        });
      function HImageElement(s, e, o) {
        (this.assetData = e.getAssetData(s.refId)), this.initElement(s, e, o);
      }
      extendPrototype(
        [
          BaseElement,
          TransformElement,
          HBaseElement,
          HSolidElement,
          HierarchyElement,
          FrameElement,
          RenderableElement,
        ],
        HImageElement
      ),
        (HImageElement.prototype.createContent = function () {
          var s = this.globalData.getAssetsPath(this.assetData),
            e = new Image();
          this.data.hasMask
            ? ((this.imageElem = createNS("image")),
              this.imageElem.setAttribute("width", this.assetData.w + "px"),
              this.imageElem.setAttribute("height", this.assetData.h + "px"),
              this.imageElem.setAttributeNS(
                "http://www.w3.org/1999/xlink",
                "href",
                s
              ),
              this.layerElement.appendChild(this.imageElem),
              this.baseElement.setAttribute("width", this.assetData.w),
              this.baseElement.setAttribute("height", this.assetData.h))
            : this.layerElement.appendChild(e),
            (e.crossOrigin = "anonymous"),
            (e.src = s),
            this.data.ln && this.baseElement.setAttribute("id", this.data.ln);
        });
      function HybridRendererBase(s, e) {
        (this.animationItem = s),
          (this.layers = null),
          (this.renderedFrame = -1),
          (this.renderConfig = {
            className: (e && e.className) || "",
            imagePreserveAspectRatio:
              (e && e.imagePreserveAspectRatio) || "xMidYMid slice",
            hideOnTransparent: !(e && e.hideOnTransparent === !1),
            filterSize: {
              width: (e && e.filterSize && e.filterSize.width) || "400%",
              height: (e && e.filterSize && e.filterSize.height) || "400%",
              x: (e && e.filterSize && e.filterSize.x) || "-100%",
              y: (e && e.filterSize && e.filterSize.y) || "-100%",
            },
          }),
          (this.globalData = {
            _mdf: !1,
            frameNum: -1,
            renderConfig: this.renderConfig,
          }),
          (this.pendingElements = []),
          (this.elements = []),
          (this.threeDElements = []),
          (this.destroyed = !1),
          (this.camera = null),
          (this.supports3d = !0),
          (this.rendererType = "html");
      }
      extendPrototype([BaseRenderer], HybridRendererBase),
        (HybridRendererBase.prototype.buildItem =
          SVGRenderer.prototype.buildItem),
        (HybridRendererBase.prototype.checkPendingElements = function () {
          for (; this.pendingElements.length; ) {
            var s = this.pendingElements.pop();
            s.checkParenting();
          }
        }),
        (HybridRendererBase.prototype.appendElementInPos = function (s, e) {
          var o = s.getBaseElement();
          if (o) {
            var a = this.layers[e];
            if (!a.ddd || !this.supports3d)
              if (this.threeDElements) this.addTo3dContainer(o, e);
              else {
                for (var c = 0, d, g, _; c < e; )
                  this.elements[c] &&
                    this.elements[c] !== !0 &&
                    this.elements[c].getBaseElement &&
                    ((g = this.elements[c]),
                    (_ = this.layers[c].ddd
                      ? this.getThreeDContainerByPos(c)
                      : g.getBaseElement()),
                    (d = _ || d)),
                    (c += 1);
                d
                  ? (!a.ddd || !this.supports3d) &&
                    this.layerElement.insertBefore(o, d)
                  : (!a.ddd || !this.supports3d) &&
                    this.layerElement.appendChild(o);
              }
            else this.addTo3dContainer(o, e);
          }
        }),
        (HybridRendererBase.prototype.createShape = function (s) {
          return this.supports3d
            ? new HShapeElement(s, this.globalData, this)
            : new SVGShapeElement(s, this.globalData, this);
        }),
        (HybridRendererBase.prototype.createText = function (s) {
          return this.supports3d
            ? new HTextElement(s, this.globalData, this)
            : new SVGTextLottieElement(s, this.globalData, this);
        }),
        (HybridRendererBase.prototype.createCamera = function (s) {
          return (
            (this.camera = new HCameraElement(s, this.globalData, this)),
            this.camera
          );
        }),
        (HybridRendererBase.prototype.createImage = function (s) {
          return this.supports3d
            ? new HImageElement(s, this.globalData, this)
            : new IImageElement(s, this.globalData, this);
        }),
        (HybridRendererBase.prototype.createSolid = function (s) {
          return this.supports3d
            ? new HSolidElement(s, this.globalData, this)
            : new ISolidElement(s, this.globalData, this);
        }),
        (HybridRendererBase.prototype.createNull =
          SVGRenderer.prototype.createNull),
        (HybridRendererBase.prototype.getThreeDContainerByPos = function (s) {
          for (var e = 0, o = this.threeDElements.length; e < o; ) {
            if (
              this.threeDElements[e].startPos <= s &&
              this.threeDElements[e].endPos >= s
            )
              return this.threeDElements[e].perspectiveElem;
            e += 1;
          }
          return null;
        }),
        (HybridRendererBase.prototype.createThreeDContainer = function (s, e) {
          var o = createTag("div"),
            a,
            c;
          styleDiv(o);
          var d = createTag("div");
          if ((styleDiv(d), e === "3d")) {
            (a = o.style),
              (a.width = this.globalData.compSize.w + "px"),
              (a.height = this.globalData.compSize.h + "px");
            var g = "50% 50%";
            (a.webkitTransformOrigin = g),
              (a.mozTransformOrigin = g),
              (a.transformOrigin = g),
              (c = d.style);
            var _ = "matrix3d(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1)";
            (c.transform = _), (c.webkitTransform = _);
          }
          o.appendChild(d);
          var b = {
            container: d,
            perspectiveElem: o,
            startPos: s,
            endPos: s,
            type: e,
          };
          return this.threeDElements.push(b), b;
        }),
        (HybridRendererBase.prototype.build3dContainers = function () {
          var s,
            e = this.layers.length,
            o,
            a = "";
          for (s = 0; s < e; s += 1)
            this.layers[s].ddd && this.layers[s].ty !== 3
              ? (a !== "3d" &&
                  ((a = "3d"), (o = this.createThreeDContainer(s, "3d"))),
                (o.endPos = Math.max(o.endPos, s)))
              : (a !== "2d" &&
                  ((a = "2d"), (o = this.createThreeDContainer(s, "2d"))),
                (o.endPos = Math.max(o.endPos, s)));
          for (e = this.threeDElements.length, s = e - 1; s >= 0; s -= 1)
            this.resizerElem.appendChild(
              this.threeDElements[s].perspectiveElem
            );
        }),
        (HybridRendererBase.prototype.addTo3dContainer = function (s, e) {
          for (var o = 0, a = this.threeDElements.length; o < a; ) {
            if (e <= this.threeDElements[o].endPos) {
              for (var c = this.threeDElements[o].startPos, d; c < e; )
                this.elements[c] &&
                  this.elements[c].getBaseElement &&
                  (d = this.elements[c].getBaseElement()),
                  (c += 1);
              d
                ? this.threeDElements[o].container.insertBefore(s, d)
                : this.threeDElements[o].container.appendChild(s);
              break;
            }
            o += 1;
          }
        }),
        (HybridRendererBase.prototype.configAnimation = function (s) {
          var e = createTag("div"),
            o = this.animationItem.wrapper,
            a = e.style;
          (a.width = s.w + "px"),
            (a.height = s.h + "px"),
            (this.resizerElem = e),
            styleDiv(e),
            (a.transformStyle = "flat"),
            (a.mozTransformStyle = "flat"),
            (a.webkitTransformStyle = "flat"),
            this.renderConfig.className &&
              e.setAttribute("class", this.renderConfig.className),
            o.appendChild(e),
            (a.overflow = "hidden");
          var c = createNS("svg");
          c.setAttribute("width", "1"),
            c.setAttribute("height", "1"),
            styleDiv(c),
            this.resizerElem.appendChild(c);
          var d = createNS("defs");
          c.appendChild(d),
            (this.data = s),
            this.setupGlobalData(s, c),
            (this.globalData.defs = d),
            (this.layers = s.layers),
            (this.layerElement = this.resizerElem),
            this.build3dContainers(),
            this.updateContainerSize();
        }),
        (HybridRendererBase.prototype.destroy = function () {
          this.animationItem.wrapper &&
            (this.animationItem.wrapper.innerText = ""),
            (this.animationItem.container = null),
            (this.globalData.defs = null);
          var s,
            e = this.layers ? this.layers.length : 0;
          for (s = 0; s < e; s += 1)
            this.elements[s] &&
              this.elements[s].destroy &&
              this.elements[s].destroy();
          (this.elements.length = 0),
            (this.destroyed = !0),
            (this.animationItem = null);
        }),
        (HybridRendererBase.prototype.updateContainerSize = function () {
          var s = this.animationItem.wrapper.offsetWidth,
            e = this.animationItem.wrapper.offsetHeight,
            o = s / e,
            a = this.globalData.compSize.w / this.globalData.compSize.h,
            c,
            d,
            g,
            _;
          a > o
            ? ((c = s / this.globalData.compSize.w),
              (d = s / this.globalData.compSize.w),
              (g = 0),
              (_ =
                (e -
                  this.globalData.compSize.h *
                    (s / this.globalData.compSize.w)) /
                2))
            : ((c = e / this.globalData.compSize.h),
              (d = e / this.globalData.compSize.h),
              (g =
                (s -
                  this.globalData.compSize.w *
                    (e / this.globalData.compSize.h)) /
                2),
              (_ = 0));
          var b = this.resizerElem.style;
          (b.webkitTransform =
            "matrix3d(" +
            c +
            ",0,0,0,0," +
            d +
            ",0,0,0,0,1,0," +
            g +
            "," +
            _ +
            ",0,1)"),
            (b.transform = b.webkitTransform);
        }),
        (HybridRendererBase.prototype.renderFrame =
          SVGRenderer.prototype.renderFrame),
        (HybridRendererBase.prototype.hide = function () {
          this.resizerElem.style.display = "none";
        }),
        (HybridRendererBase.prototype.show = function () {
          this.resizerElem.style.display = "block";
        }),
        (HybridRendererBase.prototype.initItems = function () {
          if ((this.buildAllItems(), this.camera)) this.camera.setup();
          else {
            var s = this.globalData.compSize.w,
              e = this.globalData.compSize.h,
              o,
              a = this.threeDElements.length;
            for (o = 0; o < a; o += 1) {
              var c = this.threeDElements[o].perspectiveElem.style;
              (c.webkitPerspective =
                Math.sqrt(Math.pow(s, 2) + Math.pow(e, 2)) + "px"),
                (c.perspective = c.webkitPerspective);
            }
          }
        }),
        (HybridRendererBase.prototype.searchExtraCompositions = function (s) {
          var e,
            o = s.length,
            a = createTag("div");
          for (e = 0; e < o; e += 1)
            if (s[e].xt) {
              var c = this.createComp(s[e], a, this.globalData.comp, null);
              c.initExpressions(),
                this.globalData.projectInterface.registerComposition(c);
            }
        });
      function HCompElement(s, e, o) {
        (this.layers = s.layers),
          (this.supports3d = !s.hasMask),
          (this.completeLayers = !1),
          (this.pendingElements = []),
          (this.elements = this.layers
            ? createSizedArray(this.layers.length)
            : []),
          this.initElement(s, e, o),
          (this.tm = s.tm
            ? PropertyFactory.getProp(this, s.tm, 0, e.frameRate, this)
            : { _placeholder: !0 });
      }
      extendPrototype(
        [HybridRendererBase, ICompElement, HBaseElement],
        HCompElement
      ),
        (HCompElement.prototype._createBaseContainerElements =
          HCompElement.prototype.createContainerElements),
        (HCompElement.prototype.createContainerElements = function () {
          this._createBaseContainerElements(),
            this.data.hasMask
              ? (this.svgElement.setAttribute("width", this.data.w),
                this.svgElement.setAttribute("height", this.data.h),
                (this.transformedElement = this.baseElement))
              : (this.transformedElement = this.layerElement);
        }),
        (HCompElement.prototype.addTo3dContainer = function (s, e) {
          for (var o = 0, a; o < e; )
            this.elements[o] &&
              this.elements[o].getBaseElement &&
              (a = this.elements[o].getBaseElement()),
              (o += 1);
          a
            ? this.layerElement.insertBefore(s, a)
            : this.layerElement.appendChild(s);
        }),
        (HCompElement.prototype.createComp = function (s) {
          return this.supports3d
            ? new HCompElement(s, this.globalData, this)
            : new SVGCompElement(s, this.globalData, this);
        });
      function HybridRenderer(s, e) {
        (this.animationItem = s),
          (this.layers = null),
          (this.renderedFrame = -1),
          (this.renderConfig = {
            className: (e && e.className) || "",
            imagePreserveAspectRatio:
              (e && e.imagePreserveAspectRatio) || "xMidYMid slice",
            hideOnTransparent: !(e && e.hideOnTransparent === !1),
            filterSize: {
              width: (e && e.filterSize && e.filterSize.width) || "400%",
              height: (e && e.filterSize && e.filterSize.height) || "400%",
              x: (e && e.filterSize && e.filterSize.x) || "-100%",
              y: (e && e.filterSize && e.filterSize.y) || "-100%",
            },
            runExpressions:
              !e || e.runExpressions === void 0 || e.runExpressions,
          }),
          (this.globalData = {
            _mdf: !1,
            frameNum: -1,
            renderConfig: this.renderConfig,
          }),
          (this.pendingElements = []),
          (this.elements = []),
          (this.threeDElements = []),
          (this.destroyed = !1),
          (this.camera = null),
          (this.supports3d = !0),
          (this.rendererType = "html");
      }
      extendPrototype([HybridRendererBase], HybridRenderer),
        (HybridRenderer.prototype.createComp = function (s) {
          return this.supports3d
            ? new HCompElement(s, this.globalData, this)
            : new SVGCompElement(s, this.globalData, this);
        });
      var CompExpressionInterface = (function () {
        return function (s) {
          function e(o) {
            for (var a = 0, c = s.layers.length; a < c; ) {
              if (s.layers[a].nm === o || s.layers[a].ind === o)
                return s.elements[a].layerInterface;
              a += 1;
            }
            return null;
          }
          return (
            Object.defineProperty(e, "_name", { value: s.data.nm }),
            (e.layer = e),
            (e.pixelAspect = 1),
            (e.height = s.data.h || s.globalData.compSize.h),
            (e.width = s.data.w || s.globalData.compSize.w),
            (e.pixelAspect = 1),
            (e.frameDuration = 1 / s.globalData.frameRate),
            (e.displayStartTime = 0),
            (e.numLayers = s.layers.length),
            e
          );
        };
      })();
      function _typeof$2(s) {
        "@babel/helpers - typeof";
        return (
          typeof Symbol == "function" && typeof Symbol.iterator == "symbol"
            ? (_typeof$2 = function (o) {
                return typeof o;
              })
            : (_typeof$2 = function (o) {
                return o &&
                  typeof Symbol == "function" &&
                  o.constructor === Symbol &&
                  o !== Symbol.prototype
                  ? "symbol"
                  : typeof o;
              }),
          _typeof$2(s)
        );
      }
      function seedRandom(s, e) {
        var o = this,
          a = 256,
          c = 6,
          d = 52,
          g = "random",
          _ = e.pow(a, c),
          b = e.pow(2, d),
          j = b * 2,
          $ = a - 1,
          _e;
        function et(ot, ut, pt) {
          var ft = [];
          ut = ut === !0 ? { entropy: !0 } : ut || {};
          var gt = ct(
              at(ut.entropy ? [ot, lt(s)] : ot === null ? it() : ot, 3),
              ft
            ),
            xt = new rt(ft),
            _t = function () {
              for (var Mt = xt.g(c), Rt = _, Ft = 0; Mt < b; )
                (Mt = (Mt + Ft) * a), (Rt *= a), (Ft = xt.g(1));
              for (; Mt >= j; ) (Mt /= 2), (Rt /= 2), (Ft >>>= 1);
              return (Mt + Ft) / Rt;
            };
          return (
            (_t.int32 = function () {
              return xt.g(4) | 0;
            }),
            (_t.quick = function () {
              return xt.g(4) / 4294967296;
            }),
            (_t.double = _t),
            ct(lt(xt.S), s),
            (
              ut.pass ||
              pt ||
              function (St, Mt, Rt, Ft) {
                return (
                  Ft &&
                    (Ft.S && st(Ft, xt),
                    (St.state = function () {
                      return st(xt, {});
                    })),
                  Rt ? ((e[g] = St), Mt) : St
                );
              }
            )(_t, gt, "global" in ut ? ut.global : this == e, ut.state)
          );
        }
        e["seed" + g] = et;
        function rt(ot) {
          var ut,
            pt = ot.length,
            ft = this,
            gt = 0,
            xt = (ft.i = ft.j = 0),
            _t = (ft.S = []);
          for (pt || (ot = [pt++]); gt < a; ) _t[gt] = gt++;
          for (gt = 0; gt < a; gt++)
            (_t[gt] = _t[(xt = $ & (xt + ot[gt % pt] + (ut = _t[gt])))]),
              (_t[xt] = ut);
          ft.g = function (St) {
            for (var Mt, Rt = 0, Ft = ft.i, Ot = ft.j, Lt = ft.S; St--; )
              (Mt = Lt[(Ft = $ & (Ft + 1))]),
                (Rt =
                  Rt * a +
                  Lt[
                    $ & ((Lt[Ft] = Lt[(Ot = $ & (Ot + Mt))]) + (Lt[Ot] = Mt))
                  ]);
            return (ft.i = Ft), (ft.j = Ot), Rt;
          };
        }
        function st(ot, ut) {
          return (ut.i = ot.i), (ut.j = ot.j), (ut.S = ot.S.slice()), ut;
        }
        function at(ot, ut) {
          var pt = [],
            ft = _typeof$2(ot),
            gt;
          if (ut && ft == "object")
            for (gt in ot)
              try {
                pt.push(at(ot[gt], ut - 1));
              } catch {}
          return pt.length ? pt : ft == "string" ? ot : ot + "\0";
        }
        function ct(ot, ut) {
          for (var pt = ot + "", ft, gt = 0; gt < pt.length; )
            ut[$ & gt] = $ & ((ft ^= ut[$ & gt] * 19) + pt.charCodeAt(gt++));
          return lt(ut);
        }
        function it() {
          try {
            var ot = new Uint8Array(a);
            return (o.crypto || o.msCrypto).getRandomValues(ot), lt(ot);
          } catch {
            var ut = o.navigator,
              pt = ut && ut.plugins;
            return [+new Date(), o, pt, o.screen, lt(s)];
          }
        }
        function lt(ot) {
          return String.fromCharCode.apply(0, ot);
        }
        ct(e.random(), s);
      }
      function initialize$2(s) {
        seedRandom([], s);
      }
      var propTypes = { SHAPE: "shape" };
      function _typeof$1(s) {
        "@babel/helpers - typeof";
        return (
          typeof Symbol == "function" && typeof Symbol.iterator == "symbol"
            ? (_typeof$1 = function (o) {
                return typeof o;
              })
            : (_typeof$1 = function (o) {
                return o &&
                  typeof Symbol == "function" &&
                  o.constructor === Symbol &&
                  o !== Symbol.prototype
                  ? "symbol"
                  : typeof o;
              }),
          _typeof$1(s)
        );
      }
      var ExpressionManager = (function () {
          var ob = {},
            Math = BMMath,
            window = null,
            document = null,
            XMLHttpRequest = null,
            fetch = null,
            frames = null,
            _lottieGlobal = {};
          initialize$2(BMMath);
          function resetFrame() {
            _lottieGlobal = {};
          }
          function $bm_isInstanceOfArray(s) {
            return s.constructor === Array || s.constructor === Float32Array;
          }
          function isNumerable(s, e) {
            return (
              s === "number" ||
              e instanceof Number ||
              s === "boolean" ||
              s === "string"
            );
          }
          function $bm_neg(s) {
            var e = _typeof$1(s);
            if (e === "number" || s instanceof Number || e === "boolean")
              return -s;
            if ($bm_isInstanceOfArray(s)) {
              var o,
                a = s.length,
                c = [];
              for (o = 0; o < a; o += 1) c[o] = -s[o];
              return c;
            }
            return s.propType ? s.v : -s;
          }
          var easeInBez = BezierFactory.getBezierEasing(
              0.333,
              0,
              0.833,
              0.833,
              "easeIn"
            ).get,
            easeOutBez = BezierFactory.getBezierEasing(
              0.167,
              0.167,
              0.667,
              1,
              "easeOut"
            ).get,
            easeInOutBez = BezierFactory.getBezierEasing(
              0.33,
              0,
              0.667,
              1,
              "easeInOut"
            ).get;
          function sum(s, e) {
            var o = _typeof$1(s),
              a = _typeof$1(e);
            if (
              (isNumerable(o, s) && isNumerable(a, e)) ||
              o === "string" ||
              a === "string"
            )
              return s + e;
            if ($bm_isInstanceOfArray(s) && isNumerable(a, e))
              return (s = s.slice(0)), (s[0] += e), s;
            if (isNumerable(o, s) && $bm_isInstanceOfArray(e))
              return (e = e.slice(0)), (e[0] = s + e[0]), e;
            if ($bm_isInstanceOfArray(s) && $bm_isInstanceOfArray(e)) {
              for (
                var c = 0, d = s.length, g = e.length, _ = [];
                c < d || c < g;

              )
                (typeof s[c] == "number" || s[c] instanceof Number) &&
                (typeof e[c] == "number" || e[c] instanceof Number)
                  ? (_[c] = s[c] + e[c])
                  : (_[c] = e[c] === void 0 ? s[c] : s[c] || e[c]),
                  (c += 1);
              return _;
            }
            return 0;
          }
          var add = sum;
          function sub(s, e) {
            var o = _typeof$1(s),
              a = _typeof$1(e);
            if (isNumerable(o, s) && isNumerable(a, e))
              return (
                o === "string" && (s = parseInt(s, 10)),
                a === "string" && (e = parseInt(e, 10)),
                s - e
              );
            if ($bm_isInstanceOfArray(s) && isNumerable(a, e))
              return (s = s.slice(0)), (s[0] -= e), s;
            if (isNumerable(o, s) && $bm_isInstanceOfArray(e))
              return (e = e.slice(0)), (e[0] = s - e[0]), e;
            if ($bm_isInstanceOfArray(s) && $bm_isInstanceOfArray(e)) {
              for (
                var c = 0, d = s.length, g = e.length, _ = [];
                c < d || c < g;

              )
                (typeof s[c] == "number" || s[c] instanceof Number) &&
                (typeof e[c] == "number" || e[c] instanceof Number)
                  ? (_[c] = s[c] - e[c])
                  : (_[c] = e[c] === void 0 ? s[c] : s[c] || e[c]),
                  (c += 1);
              return _;
            }
            return 0;
          }
          function mul(s, e) {
            var o = _typeof$1(s),
              a = _typeof$1(e),
              c;
            if (isNumerable(o, s) && isNumerable(a, e)) return s * e;
            var d, g;
            if ($bm_isInstanceOfArray(s) && isNumerable(a, e)) {
              for (
                g = s.length, c = createTypedArray("float32", g), d = 0;
                d < g;
                d += 1
              )
                c[d] = s[d] * e;
              return c;
            }
            if (isNumerable(o, s) && $bm_isInstanceOfArray(e)) {
              for (
                g = e.length, c = createTypedArray("float32", g), d = 0;
                d < g;
                d += 1
              )
                c[d] = s * e[d];
              return c;
            }
            return 0;
          }
          function div(s, e) {
            var o = _typeof$1(s),
              a = _typeof$1(e),
              c;
            if (isNumerable(o, s) && isNumerable(a, e)) return s / e;
            var d, g;
            if ($bm_isInstanceOfArray(s) && isNumerable(a, e)) {
              for (
                g = s.length, c = createTypedArray("float32", g), d = 0;
                d < g;
                d += 1
              )
                c[d] = s[d] / e;
              return c;
            }
            if (isNumerable(o, s) && $bm_isInstanceOfArray(e)) {
              for (
                g = e.length, c = createTypedArray("float32", g), d = 0;
                d < g;
                d += 1
              )
                c[d] = s / e[d];
              return c;
            }
            return 0;
          }
          function mod(s, e) {
            return (
              typeof s == "string" && (s = parseInt(s, 10)),
              typeof e == "string" && (e = parseInt(e, 10)),
              s % e
            );
          }
          var $bm_sum = sum,
            $bm_sub = sub,
            $bm_mul = mul,
            $bm_div = div,
            $bm_mod = mod;
          function clamp(s, e, o) {
            if (e > o) {
              var a = o;
              (o = e), (e = a);
            }
            return Math.min(Math.max(s, e), o);
          }
          function radiansToDegrees(s) {
            return s / degToRads;
          }
          var radians_to_degrees = radiansToDegrees;
          function degreesToRadians(s) {
            return s * degToRads;
          }
          var degrees_to_radians = radiansToDegrees,
            helperLengthArray = [0, 0, 0, 0, 0, 0];
          function length(s, e) {
            if (typeof s == "number" || s instanceof Number)
              return (e = e || 0), Math.abs(s - e);
            e || (e = helperLengthArray);
            var o,
              a = Math.min(s.length, e.length),
              c = 0;
            for (o = 0; o < a; o += 1) c += Math.pow(e[o] - s[o], 2);
            return Math.sqrt(c);
          }
          function normalize(s) {
            return div(s, length(s));
          }
          function rgbToHsl(s) {
            var e = s[0],
              o = s[1],
              a = s[2],
              c = Math.max(e, o, a),
              d = Math.min(e, o, a),
              g,
              _,
              b = (c + d) / 2;
            if (c === d) (g = 0), (_ = 0);
            else {
              var j = c - d;
              switch (((_ = b > 0.5 ? j / (2 - c - d) : j / (c + d)), c)) {
                case e:
                  g = (o - a) / j + (o < a ? 6 : 0);
                  break;
                case o:
                  g = (a - e) / j + 2;
                  break;
                case a:
                  g = (e - o) / j + 4;
                  break;
              }
              g /= 6;
            }
            return [g, _, b, s[3]];
          }
          function hue2rgb(s, e, o) {
            return (
              o < 0 && (o += 1),
              o > 1 && (o -= 1),
              o < 1 / 6
                ? s + (e - s) * 6 * o
                : o < 1 / 2
                ? e
                : o < 2 / 3
                ? s + (e - s) * (2 / 3 - o) * 6
                : s
            );
          }
          function hslToRgb(s) {
            var e = s[0],
              o = s[1],
              a = s[2],
              c,
              d,
              g;
            if (o === 0) (c = a), (g = a), (d = a);
            else {
              var _ = a < 0.5 ? a * (1 + o) : a + o - a * o,
                b = 2 * a - _;
              (c = hue2rgb(b, _, e + 1 / 3)),
                (d = hue2rgb(b, _, e)),
                (g = hue2rgb(b, _, e - 1 / 3));
            }
            return [c, d, g, s[3]];
          }
          function linear(s, e, o, a, c) {
            if (
              ((a === void 0 || c === void 0) &&
                ((a = e), (c = o), (e = 0), (o = 1)),
              o < e)
            ) {
              var d = o;
              (o = e), (e = d);
            }
            if (s <= e) return a;
            if (s >= o) return c;
            var g = o === e ? 0 : (s - e) / (o - e);
            if (!a.length) return a + (c - a) * g;
            var _,
              b = a.length,
              j = createTypedArray("float32", b);
            for (_ = 0; _ < b; _ += 1) j[_] = a[_] + (c[_] - a[_]) * g;
            return j;
          }
          function random(s, e) {
            if (
              (e === void 0 &&
                (s === void 0 ? ((s = 0), (e = 1)) : ((e = s), (s = void 0))),
              e.length)
            ) {
              var o,
                a = e.length;
              s || (s = createTypedArray("float32", a));
              var c = createTypedArray("float32", a),
                d = BMMath.random();
              for (o = 0; o < a; o += 1) c[o] = s[o] + d * (e[o] - s[o]);
              return c;
            }
            s === void 0 && (s = 0);
            var g = BMMath.random();
            return s + g * (e - s);
          }
          function createPath(s, e, o, a) {
            var c,
              d = s.length,
              g = shapePool.newElement();
            g.setPathData(!!a, d);
            var _ = [0, 0],
              b,
              j;
            for (c = 0; c < d; c += 1)
              (b = e && e[c] ? e[c] : _),
                (j = o && o[c] ? o[c] : _),
                g.setTripleAt(
                  s[c][0],
                  s[c][1],
                  j[0] + s[c][0],
                  j[1] + s[c][1],
                  b[0] + s[c][0],
                  b[1] + s[c][1],
                  c,
                  !0
                );
            return g;
          }
          function initiateExpression(elem, data, property) {
            function noOp(s) {
              return s;
            }
            if (!elem.globalData.renderConfig.runExpressions) return noOp;
            var val = data.x,
              needsVelocity = /velocity(?![\w\d])/.test(val),
              _needsRandom = val.indexOf("random") !== -1,
              elemType = elem.data.ty,
              transform,
              $bm_transform,
              content,
              effect,
              thisProperty = property;
            (thisProperty.valueAtTime = thisProperty.getValueAtTime),
              Object.defineProperty(thisProperty, "value", {
                get: function () {
                  return thisProperty.v;
                },
              }),
              (elem.comp.frameDuration = 1 / elem.comp.globalData.frameRate),
              (elem.comp.displayStartTime = 0);
            var inPoint = elem.data.ip / elem.comp.globalData.frameRate,
              outPoint = elem.data.op / elem.comp.globalData.frameRate,
              width = elem.data.sw ? elem.data.sw : 0,
              height = elem.data.sh ? elem.data.sh : 0,
              name = elem.data.nm,
              loopIn,
              loop_in,
              loopOut,
              loop_out,
              smooth,
              toWorld,
              fromWorld,
              fromComp,
              toComp,
              fromCompToSurface,
              position,
              rotation,
              anchorPoint,
              scale,
              thisLayer,
              thisComp,
              mask,
              valueAtTime,
              velocityAtTime,
              scoped_bm_rt,
              expression_function = eval(
                "[function _expression_function(){" +
                  val +
                  ";scoped_bm_rt=$bm_rt}]"
              )[0],
              numKeys = property.kf ? data.k.length : 0,
              active = !this.data || this.data.hd !== !0,
              wiggle = function s(e, o) {
                var a,
                  c,
                  d = this.pv.length ? this.pv.length : 1,
                  g = createTypedArray("float32", d);
                e = 5;
                var _ = Math.floor(time * e);
                for (a = 0, c = 0; a < _; ) {
                  for (c = 0; c < d; c += 1)
                    g[c] += -o + o * 2 * BMMath.random();
                  a += 1;
                }
                var b = time * e,
                  j = b - Math.floor(b),
                  $ = createTypedArray("float32", d);
                if (d > 1) {
                  for (c = 0; c < d; c += 1)
                    $[c] =
                      this.pv[c] + g[c] + (-o + o * 2 * BMMath.random()) * j;
                  return $;
                }
                return this.pv + g[0] + (-o + o * 2 * BMMath.random()) * j;
              }.bind(this);
            thisProperty.loopIn &&
              ((loopIn = thisProperty.loopIn.bind(thisProperty)),
              (loop_in = loopIn)),
              thisProperty.loopOut &&
                ((loopOut = thisProperty.loopOut.bind(thisProperty)),
                (loop_out = loopOut)),
              thisProperty.smooth &&
                (smooth = thisProperty.smooth.bind(thisProperty));
            function loopInDuration(s, e) {
              return loopIn(s, e, !0);
            }
            function loopOutDuration(s, e) {
              return loopOut(s, e, !0);
            }
            this.getValueAtTime &&
              (valueAtTime = this.getValueAtTime.bind(this)),
              this.getVelocityAtTime &&
                (velocityAtTime = this.getVelocityAtTime.bind(this));
            var comp = elem.comp.globalData.projectInterface.bind(
              elem.comp.globalData.projectInterface
            );
            function lookAt(s, e) {
              var o = [e[0] - s[0], e[1] - s[1], e[2] - s[2]],
                a =
                  Math.atan2(o[0], Math.sqrt(o[1] * o[1] + o[2] * o[2])) /
                  degToRads,
                c = -Math.atan2(o[1], o[2]) / degToRads;
              return [c, a, 0];
            }
            function easeOut(s, e, o, a, c) {
              return applyEase(easeOutBez, s, e, o, a, c);
            }
            function easeIn(s, e, o, a, c) {
              return applyEase(easeInBez, s, e, o, a, c);
            }
            function ease(s, e, o, a, c) {
              return applyEase(easeInOutBez, s, e, o, a, c);
            }
            function applyEase(s, e, o, a, c, d) {
              c === void 0 ? ((c = o), (d = a)) : (e = (e - o) / (a - o)),
                e > 1 ? (e = 1) : e < 0 && (e = 0);
              var g = s(e);
              if ($bm_isInstanceOfArray(c)) {
                var _,
                  b = c.length,
                  j = createTypedArray("float32", b);
                for (_ = 0; _ < b; _ += 1) j[_] = (d[_] - c[_]) * g + c[_];
                return j;
              }
              return (d - c) * g + c;
            }
            function nearestKey(s) {
              var e,
                o = data.k.length,
                a,
                c;
              if (!data.k.length || typeof data.k[0] == "number")
                (a = 0), (c = 0);
              else if (
                ((a = -1),
                (s *= elem.comp.globalData.frameRate),
                s < data.k[0].t)
              )
                (a = 1), (c = data.k[0].t);
              else {
                for (e = 0; e < o - 1; e += 1)
                  if (s === data.k[e].t) {
                    (a = e + 1), (c = data.k[e].t);
                    break;
                  } else if (s > data.k[e].t && s < data.k[e + 1].t) {
                    s - data.k[e].t > data.k[e + 1].t - s
                      ? ((a = e + 2), (c = data.k[e + 1].t))
                      : ((a = e + 1), (c = data.k[e].t));
                    break;
                  }
                a === -1 && ((a = e + 1), (c = data.k[e].t));
              }
              var d = {};
              return (
                (d.index = a), (d.time = c / elem.comp.globalData.frameRate), d
              );
            }
            function key(s) {
              var e, o, a;
              if (!data.k.length || typeof data.k[0] == "number")
                throw new Error("The property has no keyframe at index " + s);
              (s -= 1),
                (e = {
                  time: data.k[s].t / elem.comp.globalData.frameRate,
                  value: [],
                });
              var c = Object.prototype.hasOwnProperty.call(data.k[s], "s")
                ? data.k[s].s
                : data.k[s - 1].e;
              for (a = c.length, o = 0; o < a; o += 1)
                (e[o] = c[o]), (e.value[o] = c[o]);
              return e;
            }
            function framesToTime(s, e) {
              return e || (e = elem.comp.globalData.frameRate), s / e;
            }
            function timeToFrames(s, e) {
              return (
                !s && s !== 0 && (s = time),
                e || (e = elem.comp.globalData.frameRate),
                s * e
              );
            }
            function seedRandom(s) {
              BMMath.seedrandom(randSeed + s);
            }
            function sourceRectAtTime() {
              return elem.sourceRectAtTime();
            }
            function substring(s, e) {
              return typeof value == "string"
                ? e === void 0
                  ? value.substring(s)
                  : value.substring(s, e)
                : "";
            }
            function substr(s, e) {
              return typeof value == "string"
                ? e === void 0
                  ? value.substr(s)
                  : value.substr(s, e)
                : "";
            }
            function posterizeTime(s) {
              (time = s === 0 ? 0 : Math.floor(time * s) / s),
                (value = valueAtTime(time));
            }
            var time,
              velocity,
              value,
              text,
              textIndex,
              textTotal,
              selectorValue,
              index = elem.data.ind,
              hasParent = !!(elem.hierarchy && elem.hierarchy.length),
              parent,
              randSeed = Math.floor(Math.random() * 1e6),
              globalData = elem.globalData;
            function executeExpression(s) {
              return (
                (value = s),
                this.frameExpressionId === elem.globalData.frameId &&
                this.propType !== "textSelector"
                  ? value
                  : (this.propType === "textSelector" &&
                      ((textIndex = this.textIndex),
                      (textTotal = this.textTotal),
                      (selectorValue = this.selectorValue)),
                    thisLayer ||
                      ((text = elem.layerInterface.text),
                      (thisLayer = elem.layerInterface),
                      (thisComp = elem.comp.compInterface),
                      (toWorld = thisLayer.toWorld.bind(thisLayer)),
                      (fromWorld = thisLayer.fromWorld.bind(thisLayer)),
                      (fromComp = thisLayer.fromComp.bind(thisLayer)),
                      (toComp = thisLayer.toComp.bind(thisLayer)),
                      (mask = thisLayer.mask
                        ? thisLayer.mask.bind(thisLayer)
                        : null),
                      (fromCompToSurface = fromComp)),
                    transform ||
                      ((transform = elem.layerInterface(
                        "ADBE Transform Group"
                      )),
                      ($bm_transform = transform),
                      transform && (anchorPoint = transform.anchorPoint)),
                    elemType === 4 &&
                      !content &&
                      (content = thisLayer("ADBE Root Vectors Group")),
                    effect || (effect = thisLayer(4)),
                    (hasParent = !!(elem.hierarchy && elem.hierarchy.length)),
                    hasParent &&
                      !parent &&
                      (parent = elem.hierarchy[0].layerInterface),
                    (time =
                      this.comp.renderedFrame / this.comp.globalData.frameRate),
                    _needsRandom && seedRandom(randSeed + time),
                    needsVelocity && (velocity = velocityAtTime(time)),
                    expression_function(),
                    (this.frameExpressionId = elem.globalData.frameId),
                    (scoped_bm_rt =
                      scoped_bm_rt.propType === propTypes.SHAPE
                        ? scoped_bm_rt.v
                        : scoped_bm_rt),
                    scoped_bm_rt)
              );
            }
            return (
              (executeExpression.__preventDeadCodeRemoval = [
                $bm_transform,
                anchorPoint,
                time,
                velocity,
                inPoint,
                outPoint,
                width,
                height,
                name,
                loop_in,
                loop_out,
                smooth,
                toComp,
                fromCompToSurface,
                toWorld,
                fromWorld,
                mask,
                position,
                rotation,
                scale,
                thisComp,
                numKeys,
                active,
                wiggle,
                loopInDuration,
                loopOutDuration,
                comp,
                lookAt,
                easeOut,
                easeIn,
                ease,
                nearestKey,
                key,
                text,
                textIndex,
                textTotal,
                selectorValue,
                framesToTime,
                timeToFrames,
                sourceRectAtTime,
                substring,
                substr,
                posterizeTime,
                index,
                globalData,
              ]),
              executeExpression
            );
          }
          return (
            (ob.initiateExpression = initiateExpression),
            (ob.__preventDeadCodeRemoval = [
              window,
              document,
              XMLHttpRequest,
              fetch,
              frames,
              $bm_neg,
              add,
              $bm_sum,
              $bm_sub,
              $bm_mul,
              $bm_div,
              $bm_mod,
              clamp,
              radians_to_degrees,
              degreesToRadians,
              degrees_to_radians,
              normalize,
              rgbToHsl,
              hslToRgb,
              linear,
              random,
              createPath,
              _lottieGlobal,
            ]),
            (ob.resetFrame = resetFrame),
            ob
          );
        })(),
        Expressions = (function () {
          var s = {};
          (s.initExpressions = e),
            (s.resetFrame = ExpressionManager.resetFrame);
          function e(o) {
            var a = 0,
              c = [];
            function d() {
              a += 1;
            }
            function g() {
              (a -= 1), a === 0 && b();
            }
            function _(j) {
              c.indexOf(j) === -1 && c.push(j);
            }
            function b() {
              var j,
                $ = c.length;
              for (j = 0; j < $; j += 1) c[j].release();
              c.length = 0;
            }
            (o.renderer.compInterface = CompExpressionInterface(o.renderer)),
              o.renderer.globalData.projectInterface.registerComposition(
                o.renderer
              ),
              (o.renderer.globalData.pushExpression = d),
              (o.renderer.globalData.popExpression = g),
              (o.renderer.globalData.registerExpressionProperty = _);
          }
          return s;
        })(),
        MaskManagerInterface = (function () {
          function s(o, a) {
            (this._mask = o), (this._data = a);
          }
          Object.defineProperty(s.prototype, "maskPath", {
            get: function () {
              return (
                this._mask.prop.k && this._mask.prop.getValue(), this._mask.prop
              );
            },
          }),
            Object.defineProperty(s.prototype, "maskOpacity", {
              get: function () {
                return (
                  this._mask.op.k && this._mask.op.getValue(),
                  this._mask.op.v * 100
                );
              },
            });
          var e = function (a) {
            var c = createSizedArray(a.viewData.length),
              d,
              g = a.viewData.length;
            for (d = 0; d < g; d += 1)
              c[d] = new s(a.viewData[d], a.masksProperties[d]);
            var _ = function (j) {
              for (d = 0; d < g; ) {
                if (a.masksProperties[d].nm === j) return c[d];
                d += 1;
              }
              return null;
            };
            return _;
          };
          return e;
        })(),
        ExpressionPropertyInterface = (function () {
          var s = { pv: 0, v: 0, mult: 1 },
            e = { pv: [0, 0, 0], v: [0, 0, 0], mult: 1 };
          function o(g, _, b) {
            Object.defineProperty(g, "velocity", {
              get: function () {
                return _.getVelocityAtTime(_.comp.currentFrame);
              },
            }),
              (g.numKeys = _.keyframes ? _.keyframes.length : 0),
              (g.key = function (j) {
                if (!g.numKeys) return 0;
                var $ = "";
                "s" in _.keyframes[j - 1]
                  ? ($ = _.keyframes[j - 1].s)
                  : "e" in _.keyframes[j - 2]
                  ? ($ = _.keyframes[j - 2].e)
                  : ($ = _.keyframes[j - 2].s);
                var _e =
                  b === "unidimensional" ? new Number($) : Object.assign({}, $);
                return (
                  (_e.time =
                    _.keyframes[j - 1].t / _.elem.comp.globalData.frameRate),
                  (_e.value = b === "unidimensional" ? $[0] : $),
                  _e
                );
              }),
              (g.valueAtTime = _.getValueAtTime),
              (g.speedAtTime = _.getSpeedAtTime),
              (g.velocityAtTime = _.getVelocityAtTime),
              (g.propertyGroup = _.propertyGroup);
          }
          function a(g) {
            (!g || !("pv" in g)) && (g = s);
            var _ = 1 / g.mult,
              b = g.pv * _,
              j = new Number(b);
            return (
              (j.value = b),
              o(j, g, "unidimensional"),
              function () {
                return (
                  g.k && g.getValue(),
                  (b = g.v * _),
                  j.value !== b &&
                    ((j = new Number(b)),
                    (j.value = b),
                    o(j, g, "unidimensional")),
                  j
                );
              }
            );
          }
          function c(g) {
            (!g || !("pv" in g)) && (g = e);
            var _ = 1 / g.mult,
              b = (g.data && g.data.l) || g.pv.length,
              j = createTypedArray("float32", b),
              $ = createTypedArray("float32", b);
            return (
              (j.value = $),
              o(j, g, "multidimensional"),
              function () {
                g.k && g.getValue();
                for (var _e = 0; _e < b; _e += 1)
                  ($[_e] = g.v[_e] * _), (j[_e] = $[_e]);
                return j;
              }
            );
          }
          function d() {
            return s;
          }
          return function (g) {
            return g ? (g.propType === "unidimensional" ? a(g) : c(g)) : d;
          };
        })(),
        TransformExpressionInterface = (function () {
          return function (s) {
            function e(g) {
              switch (g) {
                case "scale":
                case "Scale":
                case "ADBE Scale":
                case 6:
                  return e.scale;
                case "rotation":
                case "Rotation":
                case "ADBE Rotation":
                case "ADBE Rotate Z":
                case 10:
                  return e.rotation;
                case "ADBE Rotate X":
                  return e.xRotation;
                case "ADBE Rotate Y":
                  return e.yRotation;
                case "position":
                case "Position":
                case "ADBE Position":
                case 2:
                  return e.position;
                case "ADBE Position_0":
                  return e.xPosition;
                case "ADBE Position_1":
                  return e.yPosition;
                case "ADBE Position_2":
                  return e.zPosition;
                case "anchorPoint":
                case "AnchorPoint":
                case "Anchor Point":
                case "ADBE AnchorPoint":
                case 1:
                  return e.anchorPoint;
                case "opacity":
                case "Opacity":
                case 11:
                  return e.opacity;
                default:
                  return null;
              }
            }
            Object.defineProperty(e, "rotation", {
              get: ExpressionPropertyInterface(s.r || s.rz),
            }),
              Object.defineProperty(e, "zRotation", {
                get: ExpressionPropertyInterface(s.rz || s.r),
              }),
              Object.defineProperty(e, "xRotation", {
                get: ExpressionPropertyInterface(s.rx),
              }),
              Object.defineProperty(e, "yRotation", {
                get: ExpressionPropertyInterface(s.ry),
              }),
              Object.defineProperty(e, "scale", {
                get: ExpressionPropertyInterface(s.s),
              });
            var o, a, c, d;
            return (
              s.p
                ? (d = ExpressionPropertyInterface(s.p))
                : ((o = ExpressionPropertyInterface(s.px)),
                  (a = ExpressionPropertyInterface(s.py)),
                  s.pz && (c = ExpressionPropertyInterface(s.pz))),
              Object.defineProperty(e, "position", {
                get: function () {
                  return s.p ? d() : [o(), a(), c ? c() : 0];
                },
              }),
              Object.defineProperty(e, "xPosition", {
                get: ExpressionPropertyInterface(s.px),
              }),
              Object.defineProperty(e, "yPosition", {
                get: ExpressionPropertyInterface(s.py),
              }),
              Object.defineProperty(e, "zPosition", {
                get: ExpressionPropertyInterface(s.pz),
              }),
              Object.defineProperty(e, "anchorPoint", {
                get: ExpressionPropertyInterface(s.a),
              }),
              Object.defineProperty(e, "opacity", {
                get: ExpressionPropertyInterface(s.o),
              }),
              Object.defineProperty(e, "skew", {
                get: ExpressionPropertyInterface(s.sk),
              }),
              Object.defineProperty(e, "skewAxis", {
                get: ExpressionPropertyInterface(s.sa),
              }),
              Object.defineProperty(e, "orientation", {
                get: ExpressionPropertyInterface(s.or),
              }),
              e
            );
          };
        })(),
        LayerExpressionInterface = (function () {
          function s(j) {
            var $ = new Matrix();
            if (j !== void 0) {
              var _e = this._elem.finalTransform.mProp.getValueAtTime(j);
              _e.clone($);
            } else {
              var et = this._elem.finalTransform.mProp;
              et.applyToMatrix($);
            }
            return $;
          }
          function e(j, $) {
            var _e = this.getMatrix($);
            return (
              (_e.props[12] = 0),
              (_e.props[13] = 0),
              (_e.props[14] = 0),
              this.applyPoint(_e, j)
            );
          }
          function o(j, $) {
            var _e = this.getMatrix($);
            return this.applyPoint(_e, j);
          }
          function a(j, $) {
            var _e = this.getMatrix($);
            return (
              (_e.props[12] = 0),
              (_e.props[13] = 0),
              (_e.props[14] = 0),
              this.invertPoint(_e, j)
            );
          }
          function c(j, $) {
            var _e = this.getMatrix($);
            return this.invertPoint(_e, j);
          }
          function d(j, $) {
            if (this._elem.hierarchy && this._elem.hierarchy.length) {
              var _e,
                et = this._elem.hierarchy.length;
              for (_e = 0; _e < et; _e += 1)
                this._elem.hierarchy[_e].finalTransform.mProp.applyToMatrix(j);
            }
            return j.applyToPointArray($[0], $[1], $[2] || 0);
          }
          function g(j, $) {
            if (this._elem.hierarchy && this._elem.hierarchy.length) {
              var _e,
                et = this._elem.hierarchy.length;
              for (_e = 0; _e < et; _e += 1)
                this._elem.hierarchy[_e].finalTransform.mProp.applyToMatrix(j);
            }
            return j.inversePoint($);
          }
          function _(j) {
            var $ = new Matrix();
            if (
              ($.reset(),
              this._elem.finalTransform.mProp.applyToMatrix($),
              this._elem.hierarchy && this._elem.hierarchy.length)
            ) {
              var _e,
                et = this._elem.hierarchy.length;
              for (_e = 0; _e < et; _e += 1)
                this._elem.hierarchy[_e].finalTransform.mProp.applyToMatrix($);
              return $.inversePoint(j);
            }
            return $.inversePoint(j);
          }
          function b() {
            return [1, 1, 1, 1];
          }
          return function (j) {
            var $;
            function _e(at) {
              rt.mask = new MaskManagerInterface(at, j);
            }
            function et(at) {
              rt.effect = at;
            }
            function rt(at) {
              switch (at) {
                case "ADBE Root Vectors Group":
                case "Contents":
                case 2:
                  return rt.shapeInterface;
                case 1:
                case 6:
                case "Transform":
                case "transform":
                case "ADBE Transform Group":
                  return $;
                case 4:
                case "ADBE Effect Parade":
                case "effects":
                case "Effects":
                  return rt.effect;
                case "ADBE Text Properties":
                  return rt.textInterface;
                default:
                  return null;
              }
            }
            (rt.getMatrix = s),
              (rt.invertPoint = g),
              (rt.applyPoint = d),
              (rt.toWorld = o),
              (rt.toWorldVec = e),
              (rt.fromWorld = c),
              (rt.fromWorldVec = a),
              (rt.toComp = o),
              (rt.fromComp = _),
              (rt.sampleImage = b),
              (rt.sourceRectAtTime = j.sourceRectAtTime.bind(j)),
              (rt._elem = j),
              ($ = TransformExpressionInterface(j.finalTransform.mProp));
            var st = getDescriptor($, "anchorPoint");
            return (
              Object.defineProperties(rt, {
                hasParent: {
                  get: function () {
                    return j.hierarchy.length;
                  },
                },
                parent: {
                  get: function () {
                    return j.hierarchy[0].layerInterface;
                  },
                },
                rotation: getDescriptor($, "rotation"),
                scale: getDescriptor($, "scale"),
                position: getDescriptor($, "position"),
                opacity: getDescriptor($, "opacity"),
                anchorPoint: st,
                anchor_point: st,
                transform: {
                  get: function () {
                    return $;
                  },
                },
                active: {
                  get: function () {
                    return j.isInRange;
                  },
                },
              }),
              (rt.startTime = j.data.st),
              (rt.index = j.data.ind),
              (rt.source = j.data.refId),
              (rt.height = j.data.ty === 0 ? j.data.h : 100),
              (rt.width = j.data.ty === 0 ? j.data.w : 100),
              (rt.inPoint = j.data.ip / j.comp.globalData.frameRate),
              (rt.outPoint = j.data.op / j.comp.globalData.frameRate),
              (rt._name = j.data.nm),
              (rt.registerMaskInterface = _e),
              (rt.registerEffectsInterface = et),
              rt
            );
          };
        })(),
        propertyGroupFactory = (function () {
          return function (s, e) {
            return function (o) {
              return (o = o === void 0 ? 1 : o), o <= 0 ? s : e(o - 1);
            };
          };
        })(),
        PropertyInterface = (function () {
          return function (s, e) {
            var o = { _name: s };
            function a(c) {
              return (c = c === void 0 ? 1 : c), c <= 0 ? o : e(c - 1);
            }
            return a;
          };
        })(),
        EffectsExpressionInterface = (function () {
          var s = { createEffectsInterface: e };
          function e(c, d) {
            if (c.effectsManager) {
              var g = [],
                _ = c.data.ef,
                b,
                j = c.effectsManager.effectElements.length;
              for (b = 0; b < j; b += 1)
                g.push(o(_[b], c.effectsManager.effectElements[b], d, c));
              var $ = c.data.ef || [],
                _e = function (rt) {
                  for (b = 0, j = $.length; b < j; ) {
                    if (rt === $[b].nm || rt === $[b].mn || rt === $[b].ix)
                      return g[b];
                    b += 1;
                  }
                  return null;
                };
              return (
                Object.defineProperty(_e, "numProperties", {
                  get: function () {
                    return $.length;
                  },
                }),
                _e
              );
            }
            return null;
          }
          function o(c, d, g, _) {
            function b(rt) {
              for (var st = c.ef, at = 0, ct = st.length; at < ct; ) {
                if (rt === st[at].nm || rt === st[at].mn || rt === st[at].ix)
                  return st[at].ty === 5 ? $[at] : $[at]();
                at += 1;
              }
              throw new Error();
            }
            var j = propertyGroupFactory(b, g),
              $ = [],
              _e,
              et = c.ef.length;
            for (_e = 0; _e < et; _e += 1)
              c.ef[_e].ty === 5
                ? $.push(
                    o(
                      c.ef[_e],
                      d.effectElements[_e],
                      d.effectElements[_e].propertyGroup,
                      _
                    )
                  )
                : $.push(a(d.effectElements[_e], c.ef[_e].ty, _, j));
            return (
              c.mn === "ADBE Color Control" &&
                Object.defineProperty(b, "color", {
                  get: function () {
                    return $[0]();
                  },
                }),
              Object.defineProperties(b, {
                numProperties: {
                  get: function () {
                    return c.np;
                  },
                },
                _name: { value: c.nm },
                propertyGroup: { value: j },
              }),
              (b.enabled = c.en !== 0),
              (b.active = b.enabled),
              b
            );
          }
          function a(c, d, g, _) {
            var b = ExpressionPropertyInterface(c.p);
            function j() {
              return d === 10 ? g.comp.compInterface(c.p.v) : b();
            }
            return (
              c.p.setGroupProperty &&
                c.p.setGroupProperty(PropertyInterface("", _)),
              j
            );
          }
          return s;
        })(),
        ShapePathInterface = (function () {
          return function (e, o, a) {
            var c = o.sh;
            function d(_) {
              return _ === "Shape" ||
                _ === "shape" ||
                _ === "Path" ||
                _ === "path" ||
                _ === "ADBE Vector Shape" ||
                _ === 2
                ? d.path
                : null;
            }
            var g = propertyGroupFactory(d, a);
            return (
              c.setGroupProperty(PropertyInterface("Path", g)),
              Object.defineProperties(d, {
                path: {
                  get: function () {
                    return c.k && c.getValue(), c;
                  },
                },
                shape: {
                  get: function () {
                    return c.k && c.getValue(), c;
                  },
                },
                _name: { value: e.nm },
                ix: { value: e.ix },
                propertyIndex: { value: e.ix },
                mn: { value: e.mn },
                propertyGroup: { value: a },
              }),
              d
            );
          };
        })(),
        ShapeExpressionInterface = (function () {
          function s(st, at, ct) {
            var it = [],
              lt,
              ot = st ? st.length : 0;
            for (lt = 0; lt < ot; lt += 1)
              st[lt].ty === "gr"
                ? it.push(o(st[lt], at[lt], ct))
                : st[lt].ty === "fl"
                ? it.push(a(st[lt], at[lt], ct))
                : st[lt].ty === "st"
                ? it.push(g(st[lt], at[lt], ct))
                : st[lt].ty === "tm"
                ? it.push(_(st[lt], at[lt], ct))
                : st[lt].ty === "tr" ||
                  (st[lt].ty === "el"
                    ? it.push(j(st[lt], at[lt], ct))
                    : st[lt].ty === "sr"
                    ? it.push($(st[lt], at[lt], ct))
                    : st[lt].ty === "sh"
                    ? it.push(ShapePathInterface(st[lt], at[lt], ct))
                    : st[lt].ty === "rc"
                    ? it.push(_e(st[lt], at[lt], ct))
                    : st[lt].ty === "rd"
                    ? it.push(et(st[lt], at[lt], ct))
                    : st[lt].ty === "rp"
                    ? it.push(rt(st[lt], at[lt], ct))
                    : st[lt].ty === "gf"
                    ? it.push(c(st[lt], at[lt], ct))
                    : it.push(d(st[lt], at[lt])));
            return it;
          }
          function e(st, at, ct) {
            var it,
              lt = function (pt) {
                for (var ft = 0, gt = it.length; ft < gt; ) {
                  if (
                    it[ft]._name === pt ||
                    it[ft].mn === pt ||
                    it[ft].propertyIndex === pt ||
                    it[ft].ix === pt ||
                    it[ft].ind === pt
                  )
                    return it[ft];
                  ft += 1;
                }
                return typeof pt == "number" ? it[pt - 1] : null;
              };
            (lt.propertyGroup = propertyGroupFactory(lt, ct)),
              (it = s(st.it, at.it, lt.propertyGroup)),
              (lt.numProperties = it.length);
            var ot = b(
              st.it[st.it.length - 1],
              at.it[at.it.length - 1],
              lt.propertyGroup
            );
            return (
              (lt.transform = ot),
              (lt.propertyIndex = st.cix),
              (lt._name = st.nm),
              lt
            );
          }
          function o(st, at, ct) {
            var it = function (pt) {
              switch (pt) {
                case "ADBE Vectors Group":
                case "Contents":
                case 2:
                  return it.content;
                default:
                  return it.transform;
              }
            };
            it.propertyGroup = propertyGroupFactory(it, ct);
            var lt = e(st, at, it.propertyGroup),
              ot = b(
                st.it[st.it.length - 1],
                at.it[at.it.length - 1],
                it.propertyGroup
              );
            return (
              (it.content = lt),
              (it.transform = ot),
              Object.defineProperty(it, "_name", {
                get: function () {
                  return st.nm;
                },
              }),
              (it.numProperties = st.np),
              (it.propertyIndex = st.ix),
              (it.nm = st.nm),
              (it.mn = st.mn),
              it
            );
          }
          function a(st, at, ct) {
            function it(lt) {
              return lt === "Color" || lt === "color"
                ? it.color
                : lt === "Opacity" || lt === "opacity"
                ? it.opacity
                : null;
            }
            return (
              Object.defineProperties(it, {
                color: { get: ExpressionPropertyInterface(at.c) },
                opacity: { get: ExpressionPropertyInterface(at.o) },
                _name: { value: st.nm },
                mn: { value: st.mn },
              }),
              at.c.setGroupProperty(PropertyInterface("Color", ct)),
              at.o.setGroupProperty(PropertyInterface("Opacity", ct)),
              it
            );
          }
          function c(st, at, ct) {
            function it(lt) {
              return lt === "Start Point" || lt === "start point"
                ? it.startPoint
                : lt === "End Point" || lt === "end point"
                ? it.endPoint
                : lt === "Opacity" || lt === "opacity"
                ? it.opacity
                : null;
            }
            return (
              Object.defineProperties(it, {
                startPoint: { get: ExpressionPropertyInterface(at.s) },
                endPoint: { get: ExpressionPropertyInterface(at.e) },
                opacity: { get: ExpressionPropertyInterface(at.o) },
                type: {
                  get: function () {
                    return "a";
                  },
                },
                _name: { value: st.nm },
                mn: { value: st.mn },
              }),
              at.s.setGroupProperty(PropertyInterface("Start Point", ct)),
              at.e.setGroupProperty(PropertyInterface("End Point", ct)),
              at.o.setGroupProperty(PropertyInterface("Opacity", ct)),
              it
            );
          }
          function d() {
            function st() {
              return null;
            }
            return st;
          }
          function g(st, at, ct) {
            var it = propertyGroupFactory(gt, ct),
              lt = propertyGroupFactory(ft, it);
            function ot(xt) {
              Object.defineProperty(ft, st.d[xt].nm, {
                get: ExpressionPropertyInterface(at.d.dataProps[xt].p),
              });
            }
            var ut,
              pt = st.d ? st.d.length : 0,
              ft = {};
            for (ut = 0; ut < pt; ut += 1)
              ot(ut), at.d.dataProps[ut].p.setGroupProperty(lt);
            function gt(xt) {
              return xt === "Color" || xt === "color"
                ? gt.color
                : xt === "Opacity" || xt === "opacity"
                ? gt.opacity
                : xt === "Stroke Width" || xt === "stroke width"
                ? gt.strokeWidth
                : null;
            }
            return (
              Object.defineProperties(gt, {
                color: { get: ExpressionPropertyInterface(at.c) },
                opacity: { get: ExpressionPropertyInterface(at.o) },
                strokeWidth: { get: ExpressionPropertyInterface(at.w) },
                dash: {
                  get: function () {
                    return ft;
                  },
                },
                _name: { value: st.nm },
                mn: { value: st.mn },
              }),
              at.c.setGroupProperty(PropertyInterface("Color", it)),
              at.o.setGroupProperty(PropertyInterface("Opacity", it)),
              at.w.setGroupProperty(PropertyInterface("Stroke Width", it)),
              gt
            );
          }
          function _(st, at, ct) {
            function it(ot) {
              return ot === st.e.ix || ot === "End" || ot === "end"
                ? it.end
                : ot === st.s.ix
                ? it.start
                : ot === st.o.ix
                ? it.offset
                : null;
            }
            var lt = propertyGroupFactory(it, ct);
            return (
              (it.propertyIndex = st.ix),
              at.s.setGroupProperty(PropertyInterface("Start", lt)),
              at.e.setGroupProperty(PropertyInterface("End", lt)),
              at.o.setGroupProperty(PropertyInterface("Offset", lt)),
              (it.propertyIndex = st.ix),
              (it.propertyGroup = ct),
              Object.defineProperties(it, {
                start: { get: ExpressionPropertyInterface(at.s) },
                end: { get: ExpressionPropertyInterface(at.e) },
                offset: { get: ExpressionPropertyInterface(at.o) },
                _name: { value: st.nm },
              }),
              (it.mn = st.mn),
              it
            );
          }
          function b(st, at, ct) {
            function it(ot) {
              return st.a.ix === ot || ot === "Anchor Point"
                ? it.anchorPoint
                : st.o.ix === ot || ot === "Opacity"
                ? it.opacity
                : st.p.ix === ot || ot === "Position"
                ? it.position
                : st.r.ix === ot ||
                  ot === "Rotation" ||
                  ot === "ADBE Vector Rotation"
                ? it.rotation
                : st.s.ix === ot || ot === "Scale"
                ? it.scale
                : (st.sk && st.sk.ix === ot) || ot === "Skew"
                ? it.skew
                : (st.sa && st.sa.ix === ot) || ot === "Skew Axis"
                ? it.skewAxis
                : null;
            }
            var lt = propertyGroupFactory(it, ct);
            return (
              at.transform.mProps.o.setGroupProperty(
                PropertyInterface("Opacity", lt)
              ),
              at.transform.mProps.p.setGroupProperty(
                PropertyInterface("Position", lt)
              ),
              at.transform.mProps.a.setGroupProperty(
                PropertyInterface("Anchor Point", lt)
              ),
              at.transform.mProps.s.setGroupProperty(
                PropertyInterface("Scale", lt)
              ),
              at.transform.mProps.r.setGroupProperty(
                PropertyInterface("Rotation", lt)
              ),
              at.transform.mProps.sk &&
                (at.transform.mProps.sk.setGroupProperty(
                  PropertyInterface("Skew", lt)
                ),
                at.transform.mProps.sa.setGroupProperty(
                  PropertyInterface("Skew Angle", lt)
                )),
              at.transform.op.setGroupProperty(
                PropertyInterface("Opacity", lt)
              ),
              Object.defineProperties(it, {
                opacity: {
                  get: ExpressionPropertyInterface(at.transform.mProps.o),
                },
                position: {
                  get: ExpressionPropertyInterface(at.transform.mProps.p),
                },
                anchorPoint: {
                  get: ExpressionPropertyInterface(at.transform.mProps.a),
                },
                scale: {
                  get: ExpressionPropertyInterface(at.transform.mProps.s),
                },
                rotation: {
                  get: ExpressionPropertyInterface(at.transform.mProps.r),
                },
                skew: {
                  get: ExpressionPropertyInterface(at.transform.mProps.sk),
                },
                skewAxis: {
                  get: ExpressionPropertyInterface(at.transform.mProps.sa),
                },
                _name: { value: st.nm },
              }),
              (it.ty = "tr"),
              (it.mn = st.mn),
              (it.propertyGroup = ct),
              it
            );
          }
          function j(st, at, ct) {
            function it(ut) {
              return st.p.ix === ut
                ? it.position
                : st.s.ix === ut
                ? it.size
                : null;
            }
            var lt = propertyGroupFactory(it, ct);
            it.propertyIndex = st.ix;
            var ot = at.sh.ty === "tm" ? at.sh.prop : at.sh;
            return (
              ot.s.setGroupProperty(PropertyInterface("Size", lt)),
              ot.p.setGroupProperty(PropertyInterface("Position", lt)),
              Object.defineProperties(it, {
                size: { get: ExpressionPropertyInterface(ot.s) },
                position: { get: ExpressionPropertyInterface(ot.p) },
                _name: { value: st.nm },
              }),
              (it.mn = st.mn),
              it
            );
          }
          function $(st, at, ct) {
            function it(ut) {
              return st.p.ix === ut
                ? it.position
                : st.r.ix === ut
                ? it.rotation
                : st.pt.ix === ut
                ? it.points
                : st.or.ix === ut || ut === "ADBE Vector Star Outer Radius"
                ? it.outerRadius
                : st.os.ix === ut
                ? it.outerRoundness
                : st.ir &&
                  (st.ir.ix === ut || ut === "ADBE Vector Star Inner Radius")
                ? it.innerRadius
                : st.is && st.is.ix === ut
                ? it.innerRoundness
                : null;
            }
            var lt = propertyGroupFactory(it, ct),
              ot = at.sh.ty === "tm" ? at.sh.prop : at.sh;
            return (
              (it.propertyIndex = st.ix),
              ot.or.setGroupProperty(PropertyInterface("Outer Radius", lt)),
              ot.os.setGroupProperty(PropertyInterface("Outer Roundness", lt)),
              ot.pt.setGroupProperty(PropertyInterface("Points", lt)),
              ot.p.setGroupProperty(PropertyInterface("Position", lt)),
              ot.r.setGroupProperty(PropertyInterface("Rotation", lt)),
              st.ir &&
                (ot.ir.setGroupProperty(PropertyInterface("Inner Radius", lt)),
                ot.is.setGroupProperty(
                  PropertyInterface("Inner Roundness", lt)
                )),
              Object.defineProperties(it, {
                position: { get: ExpressionPropertyInterface(ot.p) },
                rotation: { get: ExpressionPropertyInterface(ot.r) },
                points: { get: ExpressionPropertyInterface(ot.pt) },
                outerRadius: { get: ExpressionPropertyInterface(ot.or) },
                outerRoundness: { get: ExpressionPropertyInterface(ot.os) },
                innerRadius: { get: ExpressionPropertyInterface(ot.ir) },
                innerRoundness: { get: ExpressionPropertyInterface(ot.is) },
                _name: { value: st.nm },
              }),
              (it.mn = st.mn),
              it
            );
          }
          function _e(st, at, ct) {
            function it(ut) {
              return st.p.ix === ut
                ? it.position
                : st.r.ix === ut
                ? it.roundness
                : st.s.ix === ut ||
                  ut === "Size" ||
                  ut === "ADBE Vector Rect Size"
                ? it.size
                : null;
            }
            var lt = propertyGroupFactory(it, ct),
              ot = at.sh.ty === "tm" ? at.sh.prop : at.sh;
            return (
              (it.propertyIndex = st.ix),
              ot.p.setGroupProperty(PropertyInterface("Position", lt)),
              ot.s.setGroupProperty(PropertyInterface("Size", lt)),
              ot.r.setGroupProperty(PropertyInterface("Rotation", lt)),
              Object.defineProperties(it, {
                position: { get: ExpressionPropertyInterface(ot.p) },
                roundness: { get: ExpressionPropertyInterface(ot.r) },
                size: { get: ExpressionPropertyInterface(ot.s) },
                _name: { value: st.nm },
              }),
              (it.mn = st.mn),
              it
            );
          }
          function et(st, at, ct) {
            function it(ut) {
              return st.r.ix === ut || ut === "Round Corners 1"
                ? it.radius
                : null;
            }
            var lt = propertyGroupFactory(it, ct),
              ot = at;
            return (
              (it.propertyIndex = st.ix),
              ot.rd.setGroupProperty(PropertyInterface("Radius", lt)),
              Object.defineProperties(it, {
                radius: { get: ExpressionPropertyInterface(ot.rd) },
                _name: { value: st.nm },
              }),
              (it.mn = st.mn),
              it
            );
          }
          function rt(st, at, ct) {
            function it(ut) {
              return st.c.ix === ut || ut === "Copies"
                ? it.copies
                : st.o.ix === ut || ut === "Offset"
                ? it.offset
                : null;
            }
            var lt = propertyGroupFactory(it, ct),
              ot = at;
            return (
              (it.propertyIndex = st.ix),
              ot.c.setGroupProperty(PropertyInterface("Copies", lt)),
              ot.o.setGroupProperty(PropertyInterface("Offset", lt)),
              Object.defineProperties(it, {
                copies: { get: ExpressionPropertyInterface(ot.c) },
                offset: { get: ExpressionPropertyInterface(ot.o) },
                _name: { value: st.nm },
              }),
              (it.mn = st.mn),
              it
            );
          }
          return function (st, at, ct) {
            var it;
            function lt(ut) {
              if (typeof ut == "number")
                return (
                  (ut = ut === void 0 ? 1 : ut), ut === 0 ? ct : it[ut - 1]
                );
              for (var pt = 0, ft = it.length; pt < ft; ) {
                if (it[pt]._name === ut) return it[pt];
                pt += 1;
              }
              return null;
            }
            function ot() {
              return ct;
            }
            return (
              (lt.propertyGroup = propertyGroupFactory(lt, ot)),
              (it = s(st, at, lt.propertyGroup)),
              (lt.numProperties = it.length),
              (lt._name = "Contents"),
              lt
            );
          };
        })(),
        TextExpressionInterface = (function () {
          return function (s) {
            var e;
            function o(a) {
              switch (a) {
                case "ADBE Text Document":
                  return o.sourceText;
                default:
                  return null;
              }
            }
            return (
              Object.defineProperty(o, "sourceText", {
                get: function () {
                  s.textProperty.getValue();
                  var c = s.textProperty.currentData.t;
                  return (
                    (!e || c !== e.value) &&
                      ((e = new String(c)),
                      (e.value = c || new String(c)),
                      Object.defineProperty(e, "style", {
                        get: function () {
                          return { fillColor: s.textProperty.currentData.fc };
                        },
                      })),
                    e
                  );
                },
              }),
              o
            );
          };
        })();
      function _typeof(s) {
        "@babel/helpers - typeof";
        return (
          typeof Symbol == "function" && typeof Symbol.iterator == "symbol"
            ? (_typeof = function (o) {
                return typeof o;
              })
            : (_typeof = function (o) {
                return o &&
                  typeof Symbol == "function" &&
                  o.constructor === Symbol &&
                  o !== Symbol.prototype
                  ? "symbol"
                  : typeof o;
              }),
          _typeof(s)
        );
      }
      var FootageInterface = (function () {
          var s = function (a) {
              var c = "",
                d = a.getFootageData();
              function g() {
                return (c = ""), (d = a.getFootageData()), _;
              }
              function _(b) {
                if (d[b])
                  return (c = b), (d = d[b]), _typeof(d) === "object" ? _ : d;
                var j = b.indexOf(c);
                if (j !== -1) {
                  var $ = parseInt(b.substr(j + c.length), 10);
                  return (d = d[$]), _typeof(d) === "object" ? _ : d;
                }
                return "";
              }
              return g;
            },
            e = function (a) {
              function c(d) {
                return d === "Outline" ? c.outlineInterface() : null;
              }
              return (c._name = "Outline"), (c.outlineInterface = s(a)), c;
            };
          return function (o) {
            function a(c) {
              return c === "Data" ? a.dataInterface : null;
            }
            return (a._name = "Data"), (a.dataInterface = e(o)), a;
          };
        })(),
        interfaces = {
          layer: LayerExpressionInterface,
          effects: EffectsExpressionInterface,
          comp: CompExpressionInterface,
          shape: ShapeExpressionInterface,
          text: TextExpressionInterface,
          footage: FootageInterface,
        };
      function getInterface(s) {
        return interfaces[s] || null;
      }
      var expressionHelpers = (function () {
        function s(g, _, b) {
          _.x &&
            ((b.k = !0),
            (b.x = !0),
            (b.initiateExpression = ExpressionManager.initiateExpression),
            b.effectsSequence.push(b.initiateExpression(g, _, b).bind(b)));
        }
        function e(g) {
          return (
            (g *= this.elem.globalData.frameRate),
            (g -= this.offsetTime),
            g !== this._cachingAtTime.lastFrame &&
              ((this._cachingAtTime.lastIndex =
                this._cachingAtTime.lastFrame < g
                  ? this._cachingAtTime.lastIndex
                  : 0),
              (this._cachingAtTime.value = this.interpolateValue(
                g,
                this._cachingAtTime
              )),
              (this._cachingAtTime.lastFrame = g)),
            this._cachingAtTime.value
          );
        }
        function o(g) {
          var _ = -0.01,
            b = this.getValueAtTime(g),
            j = this.getValueAtTime(g + _),
            $ = 0;
          if (b.length) {
            var _e;
            for (_e = 0; _e < b.length; _e += 1)
              $ += Math.pow(j[_e] - b[_e], 2);
            $ = Math.sqrt($) * 100;
          } else $ = 0;
          return $;
        }
        function a(g) {
          if (this.vel !== void 0) return this.vel;
          var _ = -0.001,
            b = this.getValueAtTime(g),
            j = this.getValueAtTime(g + _),
            $;
          if (b.length) {
            $ = createTypedArray("float32", b.length);
            var _e;
            for (_e = 0; _e < b.length; _e += 1) $[_e] = (j[_e] - b[_e]) / _;
          } else $ = (j - b) / _;
          return $;
        }
        function c() {
          return this.pv;
        }
        function d(g) {
          this.propertyGroup = g;
        }
        return {
          searchExpressions: s,
          getSpeedAtTime: o,
          getVelocityAtTime: a,
          getValueAtTime: e,
          getStaticValueAtTime: c,
          setGroupProperty: d,
        };
      })();
      function addPropertyDecorator() {
        function s(et, rt, st) {
          if (!this.k || !this.keyframes) return this.pv;
          et = et ? et.toLowerCase() : "";
          var at = this.comp.renderedFrame,
            ct = this.keyframes,
            it = ct[ct.length - 1].t;
          if (at <= it) return this.pv;
          var lt, ot;
          st
            ? (rt
                ? (lt = Math.abs(it - this.elem.comp.globalData.frameRate * rt))
                : (lt = Math.max(0, it - this.elem.data.ip)),
              (ot = it - lt))
            : ((!rt || rt > ct.length - 1) && (rt = ct.length - 1),
              (ot = ct[ct.length - 1 - rt].t),
              (lt = it - ot));
          var ut, pt, ft;
          if (et === "pingpong") {
            var gt = Math.floor((at - ot) / lt);
            if (gt % 2 !== 0)
              return this.getValueAtTime(
                (lt - ((at - ot) % lt) + ot) / this.comp.globalData.frameRate,
                0
              );
          } else if (et === "offset") {
            var xt = this.getValueAtTime(
                ot / this.comp.globalData.frameRate,
                0
              ),
              _t = this.getValueAtTime(it / this.comp.globalData.frameRate, 0),
              St = this.getValueAtTime(
                (((at - ot) % lt) + ot) / this.comp.globalData.frameRate,
                0
              ),
              Mt = Math.floor((at - ot) / lt);
            if (this.pv.length) {
              for (
                ft = new Array(xt.length), pt = ft.length, ut = 0;
                ut < pt;
                ut += 1
              )
                ft[ut] = (_t[ut] - xt[ut]) * Mt + St[ut];
              return ft;
            }
            return (_t - xt) * Mt + St;
          } else if (et === "continue") {
            var Rt = this.getValueAtTime(
                it / this.comp.globalData.frameRate,
                0
              ),
              Ft = this.getValueAtTime(
                (it - 0.001) / this.comp.globalData.frameRate,
                0
              );
            if (this.pv.length) {
              for (
                ft = new Array(Rt.length), pt = ft.length, ut = 0;
                ut < pt;
                ut += 1
              )
                ft[ut] =
                  Rt[ut] +
                  ((Rt[ut] - Ft[ut]) *
                    ((at - it) / this.comp.globalData.frameRate)) /
                    5e-4;
              return ft;
            }
            return Rt + (Rt - Ft) * ((at - it) / 0.001);
          }
          return this.getValueAtTime(
            (((at - ot) % lt) + ot) / this.comp.globalData.frameRate,
            0
          );
        }
        function e(et, rt, st) {
          if (!this.k) return this.pv;
          et = et ? et.toLowerCase() : "";
          var at = this.comp.renderedFrame,
            ct = this.keyframes,
            it = ct[0].t;
          if (at >= it) return this.pv;
          var lt, ot;
          st
            ? (rt
                ? (lt = Math.abs(this.elem.comp.globalData.frameRate * rt))
                : (lt = Math.max(0, this.elem.data.op - it)),
              (ot = it + lt))
            : ((!rt || rt > ct.length - 1) && (rt = ct.length - 1),
              (ot = ct[rt].t),
              (lt = ot - it));
          var ut, pt, ft;
          if (et === "pingpong") {
            var gt = Math.floor((it - at) / lt);
            if (gt % 2 === 0)
              return this.getValueAtTime(
                (((it - at) % lt) + it) / this.comp.globalData.frameRate,
                0
              );
          } else if (et === "offset") {
            var xt = this.getValueAtTime(
                it / this.comp.globalData.frameRate,
                0
              ),
              _t = this.getValueAtTime(ot / this.comp.globalData.frameRate, 0),
              St = this.getValueAtTime(
                (lt - ((it - at) % lt) + it) / this.comp.globalData.frameRate,
                0
              ),
              Mt = Math.floor((it - at) / lt) + 1;
            if (this.pv.length) {
              for (
                ft = new Array(xt.length), pt = ft.length, ut = 0;
                ut < pt;
                ut += 1
              )
                ft[ut] = St[ut] - (_t[ut] - xt[ut]) * Mt;
              return ft;
            }
            return St - (_t - xt) * Mt;
          } else if (et === "continue") {
            var Rt = this.getValueAtTime(
                it / this.comp.globalData.frameRate,
                0
              ),
              Ft = this.getValueAtTime(
                (it + 0.001) / this.comp.globalData.frameRate,
                0
              );
            if (this.pv.length) {
              for (
                ft = new Array(Rt.length), pt = ft.length, ut = 0;
                ut < pt;
                ut += 1
              )
                ft[ut] = Rt[ut] + ((Rt[ut] - Ft[ut]) * (it - at)) / 0.001;
              return ft;
            }
            return Rt + ((Rt - Ft) * (it - at)) / 0.001;
          }
          return this.getValueAtTime(
            (lt - (((it - at) % lt) + it)) / this.comp.globalData.frameRate,
            0
          );
        }
        function o(et, rt) {
          if (!this.k) return this.pv;
          if (((et = (et || 0.4) * 0.5), (rt = Math.floor(rt || 5)), rt <= 1))
            return this.pv;
          var st = this.comp.renderedFrame / this.comp.globalData.frameRate,
            at = st - et,
            ct = st + et,
            it = rt > 1 ? (ct - at) / (rt - 1) : 1,
            lt = 0,
            ot = 0,
            ut;
          this.pv.length
            ? (ut = createTypedArray("float32", this.pv.length))
            : (ut = 0);
          for (var pt; lt < rt; ) {
            if (((pt = this.getValueAtTime(at + lt * it)), this.pv.length))
              for (ot = 0; ot < this.pv.length; ot += 1) ut[ot] += pt[ot];
            else ut += pt;
            lt += 1;
          }
          if (this.pv.length)
            for (ot = 0; ot < this.pv.length; ot += 1) ut[ot] /= rt;
          else ut /= rt;
          return ut;
        }
        function a(et) {
          this._transformCachingAtTime ||
            (this._transformCachingAtTime = { v: new Matrix() });
          var rt = this._transformCachingAtTime.v;
          if (
            (rt.cloneFromProps(this.pre.props), this.appliedTransformations < 1)
          ) {
            var st = this.a.getValueAtTime(et);
            rt.translate(
              -st[0] * this.a.mult,
              -st[1] * this.a.mult,
              st[2] * this.a.mult
            );
          }
          if (this.appliedTransformations < 2) {
            var at = this.s.getValueAtTime(et);
            rt.scale(
              at[0] * this.s.mult,
              at[1] * this.s.mult,
              at[2] * this.s.mult
            );
          }
          if (this.sk && this.appliedTransformations < 3) {
            var ct = this.sk.getValueAtTime(et),
              it = this.sa.getValueAtTime(et);
            rt.skewFromAxis(-ct * this.sk.mult, it * this.sa.mult);
          }
          if (this.r && this.appliedTransformations < 4) {
            var lt = this.r.getValueAtTime(et);
            rt.rotate(-lt * this.r.mult);
          } else if (!this.r && this.appliedTransformations < 4) {
            var ot = this.rz.getValueAtTime(et),
              ut = this.ry.getValueAtTime(et),
              pt = this.rx.getValueAtTime(et),
              ft = this.or.getValueAtTime(et);
            rt.rotateZ(-ot * this.rz.mult)
              .rotateY(ut * this.ry.mult)
              .rotateX(pt * this.rx.mult)
              .rotateZ(-ft[2] * this.or.mult)
              .rotateY(ft[1] * this.or.mult)
              .rotateX(ft[0] * this.or.mult);
          }
          if (this.data.p && this.data.p.s) {
            var gt = this.px.getValueAtTime(et),
              xt = this.py.getValueAtTime(et);
            if (this.data.p.z) {
              var _t = this.pz.getValueAtTime(et);
              rt.translate(
                gt * this.px.mult,
                xt * this.py.mult,
                -_t * this.pz.mult
              );
            } else rt.translate(gt * this.px.mult, xt * this.py.mult, 0);
          } else {
            var St = this.p.getValueAtTime(et);
            rt.translate(
              St[0] * this.p.mult,
              St[1] * this.p.mult,
              -St[2] * this.p.mult
            );
          }
          return rt;
        }
        function c() {
          return this.v.clone(new Matrix());
        }
        var d = TransformPropertyFactory.getTransformProperty;
        TransformPropertyFactory.getTransformProperty = function (et, rt, st) {
          var at = d(et, rt, st);
          return (
            at.dynamicProperties.length
              ? (at.getValueAtTime = a.bind(at))
              : (at.getValueAtTime = c.bind(at)),
            (at.setGroupProperty = expressionHelpers.setGroupProperty),
            at
          );
        };
        var g = PropertyFactory.getProp;
        PropertyFactory.getProp = function (et, rt, st, at, ct) {
          var it = g(et, rt, st, at, ct);
          it.kf
            ? (it.getValueAtTime = expressionHelpers.getValueAtTime.bind(it))
            : (it.getValueAtTime =
                expressionHelpers.getStaticValueAtTime.bind(it)),
            (it.setGroupProperty = expressionHelpers.setGroupProperty),
            (it.loopOut = s),
            (it.loopIn = e),
            (it.smooth = o),
            (it.getVelocityAtTime =
              expressionHelpers.getVelocityAtTime.bind(it)),
            (it.getSpeedAtTime = expressionHelpers.getSpeedAtTime.bind(it)),
            (it.numKeys = rt.a === 1 ? rt.k.length : 0),
            (it.propertyIndex = rt.ix);
          var lt = 0;
          return (
            st !== 0 &&
              (lt = createTypedArray(
                "float32",
                rt.a === 1 ? rt.k[0].s.length : rt.k.length
              )),
            (it._cachingAtTime = {
              lastFrame: initialDefaultFrame,
              lastIndex: 0,
              value: lt,
            }),
            expressionHelpers.searchExpressions(et, rt, it),
            it.k && ct.addDynamicProperty(it),
            it
          );
        };
        function _(et) {
          return (
            this._cachingAtTime ||
              (this._cachingAtTime = {
                shapeValue: shapePool.clone(this.pv),
                lastIndex: 0,
                lastTime: initialDefaultFrame,
              }),
            (et *= this.elem.globalData.frameRate),
            (et -= this.offsetTime),
            et !== this._cachingAtTime.lastTime &&
              ((this._cachingAtTime.lastIndex =
                this._cachingAtTime.lastTime < et
                  ? this._caching.lastIndex
                  : 0),
              (this._cachingAtTime.lastTime = et),
              this.interpolateShape(
                et,
                this._cachingAtTime.shapeValue,
                this._cachingAtTime
              )),
            this._cachingAtTime.shapeValue
          );
        }
        var b = ShapePropertyFactory.getConstructorFunction(),
          j = ShapePropertyFactory.getKeyframedConstructorFunction();
        function $() {}
        ($.prototype = {
          vertices: function (rt, st) {
            this.k && this.getValue();
            var at = this.v;
            st !== void 0 && (at = this.getValueAtTime(st, 0));
            var ct,
              it = at._length,
              lt = at[rt],
              ot = at.v,
              ut = createSizedArray(it);
            for (ct = 0; ct < it; ct += 1)
              rt === "i" || rt === "o"
                ? (ut[ct] = [lt[ct][0] - ot[ct][0], lt[ct][1] - ot[ct][1]])
                : (ut[ct] = [lt[ct][0], lt[ct][1]]);
            return ut;
          },
          points: function (rt) {
            return this.vertices("v", rt);
          },
          inTangents: function (rt) {
            return this.vertices("i", rt);
          },
          outTangents: function (rt) {
            return this.vertices("o", rt);
          },
          isClosed: function () {
            return this.v.c;
          },
          pointOnPath: function (rt, st) {
            var at = this.v;
            st !== void 0 && (at = this.getValueAtTime(st, 0)),
              this._segmentsLength ||
                (this._segmentsLength = bez.getSegmentsLength(at));
            for (
              var ct = this._segmentsLength,
                it = ct.lengths,
                lt = ct.totalLength * rt,
                ot = 0,
                ut = it.length,
                pt = 0,
                ft;
              ot < ut;

            ) {
              if (pt + it[ot].addedLength > lt) {
                var gt = ot,
                  xt = at.c && ot === ut - 1 ? 0 : ot + 1,
                  _t = (lt - pt) / it[ot].addedLength;
                ft = bez.getPointInSegment(
                  at.v[gt],
                  at.v[xt],
                  at.o[gt],
                  at.i[xt],
                  _t,
                  it[ot]
                );
                break;
              } else pt += it[ot].addedLength;
              ot += 1;
            }
            return (
              ft ||
                (ft = at.c
                  ? [at.v[0][0], at.v[0][1]]
                  : [at.v[at._length - 1][0], at.v[at._length - 1][1]]),
              ft
            );
          },
          vectorOnPath: function (rt, st, at) {
            rt == 1 ? (rt = this.v.c) : rt == 0 && (rt = 0.999);
            var ct = this.pointOnPath(rt, st),
              it = this.pointOnPath(rt + 0.001, st),
              lt = it[0] - ct[0],
              ot = it[1] - ct[1],
              ut = Math.sqrt(Math.pow(lt, 2) + Math.pow(ot, 2));
            if (ut === 0) return [0, 0];
            var pt =
              at === "tangent" ? [lt / ut, ot / ut] : [-ot / ut, lt / ut];
            return pt;
          },
          tangentOnPath: function (rt, st) {
            return this.vectorOnPath(rt, st, "tangent");
          },
          normalOnPath: function (rt, st) {
            return this.vectorOnPath(rt, st, "normal");
          },
          setGroupProperty: expressionHelpers.setGroupProperty,
          getValueAtTime: expressionHelpers.getStaticValueAtTime,
        }),
          extendPrototype([$], b),
          extendPrototype([$], j),
          (j.prototype.getValueAtTime = _),
          (j.prototype.initiateExpression =
            ExpressionManager.initiateExpression);
        var _e = ShapePropertyFactory.getShapeProp;
        ShapePropertyFactory.getShapeProp = function (et, rt, st, at, ct) {
          var it = _e(et, rt, st, at, ct);
          return (
            (it.propertyIndex = rt.ix),
            (it.lock = !1),
            st === 3
              ? expressionHelpers.searchExpressions(et, rt.pt, it)
              : st === 4 && expressionHelpers.searchExpressions(et, rt.ks, it),
            it.k && et.addDynamicProperty(it),
            it
          );
        };
      }
      function initialize$1() {
        addPropertyDecorator();
      }
      function addDecorator() {
        function s() {
          return this.data.d.x
            ? ((this.calculateExpression =
                ExpressionManager.initiateExpression.bind(this)(
                  this.elem,
                  this.data.d,
                  this
                )),
              this.addEffect(this.getExpressionValue.bind(this)),
              !0)
            : null;
        }
        (TextProperty.prototype.getExpressionValue = function (e, o) {
          var a = this.calculateExpression(o);
          if (e.t !== a) {
            var c = {};
            return (
              this.copyData(c, e), (c.t = a.toString()), (c.__complete = !1), c
            );
          }
          return e;
        }),
          (TextProperty.prototype.searchProperty = function () {
            var e = this.searchKeyframes(),
              o = this.searchExpressions();
            return (this.kf = e || o), this.kf;
          }),
          (TextProperty.prototype.searchExpressions = s);
      }
      function initialize() {
        addDecorator();
      }
      function SVGComposableEffect() {}
      SVGComposableEffect.prototype = {
        createMergeNode: function s(e, o) {
          var a = createNS("feMerge");
          a.setAttribute("result", e);
          var c, d;
          for (d = 0; d < o.length; d += 1)
            (c = createNS("feMergeNode")),
              c.setAttribute("in", o[d]),
              a.appendChild(c),
              a.appendChild(c);
          return a;
        },
      };
      var linearFilterValue =
        "0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0 0 0";
      function SVGTintFilter(s, e, o, a, c) {
        this.filterManager = e;
        var d = createNS("feColorMatrix");
        d.setAttribute("type", "matrix"),
          d.setAttribute("color-interpolation-filters", "linearRGB"),
          d.setAttribute("values", linearFilterValue + " 1 0"),
          (this.linearFilter = d),
          d.setAttribute("result", a + "_tint_1"),
          s.appendChild(d),
          (d = createNS("feColorMatrix")),
          d.setAttribute("type", "matrix"),
          d.setAttribute("color-interpolation-filters", "sRGB"),
          d.setAttribute("values", "1 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 1 0"),
          d.setAttribute("result", a + "_tint_2"),
          s.appendChild(d),
          (this.matrixFilter = d);
        var g = this.createMergeNode(a, [c, a + "_tint_1", a + "_tint_2"]);
        s.appendChild(g);
      }
      extendPrototype([SVGComposableEffect], SVGTintFilter),
        (SVGTintFilter.prototype.renderFrame = function (s) {
          if (s || this.filterManager._mdf) {
            var e = this.filterManager.effectElements[0].p.v,
              o = this.filterManager.effectElements[1].p.v,
              a = this.filterManager.effectElements[2].p.v / 100;
            this.linearFilter.setAttribute(
              "values",
              linearFilterValue + " " + a + " 0"
            ),
              this.matrixFilter.setAttribute(
                "values",
                o[0] -
                  e[0] +
                  " 0 0 0 " +
                  e[0] +
                  " " +
                  (o[1] - e[1]) +
                  " 0 0 0 " +
                  e[1] +
                  " " +
                  (o[2] - e[2]) +
                  " 0 0 0 " +
                  e[2] +
                  " 0 0 0 1 0"
              );
          }
        });
      function SVGFillFilter(s, e, o, a) {
        this.filterManager = e;
        var c = createNS("feColorMatrix");
        c.setAttribute("type", "matrix"),
          c.setAttribute("color-interpolation-filters", "sRGB"),
          c.setAttribute("values", "1 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 1 0"),
          c.setAttribute("result", a),
          s.appendChild(c),
          (this.matrixFilter = c);
      }
      SVGFillFilter.prototype.renderFrame = function (s) {
        if (s || this.filterManager._mdf) {
          var e = this.filterManager.effectElements[2].p.v,
            o = this.filterManager.effectElements[6].p.v;
          this.matrixFilter.setAttribute(
            "values",
            "0 0 0 0 " +
              e[0] +
              " 0 0 0 0 " +
              e[1] +
              " 0 0 0 0 " +
              e[2] +
              " 0 0 0 " +
              o +
              " 0"
          );
        }
      };
      function SVGStrokeEffect(s, e, o) {
        (this.initialized = !1),
          (this.filterManager = e),
          (this.elem = o),
          (this.paths = []);
      }
      (SVGStrokeEffect.prototype.initialize = function () {
        var s =
            this.elem.layerElement.children ||
            this.elem.layerElement.childNodes,
          e,
          o,
          a,
          c;
        for (
          this.filterManager.effectElements[1].p.v === 1
            ? ((c = this.elem.maskManager.masksProperties.length), (a = 0))
            : ((a = this.filterManager.effectElements[0].p.v - 1), (c = a + 1)),
            o = createNS("g"),
            o.setAttribute("fill", "none"),
            o.setAttribute("stroke-linecap", "round"),
            o.setAttribute("stroke-dashoffset", 1),
            a;
          a < c;
          a += 1
        )
          (e = createNS("path")),
            o.appendChild(e),
            this.paths.push({ p: e, m: a });
        if (this.filterManager.effectElements[10].p.v === 3) {
          var d = createNS("mask"),
            g = createElementID();
          d.setAttribute("id", g),
            d.setAttribute("mask-type", "alpha"),
            d.appendChild(o),
            this.elem.globalData.defs.appendChild(d);
          var _ = createNS("g");
          for (
            _.setAttribute("mask", "url(" + getLocationHref() + "#" + g + ")");
            s[0];

          )
            _.appendChild(s[0]);
          this.elem.layerElement.appendChild(_),
            (this.masker = d),
            o.setAttribute("stroke", "#fff");
        } else if (
          this.filterManager.effectElements[10].p.v === 1 ||
          this.filterManager.effectElements[10].p.v === 2
        ) {
          if (this.filterManager.effectElements[10].p.v === 2)
            for (
              s =
                this.elem.layerElement.children ||
                this.elem.layerElement.childNodes;
              s.length;

            )
              this.elem.layerElement.removeChild(s[0]);
          this.elem.layerElement.appendChild(o),
            this.elem.layerElement.removeAttribute("mask"),
            o.setAttribute("stroke", "#fff");
        }
        (this.initialized = !0), (this.pathMasker = o);
      }),
        (SVGStrokeEffect.prototype.renderFrame = function (s) {
          this.initialized || this.initialize();
          var e,
            o = this.paths.length,
            a,
            c;
          for (e = 0; e < o; e += 1)
            if (
              this.paths[e].m !== -1 &&
              ((a = this.elem.maskManager.viewData[this.paths[e].m]),
              (c = this.paths[e].p),
              (s || this.filterManager._mdf || a.prop._mdf) &&
                c.setAttribute("d", a.lastPath),
              s ||
                this.filterManager.effectElements[9].p._mdf ||
                this.filterManager.effectElements[4].p._mdf ||
                this.filterManager.effectElements[7].p._mdf ||
                this.filterManager.effectElements[8].p._mdf ||
                a.prop._mdf)
            ) {
              var d;
              if (
                this.filterManager.effectElements[7].p.v !== 0 ||
                this.filterManager.effectElements[8].p.v !== 100
              ) {
                var g =
                    Math.min(
                      this.filterManager.effectElements[7].p.v,
                      this.filterManager.effectElements[8].p.v
                    ) * 0.01,
                  _ =
                    Math.max(
                      this.filterManager.effectElements[7].p.v,
                      this.filterManager.effectElements[8].p.v
                    ) * 0.01,
                  b = c.getTotalLength();
                d = "0 0 0 " + b * g + " ";
                var j = b * (_ - g),
                  $ =
                    1 +
                    this.filterManager.effectElements[4].p.v *
                      2 *
                      this.filterManager.effectElements[9].p.v *
                      0.01,
                  _e = Math.floor(j / $),
                  et;
                for (et = 0; et < _e; et += 1)
                  d +=
                    "1 " +
                    this.filterManager.effectElements[4].p.v *
                      2 *
                      this.filterManager.effectElements[9].p.v *
                      0.01 +
                    " ";
                d += "0 " + b * 10 + " 0 0";
              } else
                d =
                  "1 " +
                  this.filterManager.effectElements[4].p.v *
                    2 *
                    this.filterManager.effectElements[9].p.v *
                    0.01;
              c.setAttribute("stroke-dasharray", d);
            }
          if (
            ((s || this.filterManager.effectElements[4].p._mdf) &&
              this.pathMasker.setAttribute(
                "stroke-width",
                this.filterManager.effectElements[4].p.v * 2
              ),
            (s || this.filterManager.effectElements[6].p._mdf) &&
              this.pathMasker.setAttribute(
                "opacity",
                this.filterManager.effectElements[6].p.v
              ),
            (this.filterManager.effectElements[10].p.v === 1 ||
              this.filterManager.effectElements[10].p.v === 2) &&
              (s || this.filterManager.effectElements[3].p._mdf))
          ) {
            var rt = this.filterManager.effectElements[3].p.v;
            this.pathMasker.setAttribute(
              "stroke",
              "rgb(" +
                bmFloor(rt[0] * 255) +
                "," +
                bmFloor(rt[1] * 255) +
                "," +
                bmFloor(rt[2] * 255) +
                ")"
            );
          }
        });
      function SVGTritoneFilter(s, e, o, a) {
        this.filterManager = e;
        var c = createNS("feColorMatrix");
        c.setAttribute("type", "matrix"),
          c.setAttribute("color-interpolation-filters", "linearRGB"),
          c.setAttribute(
            "values",
            "0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0 0 0 1 0"
          ),
          s.appendChild(c);
        var d = createNS("feComponentTransfer");
        d.setAttribute("color-interpolation-filters", "sRGB"),
          d.setAttribute("result", a),
          (this.matrixFilter = d);
        var g = createNS("feFuncR");
        g.setAttribute("type", "table"), d.appendChild(g), (this.feFuncR = g);
        var _ = createNS("feFuncG");
        _.setAttribute("type", "table"), d.appendChild(_), (this.feFuncG = _);
        var b = createNS("feFuncB");
        b.setAttribute("type", "table"),
          d.appendChild(b),
          (this.feFuncB = b),
          s.appendChild(d);
      }
      SVGTritoneFilter.prototype.renderFrame = function (s) {
        if (s || this.filterManager._mdf) {
          var e = this.filterManager.effectElements[0].p.v,
            o = this.filterManager.effectElements[1].p.v,
            a = this.filterManager.effectElements[2].p.v,
            c = a[0] + " " + o[0] + " " + e[0],
            d = a[1] + " " + o[1] + " " + e[1],
            g = a[2] + " " + o[2] + " " + e[2];
          this.feFuncR.setAttribute("tableValues", c),
            this.feFuncG.setAttribute("tableValues", d),
            this.feFuncB.setAttribute("tableValues", g);
        }
      };
      function SVGProLevelsFilter(s, e, o, a) {
        this.filterManager = e;
        var c = this.filterManager.effectElements,
          d = createNS("feComponentTransfer");
        (c[10].p.k ||
          c[10].p.v !== 0 ||
          c[11].p.k ||
          c[11].p.v !== 1 ||
          c[12].p.k ||
          c[12].p.v !== 1 ||
          c[13].p.k ||
          c[13].p.v !== 0 ||
          c[14].p.k ||
          c[14].p.v !== 1) &&
          (this.feFuncR = this.createFeFunc("feFuncR", d)),
          (c[17].p.k ||
            c[17].p.v !== 0 ||
            c[18].p.k ||
            c[18].p.v !== 1 ||
            c[19].p.k ||
            c[19].p.v !== 1 ||
            c[20].p.k ||
            c[20].p.v !== 0 ||
            c[21].p.k ||
            c[21].p.v !== 1) &&
            (this.feFuncG = this.createFeFunc("feFuncG", d)),
          (c[24].p.k ||
            c[24].p.v !== 0 ||
            c[25].p.k ||
            c[25].p.v !== 1 ||
            c[26].p.k ||
            c[26].p.v !== 1 ||
            c[27].p.k ||
            c[27].p.v !== 0 ||
            c[28].p.k ||
            c[28].p.v !== 1) &&
            (this.feFuncB = this.createFeFunc("feFuncB", d)),
          (c[31].p.k ||
            c[31].p.v !== 0 ||
            c[32].p.k ||
            c[32].p.v !== 1 ||
            c[33].p.k ||
            c[33].p.v !== 1 ||
            c[34].p.k ||
            c[34].p.v !== 0 ||
            c[35].p.k ||
            c[35].p.v !== 1) &&
            (this.feFuncA = this.createFeFunc("feFuncA", d)),
          (this.feFuncR || this.feFuncG || this.feFuncB || this.feFuncA) &&
            (d.setAttribute("color-interpolation-filters", "sRGB"),
            s.appendChild(d)),
          (c[3].p.k ||
            c[3].p.v !== 0 ||
            c[4].p.k ||
            c[4].p.v !== 1 ||
            c[5].p.k ||
            c[5].p.v !== 1 ||
            c[6].p.k ||
            c[6].p.v !== 0 ||
            c[7].p.k ||
            c[7].p.v !== 1) &&
            ((d = createNS("feComponentTransfer")),
            d.setAttribute("color-interpolation-filters", "sRGB"),
            d.setAttribute("result", a),
            s.appendChild(d),
            (this.feFuncRComposed = this.createFeFunc("feFuncR", d)),
            (this.feFuncGComposed = this.createFeFunc("feFuncG", d)),
            (this.feFuncBComposed = this.createFeFunc("feFuncB", d)));
      }
      (SVGProLevelsFilter.prototype.createFeFunc = function (s, e) {
        var o = createNS(s);
        return o.setAttribute("type", "table"), e.appendChild(o), o;
      }),
        (SVGProLevelsFilter.prototype.getTableValue = function (s, e, o, a, c) {
          for (
            var d = 0,
              g = 256,
              _,
              b = Math.min(s, e),
              j = Math.max(s, e),
              $ = Array.call(null, { length: g }),
              _e,
              et = 0,
              rt = c - a,
              st = e - s;
            d <= 256;

          )
            (_ = d / 256),
              _ <= b
                ? (_e = st < 0 ? c : a)
                : _ >= j
                ? (_e = st < 0 ? a : c)
                : (_e = a + rt * Math.pow((_ - s) / st, 1 / o)),
              ($[et] = _e),
              (et += 1),
              (d += 256 / (g - 1));
          return $.join(" ");
        }),
        (SVGProLevelsFilter.prototype.renderFrame = function (s) {
          if (s || this.filterManager._mdf) {
            var e,
              o = this.filterManager.effectElements;
            this.feFuncRComposed &&
              (s ||
                o[3].p._mdf ||
                o[4].p._mdf ||
                o[5].p._mdf ||
                o[6].p._mdf ||
                o[7].p._mdf) &&
              ((e = this.getTableValue(
                o[3].p.v,
                o[4].p.v,
                o[5].p.v,
                o[6].p.v,
                o[7].p.v
              )),
              this.feFuncRComposed.setAttribute("tableValues", e),
              this.feFuncGComposed.setAttribute("tableValues", e),
              this.feFuncBComposed.setAttribute("tableValues", e)),
              this.feFuncR &&
                (s ||
                  o[10].p._mdf ||
                  o[11].p._mdf ||
                  o[12].p._mdf ||
                  o[13].p._mdf ||
                  o[14].p._mdf) &&
                ((e = this.getTableValue(
                  o[10].p.v,
                  o[11].p.v,
                  o[12].p.v,
                  o[13].p.v,
                  o[14].p.v
                )),
                this.feFuncR.setAttribute("tableValues", e)),
              this.feFuncG &&
                (s ||
                  o[17].p._mdf ||
                  o[18].p._mdf ||
                  o[19].p._mdf ||
                  o[20].p._mdf ||
                  o[21].p._mdf) &&
                ((e = this.getTableValue(
                  o[17].p.v,
                  o[18].p.v,
                  o[19].p.v,
                  o[20].p.v,
                  o[21].p.v
                )),
                this.feFuncG.setAttribute("tableValues", e)),
              this.feFuncB &&
                (s ||
                  o[24].p._mdf ||
                  o[25].p._mdf ||
                  o[26].p._mdf ||
                  o[27].p._mdf ||
                  o[28].p._mdf) &&
                ((e = this.getTableValue(
                  o[24].p.v,
                  o[25].p.v,
                  o[26].p.v,
                  o[27].p.v,
                  o[28].p.v
                )),
                this.feFuncB.setAttribute("tableValues", e)),
              this.feFuncA &&
                (s ||
                  o[31].p._mdf ||
                  o[32].p._mdf ||
                  o[33].p._mdf ||
                  o[34].p._mdf ||
                  o[35].p._mdf) &&
                ((e = this.getTableValue(
                  o[31].p.v,
                  o[32].p.v,
                  o[33].p.v,
                  o[34].p.v,
                  o[35].p.v
                )),
                this.feFuncA.setAttribute("tableValues", e));
          }
        });
      function SVGDropShadowEffect(s, e, o, a, c) {
        var d = e.container.globalData.renderConfig.filterSize,
          g = e.data.fs || d;
        s.setAttribute("x", g.x || d.x),
          s.setAttribute("y", g.y || d.y),
          s.setAttribute("width", g.width || d.width),
          s.setAttribute("height", g.height || d.height),
          (this.filterManager = e);
        var _ = createNS("feGaussianBlur");
        _.setAttribute("in", "SourceAlpha"),
          _.setAttribute("result", a + "_drop_shadow_1"),
          _.setAttribute("stdDeviation", "0"),
          (this.feGaussianBlur = _),
          s.appendChild(_);
        var b = createNS("feOffset");
        b.setAttribute("dx", "25"),
          b.setAttribute("dy", "0"),
          b.setAttribute("in", a + "_drop_shadow_1"),
          b.setAttribute("result", a + "_drop_shadow_2"),
          (this.feOffset = b),
          s.appendChild(b);
        var j = createNS("feFlood");
        j.setAttribute("flood-color", "#00ff00"),
          j.setAttribute("flood-opacity", "1"),
          j.setAttribute("result", a + "_drop_shadow_3"),
          (this.feFlood = j),
          s.appendChild(j);
        var $ = createNS("feComposite");
        $.setAttribute("in", a + "_drop_shadow_3"),
          $.setAttribute("in2", a + "_drop_shadow_2"),
          $.setAttribute("operator", "in"),
          $.setAttribute("result", a + "_drop_shadow_4"),
          s.appendChild($);
        var _e = this.createMergeNode(a, [a + "_drop_shadow_4", c]);
        s.appendChild(_e);
      }
      extendPrototype([SVGComposableEffect], SVGDropShadowEffect),
        (SVGDropShadowEffect.prototype.renderFrame = function (s) {
          if (s || this.filterManager._mdf) {
            if (
              ((s || this.filterManager.effectElements[4].p._mdf) &&
                this.feGaussianBlur.setAttribute(
                  "stdDeviation",
                  this.filterManager.effectElements[4].p.v / 4
                ),
              s || this.filterManager.effectElements[0].p._mdf)
            ) {
              var e = this.filterManager.effectElements[0].p.v;
              this.feFlood.setAttribute(
                "flood-color",
                rgbToHex(
                  Math.round(e[0] * 255),
                  Math.round(e[1] * 255),
                  Math.round(e[2] * 255)
                )
              );
            }
            if (
              ((s || this.filterManager.effectElements[1].p._mdf) &&
                this.feFlood.setAttribute(
                  "flood-opacity",
                  this.filterManager.effectElements[1].p.v / 255
                ),
              s ||
                this.filterManager.effectElements[2].p._mdf ||
                this.filterManager.effectElements[3].p._mdf)
            ) {
              var o = this.filterManager.effectElements[3].p.v,
                a = (this.filterManager.effectElements[2].p.v - 90) * degToRads,
                c = o * Math.cos(a),
                d = o * Math.sin(a);
              this.feOffset.setAttribute("dx", c),
                this.feOffset.setAttribute("dy", d);
            }
          }
        });
      var _svgMatteSymbols = [];
      function SVGMatte3Effect(s, e, o) {
        (this.initialized = !1),
          (this.filterManager = e),
          (this.filterElem = s),
          (this.elem = o),
          (o.matteElement = createNS("g")),
          o.matteElement.appendChild(o.layerElement),
          o.matteElement.appendChild(o.transformedElement),
          (o.baseElement = o.matteElement);
      }
      (SVGMatte3Effect.prototype.findSymbol = function (s) {
        for (var e = 0, o = _svgMatteSymbols.length; e < o; ) {
          if (_svgMatteSymbols[e] === s) return _svgMatteSymbols[e];
          e += 1;
        }
        return null;
      }),
        (SVGMatte3Effect.prototype.replaceInParent = function (s, e) {
          var o = s.layerElement.parentNode;
          if (o) {
            for (
              var a = o.children, c = 0, d = a.length;
              c < d && a[c] !== s.layerElement;

            )
              c += 1;
            var g;
            c <= d - 2 && (g = a[c + 1]);
            var _ = createNS("use");
            _.setAttribute("href", "#" + e),
              g ? o.insertBefore(_, g) : o.appendChild(_);
          }
        }),
        (SVGMatte3Effect.prototype.setElementAsMask = function (s, e) {
          if (!this.findSymbol(e)) {
            var o = createElementID(),
              a = createNS("mask");
            a.setAttribute("id", e.layerId),
              a.setAttribute("mask-type", "alpha"),
              _svgMatteSymbols.push(e);
            var c = s.globalData.defs;
            c.appendChild(a);
            var d = createNS("symbol");
            d.setAttribute("id", o),
              this.replaceInParent(e, o),
              d.appendChild(e.layerElement),
              c.appendChild(d);
            var g = createNS("use");
            g.setAttribute("href", "#" + o),
              a.appendChild(g),
              (e.data.hd = !1),
              e.show();
          }
          s.setMatte(e.layerId);
        }),
        (SVGMatte3Effect.prototype.initialize = function () {
          for (
            var s = this.filterManager.effectElements[0].p.v,
              e = this.elem.comp.elements,
              o = 0,
              a = e.length;
            o < a;

          )
            e[o] &&
              e[o].data.ind === s &&
              this.setElementAsMask(this.elem, e[o]),
              (o += 1);
          this.initialized = !0;
        }),
        (SVGMatte3Effect.prototype.renderFrame = function () {
          this.initialized || this.initialize();
        });
      function SVGGaussianBlurEffect(s, e, o, a) {
        s.setAttribute("x", "-100%"),
          s.setAttribute("y", "-100%"),
          s.setAttribute("width", "300%"),
          s.setAttribute("height", "300%"),
          (this.filterManager = e);
        var c = createNS("feGaussianBlur");
        c.setAttribute("result", a),
          s.appendChild(c),
          (this.feGaussianBlur = c);
      }
      SVGGaussianBlurEffect.prototype.renderFrame = function (s) {
        if (s || this.filterManager._mdf) {
          var e = 0.3,
            o = this.filterManager.effectElements[0].p.v * e,
            a = this.filterManager.effectElements[1].p.v,
            c = a == 3 ? 0 : o,
            d = a == 2 ? 0 : o;
          this.feGaussianBlur.setAttribute("stdDeviation", c + " " + d);
          var g =
            this.filterManager.effectElements[2].p.v == 1
              ? "wrap"
              : "duplicate";
          this.feGaussianBlur.setAttribute("edgeMode", g);
        }
      };
      function TransformEffect() {}
      (TransformEffect.prototype.init = function (s) {
        (this.effectsManager = s),
          (this.type = effectTypes.TRANSFORM_EFFECT),
          (this.matrix = new Matrix()),
          (this.opacity = -1),
          (this._mdf = !1),
          (this._opMdf = !1);
      }),
        (TransformEffect.prototype.renderFrame = function (s) {
          if (
            ((this._opMdf = !1),
            (this._mdf = !1),
            s || this.effectsManager._mdf)
          ) {
            var e = this.effectsManager.effectElements,
              o = e[0].p.v,
              a = e[1].p.v,
              c = e[2].p.v === 1,
              d = e[3].p.v,
              g = c ? d : e[4].p.v,
              _ = e[5].p.v,
              b = e[6].p.v,
              j = e[7].p.v;
            this.matrix.reset(),
              this.matrix.translate(-o[0], -o[1], o[2]),
              this.matrix.scale(g * 0.01, d * 0.01, 1),
              this.matrix.rotate(-j * degToRads),
              this.matrix.skewFromAxis(-_ * degToRads, (b + 90) * degToRads),
              this.matrix.translate(a[0], a[1], 0),
              (this._mdf = !0),
              this.opacity !== e[8].p.v &&
                ((this.opacity = e[8].p.v), (this._opMdf = !0));
          }
        });
      function SVGTransformEffect(s, e) {
        this.init(e);
      }
      extendPrototype([TransformEffect], SVGTransformEffect);
      function CVTransformEffect(s) {
        this.init(s);
      }
      return (
        extendPrototype([TransformEffect], CVTransformEffect),
        registerRenderer("canvas", CanvasRenderer),
        registerRenderer("html", HybridRenderer),
        registerRenderer("svg", SVGRenderer),
        ShapeModifiers.registerModifier("tm", TrimModifier),
        ShapeModifiers.registerModifier("pb", PuckerAndBloatModifier),
        ShapeModifiers.registerModifier("rp", RepeaterModifier),
        ShapeModifiers.registerModifier("rd", RoundCornersModifier),
        ShapeModifiers.registerModifier("zz", ZigZagModifier),
        ShapeModifiers.registerModifier("op", OffsetPathModifier),
        setExpressionsPlugin(Expressions),
        setExpressionInterfaces(getInterface),
        initialize$1(),
        initialize(),
        registerEffect$1(20, SVGTintFilter, !0),
        registerEffect$1(21, SVGFillFilter, !0),
        registerEffect$1(22, SVGStrokeEffect, !1),
        registerEffect$1(23, SVGTritoneFilter, !0),
        registerEffect$1(24, SVGProLevelsFilter, !0),
        registerEffect$1(25, SVGDropShadowEffect, !0),
        registerEffect$1(28, SVGMatte3Effect, !1),
        registerEffect$1(29, SVGGaussianBlurEffect, !0),
        registerEffect$1(35, SVGTransformEffect, !1),
        registerEffect(35, CVTransformEffect),
        lottie
      );
    });
})(lottie$1, lottie$1.exports);
var lottieExports = lottie$1.exports;
const lottie = getDefaultExportFromCjs(lottieExports);
function _iterableToArrayLimit(s, e) {
  var o =
    s == null
      ? null
      : (typeof Symbol < "u" && s[Symbol.iterator]) || s["@@iterator"];
  if (o != null) {
    var a,
      c,
      d,
      g,
      _ = [],
      b = !0,
      j = !1;
    try {
      if (((d = (o = o.call(s)).next), e !== 0))
        for (
          ;
          !(b = (a = d.call(o)).done) && (_.push(a.value), _.length !== e);
          b = !0
        );
    } catch ($) {
      (j = !0), (c = $);
    } finally {
      try {
        if (!b && o.return != null && ((g = o.return()), Object(g) !== g))
          return;
      } finally {
        if (j) throw c;
      }
    }
    return _;
  }
}
function ownKeys(s, e) {
  var o = Object.keys(s);
  if (Object.getOwnPropertySymbols) {
    var a = Object.getOwnPropertySymbols(s);
    e &&
      (a = a.filter(function (c) {
        return Object.getOwnPropertyDescriptor(s, c).enumerable;
      })),
      o.push.apply(o, a);
  }
  return o;
}
function _objectSpread2(s) {
  for (var e = 1; e < arguments.length; e++) {
    var o = arguments[e] != null ? arguments[e] : {};
    e % 2
      ? ownKeys(Object(o), !0).forEach(function (a) {
          _defineProperty(s, a, o[a]);
        })
      : Object.getOwnPropertyDescriptors
      ? Object.defineProperties(s, Object.getOwnPropertyDescriptors(o))
      : ownKeys(Object(o)).forEach(function (a) {
          Object.defineProperty(s, a, Object.getOwnPropertyDescriptor(o, a));
        });
  }
  return s;
}
function _defineProperty(s, e, o) {
  return (
    (e = _toPropertyKey(e)),
    e in s
      ? Object.defineProperty(s, e, {
          value: o,
          enumerable: !0,
          configurable: !0,
          writable: !0,
        })
      : (s[e] = o),
    s
  );
}
function _objectWithoutPropertiesLoose(s, e) {
  if (s == null) return {};
  var o = {},
    a = Object.keys(s),
    c,
    d;
  for (d = 0; d < a.length; d++)
    (c = a[d]), !(e.indexOf(c) >= 0) && (o[c] = s[c]);
  return o;
}
function _objectWithoutProperties(s, e) {
  if (s == null) return {};
  var o = _objectWithoutPropertiesLoose(s, e),
    a,
    c;
  if (Object.getOwnPropertySymbols) {
    var d = Object.getOwnPropertySymbols(s);
    for (c = 0; c < d.length; c++)
      (a = d[c]),
        !(e.indexOf(a) >= 0) &&
          Object.prototype.propertyIsEnumerable.call(s, a) &&
          (o[a] = s[a]);
  }
  return o;
}
function _slicedToArray(s, e) {
  return (
    _arrayWithHoles(s) ||
    _iterableToArrayLimit(s, e) ||
    _unsupportedIterableToArray(s, e) ||
    _nonIterableRest()
  );
}
function _arrayWithHoles(s) {
  if (Array.isArray(s)) return s;
}
function _unsupportedIterableToArray(s, e) {
  if (s) {
    if (typeof s == "string") return _arrayLikeToArray(s, e);
    var o = Object.prototype.toString.call(s).slice(8, -1);
    if (
      (o === "Object" && s.constructor && (o = s.constructor.name),
      o === "Map" || o === "Set")
    )
      return Array.from(s);
    if (o === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(o))
      return _arrayLikeToArray(s, e);
  }
}
function _arrayLikeToArray(s, e) {
  (e == null || e > s.length) && (e = s.length);
  for (var o = 0, a = new Array(e); o < e; o++) a[o] = s[o];
  return a;
}
function _nonIterableRest() {
  throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function _toPrimitive(s, e) {
  if (typeof s != "object" || s === null) return s;
  var o = s[Symbol.toPrimitive];
  if (o !== void 0) {
    var a = o.call(s, e || "default");
    if (typeof a != "object") return a;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (e === "string" ? String : Number)(s);
}
function _toPropertyKey(s) {
  var e = _toPrimitive(s, "string");
  return typeof e == "symbol" ? e : String(e);
}
var _excluded$1 = [
    "animationData",
    "loop",
    "autoplay",
    "initialSegment",
    "onComplete",
    "onLoopComplete",
    "onEnterFrame",
    "onSegmentStart",
    "onConfigReady",
    "onDataReady",
    "onDataFailed",
    "onLoadedImages",
    "onDOMLoaded",
    "onDestroy",
    "lottieRef",
    "renderer",
    "name",
    "assetsPath",
    "rendererSettings",
  ],
  useLottie = function s(e, o) {
    var a = e.animationData,
      c = e.loop,
      d = e.autoplay,
      g = e.initialSegment,
      _ = e.onComplete,
      b = e.onLoopComplete,
      j = e.onEnterFrame,
      $ = e.onSegmentStart,
      _e = e.onConfigReady,
      et = e.onDataReady,
      rt = e.onDataFailed,
      st = e.onLoadedImages,
      at = e.onDOMLoaded,
      ct = e.onDestroy;
    e.lottieRef, e.renderer, e.name, e.assetsPath, e.rendererSettings;
    var it = _objectWithoutProperties(e, _excluded$1),
      lt = reactExports$1.useState(!1),
      ot = _slicedToArray(lt, 2),
      ut = ot[0],
      pt = ot[1],
      ft = reactExports$1.useRef(),
      gt = reactExports$1.useRef(null),
      xt = function () {
        var Dt;
        (Dt = ft.current) === null || Dt === void 0 || Dt.play();
      },
      _t = function () {
        var Dt;
        (Dt = ft.current) === null || Dt === void 0 || Dt.stop();
      },
      St = function () {
        var Dt;
        (Dt = ft.current) === null || Dt === void 0 || Dt.pause();
      },
      Mt = function (Dt) {
        var Wt;
        (Wt = ft.current) === null || Wt === void 0 || Wt.setSpeed(Dt);
      },
      Rt = function (Dt, Wt) {
        var Pt;
        (Pt = ft.current) === null || Pt === void 0 || Pt.goToAndPlay(Dt, Wt);
      },
      Ft = function (Dt, Wt) {
        var Pt;
        (Pt = ft.current) === null || Pt === void 0 || Pt.goToAndStop(Dt, Wt);
      },
      Ot = function (Dt) {
        var Wt;
        (Wt = ft.current) === null || Wt === void 0 || Wt.setDirection(Dt);
      },
      Lt = function (Dt, Wt) {
        var Pt;
        (Pt = ft.current) === null || Pt === void 0 || Pt.playSegments(Dt, Wt);
      },
      Et = function (Dt) {
        var Wt;
        (Wt = ft.current) === null || Wt === void 0 || Wt.setSubframe(Dt);
      },
      bt = function (Dt) {
        var Wt;
        return (Wt = ft.current) === null || Wt === void 0
          ? void 0
          : Wt.getDuration(Dt);
      },
      mt = function () {
        var Dt;
        (Dt = ft.current) === null || Dt === void 0 || Dt.destroy(),
          (ft.current = void 0);
      },
      vt = function () {
        var Dt =
            arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {},
          Wt;
        if (gt.current) {
          (Wt = ft.current) === null || Wt === void 0 || Wt.destroy();
          var Pt = _objectSpread2(
            _objectSpread2(_objectSpread2({}, e), Dt),
            {},
            { container: gt.current }
          );
          return (
            (ft.current = lottie.loadAnimation(Pt)),
            pt(!!ft.current),
            function () {
              var Jt;
              (Jt = ft.current) === null || Jt === void 0 || Jt.destroy(),
                (ft.current = void 0);
            }
          );
        }
      };
    reactExports$1.useEffect(
      function () {
        var Tt = vt();
        return function () {
          return Tt == null ? void 0 : Tt();
        };
      },
      [a, c]
    ),
      reactExports$1.useEffect(
        function () {
          ft.current && (ft.current.autoplay = !!d);
        },
        [d]
      ),
      reactExports$1.useEffect(
        function () {
          if (ft.current) {
            if (!g) {
              ft.current.resetSegments(!0);
              return;
            }
            !Array.isArray(g) ||
              !g.length ||
              ((ft.current.currentRawFrame < g[0] ||
                ft.current.currentRawFrame > g[1]) &&
                (ft.current.currentRawFrame = g[0]),
              ft.current.setSegment(g[0], g[1]));
          }
        },
        [g]
      ),
      reactExports$1.useEffect(
        function () {
          var Tt = [
              { name: "complete", handler: _ },
              { name: "loopComplete", handler: b },
              { name: "enterFrame", handler: j },
              { name: "segmentStart", handler: $ },
              { name: "config_ready", handler: _e },
              { name: "data_ready", handler: et },
              { name: "data_failed", handler: rt },
              { name: "loaded_images", handler: st },
              { name: "DOMLoaded", handler: at },
              { name: "destroy", handler: ct },
            ],
            Dt = Tt.filter(function (Pt) {
              return Pt.handler != null;
            });
          if (Dt.length) {
            var Wt = Dt.map(function (Pt) {
              var Jt;
              return (
                (Jt = ft.current) === null ||
                  Jt === void 0 ||
                  Jt.addEventListener(Pt.name, Pt.handler),
                function () {
                  var Gt;
                  (Gt = ft.current) === null ||
                    Gt === void 0 ||
                    Gt.removeEventListener(Pt.name, Pt.handler);
                }
              );
            });
            return function () {
              Wt.forEach(function (Pt) {
                return Pt();
              });
            };
          }
        },
        [_, b, j, $, _e, et, rt, st, at, ct]
      );
    var Ct = React.createElement(
      "div",
      _objectSpread2({ style: o, ref: gt }, it)
    );
    return {
      View: Ct,
      play: xt,
      stop: _t,
      pause: St,
      setSpeed: Mt,
      goToAndStop: Ft,
      goToAndPlay: Rt,
      setDirection: Ot,
      playSegments: Lt,
      setSubframe: Et,
      getDuration: bt,
      destroy: mt,
      animationContainerRef: gt,
      animationLoaded: ut,
      animationItem: ft.current,
    };
  };
function getContainerVisibility(s) {
  var e = s.getBoundingClientRect(),
    o = e.top,
    a = e.height,
    c = window.innerHeight - o,
    d = window.innerHeight + a;
  return c / d;
}
function getContainerCursorPosition(s, e, o) {
  var a = s.getBoundingClientRect(),
    c = a.top,
    d = a.left,
    g = a.width,
    _ = a.height,
    b = (e - d) / g,
    j = (o - c) / _;
  return { x: b, y: j };
}
var useInitInteractivity = function s(e) {
    var o = e.wrapperRef,
      a = e.animationItem,
      c = e.mode,
      d = e.actions;
    reactExports$1.useEffect(
      function () {
        var g = o.current;
        if (!(!g || !a || !d.length)) {
          a.stop();
          var _ = function () {
              var $ = null,
                _e = function () {
                  var rt = getContainerVisibility(g),
                    st = d.find(function (ct) {
                      var it = ct.visibility;
                      return it && rt >= it[0] && rt <= it[1];
                    });
                  if (st) {
                    if (
                      st.type === "seek" &&
                      st.visibility &&
                      st.frames.length === 2
                    ) {
                      var at =
                        st.frames[0] +
                        Math.ceil(
                          ((rt - st.visibility[0]) /
                            (st.visibility[1] - st.visibility[0])) *
                            st.frames[1]
                        ); //! goToAndStop must be relative to the start of the current segment
                      a.goToAndStop(at - a.firstFrame - 1, !0);
                    }
                    st.type === "loop" &&
                      ($ === null || $ !== st.frames || a.isPaused) &&
                      (a.playSegments(st.frames, !0), ($ = st.frames)),
                      st.type === "play" &&
                        a.isPaused &&
                        (a.resetSegments(!0), a.play()),
                      st.type === "stop" &&
                        a.goToAndStop(st.frames[0] - a.firstFrame - 1, !0);
                  }
                };
              return (
                document.addEventListener("scroll", _e),
                function () {
                  document.removeEventListener("scroll", _e);
                }
              );
            },
            b = function () {
              var $ = function (st, at) {
                  var ct = st,
                    it = at;
                  if (ct !== -1 && it !== -1) {
                    var lt = getContainerCursorPosition(g, ct, it);
                    (ct = lt.x), (it = lt.y);
                  }
                  var ot = d.find(function (ft) {
                    var gt = ft.position;
                    return gt && Array.isArray(gt.x) && Array.isArray(gt.y)
                      ? ct >= gt.x[0] &&
                          ct <= gt.x[1] &&
                          it >= gt.y[0] &&
                          it <= gt.y[1]
                      : gt && !Number.isNaN(gt.x) && !Number.isNaN(gt.y)
                      ? ct === gt.x && it === gt.y
                      : !1;
                  });
                  if (ot) {
                    if (
                      ot.type === "seek" &&
                      ot.position &&
                      Array.isArray(ot.position.x) &&
                      Array.isArray(ot.position.y) &&
                      ot.frames.length === 2
                    ) {
                      var ut =
                          (ct - ot.position.x[0]) /
                          (ot.position.x[1] - ot.position.x[0]),
                        pt =
                          (it - ot.position.y[0]) /
                          (ot.position.y[1] - ot.position.y[0]);
                      a.playSegments(ot.frames, !0),
                        a.goToAndStop(
                          Math.ceil(
                            ((ut + pt) / 2) * (ot.frames[1] - ot.frames[0])
                          ),
                          !0
                        );
                    }
                    ot.type === "loop" && a.playSegments(ot.frames, !0),
                      ot.type === "play" &&
                        (a.isPaused && a.resetSegments(!1),
                        a.playSegments(ot.frames)),
                      ot.type === "stop" && a.goToAndStop(ot.frames[0], !0);
                  }
                },
                _e = function (st) {
                  $(st.clientX, st.clientY);
                },
                et = function () {
                  $(-1, -1);
                };
              return (
                g.addEventListener("mousemove", _e),
                g.addEventListener("mouseout", et),
                function () {
                  g.removeEventListener("mousemove", _e),
                    g.removeEventListener("mouseout", et);
                }
              );
            };
          switch (c) {
            case "scroll":
              return _();
            case "cursor":
              return b();
          }
        }
      },
      [c, a]
    );
  },
  useLottieInteractivity = function s(e) {
    var o = e.actions,
      a = e.mode,
      c = e.lottieObj,
      d = c.animationItem,
      g = c.View,
      _ = c.animationContainerRef;
    return (
      useInitInteractivity({
        actions: o,
        animationItem: d,
        mode: a,
        wrapperRef: _,
      }),
      g
    );
  },
  _excluded = ["style", "interactivity"],
  Lottie = function s(e) {
    var o,
      a,
      c,
      d = e.style,
      g = e.interactivity,
      _ = _objectWithoutProperties(e, _excluded),
      b = useLottie(_, d),
      j = b.View,
      $ = b.play,
      _e = b.stop,
      et = b.pause,
      rt = b.setSpeed,
      st = b.goToAndStop,
      at = b.goToAndPlay,
      ct = b.setDirection,
      it = b.playSegments,
      lt = b.setSubframe,
      ot = b.getDuration,
      ut = b.destroy,
      pt = b.animationContainerRef,
      ft = b.animationLoaded,
      gt = b.animationItem;
    return (
      reactExports$1.useEffect(
        function () {
          e.lottieRef &&
            (e.lottieRef.current = {
              play: $,
              stop: _e,
              pause: et,
              setSpeed: rt,
              goToAndPlay: at,
              goToAndStop: st,
              setDirection: ct,
              playSegments: it,
              setSubframe: lt,
              getDuration: ot,
              destroy: ut,
              animationContainerRef: pt,
              animationLoaded: ft,
              animationItem: gt,
            });
        },
        [(o = e.lottieRef) === null || o === void 0 ? void 0 : o.current]
      ),
      useLottieInteractivity({
        lottieObj: {
          View: j,
          play: $,
          stop: _e,
          pause: et,
          setSpeed: rt,
          goToAndStop: st,
          goToAndPlay: at,
          setDirection: ct,
          playSegments: it,
          setSubframe: lt,
          getDuration: ot,
          destroy: ut,
          animationContainerRef: pt,
          animationLoaded: ft,
          animationItem: gt,
        },
        actions:
          (a = g == null ? void 0 : g.actions) !== null && a !== void 0
            ? a
            : [],
        mode:
          (c = g == null ? void 0 : g.mode) !== null && c !== void 0
            ? c
            : "scroll",
      })
    );
  };
const v$6 = "5.6.5",
  fr$6 = 24,
  ip$6 = 0,
  op$6 = 28,
  w$7 = 48,
  h$6 = 48,
  nm$6 = "twit-flying",
  ddd$6 = 0,
  assets$6 = [],
  layers$6 = [
    {
      ddd: 0,
      ind: 1,
      ty: 4,
      nm: "Wing ",
      parent: 2,
      sr: 1,
      ks: {
        o: { a: 0, k: 100, ix: 11 },
        r: { a: 0, k: 0, ix: 10 },
        p: { a: 0, k: [10.108, 12.265, 0], ix: 2 },
        a: { a: 0, k: [8.665, 10.925, 0], ix: 1 },
        s: { a: 0, k: [100, 100, 100], ix: 6 },
      },
      ao: 0,
      shapes: [
        {
          ty: "gr",
          it: [
            {
              ind: 0,
              ty: "sh",
              ix: 1,
              ks: {
                a: 1,
                k: [
                  {
                    i: { x: 0.833, y: 0.833 },
                    o: { x: 0.333, y: 0 },
                    t: 0,
                    s: [
                      {
                        i: [
                          [4.715, 6.936],
                          [-4.885, 8.486],
                          [-4.904999999999999, 5.715],
                          [-3.105, 5.624],
                          [-8.415, 1.8239999999999998],
                          [-8.415, -1.814],
                          [-6.275, -0.935],
                          [-8.345, -4.455],
                          [-7.984999999999999, -9.596],
                          [1.7350000000000003, -3.335],
                        ],
                        o: [
                          [-2.1550000000000002, 10.606],
                          [-5.375, 5.665],
                          [-3.755, 5.715],
                          [-5.865, 4.784],
                          [-8.415, -1.725],
                          [-7.414999999999999, -1.274],
                          [-7.045, -2.216],
                          [-8.345, -8.325],
                          [-3.7049999999999996, -6.256],
                          [8.415, -0.10499999999999998],
                        ],
                        v: [
                          [1.075, 10.676],
                          [-5.825, 5.585],
                          [-4.425, 5.715],
                          [-2.485, 5.454],
                          [-8.415, -1.725],
                          [-8.415, -1.814],
                          [-5.065, -0.895],
                          [-8.345, -6.995],
                          [-7.345, -10.676],
                          [7.875, -3.025],
                        ],
                        c: !0,
                      },
                    ],
                  },
                  {
                    i: { x: 0.833, y: 0.833 },
                    o: { x: 0.167, y: 0.167 },
                    t: 1,
                    s: [
                      {
                        i: [
                          [3.7729999999999997, 7.305],
                          [-0.926, 9.308],
                          [-0.8799999999999999, 7.384],
                          [0.8400000000000001, 6.651],
                          [-1.263, 3.963],
                          [-1.543, 1.595],
                          [1.734, 1.402],
                          [0.843, -0.31499999999999995],
                          [-0.04500000000000004, -5.079000000000001],
                          [6.401, -2.9979999999999998],
                        ],
                        o: [
                          [-0.5509999999999999, 9.683],
                          [-1.299, 7.4799999999999995],
                          [-0.19999999999999996, 7.147],
                          [-0.7949999999999999, 4.526],
                          [-1.605, 1.567],
                          [-1.4589999999999999, 1.655],
                          [1.351, 0.05399999999999994],
                          [-0.068, -3.13],
                          [1.185, -5.221],
                          [7.583, -0.4950000000000001],
                        ],
                        v: [
                          [1.075, 10.676],
                          [-1.625, 7.504],
                          [-0.589, 7.296],
                          [1.012, 6.334],
                          [-1.605, 1.567],
                          [-1.543, 1.595],
                          [2.48, 0.962],
                          [0.187, -2.338],
                          [0.484, -6.277],
                          [7.875, -3.025],
                        ],
                        c: !0,
                      },
                    ],
                  },
                  {
                    i: { x: 0.667, y: 1 },
                    o: { x: 0.167, y: 0.167 },
                    t: 2,
                    s: [
                      {
                        i: [
                          [2.1189999999999998, 7.714],
                          [3.9699999999999998, 10.504000000000001],
                          [3.73, 8.799999999999999],
                          [5.037, 7.828],
                          [7.119000000000001, 6.5329999999999995],
                          [8.291, 5.005],
                          [7.1209999999999996, 3.176],
                          [8.742, 1.712],
                          [10.969000000000001, -0.123],
                          [8.166, -2.604],
                        ],
                        o: [
                          [2.282, 10.762],
                          [4.428, 9.506],
                          [4.292, 8.136999999999999],
                          [6.619, 6.897],
                          [8.291, 5.055],
                          [7.418, 4.2989999999999995],
                          [7.944, 2.077],
                          [9.991, 0.7719999999999999],
                          [10.287, -1.594],
                          [5.9239999999999995, -0.3580000000000001],
                        ],
                        v: [
                          [1.075, 10.676],
                          [5.231, 9.637],
                          [3.676, 8.325],
                          [5.645, 7.434],
                          [8.291, 5.055],
                          [8.291, 5.005],
                          [7.015, 2.571],
                          [9.285, 1.317],
                          [11.528, -1.526],
                          [7.875, -3.025],
                        ],
                        c: !0,
                      },
                    ],
                  },
                  {
                    i: { x: 0.833, y: 0.833 },
                    o: { x: 0.333, y: 0 },
                    t: 3,
                    s: [
                      {
                        i: [
                          [1.0819999999999999, 8.361],
                          [6.239000000000001, 14.36],
                          [8.161, 12.727],
                          [7.332, 11.328999999999999],
                          [11.707, 12.421999999999999],
                          [17.007, 11.576],
                          [13.379000000000001, 9.032],
                          [17.363, 8.22],
                          [23.005, 5.173],
                          [10.02, -0.6719999999999997],
                        ],
                        o: [
                          [2.301, 13.048],
                          [8.723, 13.211],
                          [7.4959999999999996, 11.813],
                          [9.739, 12.235],
                          [17.007, 11.572],
                          [14.473000000000003, 10.266],
                          [14.489, 8.501],
                          [21.981, 6.63],
                          [16.489, 2.641],
                          [5.207, -1.609],
                        ],
                        v: [
                          [1.075, 10.676],
                          [9.894, 13.709],
                          [7.911, 12.387],
                          [7.265, 10.892],
                          [17.007, 11.572],
                          [17.007, 11.576],
                          [13.185, 8.231],
                          [19.483, 7.49],
                          [23.218, 3.637],
                          [7.875, -3.025],
                        ],
                        c: !0,
                      },
                    ],
                  },
                  {
                    i: { x: 0.833, y: 0.833 },
                    o: { x: 0.167, y: 0.167 },
                    t: 4,
                    s: [
                      {
                        i: [
                          [2.1189999999999998, 7.714],
                          [3.5009999999999994, 10.533000000000001],
                          [3.73, 8.799999999999999],
                          [5.037, 7.828],
                          [7.119000000000001, 6.5329999999999995],
                          [8.291, 5.005],
                          [7.1209999999999996, 3.176],
                          [8.742, 1.712],
                          [10.969000000000001, -0.123],
                          [8.166, -2.604],
                        ],
                        o: [
                          [2.282, 10.762],
                          [4.407, 9.498000000000001],
                          [4.292, 8.136999999999999],
                          [6.619, 6.897],
                          [8.291, 5.055],
                          [7.418, 4.2989999999999995],
                          [7.944, 2.077],
                          [9.991, 0.7719999999999999],
                          [10.287, -1.594],
                          [5.9239999999999995, -0.3580000000000001],
                        ],
                        v: [
                          [1.075, 10.676],
                          [4.762, 9.666],
                          [3.676, 8.325],
                          [5.645, 7.434],
                          [8.291, 5.055],
                          [8.291, 5.005],
                          [7.015, 2.571],
                          [9.285, 1.317],
                          [11.528, -1.526],
                          [7.875, -3.025],
                        ],
                        c: !0,
                      },
                    ],
                  },
                  {
                    i: { x: 0.667, y: 1 },
                    o: { x: 0.167, y: 0.167 },
                    t: 6,
                    s: [
                      {
                        i: [
                          [3.7729999999999997, 7.305],
                          [-0.926, 9.308],
                          [-0.8799999999999999, 7.384],
                          [0.8400000000000001, 6.651],
                          [-1.263, 3.963],
                          [-1.543, 1.595],
                          [1.734, 1.402],
                          [0.843, -0.31499999999999995],
                          [-0.04500000000000004, -5.079000000000001],
                          [6.401, -2.9979999999999998],
                        ],
                        o: [
                          [-0.5509999999999999, 9.683],
                          [-1.299, 7.4799999999999995],
                          [-0.19999999999999996, 7.147],
                          [-0.7949999999999999, 4.526],
                          [-1.605, 1.567],
                          [-1.4589999999999999, 1.655],
                          [1.351, 0.05399999999999994],
                          [-0.068, -3.13],
                          [1.185, -5.221],
                          [7.583, -0.4950000000000001],
                        ],
                        v: [
                          [1.075, 10.676],
                          [-1.625, 7.504],
                          [-0.589, 7.296],
                          [1.012, 6.334],
                          [-1.605, 1.567],
                          [-1.543, 1.595],
                          [2.48, 0.962],
                          [0.187, -2.338],
                          [0.484, -6.277],
                          [7.875, -3.025],
                        ],
                        c: !0,
                      },
                    ],
                  },
                  {
                    i: { x: 0.833, y: 0.833 },
                    o: { x: 0.333, y: 0 },
                    t: 7,
                    s: [
                      {
                        i: [
                          [4.715, 6.936],
                          [-4.885, 8.486],
                          [-4.904999999999999, 5.715],
                          [-3.105, 5.624],
                          [-8.415, 1.8239999999999998],
                          [-8.415, -1.814],
                          [-6.275, -0.935],
                          [-8.345, -4.455],
                          [-7.984999999999999, -9.596],
                          [1.7350000000000003, -3.335],
                        ],
                        o: [
                          [-2.1550000000000002, 10.606],
                          [-5.375, 5.665],
                          [-3.755, 5.715],
                          [-5.865, 4.784],
                          [-8.415, -1.725],
                          [-7.414999999999999, -1.274],
                          [-7.045, -2.216],
                          [-8.345, -8.325],
                          [-3.7049999999999996, -6.256],
                          [8.415, -0.10499999999999998],
                        ],
                        v: [
                          [1.075, 10.676],
                          [-5.825, 5.585],
                          [-4.425, 5.715],
                          [-2.485, 5.454],
                          [-8.415, -1.725],
                          [-8.415, -1.814],
                          [-5.065, -0.895],
                          [-8.345, -6.995],
                          [-7.345, -10.676],
                          [7.875, -3.025],
                        ],
                        c: !0,
                      },
                    ],
                  },
                  {
                    i: { x: 0.833, y: 0.833 },
                    o: { x: 0.167, y: 0.167 },
                    t: 9,
                    s: [
                      {
                        i: [
                          [3.7729999999999997, 7.305],
                          [-0.926, 9.308],
                          [-0.8799999999999999, 7.384],
                          [0.8400000000000001, 6.651],
                          [-1.263, 3.963],
                          [-1.543, 1.595],
                          [1.734, 1.402],
                          [0.843, -0.31499999999999995],
                          [-0.04500000000000004, -5.079000000000001],
                          [6.401, -2.9979999999999998],
                        ],
                        o: [
                          [-0.5509999999999999, 9.683],
                          [-1.299, 7.4799999999999995],
                          [-0.19999999999999996, 7.147],
                          [-0.7949999999999999, 4.526],
                          [-1.605, 1.567],
                          [-1.4589999999999999, 1.655],
                          [1.351, 0.05399999999999994],
                          [-0.068, -3.13],
                          [1.185, -5.221],
                          [7.583, -0.4950000000000001],
                        ],
                        v: [
                          [1.075, 10.676],
                          [-1.625, 7.504],
                          [-0.589, 7.296],
                          [1.012, 6.334],
                          [-1.605, 1.567],
                          [-1.543, 1.595],
                          [2.48, 0.962],
                          [0.187, -2.338],
                          [0.484, -6.277],
                          [7.875, -3.025],
                        ],
                        c: !0,
                      },
                    ],
                  },
                  {
                    i: { x: 0.667, y: 1 },
                    o: { x: 0.167, y: 0.167 },
                    t: 10,
                    s: [
                      {
                        i: [
                          [2.1189999999999998, 7.714],
                          [3.9699999999999998, 10.504000000000001],
                          [3.73, 8.799999999999999],
                          [5.037, 7.828],
                          [7.119000000000001, 6.5329999999999995],
                          [8.291, 5.005],
                          [7.1209999999999996, 3.176],
                          [8.742, 1.712],
                          [10.969000000000001, -0.123],
                          [8.166, -2.604],
                        ],
                        o: [
                          [2.282, 10.762],
                          [4.428, 9.506],
                          [4.292, 8.136999999999999],
                          [6.619, 6.897],
                          [8.291, 5.055],
                          [7.418, 4.2989999999999995],
                          [7.944, 2.077],
                          [9.991, 0.7719999999999999],
                          [10.287, -1.594],
                          [5.9239999999999995, -0.3580000000000001],
                        ],
                        v: [
                          [1.075, 10.676],
                          [5.231, 9.637],
                          [3.676, 8.325],
                          [5.645, 7.434],
                          [8.291, 5.055],
                          [8.291, 5.005],
                          [7.015, 2.571],
                          [9.285, 1.317],
                          [11.528, -1.526],
                          [7.875, -3.025],
                        ],
                        c: !0,
                      },
                    ],
                  },
                  {
                    i: { x: 0.833, y: 0.833 },
                    o: { x: 0.333, y: 0 },
                    t: 12,
                    s: [
                      {
                        i: [
                          [1.0819999999999999, 8.361],
                          [6.239000000000001, 14.36],
                          [8.161, 12.727],
                          [7.332, 11.328999999999999],
                          [11.707, 12.421999999999999],
                          [17.007, 11.576],
                          [13.379000000000001, 9.032],
                          [17.363, 8.22],
                          [23.005, 5.173],
                          [10.02, -0.6719999999999997],
                        ],
                        o: [
                          [2.301, 13.048],
                          [8.723, 13.211],
                          [7.4959999999999996, 11.813],
                          [9.739, 12.235],
                          [17.007, 11.572],
                          [14.473000000000003, 10.266],
                          [14.489, 8.501],
                          [21.981, 6.63],
                          [16.489, 2.641],
                          [5.207, -1.609],
                        ],
                        v: [
                          [1.075, 10.676],
                          [9.894, 13.709],
                          [7.911, 12.387],
                          [7.265, 10.892],
                          [17.007, 11.572],
                          [17.007, 11.576],
                          [13.185, 8.231],
                          [19.483, 7.49],
                          [23.218, 3.637],
                          [7.875, -3.025],
                        ],
                        c: !0,
                      },
                    ],
                  },
                  {
                    i: { x: 0.833, y: 0.833 },
                    o: { x: 0.167, y: 0.167 },
                    t: 14,
                    s: [
                      {
                        i: [
                          [2.1189999999999998, 7.714],
                          [3.9699999999999998, 10.504000000000001],
                          [3.73, 8.799999999999999],
                          [5.037, 7.828],
                          [7.119000000000001, 6.5329999999999995],
                          [8.291, 5.005],
                          [7.1209999999999996, 3.176],
                          [8.742, 1.712],
                          [10.969000000000001, -0.123],
                          [8.166, -2.604],
                        ],
                        o: [
                          [2.282, 10.762],
                          [4.428, 9.506],
                          [4.292, 8.136999999999999],
                          [6.619, 6.897],
                          [8.291, 5.055],
                          [7.418, 4.2989999999999995],
                          [7.944, 2.077],
                          [9.991, 0.7719999999999999],
                          [10.287, -1.594],
                          [5.9239999999999995, -0.3580000000000001],
                        ],
                        v: [
                          [1.075, 10.676],
                          [5.231, 9.637],
                          [3.676, 8.325],
                          [5.645, 7.434],
                          [8.291, 5.055],
                          [8.291, 5.005],
                          [7.015, 2.571],
                          [9.285, 1.317],
                          [11.528, -1.526],
                          [7.875, -3.025],
                        ],
                        c: !0,
                      },
                    ],
                  },
                  {
                    i: { x: 0.667, y: 1 },
                    o: { x: 0.167, y: 0.167 },
                    t: 15,
                    s: [
                      {
                        i: [
                          [3.7729999999999997, 7.305],
                          [-0.926, 9.308],
                          [-0.8799999999999999, 7.384],
                          [0.8400000000000001, 6.651],
                          [-1.263, 3.963],
                          [-1.543, 1.595],
                          [1.734, 1.402],
                          [0.843, -0.31499999999999995],
                          [-0.04500000000000004, -5.079000000000001],
                          [6.401, -2.9979999999999998],
                        ],
                        o: [
                          [-0.5509999999999999, 9.683],
                          [-1.299, 7.4799999999999995],
                          [-0.19999999999999996, 7.147],
                          [-0.7949999999999999, 4.526],
                          [-1.605, 1.567],
                          [-1.4589999999999999, 1.655],
                          [1.351, 0.05399999999999994],
                          [-0.068, -3.13],
                          [1.185, -5.221],
                          [7.583, -0.4950000000000001],
                        ],
                        v: [
                          [1.075, 10.676],
                          [-1.625, 7.504],
                          [-0.589, 7.296],
                          [1.012, 6.334],
                          [-1.605, 1.567],
                          [-1.543, 1.595],
                          [2.48, 0.962],
                          [0.187, -2.338],
                          [0.484, -6.277],
                          [7.875, -3.025],
                        ],
                        c: !0,
                      },
                    ],
                  },
                  {
                    i: { x: 0.833, y: 0.833 },
                    o: { x: 0.333, y: 0 },
                    t: 17,
                    s: [
                      {
                        i: [
                          [4.715, 6.936],
                          [-4.885, 8.486],
                          [-4.904999999999999, 5.715],
                          [-3.105, 5.624],
                          [-8.415, 1.8239999999999998],
                          [-8.415, -1.814],
                          [-6.275, -0.935],
                          [-8.345, -4.455],
                          [-7.984999999999999, -9.596],
                          [1.7350000000000003, -3.335],
                        ],
                        o: [
                          [-2.1550000000000002, 10.606],
                          [-5.375, 5.665],
                          [-3.755, 5.715],
                          [-5.865, 4.784],
                          [-8.415, -1.725],
                          [-7.414999999999999, -1.274],
                          [-7.045, -2.216],
                          [-8.345, -8.325],
                          [-3.7049999999999996, -6.256],
                          [8.415, -0.10499999999999998],
                        ],
                        v: [
                          [1.075, 10.676],
                          [-5.825, 5.585],
                          [-4.425, 5.715],
                          [-2.485, 5.454],
                          [-8.415, -1.725],
                          [-8.415, -1.814],
                          [-5.065, -0.895],
                          [-8.345, -6.995],
                          [-7.345, -10.676],
                          [7.875, -3.025],
                        ],
                        c: !0,
                      },
                    ],
                  },
                  {
                    i: { x: 0.833, y: 0.833 },
                    o: { x: 0.167, y: 0.167 },
                    t: 18,
                    s: [
                      {
                        i: [
                          [3.7729999999999997, 7.305],
                          [-0.926, 9.308],
                          [-0.8799999999999999, 7.384],
                          [0.8400000000000001, 6.651],
                          [-1.263, 3.963],
                          [-1.543, 1.595],
                          [1.734, 1.402],
                          [0.843, -0.31499999999999995],
                          [-0.04500000000000004, -5.079000000000001],
                          [6.401, -2.9979999999999998],
                        ],
                        o: [
                          [-0.5509999999999999, 9.683],
                          [-1.299, 7.4799999999999995],
                          [-0.19999999999999996, 7.147],
                          [-0.7949999999999999, 4.526],
                          [-1.605, 1.567],
                          [-1.4589999999999999, 1.655],
                          [1.351, 0.05399999999999994],
                          [-0.068, -3.13],
                          [1.185, -5.221],
                          [7.583, -0.4950000000000001],
                        ],
                        v: [
                          [1.075, 10.676],
                          [-1.625, 7.504],
                          [-0.589, 7.296],
                          [1.012, 6.334],
                          [-1.605, 1.567],
                          [-1.543, 1.595],
                          [2.48, 0.962],
                          [0.187, -2.338],
                          [0.484, -6.277],
                          [7.875, -3.025],
                        ],
                        c: !0,
                      },
                    ],
                  },
                  {
                    i: { x: 0.667, y: 1 },
                    o: { x: 0.167, y: 0.167 },
                    t: 19,
                    s: [
                      {
                        i: [
                          [2.1189999999999998, 7.714],
                          [3.9699999999999998, 10.504000000000001],
                          [3.73, 8.799999999999999],
                          [5.037, 7.828],
                          [7.119000000000001, 6.5329999999999995],
                          [8.291, 5.005],
                          [7.1209999999999996, 3.176],
                          [8.742, 1.712],
                          [10.969000000000001, -0.123],
                          [8.166, -2.604],
                        ],
                        o: [
                          [2.282, 10.762],
                          [4.428, 9.506],
                          [4.292, 8.136999999999999],
                          [6.619, 6.897],
                          [8.291, 5.055],
                          [7.418, 4.2989999999999995],
                          [7.944, 2.077],
                          [9.991, 0.7719999999999999],
                          [10.287, -1.594],
                          [5.9239999999999995, -0.3580000000000001],
                        ],
                        v: [
                          [1.075, 10.676],
                          [5.231, 9.637],
                          [3.676, 8.325],
                          [5.645, 7.434],
                          [8.291, 5.055],
                          [8.291, 5.005],
                          [7.015, 2.571],
                          [9.285, 1.317],
                          [11.528, -1.526],
                          [7.875, -3.025],
                        ],
                        c: !0,
                      },
                    ],
                  },
                  {
                    i: { x: 0.833, y: 0.833 },
                    o: { x: 0.333, y: 0 },
                    t: 21,
                    s: [
                      {
                        i: [
                          [1.0819999999999999, 8.361],
                          [6.239000000000001, 14.36],
                          [8.161, 12.727],
                          [7.332, 11.328999999999999],
                          [11.707, 12.421999999999999],
                          [17.007, 11.576],
                          [13.379000000000001, 9.032],
                          [17.363, 8.22],
                          [23.005, 5.173],
                          [10.02, -0.6719999999999997],
                        ],
                        o: [
                          [2.301, 13.048],
                          [8.723, 13.211],
                          [7.4959999999999996, 11.813],
                          [9.739, 12.235],
                          [17.007, 11.572],
                          [14.473000000000003, 10.266],
                          [14.489, 8.501],
                          [21.981, 6.63],
                          [16.489, 2.641],
                          [5.207, -1.609],
                        ],
                        v: [
                          [1.075, 10.676],
                          [9.894, 13.709],
                          [7.911, 12.387],
                          [7.265, 10.892],
                          [17.007, 11.572],
                          [17.007, 11.576],
                          [13.185, 8.231],
                          [19.483, 7.49],
                          [23.218, 3.637],
                          [7.875, -3.025],
                        ],
                        c: !0,
                      },
                    ],
                  },
                  {
                    i: { x: 0.833, y: 0.833 },
                    o: { x: 0.167, y: 0.167 },
                    t: 22,
                    s: [
                      {
                        i: [
                          [2.1189999999999998, 7.714],
                          [3.9699999999999998, 10.504000000000001],
                          [3.73, 8.799999999999999],
                          [5.037, 7.828],
                          [7.119000000000001, 6.5329999999999995],
                          [8.291, 5.005],
                          [7.1209999999999996, 3.176],
                          [8.742, 1.712],
                          [10.969000000000001, -0.123],
                          [8.166, -2.604],
                        ],
                        o: [
                          [2.282, 10.762],
                          [4.428, 9.506],
                          [4.292, 8.136999999999999],
                          [6.619, 6.897],
                          [8.291, 5.055],
                          [7.418, 4.2989999999999995],
                          [7.944, 2.077],
                          [9.991, 0.7719999999999999],
                          [10.287, -1.594],
                          [5.9239999999999995, -0.3580000000000001],
                        ],
                        v: [
                          [1.075, 10.676],
                          [5.231, 9.637],
                          [3.676, 8.325],
                          [5.645, 7.434],
                          [8.291, 5.055],
                          [8.291, 5.005],
                          [7.015, 2.571],
                          [9.285, 1.317],
                          [11.528, -1.526],
                          [7.875, -3.025],
                        ],
                        c: !0,
                      },
                    ],
                  },
                  {
                    i: { x: 0.667, y: 1 },
                    o: { x: 0.167, y: 0.167 },
                    t: 23,
                    s: [
                      {
                        i: [
                          [3.7729999999999997, 7.305],
                          [-0.926, 9.308],
                          [-0.8799999999999999, 7.384],
                          [0.8400000000000001, 6.651],
                          [-1.263, 3.963],
                          [-1.543, 1.595],
                          [1.734, 1.402],
                          [0.843, -0.31499999999999995],
                          [-0.04500000000000004, -5.079000000000001],
                          [6.401, -2.9979999999999998],
                        ],
                        o: [
                          [-0.5509999999999999, 9.683],
                          [-1.299, 7.4799999999999995],
                          [-0.19999999999999996, 7.147],
                          [-0.7949999999999999, 4.526],
                          [-1.605, 1.567],
                          [-1.4589999999999999, 1.655],
                          [1.351, 0.05399999999999994],
                          [-0.068, -3.13],
                          [1.185, -5.221],
                          [7.583, -0.4950000000000001],
                        ],
                        v: [
                          [1.075, 10.676],
                          [-1.625, 7.504],
                          [-0.589, 7.296],
                          [1.012, 6.334],
                          [-1.605, 1.567],
                          [-1.543, 1.595],
                          [2.48, 0.962],
                          [0.187, -2.338],
                          [0.484, -6.277],
                          [7.875, -3.025],
                        ],
                        c: !0,
                      },
                    ],
                  },
                  {
                    i: { x: 0.833, y: 0.833 },
                    o: { x: 0.333, y: 0 },
                    t: 24,
                    s: [
                      {
                        i: [
                          [4.715, 6.936],
                          [-4.885, 8.486],
                          [-4.904999999999999, 5.715],
                          [-3.105, 5.624],
                          [-8.415, 1.8239999999999998],
                          [-8.415, -1.814],
                          [-6.275, -0.935],
                          [-8.345, -4.455],
                          [-7.984999999999999, -9.596],
                          [1.7350000000000003, -3.335],
                        ],
                        o: [
                          [-2.1550000000000002, 10.606],
                          [-5.375, 5.665],
                          [-3.755, 5.715],
                          [-5.865, 4.784],
                          [-8.415, -1.725],
                          [-7.414999999999999, -1.274],
                          [-7.045, -2.216],
                          [-8.345, -8.325],
                          [-3.7049999999999996, -6.256],
                          [8.415, -0.10499999999999998],
                        ],
                        v: [
                          [1.075, 10.676],
                          [-5.825, 5.585],
                          [-4.425, 5.715],
                          [-2.485, 5.454],
                          [-8.415, -1.725],
                          [-8.415, -1.814],
                          [-5.065, -0.895],
                          [-8.345, -6.995],
                          [-7.345, -10.676],
                          [7.875, -3.025],
                        ],
                        c: !0,
                      },
                    ],
                  },
                  {
                    i: { x: 0.667, y: 1 },
                    o: { x: 0.167, y: 0.167 },
                    t: 25,
                    s: [
                      {
                        i: [
                          [2.1189999999999998, 7.714],
                          [3.9699999999999998, 10.504000000000001],
                          [3.73, 8.799999999999999],
                          [5.037, 7.828],
                          [7.119000000000001, 6.5329999999999995],
                          [8.291, 5.005],
                          [7.1209999999999996, 3.176],
                          [8.742, 1.712],
                          [10.969000000000001, -0.123],
                          [8.166, -2.604],
                        ],
                        o: [
                          [2.282, 10.762],
                          [4.428, 9.506],
                          [4.292, 8.136999999999999],
                          [6.619, 6.897],
                          [8.291, 5.055],
                          [7.418, 4.2989999999999995],
                          [7.944, 2.077],
                          [9.991, 0.7719999999999999],
                          [10.287, -1.594],
                          [5.9239999999999995, -0.3580000000000001],
                        ],
                        v: [
                          [1.075, 10.676],
                          [5.231, 9.637],
                          [3.676, 8.325],
                          [5.645, 7.434],
                          [8.291, 5.055],
                          [8.291, 5.005],
                          [7.015, 2.571],
                          [9.285, 1.317],
                          [11.528, -1.526],
                          [7.875, -3.025],
                        ],
                        c: !0,
                      },
                    ],
                  },
                  {
                    i: { x: 0.833, y: 0.833 },
                    o: { x: 0.333, y: 0 },
                    t: 26,
                    s: [
                      {
                        i: [
                          [1.0819999999999999, 8.361],
                          [6.239000000000001, 14.36],
                          [8.161, 12.727],
                          [7.332, 11.328999999999999],
                          [11.707, 12.421999999999999],
                          [17.007, 11.576],
                          [13.379000000000001, 9.032],
                          [17.363, 8.22],
                          [23.005, 5.173],
                          [10.02, -0.6719999999999997],
                        ],
                        o: [
                          [2.301, 13.048],
                          [8.723, 13.211],
                          [7.4959999999999996, 11.813],
                          [9.739, 12.235],
                          [17.007, 11.572],
                          [14.473000000000003, 10.266],
                          [14.489, 8.501],
                          [21.981, 6.63],
                          [16.489, 2.641],
                          [5.207, -1.609],
                        ],
                        v: [
                          [1.075, 10.676],
                          [9.894, 13.709],
                          [7.911, 12.387],
                          [7.265, 10.892],
                          [17.007, 11.572],
                          [17.007, 11.576],
                          [13.185, 8.231],
                          [19.483, 7.49],
                          [23.218, 3.637],
                          [7.875, -3.025],
                        ],
                        c: !0,
                      },
                    ],
                  },
                  {
                    i: { x: 0.667, y: 1 },
                    o: { x: 0.167, y: 0.167 },
                    t: 27,
                    s: [
                      {
                        i: [
                          [3.7729999999999997, 7.305],
                          [-0.926, 9.308],
                          [-0.8799999999999999, 7.384],
                          [0.8400000000000001, 6.651],
                          [-1.263, 3.963],
                          [-1.543, 1.595],
                          [1.734, 1.402],
                          [0.843, -0.31499999999999995],
                          [-0.04500000000000004, -5.079000000000001],
                          [6.401, -2.9979999999999998],
                        ],
                        o: [
                          [-0.5509999999999999, 9.683],
                          [-1.299, 7.4799999999999995],
                          [-0.19999999999999996, 7.147],
                          [-0.7949999999999999, 4.526],
                          [-1.605, 1.567],
                          [-1.4589999999999999, 1.655],
                          [1.351, 0.05399999999999994],
                          [-0.068, -3.13],
                          [1.185, -5.221],
                          [7.583, -0.4950000000000001],
                        ],
                        v: [
                          [1.075, 10.676],
                          [-1.625, 7.504],
                          [-0.589, 7.296],
                          [1.012, 6.334],
                          [-1.605, 1.567],
                          [-1.543, 1.595],
                          [2.48, 0.962],
                          [0.187, -2.338],
                          [0.484, -6.277],
                          [7.875, -3.025],
                        ],
                        c: !0,
                      },
                    ],
                  },
                  {
                    t: 28,
                    s: [
                      {
                        i: [
                          [4.715, 6.936],
                          [-4.885, 8.486],
                          [-4.904999999999999, 5.715],
                          [-3.105, 5.624],
                          [-8.415, 1.8239999999999998],
                          [-8.415, -1.814],
                          [-6.275, -0.935],
                          [-8.345, -4.455],
                          [-7.984999999999999, -9.596],
                          [1.7350000000000003, -3.335],
                        ],
                        o: [
                          [-2.1550000000000002, 10.606],
                          [-5.375, 5.665],
                          [-3.755, 5.715],
                          [-5.865, 4.784],
                          [-8.415, -1.725],
                          [-7.414999999999999, -1.274],
                          [-7.045, -2.216],
                          [-8.345, -8.325],
                          [-3.7049999999999996, -6.256],
                          [8.415, -0.10499999999999998],
                        ],
                        v: [
                          [1.075, 10.676],
                          [-5.825, 5.585],
                          [-4.425, 5.715],
                          [-2.485, 5.454],
                          [-8.415, -1.725],
                          [-8.415, -1.814],
                          [-5.065, -0.895],
                          [-8.345, -6.995],
                          [-7.345, -10.676],
                          [7.875, -3.025],
                        ],
                        c: !0,
                      },
                    ],
                  },
                ],
                ix: 2,
              },
              nm: "Path 1",
              mn: "ADBE Vector Shape - Group",
              hd: !1,
              _render: !0,
            },
            {
              ty: "fl",
              c: {
                a: 1,
                k: [
                  {
                    i: { x: [0.17], y: [1] },
                    o: { x: [0.83], y: [0] },
                    t: 0,
                    s: [0.48, 0.48, 0.48, 1],
                  },
                  {
                    i: { x: [0.17], y: [1] },
                    o: { x: [0.19], y: [0] },
                    t: 3,
                    s: [0.6078, 0.6039, 0.6078, 1],
                  },
                  {
                    i: { x: [0.17], y: [1] },
                    o: { x: [0.19], y: [0] },
                    t: 7,
                    s: [0.48, 0.48, 0.48, 1],
                  },
                  {
                    i: { x: [0.17], y: [1] },
                    o: { x: [0.19], y: [0] },
                    t: 12,
                    s: [0.6078, 0.6039, 0.6078, 1],
                  },
                  {
                    i: { x: [0.17], y: [1] },
                    o: { x: [0.19], y: [0] },
                    t: 17,
                    s: [0.48, 0.48, 0.48, 1],
                  },
                  {
                    i: { x: [0.17], y: [1] },
                    o: { x: [0.19], y: [0] },
                    t: 21,
                    s: [0.6078, 0.6039, 0.6078, 1],
                  },
                  {
                    i: { x: [0.17], y: [1] },
                    o: { x: [0.19], y: [0] },
                    t: 24,
                    s: [0.48, 0.48, 0.48, 1],
                  },
                  {
                    i: { x: [0.17], y: [1] },
                    o: { x: [0.19], y: [0] },
                    t: 26,
                    s: [0.6078, 0.6039, 0.6078, 1],
                  },
                  { t: 28, s: [0.48, 0.48, 0.48, 1] },
                ],
                ix: 4,
              },
              o: { a: 0, k: 100, ix: 5 },
              r: 1,
              bm: 0,
              nm: "Fill 1",
              mn: "ADBE Vector Graphic - Fill",
              hd: !1,
              _render: !0,
            },
            {
              ty: "tr",
              p: { a: 0, k: [8.665, 10.925], ix: 2 },
              a: { a: 0, k: [0, 0], ix: 1 },
              s: { a: 0, k: [100, 100], ix: 3 },
              r: { a: 0, k: 0, ix: 6 },
              o: { a: 0, k: 100, ix: 7 },
              sk: { a: 0, k: 0, ix: 4 },
              sa: { a: 0, k: 0, ix: 5 },
              nm: "Transform",
              _render: !0,
            },
          ],
          nm: "Group 1",
          np: 2,
          cix: 2,
          bm: 0,
          ix: 1,
          mn: "ADBE Vector Group",
          hd: !1,
          _render: !0,
        },
      ],
      ip: 0,
      op: 28,
      st: 0,
      bm: 0,
      completed: !0,
    },
    {
      ddd: 0,
      ind: 2,
      ty: 4,
      nm: "Bird",
      sr: 1,
      ks: {
        o: { a: 0, k: 100, ix: 11 },
        r: {
          a: 1,
          k: [
            {
              i: { x: [0.667], y: [1] },
              o: { x: [0.333], y: [0] },
              t: 0,
              s: [0],
            },
            {
              i: { x: [0.667], y: [1] },
              o: { x: [0.333], y: [0] },
              t: 15,
              s: [-5],
            },
            { t: 28, s: [0] },
          ],
          ix: 10,
        },
        p: {
          a: 1,
          k: [
            {
              i: { x: 0.667, y: 1 },
              o: { x: 0.333, y: 0 },
              t: 0,
              s: [23.999, 23.5, 0],
              to: null,
              ti: null,
            },
            {
              i: { x: 0.667, y: 1 },
              o: { x: 0.333, y: 0 },
              t: 8,
              s: [23.999, 21, 0],
              to: null,
              ti: null,
            },
            {
              i: { x: 0.667, y: 1 },
              o: { x: 0.333, y: 0 },
              t: 23,
              s: [23.999, 26, 0],
              to: null,
              ti: null,
            },
            { t: 28, s: [23.999, 23.5, 0] },
          ],
          ix: 2,
        },
        a: { a: 0, k: [18.251, 14.75, 0], ix: 1 },
        s: { a: 0, k: [100, 100, 100], ix: 6 },
      },
      ao: 0,
      shapes: [
        {
          ty: "gr",
          it: [
            {
              ind: 0,
              ty: "sh",
              ix: 1,
              ks: {
                a: 1,
                k: [
                  {
                    i: { x: 0.833, y: 0.833 },
                    o: { x: 0.167, y: 0.167 },
                    t: 0,
                    s: [
                      {
                        i: [
                          [17.014000000000003, -9.594999999999999],
                          [15.256, -10.094000000000001],
                          [16.454, -12.26],
                          [13.996, -12.515],
                          [9.052, -14.5],
                          [-0.46, -11.222],
                          [-0.392, -6.051],
                          [-2.641, -2.0949999999999998],
                          [-5.811, 5.999999999999999],
                          [-12.779, 11.319],
                          [-17.423000000000002, 11.285],
                          [-10.847, 14.5],
                          [14.339, 3.344000000000001],
                          [14.329, -6.967],
                        ],
                        o: [
                          [16.678, -10.485],
                          [15.281, -10.815000000000001],
                          [15.576999999999998, -13.13],
                          [10.969000000000001, -13.616000000000001],
                          [2.848, -14.5],
                          [-0.46, -6.608],
                          [-0.7170000000000001, -4.5],
                          [-5.491, 3.1100000000000003],
                          [-9.594, 10.143999999999998],
                          [-16.839, 11.319],
                          [-14.73, 13.286],
                          [6.907000000000001, 14.5],
                          [14.339, -6.651],
                          [15.764, -8.303],
                        ],
                        v: [
                          [18.001, -11.071],
                          [13.755, -9.909],
                          [17.005, -13.967],
                          [12.313, -12.191],
                          [6.928, -14.5],
                          [-0.46, -7.18],
                          [-0.266, -5.51],
                          [-4.231, 0.808],
                          [-7.066, 8.184],
                          [-16.241, 11.319],
                          [-18.001, 11.215],
                          [-6.678, 14.5],
                          [14.339, -6.334],
                          [14.314, -7.279],
                        ],
                        c: !0,
                      },
                    ],
                  },
                  {
                    t: 2,
                    s: [
                      {
                        i: [
                          [17.014000000000003, -9.594999999999999],
                          [15.256, -10.094000000000001],
                          [16.454, -12.26],
                          [13.996, -12.515],
                          [9.052, -14.5],
                          [-0.46, -11.222],
                          [-0.392, -6.051],
                          [-2.314, -2.2049999999999996],
                          [-6.048, 5.829999999999999],
                          [-12.779, 11.319],
                          [-17.423000000000002, 11.285],
                          [-10.847, 14.5],
                          [14.339, 3.344000000000001],
                          [14.329, -6.967],
                        ],
                        o: [
                          [16.678, -10.485],
                          [15.281, -10.815000000000001],
                          [15.576999999999998, -13.13],
                          [10.969000000000001, -13.616000000000001],
                          [2.848, -14.5],
                          [-0.46, -6.608],
                          [-0.879, -4.473],
                          [-4.93, 3.168],
                          [-9.594, 10.143999999999998],
                          [-16.839, 11.319],
                          [-14.73, 13.286],
                          [6.907000000000001, 14.5],
                          [14.339, -6.651],
                          [15.764, -8.303],
                        ],
                        v: [
                          [18.001, -11.071],
                          [13.755, -9.909],
                          [17.005, -13.967],
                          [12.313, -12.191],
                          [6.928, -14.5],
                          [-0.46, -7.18],
                          [-0.266, -5.51],
                          [-3.781, 0.809],
                          [-7.066, 8.184],
                          [-16.241, 11.319],
                          [-18.001, 11.215],
                          [-6.678, 14.5],
                          [14.339, -6.334],
                          [14.314, -7.279],
                        ],
                        c: !0,
                      },
                    ],
                  },
                ],
                ix: 2,
              },
              nm: "Path 1",
              mn: "ADBE Vector Shape - Group",
              hd: !1,
              _render: !0,
            },
            {
              ty: "fl",
              c: { a: 0, k: [0.48, 0.48, 0.48, 1], ix: 4 },
              o: { a: 0, k: 100, ix: 5 },
              r: 1,
              bm: 0,
              nm: "Fill 1",
              mn: "ADBE Vector Graphic - Fill",
              hd: !1,
              _render: !0,
            },
            {
              ty: "tr",
              p: { a: 0, k: [18.251, 14.75], ix: 2 },
              a: { a: 0, k: [0, 0], ix: 1 },
              s: { a: 0, k: [100, 100], ix: 3 },
              r: { a: 0, k: 0, ix: 6 },
              o: { a: 0, k: 100, ix: 7 },
              sk: { a: 0, k: 0, ix: 4 },
              sa: { a: 0, k: 0, ix: 5 },
              nm: "Transform",
              _render: !0,
            },
          ],
          nm: "Group 1",
          np: 2,
          cix: 2,
          bm: 0,
          ix: 1,
          mn: "ADBE Vector Group",
          hd: !1,
          _render: !0,
        },
      ],
      ip: 0,
      op: 28,
      st: 0,
      bm: 0,
      completed: !0,
    },
  ],
  markers$3 = [],
  __complete$5 = !0,
  twt = {
    v: v$6,
    fr: fr$6,
    ip: ip$6,
    op: op$6,
    w: w$7,
    h: h$6,
    nm: nm$6,
    ddd: ddd$6,
    assets: assets$6,
    layers: layers$6,
    markers: markers$3,
    __complete: __complete$5,
  },
  v$5 = "5.5.7",
  meta$3 = { g: "LottieFiles AE 0.1.20", a: "", k: "", d: "", tc: "" },
  fr$5 = 60,
  ip$5 = 0,
  op$5 = 180,
  w$6 = 400,
  h$5 = 400,
  nm$5 = "facebookicon",
  ddd$5 = 0,
  assets$5 = [],
  layers$5 = [
    {
      ddd: 0,
      ind: 1,
      ty: 4,
      nm: "Path 2",
      sr: 1,
      ks: {
        o: { a: 0, k: 100, ix: 11 },
        r: { a: 0, k: 0, ix: 10 },
        p: { a: 0, k: [225.198, 214.958, 0], ix: 2 },
        a: { a: 0, k: [44.118, 85.37, 0], ix: 1 },
        s: { a: 0, k: [100, 100, 100], ix: 6 },
      },
      ao: 0,
      shapes: [
        {
          ty: "gr",
          it: [
            {
              ind: 0,
              ty: "sh",
              ix: 1,
              ks: {
                a: 0,
                k: {
                  i: [
                    [57.324, 170.741],
                    [57.324, 92.966],
                    [83.442, 92.966],
                    [87.355, 62.524],
                    [57.324, 62.524],
                    [57.324, 43.136],
                    [59.75599999999999, 28.351],
                    [88.236, 28.351],
                    [88.236, 1.197],
                    [75.964, 0],
                    [26.021, 14.141000000000002],
                    [26.021, 62.524],
                    [0, 62.524],
                    [0, 92.966],
                    [26.021, 92.966],
                    [26.021, 170.741],
                  ],
                  o: [
                    [57.324, 170.741],
                    [57.324, 92.966],
                    [83.442, 92.966],
                    [87.355, 62.524],
                    [57.324, 62.524],
                    [57.324, 34.342],
                    [72.317, 28.351],
                    [88.236, 28.351],
                    [85.46600000000001, 0.8270000000000001],
                    [41.821, 0],
                    [26.021, 40.121],
                    [26.021, 62.524],
                    [0, 62.524],
                    [0, 92.966],
                    [26.021, 92.966],
                    [26.021, 170.741],
                  ],
                  v: [
                    [57.324, 170.741],
                    [57.324, 92.966],
                    [83.442, 92.966],
                    [87.355, 62.524],
                    [57.324, 62.524],
                    [57.324, 43.136],
                    [72.317, 28.351],
                    [88.236, 28.351],
                    [88.236, 1.197],
                    [64.907, 0],
                    [26.021, 40.121],
                    [26.021, 62.524],
                    [0, 62.524],
                    [0, 92.966],
                    [26.021, 92.966],
                    [26.021, 170.741],
                  ],
                  c: !0,
                },
                ix: 2,
              },
              nm: "Path 1",
              mn: "ADBE Vector Shape - Group",
              hd: !1,
              _render: !0,
            },
            {
              ty: "fl",
              c: { a: 0, k: [1, 1, 1, 1], ix: 4 },
              o: { a: 0, k: 100, ix: 5 },
              r: 1,
              bm: 0,
              nm: "Fill 1",
              mn: "ADBE Vector Graphic - Fill",
              hd: !1,
              _render: !0,
            },
            {
              ty: "tr",
              p: { a: 0, k: [1, 170], ix: 2 },
              a: { a: 0, k: [0, 170], ix: 1 },
              s: {
                a: 1,
                k: [
                  {
                    i: { x: [0, 0.275], y: [1, 0.898] },
                    o: { x: [0, 0.266], y: [0, 0.881] },
                    t: 32,
                    s: [100, 100],
                  },
                  {
                    i: { x: [0.833, 0.863], y: [1, 0.783] },
                    o: { x: [0.358, 0.441], y: [0, 0.027] },
                    t: 38,
                    s: [100, 112],
                  },
                  {
                    i: { x: [0.395, 0.39], y: [1, 1] },
                    o: { x: [0.333, 0.105], y: [0, 0.445] },
                    t: 47,
                    s: [100, 0],
                  },
                  {
                    i: { x: [0.667, 0.899], y: [1, 0.582] },
                    o: { x: [0.974, 0.77], y: [0, 0] },
                    t: 66,
                    s: [100, 116],
                  },
                  {
                    i: { x: [0.667, 0.667], y: [1, 1] },
                    o: { x: [0.333, 0.075], y: [0, 0.588] },
                    t: 73,
                    s: [100, 88],
                  },
                  {
                    i: { x: [0.667, 0.889], y: [1, 0.649] },
                    o: { x: [0.333, 0.333], y: [0, 0] },
                    t: 81,
                    s: [100, 108],
                  },
                  {
                    i: { x: [0.667, 0.667], y: [1, 1] },
                    o: { x: [0.333, 0.113], y: [0, 0.693] },
                    t: 91,
                    s: [100, 96],
                  },
                  {
                    i: { x: [0.667, 0.667], y: [1, 1] },
                    o: { x: [0.333, 0.333], y: [0, 0] },
                    t: 100,
                    s: [100, 102],
                  },
                  { t: 112, s: [100, 100] },
                ],
                ix: 3,
              },
              r: { a: 0, k: 0, ix: 6 },
              o: { a: 0, k: 100, ix: 7 },
              sk: { a: 0, k: 0, ix: 4 },
              sa: { a: 0, k: 0, ix: 5 },
              nm: "Transform",
              _render: !0,
            },
          ],
          nm: "Path 2",
          np: 2,
          cix: 2,
          bm: 0,
          ix: 1,
          mn: "ADBE Vector Group",
          hd: !1,
          _render: !0,
        },
        {
          ty: "gr",
          it: [
            {
              ty: "rc",
              d: 1,
              s: { a: 0, k: [200, 200], ix: 2 },
              p: { a: 0, k: [0, 0], ix: 3 },
              r: { a: 0, k: 24, ix: 4 },
              nm: "Rectangle Path 1",
              mn: "ADBE Vector Shape - Rect",
              hd: !1,
              _render: !0,
            },
            {
              ty: "fl",
              c: { a: 0, k: [0.6078, 0.6039, 0.6078, 1], ix: 4 },
              o: { a: 0, k: 100, ix: 5 },
              r: 1,
              bm: 0,
              nm: "Fill 1",
              mn: "ADBE Vector Graphic - Fill",
              hd: !1,
              _render: !0,
            },
            {
              ty: "tr",
              p: { a: 0, k: [19, 70], ix: 2 },
              a: { a: 0, k: [0, 0], ix: 1 },
              s: { a: 0, k: [100, 100], ix: 3 },
              r: { a: 0, k: 0, ix: 6 },
              o: { a: 0, k: 100, ix: 7 },
              sk: { a: 0, k: 0, ix: 4 },
              sa: { a: 0, k: 0, ix: 5 },
              nm: "Transform",
              _render: !0,
            },
          ],
          nm: "Rectangle 1",
          np: 2,
          cix: 2,
          bm: 0,
          ix: 2,
          mn: "ADBE Vector Group",
          hd: !1,
          _render: !0,
        },
      ],
      ip: 0,
      op: 240,
      st: 0,
      bm: 0,
      completed: !0,
    },
  ],
  markers$2 = [],
  __complete$4 = !0,
  fb = {
    v: v$5,
    meta: meta$3,
    fr: fr$5,
    ip: ip$5,
    op: op$5,
    w: w$6,
    h: h$5,
    nm: nm$5,
    ddd: ddd$5,
    assets: assets$5,
    layers: layers$5,
    markers: markers$2,
    __complete: __complete$4,
  },
  v$4 = "5.3.4",
  fr$4 = 24,
  ip$4 = 0,
  op$4 = 25,
  w$5 = 113,
  h$4 = 110,
  nm$4 = "LinkedIn_111",
  ddd$4 = 0,
  assets$4 = [],
  layers$4 = [
    {
      ddd: 0,
      ind: 1,
      ty: 4,
      nm: "Layer 5",
      sr: 1,
      ks: {
        o: { a: 0, k: 100, ix: 11 },
        r: { a: 0, k: 0, ix: 10 },
        p: { a: 0, k: [68.347, 64.076, 0], ix: 2 },
        a: { a: 0, k: [-525.52, 473.284, 0], ix: 1 },
        s: { a: 0, k: [24, 24, 100], ix: 6 },
      },
      ao: 0,
      shapes: [
        {
          ty: "gr",
          it: [
            {
              ind: 0,
              ty: "sh",
              ix: 1,
              ks: {
                a: 0,
                k: {
                  i: [
                    [-619.631, 378.581],
                    [-561.767, 378.581],
                    [-561.767, 405.133],
                    [-560.939, 405.133],
                    [-533.1940000000001, 373.761],
                    [-431.41, 413.977],
                    [-431.41, 572.807],
                    [-491.769, 572.807],
                    [-491.769, 478.355],
                    [-492.157, 426.856],
                    [-559.338, 451.405],
                    [-559.338, 572.807],
                    [-619.631, 572.807],
                  ],
                  o: [
                    [-619.631, 378.581],
                    [-561.767, 378.581],
                    [-561.767, 405.133],
                    [-552.891, 389.864],
                    [-442.706, 373.761],
                    [-431.41, 466.287],
                    [-431.41, 572.807],
                    [-491.769, 572.807],
                    [-491.769, 455.832],
                    [-554.5459999999999, 426.856],
                    [-559.338, 476.743],
                    [-559.338, 572.807],
                    [-619.631, 572.807],
                  ],
                  v: [
                    [-619.631, 378.581],
                    [-561.767, 378.581],
                    [-561.767, 405.133],
                    [-560.939, 405.133],
                    [-503.826, 373.761],
                    [-431.41, 466.287],
                    [-431.41, 572.807],
                    [-491.769, 572.807],
                    [-491.769, 478.355],
                    [-523.136, 426.856],
                    [-559.338, 476.743],
                    [-559.338, 572.807],
                    [-619.631, 572.807],
                  ],
                  c: !0,
                },
                ix: 2,
              },
              nm: "Path 1",
              mn: "ADBE Vector Shape - Group",
              hd: !1,
              _render: !0,
            },
            {
              ty: "fl",
              c: { a: 0, k: [0.6078, 0.6039, 0.6078, 1], ix: 4 },
              o: { a: 0, k: 100, ix: 5 },
              r: 1,
              nm: "Fill 1",
              mn: "ADBE Vector Graphic - Fill",
              hd: !1,
              _render: !0,
            },
            {
              ty: "tr",
              p: { a: 0, k: [0, 0], ix: 2 },
              a: { a: 0, k: [0, 0], ix: 1 },
              s: { a: 0, k: [100, 100], ix: 3 },
              r: { a: 0, k: 0, ix: 6 },
              o: { a: 0, k: 100, ix: 7 },
              sk: { a: 0, k: 0, ix: 4 },
              sa: { a: 0, k: 0, ix: 5 },
              nm: "Transform",
              _render: !0,
            },
          ],
          nm: "Group 1",
          np: 2,
          cix: 2,
          ix: 1,
          mn: "ADBE Vector Group",
          hd: !1,
          _render: !0,
        },
      ],
      ip: 0,
      op: 120,
      st: 0,
      bm: 0,
      completed: !0,
    },
    {
      ddd: 0,
      ind: 2,
      ty: 4,
      nm: "Layer 4",
      sr: 1,
      ks: {
        o: { a: 0, k: 100, ix: 11 },
        r: { a: 0, k: 0, ix: 10 },
        p: {
          a: 1,
          k: [
            {
              i: { x: 0.23, y: 1 },
              o: { x: 0.167, y: 0.167 },
              n: "0p23_1_0p167_0p167",
              t: 0,
              s: [29.421, 26.577, 0],
              e: [29.421, 19.077, 0],
              to: null,
              ti: null,
            },
            {
              i: { x: 0.833, y: 0.833 },
              o: { x: 0.77, y: 0 },
              n: "0p833_0p833_0p77_0",
              t: 3.25,
              s: [29.421, 19.077, 0],
              e: [29.421, 33.077, 0],
              to: null,
              ti: null,
            },
            {
              i: { x: 0.23, y: 1 },
              o: { x: 0.167, y: 0.167 },
              n: "0p23_1_0p167_0p167",
              t: 8.125,
              s: [29.421, 33.077, 0],
              e: [29.421, 18.077, 0],
              to: null,
              ti: null,
            },
            {
              i: { x: 0.667, y: 1 },
              o: { x: 0.268, y: 0 },
              n: "0p667_1_0p268_0",
              t: 13,
              s: [29.421, 18.077, 0],
              e: [29.421, 29.077, 0],
              to: null,
              ti: null,
            },
            {
              i: { x: 0.667, y: 1 },
              o: { x: 0.333, y: 0 },
              n: "0p667_1_0p333_0",
              t: 18.5,
              s: [29.421, 29.077, 0],
              e: [29.421, 26.577, 0],
              to: [0, 1.41666662693024, 0],
              ti: [0, 0.41666665673256, 0],
            },
            { t: 24 },
          ],
          ix: 2,
        },
        a: { a: 0, k: [-687.712, 317.038, 0], ix: 1 },
        s: { a: 0, k: [24, 24, 100], ix: 6 },
      },
      ao: 0,
      shapes: [
        {
          ty: "gr",
          it: [
            {
              ind: 0,
              ty: "sh",
              ix: 1,
              ks: {
                a: 0,
                k: {
                  i: [
                    [-687.696, 282.031],
                    [-652.708, 297.714],
                    [-668.3860000000001, 352.044],
                    [-722.716, 336.362],
                    [-707.0830000000001, 282.031],
                  ],
                  o: [
                    [-668.3860000000001, 282.031],
                    [-652.708, 336.362],
                    [-707.0830000000001, 352.044],
                    [-722.716, 297.714],
                    [-687.696, 282.031],
                  ],
                  v: [
                    [-687.696, 282.031],
                    [-652.708, 317.035],
                    [-687.696, 352.044],
                    [-722.716, 317.035],
                    [-687.696, 282.031],
                  ],
                  c: !1,
                },
                ix: 2,
              },
              nm: "Path 1",
              mn: "ADBE Vector Shape - Group",
              hd: !1,
              _render: !0,
            },
            {
              ty: "fl",
              c: { a: 0, k: [0.6078, 0.6039, 0.6078, 1], ix: 4 },
              o: { a: 0, k: 100, ix: 5 },
              r: 1,
              nm: "Fill 1",
              mn: "ADBE Vector Graphic - Fill",
              hd: !1,
              _render: !0,
            },
            {
              ty: "tr",
              p: { a: 0, k: [0, 0], ix: 2 },
              a: { a: 0, k: [0, 0], ix: 1 },
              s: { a: 0, k: [100, 100], ix: 3 },
              r: { a: 0, k: 0, ix: 6 },
              o: { a: 0, k: 100, ix: 7 },
              sk: { a: 0, k: 0, ix: 4 },
              sa: { a: 0, k: 0, ix: 5 },
              nm: "Transform",
              _render: !0,
            },
          ],
          nm: "Group 1",
          np: 2,
          cix: 2,
          ix: 1,
          mn: "ADBE Vector Group",
          hd: !1,
          _render: !0,
        },
      ],
      ip: 0,
      op: 120,
      st: 0,
      bm: 0,
      completed: !0,
    },
    {
      ddd: 0,
      ind: 3,
      ty: 4,
      nm: "Layer 1",
      sr: 1,
      ks: {
        o: { a: 0, k: 100, ix: 11 },
        r: { a: 0, k: 0, ix: 10 },
        p: { a: 0, k: [29.421, 87.962, 0], ix: 2 },
        a: { a: 0, k: [-687.712, 572.807, 0], ix: 1 },
        s: {
          a: 1,
          k: [
            {
              i: { x: [0.833, 0.833, 0.833], y: [0.833, 0.833, 0.833] },
              o: { x: [0.167, 0.167, 0.167], y: [0.167, 0.167, 0.167] },
              n: [
                "0p833_0p833_0p167_0p167",
                "0p833_0p833_0p167_0p167",
                "0p833_0p833_0p167_0p167",
              ],
              t: 0,
              s: [24, 24, 100],
              e: [24, 24, 100],
            },
            {
              i: { x: [0.833, 0.833, 0.833], y: [0.833, 0.833, 0.833] },
              o: { x: [0.167, 0.167, 0.167], y: [0.167, 0.167, 0.167] },
              n: [
                "0p833_0p833_0p167_0p167",
                "0p833_0p833_0p167_0p167",
                "0p833_0p833_0p167_0p167",
              ],
              t: 8,
              s: [24, 24, 100],
              e: [24, 22, 100],
            },
            {
              i: { x: [0.23, 0.23, 0.23], y: [1, 1, 1] },
              o: { x: [0.167, 0.167, 0.167], y: [0, 0.167, 0] },
              n: ["0p23_1_0p167_0", "0p23_1_0p167_0p167", "0p23_1_0p167_0"],
              t: 10,
              s: [24, 22, 100],
              e: [24, 24, 100],
            },
            { t: 20 },
          ],
          ix: 6,
        },
      },
      ao: 0,
      shapes: [
        {
          ty: "gr",
          it: [
            {
              ind: 0,
              ty: "sh",
              ix: 1,
              ks: {
                a: 0,
                k: {
                  i: [
                    [-717.925, 378.581],
                    [-657.5, 378.581],
                    [-657.5, 572.807],
                    [-717.925, 572.807],
                  ],
                  o: [
                    [-717.925, 378.581],
                    [-657.5, 378.581],
                    [-657.5, 572.807],
                    [-717.925, 572.807],
                  ],
                  v: [
                    [-717.925, 378.581],
                    [-657.5, 378.581],
                    [-657.5, 572.807],
                    [-717.925, 572.807],
                  ],
                  c: !0,
                },
                ix: 2,
              },
              nm: "Path 1",
              mn: "ADBE Vector Shape - Group",
              hd: !1,
              _render: !0,
            },
            {
              ty: "fl",
              c: { a: 0, k: [0.6078, 0.6039, 0.6078, 1], ix: 4 },
              o: { a: 0, k: 100, ix: 5 },
              r: 1,
              nm: "Fill 1",
              mn: "ADBE Vector Graphic - Fill",
              hd: !1,
              _render: !0,
            },
            {
              ty: "tr",
              p: { a: 0, k: [0, 0], ix: 2 },
              a: { a: 0, k: [0, 0], ix: 1 },
              s: { a: 0, k: [100, 100], ix: 3 },
              r: { a: 0, k: 0, ix: 6 },
              o: { a: 0, k: 100, ix: 7 },
              sk: { a: 0, k: 0, ix: 4 },
              sa: { a: 0, k: 0, ix: 5 },
              nm: "Transform",
              _render: !0,
            },
          ],
          nm: "Group 1",
          np: 2,
          cix: 2,
          ix: 1,
          mn: "ADBE Vector Group",
          hd: !1,
          _render: !0,
        },
      ],
      ip: 0,
      op: 120,
      st: 0,
      bm: 0,
      completed: !0,
    },
  ],
  markers$1 = [
    { tm: 3, cm: "1", dr: 0 },
    { tm: 7, cm: "2", dr: 0 },
    { tm: 11, cm: "3", dr: 0 },
    { tm: 15, cm: "4", dr: 0 },
  ],
  __complete$3 = !0,
  ln = {
    v: v$4,
    fr: fr$4,
    ip: ip$4,
    op: op$4,
    w: w$5,
    h: h$4,
    nm: nm$4,
    ddd: ddd$4,
    assets: assets$4,
    layers: layers$4,
    markers: markers$1,
    __complete: __complete$3,
  },
  nm$3 = "Comp 1",
  mn$1 = "",
  layers$3 = [
    {
      ty: 4,
      nm: "github logo Outlines",
      mn: "",
      sr: 1,
      st: 0,
      op: 180,
      ip: 0,
      hd: !1,
      cl: "",
      ln: "",
      ddd: 0,
      bm: 0,
      tt: 0,
      hasMask: !1,
      td: 0,
      ao: 0,
      ks: {
        a: { a: 0, k: [400, 400, 0], ix: 1 },
        s: { a: 0, k: [107.92, 107.92, 100], ix: 6 },
        sk: { a: 0, k: 0 },
        p: { a: 0, k: [400, 400, 0], ix: 2 },
        sa: { a: 0, k: 0 },
        o: { a: 0, k: 100, ix: 11 },
        r: { a: 0, k: 0, ix: 10 },
      },
      ef: [],
      shapes: [
        {
          ty: "gr",
          bm: 0,
          cl: "",
          ln: "",
          hd: !1,
          mn: "ADBE Vector Group",
          nm: "Group 1",
          ix: 1,
          cix: 2,
          np: 2,
          it: [
            {
              ty: "sh",
              bm: 0,
              cl: "",
              ln: "",
              hd: !1,
              mn: "ADBE Vector Shape - Group",
              nm: "Path 1",
              ix: 1,
              d: 1,
              ks: {
                a: 1,
                k: [
                  {
                    o: { x: 0.167, y: 0.167 },
                    i: { x: 0.833, y: 0.833 },
                    s: [
                      {
                        c: !0,
                        i: [
                          [-165.449, -213.833],
                          [-31.175, -179.084],
                          [61.39300000000001, -174.993],
                          [190.198, -203.95],
                          [194.112, -107.772],
                          [231.429, -48.572],
                          [228.191, 39.974000000000004],
                          [206.957, 97.749],
                          [173.732, 133.10299999999998],
                          [128.386, 156.238],
                          [83.601, 166.64399999999998],
                          [90.208, 205.053],
                          [90.208, 335.238],
                          [92.17699999999999, 345.626],
                          [106.267, 354.282],
                          [247.41500000000002, 284.776],
                          [362.727, 87.443],
                          [346.486, -118.06599999999999],
                          [237.636, -273.214],
                          [65.812, -354.296],
                          [-126.505, -338.077],
                          [-281.644, -229.21499999999997],
                          [-362.727, -57.379000000000005],
                          [-339.66700000000003, 158.53099999999998],
                          [-187.82100000000003, 328.47499999999997],
                          [-99.97800000000001, 353.185],
                          [-89.747, 340.913],
                          [-89.828, 325.81100000000004],
                          [-90.223, 279.678],
                          [-103.325, 270.567],
                          [-143.75500000000002, 270.31600000000003],
                          [-182.006, 261.19],
                          [-209.262, 234.827],
                          [-252.861, 176.52],
                          [-267.302, 157.171],
                          [-263.92, 149.37800000000001],
                          [-229.618, 154.025],
                          [-200.77100000000002, 176.19199999999998],
                          [-163.332, 224.51999999999998],
                          [-95.894, 220.32199999999997],
                          [-78.72999999999999, 179.859],
                          [-100.218, 163.798],
                          [-143.671, 150.10299999999998],
                          [-186.88899999999998, 122.54299999999999],
                          [-215.304, 80.82300000000001],
                          [-231.434, 16.281],
                          [-218.995, -81.012],
                          [-213.979, -150.126],
                        ],
                        o: [
                          [-61.400000000000006, -174.993],
                          [31.163, -179.084],
                          [167.87400000000002, -216.726],
                          [213.727, -148.773],
                          [218.98499999999999, -81.007],
                          [231.429, 16.286],
                          [215.295, 81.23],
                          [186.486, 122.633],
                          [143.192, 150.10199999999998],
                          [99.73499999999999, 163.80100000000002],
                          [82.023, 182.696],
                          [90.208, 235.593],
                          [90.208, 340.899],
                          [100.05199999999999, 353.173],
                          [187.826, 328.463],
                          [339.659, 158.518],
                          [362.71, -57.385000000000005],
                          [281.633, -229.21499999999997],
                          [126.487, -338.081],
                          [-65.81, -354.296],
                          [-237.647, -273.216],
                          [-346.51099999999997, -118.06599999999999],
                          [-362.727, 87.458],
                          [-247.409, 284.78999999999996],
                          [-106.272, 354.29499999999996],
                          [-91.79100000000001, 345.64000000000004],
                          [-89.747, 334.308],
                          [-90.147, 293.689],
                          [-90.223, 267.723],
                          [-130.639, 271.656],
                          [-175.067, 265.75],
                          [-201.524, 246.391],
                          [-240.861, 168.401],
                          [-264.346, 160.775],
                          [-266.095, 153.045],
                          [-240.508, 149.844],
                          [-209.523, 167.93],
                          [-181.685, 209.433],
                          [-114.09700000000001, 228.314],
                          [-86.44500000000001, 196.071],
                          [-84.084, 166.639],
                          [-128.871, 156.239],
                          [-174.21599999999998, 133.096],
                          [-207.036, 97.359],
                          [-228.207, 39.893],
                          [-231.434, -48.586],
                          [-194.12, -107.777],
                          [-190.155, -204.656],
                        ],
                        v: [
                          [-90.688, -166.809],
                          [-0.006, -179.084],
                          [90.683, -166.809],
                          [190.198, -203.95],
                          [194.112, -107.772],
                          [231.429, -10.475],
                          [221.748, 60.6],
                          [196.727, 110.192],
                          [158.463, 141.599],
                          [114.064, 160.02],
                          [65.657, 168.533],
                          [90.208, 235.593],
                          [90.208, 335.238],
                          [96.118, 349.402],
                          [114.77, 352.702],
                          [293.54, 221.645],
                          [362.727, 8.404],
                          [314.07, -173.64],
                          [182.066, -305.647],
                          [-0.003, -354.296],
                          [-182.072, -305.647],
                          [-314.08, -173.64],
                          [-362.727, 8.419],
                          [-293.536, 221.658],
                          [-114.775, 352.717],
                          [-95.885, 349.415],
                          [-89.747, 335.253],
                          [-89.985, 309.749],
                          [-90.223, 267.723],
                          [-119.126, 271.197],
                          [-153.449, 268.901],
                          [-191.768, 253.79],
                          [-217.268, 213.88],
                          [-262.132, 163.812],
                          [-266.567, 154.659],
                          [-250.322, 149.649],
                          [-218.368, 161.81],
                          [-194.596, 186.944],
                          [-142.501, 226.35],
                          [-89.278, 217.176],
                          [-66.139, 168.525],
                          [-114.548, 160.022],
                          [-158.939, 141.593],
                          [-196.962, 109.954],
                          [-221.754, 60.362],
                          [-231.434, -10.48],
                          [-194.12, -107.777],
                          [-190.155, -204.656],
                        ],
                      },
                    ],
                    t: 0,
                  },
                  {
                    o: { x: 0.167, y: 0.167 },
                    i: { x: 0.833, y: 0.833 },
                    s: [
                      {
                        c: !0,
                        i: [
                          [-165.449, -213.833],
                          [-31.175, -179.084],
                          [61.39300000000001, -174.993],
                          [190.198, -203.95],
                          [194.112, -107.772],
                          [231.429, -48.572],
                          [228.191, 39.974000000000004],
                          [206.957, 97.749],
                          [173.732, 133.10299999999998],
                          [128.386, 156.238],
                          [83.601, 166.64399999999998],
                          [90.208, 205.053],
                          [90.208, 335.238],
                          [92.17699999999999, 345.626],
                          [106.267, 354.282],
                          [247.41500000000002, 284.776],
                          [362.727, 87.443],
                          [346.486, -118.06599999999999],
                          [237.636, -273.214],
                          [65.812, -354.296],
                          [-126.505, -338.077],
                          [-281.644, -229.21499999999997],
                          [-362.727, -57.379000000000005],
                          [-339.66700000000003, 158.53099999999998],
                          [-187.82100000000003, 328.47499999999997],
                          [-99.97800000000001, 353.185],
                          [-89.747, 340.913],
                          [-89.828, 325.81100000000004],
                          [-90.223, 279.678],
                          [-102.862, 265.007],
                          [-143.292, 264.757],
                          [-181.071, 259.759],
                          [-212.978, 241.356],
                          [-249.357, 176.675],
                          [-265.449, 155.781],
                          [-262.797, 146.869],
                          [-231.21099999999998, 153.924],
                          [-209.331, 180.53300000000002],
                          [-162.869, 218.96099999999998],
                          [-95.894, 220.32199999999997],
                          [-78.72999999999999, 179.859],
                          [-100.218, 163.798],
                          [-143.671, 150.10299999999998],
                          [-186.88899999999998, 122.54299999999999],
                          [-215.304, 80.82300000000001],
                          [-231.434, 16.281],
                          [-218.995, -81.012],
                          [-213.979, -150.126],
                        ],
                        o: [
                          [-61.400000000000006, -174.993],
                          [31.163, -179.084],
                          [167.87400000000002, -216.726],
                          [213.727, -148.773],
                          [218.98499999999999, -81.007],
                          [231.429, 16.286],
                          [215.295, 81.23],
                          [186.486, 122.633],
                          [143.192, 150.10199999999998],
                          [99.73499999999999, 163.80100000000002],
                          [82.023, 182.696],
                          [90.208, 235.593],
                          [90.208, 340.899],
                          [100.05199999999999, 353.173],
                          [187.826, 328.463],
                          [339.659, 158.518],
                          [362.71, -57.385000000000005],
                          [281.633, -229.21499999999997],
                          [126.487, -338.081],
                          [-65.81, -354.296],
                          [-237.647, -273.216],
                          [-346.51099999999997, -118.06599999999999],
                          [-362.727, 87.458],
                          [-247.409, 284.78999999999996],
                          [-106.272, 354.29499999999996],
                          [-91.79100000000001, 345.64000000000004],
                          [-89.747, 334.308],
                          [-90.147, 293.689],
                          [-90.223, 267.723],
                          [-130.176, 266.096],
                          [-174.60399999999998, 260.191],
                          [-202.1, 248.025],
                          [-241.94400000000002, 182.69799999999998],
                          [-264.346, 160.775],
                          [-264.242, 151.655],
                          [-237.774, 151.193],
                          [-214.84099999999998, 171.348],
                          [-191.907, 207.254],
                          [-113.63400000000001, 222.755],
                          [-86.44500000000001, 196.071],
                          [-84.084, 166.639],
                          [-128.871, 156.239],
                          [-174.21599999999998, 133.096],
                          [-207.036, 97.359],
                          [-228.207, 39.893],
                          [-231.434, -48.586],
                          [-194.12, -107.777],
                          [-190.155, -204.656],
                        ],
                        v: [
                          [-90.688, -166.809],
                          [-0.006, -179.084],
                          [90.683, -166.809],
                          [190.198, -203.95],
                          [194.112, -107.772],
                          [231.429, -10.475],
                          [221.748, 60.6],
                          [196.727, 110.192],
                          [158.463, 141.599],
                          [114.064, 160.02],
                          [65.657, 168.533],
                          [90.208, 235.593],
                          [90.208, 335.238],
                          [96.118, 349.402],
                          [114.77, 352.702],
                          [293.54, 221.645],
                          [362.727, 8.404],
                          [314.07, -173.64],
                          [182.066, -305.647],
                          [-0.003, -354.296],
                          [-182.072, -305.647],
                          [-314.08, -173.64],
                          [-362.727, 8.419],
                          [-293.536, 221.658],
                          [-114.775, 352.717],
                          [-95.885, 349.415],
                          [-89.747, 335.253],
                          [-89.985, 309.749],
                          [-90.223, 267.723],
                          [-118.663, 265.637],
                          [-152.986, 263.342],
                          [-191.768, 253.79],
                          [-227.461, 212.027],
                          [-262.132, 163.812],
                          [-264.714, 153.269],
                          [-249.395, 149.185],
                          [-221.843, 163.895],
                          [-200.619, 193.893],
                          [-142.038, 220.791],
                          [-89.278, 217.176],
                          [-66.139, 168.525],
                          [-114.548, 160.022],
                          [-158.939, 141.593],
                          [-196.962, 109.954],
                          [-221.754, 60.362],
                          [-231.434, -10.48],
                          [-194.12, -107.777],
                          [-190.155, -204.656],
                        ],
                      },
                    ],
                    t: 20,
                  },
                  {
                    o: { x: 0.167, y: 0.167 },
                    i: { x: 0.833, y: 0.833 },
                    s: [
                      {
                        c: !0,
                        i: [
                          [-165.449, -213.833],
                          [-31.175, -179.084],
                          [61.39300000000001, -174.993],
                          [190.198, -203.95],
                          [194.112, -107.772],
                          [231.429, -48.572],
                          [228.191, 39.974000000000004],
                          [206.957, 97.749],
                          [173.732, 133.10299999999998],
                          [128.386, 156.238],
                          [83.601, 166.64399999999998],
                          [90.208, 205.053],
                          [90.208, 335.238],
                          [92.17699999999999, 345.626],
                          [106.267, 354.282],
                          [247.41500000000002, 284.776],
                          [362.727, 87.443],
                          [346.486, -118.06599999999999],
                          [237.636, -273.214],
                          [65.812, -354.296],
                          [-126.505, -338.077],
                          [-281.644, -229.21499999999997],
                          [-362.727, -57.379000000000005],
                          [-339.66700000000003, 158.53099999999998],
                          [-187.82100000000003, 328.47499999999997],
                          [-99.97800000000001, 353.185],
                          [-89.747, 340.913],
                          [-89.828, 325.81100000000004],
                          [-90.223, 279.678],
                          [-102.952, 265.167],
                          [-139.122, 252.47899999999998],
                          [-179.63, 248.72],
                          [-224.106, 240.148],
                          [-262.465, 184.891],
                          [-268.92400000000004, 159.14],
                          [-263.488, 153.857],
                          [-241.635, 162.726],
                          [-221.55900000000003, 186.405],
                          [-160.552, 207.84099999999998],
                          [-95.894, 220.32199999999997],
                          [-78.72999999999999, 179.859],
                          [-100.218, 163.798],
                          [-143.671, 150.10299999999998],
                          [-186.88899999999998, 122.54299999999999],
                          [-215.304, 80.82300000000001],
                          [-231.434, 16.281],
                          [-218.995, -81.012],
                          [-213.979, -150.126],
                        ],
                        o: [
                          [-61.400000000000006, -174.993],
                          [31.163, -179.084],
                          [167.87400000000002, -216.726],
                          [213.727, -148.773],
                          [218.98499999999999, -81.007],
                          [231.429, 16.286],
                          [215.295, 81.23],
                          [186.486, 122.633],
                          [143.192, 150.10199999999998],
                          [99.73499999999999, 163.80100000000002],
                          [82.023, 182.696],
                          [90.208, 235.593],
                          [90.208, 340.899],
                          [100.05199999999999, 353.173],
                          [187.826, 328.463],
                          [339.659, 158.518],
                          [362.71, -57.385000000000005],
                          [281.633, -229.21499999999997],
                          [126.487, -338.081],
                          [-65.81, -354.296],
                          [-237.647, -273.216],
                          [-346.51099999999997, -118.06599999999999],
                          [-362.727, 87.458],
                          [-247.409, 284.78999999999996],
                          [-106.272, 354.29499999999996],
                          [-91.79100000000001, 345.64000000000004],
                          [-89.747, 334.308],
                          [-90.147, 293.689],
                          [-90.223, 267.723],
                          [-129.128, 256.429],
                          [-170.434, 247.91299999999998],
                          [-205.22, 249.102],
                          [-261.402, 181.077],
                          [-270.437, 166.135],
                          [-267.71700000000004, 155.01399999999998],
                          [-247.135, 158.006],
                          [-225.265, 180.15],
                          [-196.181, 219.851],
                          [-111.31700000000001, 211.635],
                          [-86.44500000000001, 196.071],
                          [-84.084, 166.639],
                          [-128.871, 156.239],
                          [-174.21599999999998, 133.096],
                          [-207.036, 97.359],
                          [-228.207, 39.893],
                          [-231.434, -48.586],
                          [-194.12, -107.777],
                          [-190.155, -204.656],
                        ],
                        v: [
                          [-90.688, -166.809],
                          [-0.006, -179.084],
                          [90.683, -166.809],
                          [190.198, -203.95],
                          [194.112, -107.772],
                          [231.429, -10.475],
                          [221.748, 60.6],
                          [196.727, 110.192],
                          [158.463, 141.599],
                          [114.064, 160.02],
                          [65.657, 168.533],
                          [90.208, 235.593],
                          [90.208, 335.238],
                          [96.118, 349.402],
                          [114.77, 352.702],
                          [293.54, 221.645],
                          [362.727, 8.404],
                          [314.07, -173.64],
                          [182.066, -305.647],
                          [-0.003, -354.296],
                          [-182.072, -305.647],
                          [-314.08, -173.64],
                          [-362.727, 8.419],
                          [-293.536, 221.658],
                          [-114.775, 352.717],
                          [-95.885, 349.415],
                          [-89.747, 335.253],
                          [-89.985, 309.749],
                          [-90.223, 267.723],
                          [-118.199, 260.077],
                          [-148.816, 251.064],
                          [-193.39, 248.925],
                          [-236.263, 222.683],
                          [-268.618, 170.414],
                          [-268.189, 156.628],
                          [-255.882, 155.787],
                          [-232.267, 172.697],
                          [-213.592, 196.905],
                          [-139.721, 209.671],
                          [-89.278, 217.176],
                          [-66.139, 168.525],
                          [-114.548, 160.022],
                          [-158.939, 141.593],
                          [-196.962, 109.954],
                          [-221.754, 60.362],
                          [-231.434, -10.48],
                          [-194.12, -107.777],
                          [-190.155, -204.656],
                        ],
                      },
                    ],
                    t: 44,
                  },
                  {
                    o: { x: 0.167, y: 0.167 },
                    i: { x: 0.833, y: 0.833 },
                    s: [
                      {
                        c: !0,
                        i: [
                          [-165.449, -213.833],
                          [-31.175, -179.084],
                          [61.39300000000001, -174.993],
                          [190.198, -203.95],
                          [194.112, -107.772],
                          [231.429, -48.572],
                          [228.191, 39.974000000000004],
                          [206.957, 97.749],
                          [173.732, 133.10299999999998],
                          [128.386, 156.238],
                          [83.601, 166.64399999999998],
                          [90.208, 205.053],
                          [90.208, 335.238],
                          [92.17699999999999, 345.626],
                          [106.267, 354.282],
                          [247.41500000000002, 284.776],
                          [362.727, 87.443],
                          [346.486, -118.06599999999999],
                          [237.636, -273.214],
                          [65.812, -354.296],
                          [-126.505, -338.077],
                          [-281.644, -229.21499999999997],
                          [-362.727, -57.379000000000005],
                          [-339.66700000000003, 158.53099999999998],
                          [-187.82100000000003, 328.47499999999997],
                          [-99.97800000000001, 353.185],
                          [-89.747, 340.913],
                          [-89.828, 325.81100000000004],
                          [-90.223, 284.542],
                          [-99.47800000000001, 257.059],
                          [-134.952, 237.19],
                          [-179.63, 237.601],
                          [-222.022, 237.137],
                          [-267.794, 196.184],
                          [-274.252, 170.433],
                          [-268.816, 165.15],
                          [-249.975, 178.71],
                          [-223.64000000000001, 203.006],
                          [-156.38199999999998, 192.552],
                          [-95.771, 210.266],
                          [-78.72999999999999, 179.859],
                          [-100.218, 163.798],
                          [-143.671, 150.10299999999998],
                          [-186.88899999999998, 122.54299999999999],
                          [-215.304, 80.82300000000001],
                          [-231.434, 16.281],
                          [-218.995, -81.012],
                          [-213.979, -150.126],
                        ],
                        o: [
                          [-61.400000000000006, -174.993],
                          [31.163, -179.084],
                          [167.87400000000002, -216.726],
                          [213.727, -148.773],
                          [218.98499999999999, -81.007],
                          [231.429, 16.286],
                          [215.295, 81.23],
                          [186.486, 122.633],
                          [143.192, 150.10199999999998],
                          [99.73499999999999, 163.80100000000002],
                          [82.023, 182.696],
                          [90.208, 235.593],
                          [90.208, 340.899],
                          [100.05199999999999, 353.173],
                          [187.826, 328.463],
                          [339.659, 158.518],
                          [362.71, -57.385000000000005],
                          [281.633, -229.21499999999997],
                          [126.487, -338.081],
                          [-65.81, -354.296],
                          [-237.647, -273.216],
                          [-346.51099999999997, -118.06599999999999],
                          [-362.727, 87.458],
                          [-247.409, 284.78999999999996],
                          [-106.272, 354.29499999999996],
                          [-91.79100000000001, 345.64000000000004],
                          [-89.747, 334.308],
                          [-90.147, 293.689],
                          [-90.223, 272.587],
                          [-124.61500000000001, 238.07600000000002],
                          [-166.26399999999998, 232.624],
                          [-205.22, 237.983],
                          [-255.803, 211.986],
                          [-275.766, 177.428],
                          [-273.045, 166.307],
                          [-252.46299999999997, 169.299],
                          [-233.605, 196.13400000000001],
                          [-187.274, 207.949],
                          [-107.14699999999999, 196.346],
                          [-86.44500000000001, 196.071],
                          [-84.084, 166.639],
                          [-128.871, 156.239],
                          [-174.21599999999998, 133.096],
                          [-207.036, 97.359],
                          [-228.207, 39.893],
                          [-231.434, -48.586],
                          [-194.12, -107.777],
                          [-190.155, -204.656],
                        ],
                        v: [
                          [-90.688, -166.809],
                          [-0.006, -179.084],
                          [90.683, -166.809],
                          [190.198, -203.95],
                          [194.112, -107.772],
                          [231.429, -10.475],
                          [221.748, 60.6],
                          [196.727, 110.192],
                          [158.463, 141.599],
                          [114.064, 160.02],
                          [65.657, 168.533],
                          [90.208, 235.593],
                          [90.208, 335.238],
                          [96.118, 349.402],
                          [114.77, 352.702],
                          [293.54, 221.645],
                          [362.727, 8.404],
                          [314.07, -173.64],
                          [182.066, -305.647],
                          [-0.003, -354.296],
                          [-182.072, -305.647],
                          [-314.08, -173.64],
                          [-362.727, 8.419],
                          [-293.536, 221.658],
                          [-114.775, 352.717],
                          [-95.885, 349.415],
                          [-89.747, 335.253],
                          [-89.985, 309.749],
                          [-90.223, 272.587],
                          [-115.42, 245.02],
                          [-144.646, 235.775],
                          [-193.39, 237.806],
                          [-231.167, 230.328],
                          [-273.947, 181.707],
                          [-273.517, 167.921],
                          [-261.21, 167.08],
                          [-240.607, 188.681],
                          [-210.58, 204.781],
                          [-135.551, 194.382],
                          [-89.278, 217.176],
                          [-66.139, 168.525],
                          [-114.548, 160.022],
                          [-158.939, 141.593],
                          [-196.962, 109.954],
                          [-221.754, 60.362],
                          [-231.434, -10.48],
                          [-194.12, -107.777],
                          [-190.155, -204.656],
                        ],
                      },
                    ],
                    t: 65,
                  },
                  {
                    o: { x: 0.167, y: 0.167 },
                    i: { x: 0.833, y: 0.833 },
                    s: [
                      {
                        c: !0,
                        i: [
                          [-165.449, -213.833],
                          [-31.175, -179.084],
                          [61.39300000000001, -174.993],
                          [190.198, -203.95],
                          [194.112, -107.772],
                          [231.429, -48.572],
                          [228.191, 39.974000000000004],
                          [206.957, 97.749],
                          [173.732, 133.10299999999998],
                          [128.386, 156.238],
                          [83.601, 166.64399999999998],
                          [90.208, 205.053],
                          [90.208, 335.238],
                          [92.17699999999999, 345.626],
                          [106.267, 354.282],
                          [247.41500000000002, 284.776],
                          [362.727, 87.443],
                          [346.486, -118.06599999999999],
                          [237.636, -273.214],
                          [65.812, -354.296],
                          [-126.505, -338.077],
                          [-281.644, -229.21499999999997],
                          [-362.727, -57.379000000000005],
                          [-339.66700000000003, 158.53099999999998],
                          [-187.82100000000003, 328.47499999999997],
                          [-99.97800000000001, 353.185],
                          [-89.747, 340.913],
                          [-89.828, 325.81100000000004],
                          [-90.223, 279.678],
                          [-103.795, 265.64300000000003],
                          [-137.931, 244.54899999999998],
                          [-173.838, 216.288],
                          [-208.31400000000002, 218.498],
                          [-271.847, 208.346],
                          [-278.30600000000004, 182.594],
                          [-270.356, 173.27100000000002],
                          [-257.802, 193.042],
                          [-220.917, 189.71499999999997],
                          [-153.453, 182.23499999999999],
                          [-99.709, 219.06799999999998],
                          [-78.72999999999999, 179.859],
                          [-100.218, 163.798],
                          [-143.671, 150.10299999999998],
                          [-186.88899999999998, 122.54299999999999],
                          [-215.304, 80.82300000000001],
                          [-231.434, 16.281],
                          [-218.995, -81.012],
                          [-213.979, -150.126],
                        ],
                        o: [
                          [-61.400000000000006, -174.993],
                          [31.163, -179.084],
                          [167.87400000000002, -216.726],
                          [213.727, -148.773],
                          [218.98499999999999, -81.007],
                          [231.429, 16.286],
                          [215.295, 81.23],
                          [186.486, 122.633],
                          [143.192, 150.10199999999998],
                          [99.73499999999999, 163.80100000000002],
                          [82.023, 182.696],
                          [90.208, 235.593],
                          [90.208, 340.899],
                          [100.05199999999999, 353.173],
                          [187.826, 328.463],
                          [339.659, 158.518],
                          [362.71, -57.385000000000005],
                          [281.633, -229.21499999999997],
                          [126.487, -338.081],
                          [-65.81, -354.296],
                          [-237.647, -273.216],
                          [-346.51099999999997, -118.06599999999999],
                          [-362.727, 87.458],
                          [-247.409, 284.78999999999996],
                          [-106.272, 354.29499999999996],
                          [-91.79100000000001, 345.64000000000004],
                          [-89.747, 334.308],
                          [-90.147, 293.689],
                          [-90.223, 267.723],
                          [-131.677, 251.73100000000002],
                          [-163, 218.376],
                          [-203.35, 214.699],
                          [-259.086, 222.079],
                          [-279.819, 189.59],
                          [-277.09900000000005, 178.468],
                          [-259.55, 185.941],
                          [-233.604, 197.292],
                          [-171.05800000000002, 178.992],
                          [-109.67099999999999, 206.79],
                          [-86.44500000000001, 196.071],
                          [-84.084, 166.639],
                          [-128.871, 156.239],
                          [-174.21599999999998, 133.096],
                          [-207.036, 97.359],
                          [-228.207, 39.893],
                          [-231.434, -48.586],
                          [-194.12, -107.777],
                          [-190.155, -204.656],
                        ],
                        v: [
                          [-90.688, -166.809],
                          [-0.006, -179.084],
                          [90.683, -166.809],
                          [190.198, -203.95],
                          [194.112, -107.772],
                          [231.429, -10.475],
                          [221.748, 60.6],
                          [196.727, 110.192],
                          [158.463, 141.599],
                          [114.064, 160.02],
                          [65.657, 168.533],
                          [90.208, 235.593],
                          [90.208, 335.238],
                          [96.118, 349.402],
                          [114.77, 352.702],
                          [293.54, 221.645],
                          [362.727, 8.404],
                          [314.07, -173.64],
                          [182.066, -305.647],
                          [-0.003, -354.296],
                          [-182.072, -305.647],
                          [-314.08, -173.64],
                          [-362.727, 8.419],
                          [-293.536, 221.658],
                          [-114.775, 352.717],
                          [-95.885, 349.415],
                          [-89.747, 335.253],
                          [-89.985, 309.749],
                          [-90.223, 267.723],
                          [-117.736, 258.687],
                          [-147.889, 234.153],
                          [-191.536, 215.335],
                          [-221.669, 219.44],
                          [-278, 193.869],
                          [-277.571, 180.082],
                          [-265.264, 179.241],
                          [-245.703, 195.167],
                          [-208.032, 186.944],
                          [-132.772, 193.224],
                          [-89.278, 217.176],
                          [-66.139, 168.525],
                          [-114.548, 160.022],
                          [-158.939, 141.593],
                          [-196.962, 109.954],
                          [-221.754, 60.362],
                          [-231.434, -10.48],
                          [-194.12, -107.777],
                          [-190.155, -204.656],
                        ],
                      },
                    ],
                    t: 89,
                  },
                  {
                    o: { x: 0.167, y: 0.167 },
                    i: { x: 0.833, y: 0.833 },
                    s: [
                      {
                        c: !0,
                        i: [
                          [-165.449, -213.833],
                          [-31.175, -179.084],
                          [61.39300000000001, -174.993],
                          [190.198, -203.95],
                          [194.112, -107.772],
                          [231.429, -48.572],
                          [228.191, 39.974000000000004],
                          [206.957, 97.749],
                          [173.732, 133.10299999999998],
                          [128.386, 156.238],
                          [83.601, 166.64399999999998],
                          [90.208, 205.053],
                          [90.208, 335.238],
                          [92.17699999999999, 345.626],
                          [106.267, 354.282],
                          [247.41500000000002, 284.776],
                          [362.727, 87.443],
                          [346.486, -118.06599999999999],
                          [237.636, -273.214],
                          [65.812, -354.296],
                          [-126.505, -338.077],
                          [-281.644, -229.21499999999997],
                          [-362.727, -57.379000000000005],
                          [-339.66700000000003, 158.53099999999998],
                          [-187.82100000000003, 328.47499999999997],
                          [-99.97800000000001, 353.185],
                          [-89.747, 340.913],
                          [-89.828, 325.81100000000004],
                          [-90.223, 279.678],
                          [-103.563, 265.87399999999997],
                          [-138.85199999999998, 252.945],
                          [-168.00099999999998, 208.12800000000001],
                          [-213.219, 193.401],
                          [-261.22900000000004, 195.38199999999998],
                          [-282.38899999999995, 198.30599999999998],
                          [-279.63100000000003, 185.541],
                          [-261.024, 175.93099999999998],
                          [-221.881, 171.522],
                          [-152.862, 183.596],
                          [-99.709, 219.06799999999998],
                          [-78.72999999999999, 179.859],
                          [-100.218, 163.798],
                          [-143.671, 150.10299999999998],
                          [-186.88899999999998, 122.54299999999999],
                          [-215.304, 80.82300000000001],
                          [-231.434, 16.281],
                          [-218.995, -81.012],
                          [-213.979, -150.126],
                        ],
                        o: [
                          [-61.400000000000006, -174.993],
                          [31.163, -179.084],
                          [167.87400000000002, -216.726],
                          [213.727, -148.773],
                          [218.98499999999999, -81.007],
                          [231.429, 16.286],
                          [215.295, 81.23],
                          [186.486, 122.633],
                          [143.192, 150.10199999999998],
                          [99.73499999999999, 163.80100000000002],
                          [82.023, 182.696],
                          [90.208, 235.593],
                          [90.208, 340.899],
                          [100.05199999999999, 353.173],
                          [187.826, 328.463],
                          [339.659, 158.518],
                          [362.71, -57.385000000000005],
                          [281.633, -229.21499999999997],
                          [126.487, -338.081],
                          [-65.81, -354.296],
                          [-237.647, -273.216],
                          [-346.51099999999997, -118.06599999999999],
                          [-362.727, 87.458],
                          [-247.409, 284.78999999999996],
                          [-106.272, 354.29499999999996],
                          [-91.79100000000001, 345.64000000000004],
                          [-89.747, 334.308],
                          [-90.147, 293.689],
                          [-90.223, 267.723],
                          [-130.055, 257.522],
                          [-162.024, 227.40699999999998],
                          [-206.733, 195.208],
                          [-249.588, 192.891],
                          [-276.283, 200.291],
                          [-283.46799999999996, 190.111],
                          [-265.10900000000004, 177.95000000000002],
                          [-232.214, 171.463],
                          [-169.437, 174.823],
                          [-117.77799999999999, 214.89800000000002],
                          [-86.44500000000001, 196.071],
                          [-84.084, 166.639],
                          [-128.871, 156.239],
                          [-174.21599999999998, 133.096],
                          [-207.036, 97.359],
                          [-228.207, 39.893],
                          [-231.434, -48.586],
                          [-194.12, -107.777],
                          [-190.155, -204.656],
                        ],
                        v: [
                          [-90.688, -166.809],
                          [-0.006, -179.084],
                          [90.683, -166.809],
                          [190.198, -203.95],
                          [194.112, -107.772],
                          [231.429, -10.475],
                          [221.748, 60.6],
                          [196.727, 110.192],
                          [158.463, 141.599],
                          [114.064, 160.02],
                          [65.657, 168.533],
                          [90.208, 235.593],
                          [90.208, 335.238],
                          [96.118, 349.402],
                          [114.77, 352.702],
                          [293.54, 221.645],
                          [362.727, 8.404],
                          [314.07, -173.64],
                          [182.066, -305.647],
                          [-0.003, -354.296],
                          [-182.072, -305.647],
                          [-314.08, -173.64],
                          [-362.727, 8.419],
                          [-293.536, 221.658],
                          [-114.775, 352.717],
                          [-95.885, 349.415],
                          [-89.747, 335.253],
                          [-89.985, 309.749],
                          [-90.223, 267.723],
                          [-116.809, 261.698],
                          [-150.438, 240.176],
                          [-187.367, 201.668],
                          [-223.059, 193.263],
                          [-271.862, 198.849],
                          [-283.073, 193.112],
                          [-272.677, 181.906],
                          [-243.155, 173.16],
                          [-208.727, 172.35],
                          [-135.32, 199.247],
                          [-89.278, 217.176],
                          [-66.139, 168.525],
                          [-114.548, 160.022],
                          [-158.939, 141.593],
                          [-196.962, 109.954],
                          [-221.754, 60.362],
                          [-231.434, -10.48],
                          [-194.12, -107.777],
                          [-190.155, -204.656],
                        ],
                      },
                    ],
                    t: 112,
                  },
                  {
                    o: { x: 0.167, y: 0.167 },
                    i: { x: 0.833, y: 0.833 },
                    s: [
                      {
                        c: !0,
                        i: [
                          [-165.449, -213.833],
                          [-31.175, -179.084],
                          [61.39300000000001, -174.993],
                          [190.198, -203.95],
                          [194.112, -107.772],
                          [231.429, -48.572],
                          [228.191, 39.974000000000004],
                          [206.957, 97.749],
                          [173.732, 133.10299999999998],
                          [128.386, 156.238],
                          [83.601, 166.64399999999998],
                          [90.208, 205.053],
                          [90.208, 335.238],
                          [92.17699999999999, 345.626],
                          [106.267, 354.282],
                          [247.41500000000002, 284.776],
                          [362.727, 87.443],
                          [346.486, -118.06599999999999],
                          [237.636, -273.214],
                          [65.812, -354.296],
                          [-126.505, -338.077],
                          [-281.644, -229.21499999999997],
                          [-362.727, -57.379000000000005],
                          [-339.66700000000003, 158.53099999999998],
                          [-187.82100000000003, 328.47499999999997],
                          [-99.97800000000001, 353.185],
                          [-89.747, 340.913],
                          [-89.828, 325.81100000000004],
                          [-90.223, 279.678],
                          [-102.721, 267.483],
                          [-146.72799999999998, 257.81],
                          [-171.177, 218.946],
                          [-206.691, 187.154],
                          [-253.989, 180.613],
                          [-274.976, 180.237],
                          [-273.014, 165.066],
                          [-251.455, 162.169],
                          [-214.332, 163.59199999999998],
                          [-156.568, 193.325],
                          [-99.477, 220.22699999999998],
                          [-78.72999999999999, 179.859],
                          [-100.218, 163.798],
                          [-143.671, 150.10299999999998],
                          [-186.88899999999998, 122.54299999999999],
                          [-215.304, 80.82300000000001],
                          [-231.434, 16.281],
                          [-218.995, -81.012],
                          [-213.979, -150.126],
                        ],
                        o: [
                          [-61.400000000000006, -174.993],
                          [31.163, -179.084],
                          [167.87400000000002, -216.726],
                          [213.727, -148.773],
                          [218.98499999999999, -81.007],
                          [231.429, 16.286],
                          [215.295, 81.23],
                          [186.486, 122.633],
                          [143.192, 150.10199999999998],
                          [99.73499999999999, 163.80100000000002],
                          [82.023, 182.696],
                          [90.208, 235.593],
                          [90.208, 340.899],
                          [100.05199999999999, 353.173],
                          [187.826, 328.463],
                          [339.659, 158.518],
                          [362.71, -57.385000000000005],
                          [281.633, -229.21499999999997],
                          [126.487, -338.081],
                          [-65.81, -354.296],
                          [-237.647, -273.216],
                          [-346.51099999999997, -118.06599999999999],
                          [-362.727, 87.458],
                          [-247.409, 284.78999999999996],
                          [-106.272, 354.29499999999996],
                          [-91.79100000000001, 345.64000000000004],
                          [-89.747, 334.308],
                          [-90.147, 293.689],
                          [-90.223, 267.723],
                          [-131.46, 263.65200000000004],
                          [-169.9, 232.272],
                          [-200.015, 192.428],
                          [-239.627, 179.919],
                          [-269.098, 180.854],
                          [-276.055, 172.042],
                          [-257.117, 162.545],
                          [-228.508, 163.24],
                          [-162.951, 176.444],
                          [-121.48400000000001, 224.627],
                          [-86.44500000000001, 196.071],
                          [-84.084, 166.639],
                          [-128.871, 156.239],
                          [-174.21599999999998, 133.096],
                          [-207.036, 97.359],
                          [-228.207, 39.893],
                          [-231.434, -48.586],
                          [-194.12, -107.777],
                          [-190.155, -204.656],
                        ],
                        v: [
                          [-90.688, -166.809],
                          [-0.006, -179.084],
                          [90.683, -166.809],
                          [190.198, -203.95],
                          [194.112, -107.772],
                          [231.429, -10.475],
                          [221.748, 60.6],
                          [196.727, 110.192],
                          [158.463, 141.599],
                          [114.064, 160.02],
                          [65.657, 168.533],
                          [90.208, 235.593],
                          [90.208, 335.238],
                          [96.118, 349.402],
                          [114.77, 352.702],
                          [293.54, 221.645],
                          [362.727, 8.404],
                          [314.07, -173.64],
                          [182.066, -305.647],
                          [-0.003, -354.296],
                          [-182.072, -305.647],
                          [-314.08, -173.64],
                          [-362.727, 8.419],
                          [-293.536, 221.658],
                          [-114.775, 352.717],
                          [-95.885, 349.415],
                          [-89.747, 335.253],
                          [-89.985, 309.749],
                          [-90.223, 267.723],
                          [-116.578, 265.636],
                          [-158.314, 245.041],
                          [-186.44, 204.911],
                          [-215.704, 185.174],
                          [-264.449, 180.78],
                          [-275.66, 175.043],
                          [-265.264, 163.837],
                          [-240.143, 162.697],
                          [-201.546, 166.79],
                          [-139.026, 208.976],
                          [-89.278, 217.176],
                          [-66.139, 168.525],
                          [-114.548, 160.022],
                          [-158.939, 141.593],
                          [-196.962, 109.954],
                          [-221.754, 60.362],
                          [-231.434, -10.48],
                          [-194.12, -107.777],
                          [-190.155, -204.656],
                        ],
                      },
                    ],
                    t: 133,
                  },
                  {
                    o: { x: 0.167, y: 0.167 },
                    i: { x: 0.833, y: 0.833 },
                    s: [
                      {
                        c: !0,
                        i: [
                          [-165.449, -213.833],
                          [-31.175, -179.084],
                          [61.39300000000001, -174.993],
                          [190.198, -203.95],
                          [194.112, -107.772],
                          [231.429, -48.572],
                          [228.191, 39.974000000000004],
                          [206.957, 97.749],
                          [173.732, 133.10299999999998],
                          [128.386, 156.238],
                          [83.601, 166.64399999999998],
                          [90.208, 205.053],
                          [90.208, 335.238],
                          [92.17699999999999, 345.626],
                          [106.267, 354.282],
                          [247.41500000000002, 284.776],
                          [362.727, 87.443],
                          [346.486, -118.06599999999999],
                          [237.636, -273.214],
                          [65.812, -354.296],
                          [-126.505, -338.077],
                          [-281.644, -229.21499999999997],
                          [-362.727, -57.379000000000005],
                          [-339.66700000000003, 158.53099999999998],
                          [-187.82100000000003, 328.47499999999997],
                          [-99.97800000000001, 353.185],
                          [-89.747, 340.913],
                          [-89.828, 325.81100000000004],
                          [-90.223, 279.678],
                          [-106.89099999999999, 273.738],
                          [-148.82, 270.72700000000003],
                          [-180.324, 244.31799999999998],
                          [-200.884, 211.983],
                          [-242.407, 176.21200000000002],
                          [-272.373, 174.26299999999998],
                          [-270.411, 159.091],
                          [-246.591, 156.37800000000001],
                          [-210.346, 162.348],
                          [-172.295, 200.942],
                          [-99.477, 220.22699999999998],
                          [-78.72999999999999, 179.859],
                          [-100.218, 163.798],
                          [-143.671, 150.10299999999998],
                          [-186.88899999999998, 122.54299999999999],
                          [-215.304, 80.82300000000001],
                          [-231.434, 16.281],
                          [-218.995, -81.012],
                          [-213.979, -150.126],
                        ],
                        o: [
                          [-61.400000000000006, -174.993],
                          [31.163, -179.084],
                          [167.87400000000002, -216.726],
                          [213.727, -148.773],
                          [218.98499999999999, -81.007],
                          [231.429, 16.286],
                          [215.295, 81.23],
                          [186.486, 122.633],
                          [143.192, 150.10199999999998],
                          [99.73499999999999, 163.80100000000002],
                          [82.023, 182.696],
                          [90.208, 235.593],
                          [90.208, 340.899],
                          [100.05199999999999, 353.173],
                          [187.826, 328.463],
                          [339.659, 158.518],
                          [362.71, -57.385000000000005],
                          [281.633, -229.21499999999997],
                          [126.487, -338.081],
                          [-65.81, -354.296],
                          [-237.647, -273.216],
                          [-346.51099999999997, -118.06599999999999],
                          [-362.727, 87.458],
                          [-247.409, 284.78999999999996],
                          [-106.272, 354.29499999999996],
                          [-91.79100000000001, 345.64000000000004],
                          [-89.747, 334.308],
                          [-90.147, 293.689],
                          [-90.223, 267.723],
                          [-136.45499999999998, 274.22],
                          [-174.899, 251.61900000000003],
                          [-193.898, 223.647],
                          [-217.852, 181.309],
                          [-266.484, 174.469],
                          [-273.452, 166.06799999999998],
                          [-254.514, 156.57],
                          [-223.644, 157.449],
                          [-172.91199999999998, 182.698],
                          [-124.728, 238.758],
                          [-86.44500000000001, 196.071],
                          [-84.084, 166.639],
                          [-128.871, 156.239],
                          [-174.21599999999998, 133.096],
                          [-207.036, 97.359],
                          [-228.207, 39.893],
                          [-231.434, -48.586],
                          [-194.12, -107.777],
                          [-190.155, -204.656],
                        ],
                        v: [
                          [-90.688, -166.809],
                          [-0.006, -179.084],
                          [90.683, -166.809],
                          [190.198, -203.95],
                          [194.112, -107.772],
                          [231.429, -10.475],
                          [221.748, 60.6],
                          [196.727, 110.192],
                          [158.463, 141.599],
                          [114.064, 160.02],
                          [65.657, 168.533],
                          [90.208, 235.593],
                          [90.208, 335.238],
                          [96.118, 349.402],
                          [114.77, 352.702],
                          [293.54, 221.645],
                          [362.727, 8.404],
                          [314.07, -173.64],
                          [182.066, -305.647],
                          [-0.003, -354.296],
                          [-182.072, -305.647],
                          [-314.08, -173.64],
                          [-362.727, 8.419],
                          [-293.536, 221.658],
                          [-114.775, 352.717],
                          [-95.885, 349.415],
                          [-89.747, 335.253],
                          [-89.985, 309.749],
                          [-90.223, 267.723],
                          [-121.443, 273.975],
                          [-163.642, 259.867],
                          [-185.513, 236.416],
                          [-205.975, 202.78],
                          [-261.846, 174.805],
                          [-273.057, 169.069],
                          [-262.661, 157.862],
                          [-235.279, 156.906],
                          [-198.766, 168.643],
                          [-144.123, 223.339],
                          [-89.278, 217.176],
                          [-66.139, 168.525],
                          [-114.548, 160.022],
                          [-158.939, 141.593],
                          [-196.962, 109.954],
                          [-221.754, 60.362],
                          [-231.434, -10.48],
                          [-194.12, -107.777],
                          [-190.155, -204.656],
                        ],
                      },
                    ],
                    t: 156,
                  },
                  {
                    o: { x: 0.167, y: 0.167 },
                    i: { x: 0.833, y: 0.833 },
                    s: [
                      {
                        c: !0,
                        i: [
                          [-165.449, -213.833],
                          [-31.175, -179.084],
                          [61.39300000000001, -174.993],
                          [228.653, -164.57],
                          [194.112, -107.772],
                          [231.429, -48.572],
                          [228.191, 39.974000000000004],
                          [206.957, 97.749],
                          [173.732, 133.10299999999998],
                          [128.386, 156.238],
                          [83.601, 166.64399999999998],
                          [90.208, 205.053],
                          [90.208, 335.238],
                          [92.17699999999999, 345.626],
                          [106.267, 354.282],
                          [247.41500000000002, 284.776],
                          [362.727, 87.443],
                          [346.486, -118.06599999999999],
                          [237.636, -273.214],
                          [65.812, -354.296],
                          [-126.505, -338.077],
                          [-281.644, -229.21499999999997],
                          [-362.727, -57.379000000000005],
                          [-339.66700000000003, 158.53099999999998],
                          [-187.82100000000003, 328.47499999999997],
                          [-99.97800000000001, 353.185],
                          [-89.747, 340.913],
                          [-89.828, 325.81100000000004],
                          [-90.223, 279.678],
                          [-105.918, 272.873],
                          [-147.438, 270.615],
                          [-180.783, 248.91899999999998],
                          [-203.169, 218.213],
                          [-245.25799999999998, 176.296],
                          [-270.98999999999995, 169.602],
                          [-268.64000000000004, 156.442],
                          [-241.962, 155.736],
                          [-207.73499999999999, 166.123],
                          [-169.85000000000002, 207.37199999999999],
                          [-98.5, 220.253],
                          [-78.72999999999999, 179.859],
                          [-100.218, 163.798],
                          [-143.671, 150.10299999999998],
                          [-186.88899999999998, 122.54299999999999],
                          [-215.304, 80.82300000000001],
                          [-231.434, 16.281],
                          [-218.995, -81.012],
                          [-213.979, -150.126],
                        ],
                        o: [
                          [-61.400000000000006, -174.993],
                          [31.163, -179.084],
                          [196.34300000000002, -174.51],
                          [216.72899999999998, -123.547],
                          [218.98499999999999, -81.007],
                          [231.429, 16.286],
                          [215.295, 81.23],
                          [186.486, 122.633],
                          [143.192, 150.10199999999998],
                          [99.73499999999999, 163.80100000000002],
                          [82.023, 182.696],
                          [90.208, 235.593],
                          [90.208, 340.899],
                          [100.05199999999999, 353.173],
                          [187.826, 328.463],
                          [339.659, 158.518],
                          [362.71, -57.385000000000005],
                          [281.633, -229.21499999999997],
                          [126.487, -338.081],
                          [-65.81, -354.296],
                          [-237.647, -273.216],
                          [-346.51099999999997, -118.06599999999999],
                          [-362.727, 87.458],
                          [-247.409, 284.78999999999996],
                          [-106.272, 354.29499999999996],
                          [-91.79100000000001, 345.64000000000004],
                          [-89.747, 334.308],
                          [-90.147, 293.689],
                          [-90.223, 267.723],
                          [-134.869, 273.52],
                          [-174.945, 255.473],
                          [-195.978, 229.85],
                          [-224.127, 177.78799999999998],
                          [-265.90099999999995, 170.73499999999999],
                          [-271.44599999999997, 162.51600000000002],
                          [-250.69400000000002, 154.735],
                          [-219.793, 160.307],
                          [-175.30499999999998, 189.98899999999998],
                          [-121.828, 235.91],
                          [-86.44500000000001, 196.071],
                          [-84.084, 166.639],
                          [-128.871, 156.239],
                          [-174.21599999999998, 133.096],
                          [-207.036, 97.359],
                          [-228.207, 39.893],
                          [-231.434, -48.586],
                          [-194.12, -107.777],
                          [-190.155, -204.656],
                        ],
                        v: [
                          [-90.688, -166.809],
                          [-0.006, -179.084],
                          [90.683, -166.809],
                          [228.653, -164.57],
                          [194.112, -107.772],
                          [231.429, -10.475],
                          [221.748, 60.6],
                          [196.727, 110.192],
                          [158.463, 141.599],
                          [114.064, 160.02],
                          [65.657, 168.533],
                          [90.208, 235.593],
                          [90.208, 335.238],
                          [96.118, 349.402],
                          [114.77, 352.702],
                          [293.54, 221.645],
                          [362.727, 8.404],
                          [314.07, -173.64],
                          [182.066, -305.647],
                          [-0.003, -354.296],
                          [-182.072, -305.647],
                          [-314.08, -173.64],
                          [-362.727, 8.419],
                          [-293.536, 221.658],
                          [-114.775, 352.717],
                          [-95.885, 349.415],
                          [-89.747, 335.253],
                          [-89.985, 309.749],
                          [-90.223, 267.723],
                          [-120.811, 273.217],
                          [-160.862, 262.331],
                          [-187.219, 241.154],
                          [-209.055, 205.807],
                          [-261.924, 171.807],
                          [-271.287, 165.139],
                          [-259.295, 155.622],
                          [-230.667, 158.243],
                          [-197.629, 173.634],
                          [-143.68, 224.16],
                          [-89.278, 217.176],
                          [-66.139, 168.525],
                          [-114.548, 160.022],
                          [-158.939, 141.593],
                          [-196.962, 109.954],
                          [-221.754, 60.362],
                          [-231.434, -10.48],
                          [-194.12, -107.777],
                          [-190.155, -204.656],
                        ],
                      },
                    ],
                    t: 162,
                  },
                  {
                    o: { x: 0.167, y: 0.167 },
                    i: { x: 0.833, y: 0.833 },
                    s: [
                      {
                        c: !0,
                        i: [
                          [-165.449, -213.833],
                          [-31.175, -179.084],
                          [61.39300000000001, -174.993],
                          [190.198, -203.95],
                          [194.112, -107.772],
                          [231.429, -48.572],
                          [228.191, 39.974000000000004],
                          [206.957, 97.749],
                          [173.732, 133.10299999999998],
                          [128.386, 156.238],
                          [83.601, 166.64399999999998],
                          [90.208, 205.053],
                          [90.208, 335.238],
                          [92.17699999999999, 345.626],
                          [106.267, 354.282],
                          [247.41500000000002, 284.776],
                          [362.727, 87.443],
                          [346.486, -118.06599999999999],
                          [237.636, -273.214],
                          [65.812, -354.296],
                          [-126.505, -338.077],
                          [-281.644, -229.21499999999997],
                          [-362.727, -57.379000000000005],
                          [-339.66700000000003, 158.53099999999998],
                          [-187.82100000000003, 328.47499999999997],
                          [-99.97800000000001, 353.185],
                          [-89.747, 340.913],
                          [-89.828, 325.81100000000004],
                          [-90.223, 279.678],
                          [-105.107, 272.152],
                          [-146.28699999999998, 270.521],
                          [-181.165, 252.75400000000002],
                          [-205.073, 223.405],
                          [-247.634, 176.36599999999999],
                          [-269.838, 165.717],
                          [-267.16499999999996, 154.234],
                          [-238.104, 155.202],
                          [-205.55800000000002, 169.269],
                          [-167.81300000000002, 212.731],
                          [-97.686, 220.274],
                          [-78.72999999999999, 179.859],
                          [-100.218, 163.798],
                          [-143.671, 150.10299999999998],
                          [-186.88899999999998, 122.54299999999999],
                          [-215.304, 80.82300000000001],
                          [-231.434, 16.281],
                          [-218.995, -81.012],
                          [-213.979, -150.126],
                        ],
                        o: [
                          [-61.400000000000006, -174.993],
                          [31.163, -179.084],
                          [167.87400000000002, -216.726],
                          [213.727, -148.773],
                          [218.98499999999999, -81.007],
                          [231.429, 16.286],
                          [215.295, 81.23],
                          [186.486, 122.633],
                          [143.192, 150.10199999999998],
                          [99.73499999999999, 163.80100000000002],
                          [82.023, 182.696],
                          [90.208, 235.593],
                          [90.208, 340.899],
                          [100.05199999999999, 353.173],
                          [187.826, 328.463],
                          [339.659, 158.518],
                          [362.71, -57.385000000000005],
                          [281.633, -229.21499999999997],
                          [126.487, -338.081],
                          [-65.81, -354.296],
                          [-237.647, -273.216],
                          [-346.51099999999997, -118.06599999999999],
                          [-362.727, 87.458],
                          [-247.409, 284.78999999999996],
                          [-106.272, 354.29499999999996],
                          [-91.79100000000001, 345.64000000000004],
                          [-89.747, 334.308],
                          [-90.147, 293.689],
                          [-90.223, 267.723],
                          [-133.547, 272.938],
                          [-174.982, 258.685],
                          [-197.71099999999998, 235.019],
                          [-229.356, 174.85500000000002],
                          [-265.41499999999996, 167.623],
                          [-269.773, 159.55700000000002],
                          [-247.511, 153.206],
                          [-216.583, 162.689],
                          [-177.298, 196.065],
                          [-119.41300000000001, 233.537],
                          [-86.44500000000001, 196.071],
                          [-84.084, 166.639],
                          [-128.871, 156.239],
                          [-174.21599999999998, 133.096],
                          [-207.036, 97.359],
                          [-228.207, 39.893],
                          [-231.434, -48.586],
                          [-194.12, -107.777],
                          [-190.155, -204.656],
                        ],
                        v: [
                          [-90.688, -166.809],
                          [-0.006, -179.084],
                          [90.683, -166.809],
                          [190.198, -203.95],
                          [194.112, -107.772],
                          [231.429, -10.475],
                          [221.748, 60.6],
                          [196.727, 110.192],
                          [158.463, 141.599],
                          [114.064, 160.02],
                          [65.657, 168.533],
                          [90.208, 235.593],
                          [90.208, 335.238],
                          [96.118, 349.402],
                          [114.77, 352.702],
                          [293.54, 221.645],
                          [362.727, 8.404],
                          [314.07, -173.64],
                          [182.066, -305.647],
                          [-0.003, -354.296],
                          [-182.072, -305.647],
                          [-314.08, -173.64],
                          [-362.727, 8.419],
                          [-293.536, 221.658],
                          [-114.775, 352.717],
                          [-95.885, 349.415],
                          [-89.747, 335.253],
                          [-89.985, 309.749],
                          [-90.223, 267.723],
                          [-120.284, 272.586],
                          [-158.545, 264.384],
                          [-188.641, 245.103],
                          [-211.621, 208.33],
                          [-261.989, 169.309],
                          [-269.812, 161.864],
                          [-256.491, 153.755],
                          [-226.823, 159.358],
                          [-196.681, 177.793],
                          [-143.312, 224.845],
                          [-89.278, 217.176],
                          [-66.139, 168.525],
                          [-114.548, 160.022],
                          [-158.939, 141.593],
                          [-196.962, 109.954],
                          [-221.754, 60.362],
                          [-231.434, -10.48],
                          [-194.12, -107.777],
                          [-190.155, -204.656],
                        ],
                      },
                    ],
                    t: 167,
                  },
                  {
                    o: { x: 0.167, y: 0.167 },
                    i: { x: 0.833, y: 0.833 },
                    s: [
                      {
                        c: !0,
                        i: [
                          [-165.449, -213.833],
                          [-31.175, -179.084],
                          [61.39300000000001, -174.993],
                          [190.198, -203.95],
                          [194.112, -107.772],
                          [231.429, -48.572],
                          [228.191, 39.974000000000004],
                          [206.957, 97.749],
                          [173.732, 133.10299999999998],
                          [128.386, 156.238],
                          [83.601, 166.64399999999998],
                          [90.208, 205.053],
                          [90.208, 335.238],
                          [92.17699999999999, 345.626],
                          [106.267, 354.282],
                          [247.41500000000002, 284.776],
                          [362.727, 87.443],
                          [346.486, -118.06599999999999],
                          [237.636, -273.214],
                          [65.812, -354.296],
                          [-126.505, -338.077],
                          [-281.644, -229.21499999999997],
                          [-362.727, -57.379000000000005],
                          [-339.66700000000003, 158.53099999999998],
                          [-187.82100000000003, 328.47499999999997],
                          [-99.97800000000001, 353.185],
                          [-89.747, 340.913],
                          [-89.828, 325.81100000000004],
                          [-90.223, 279.678],
                          [-103.325, 270.567],
                          [-143.75500000000002, 270.31600000000003],
                          [-182.006, 261.19],
                          [-209.262, 234.827],
                          [-252.861, 176.52],
                          [-267.302, 157.171],
                          [-263.92, 149.37800000000001],
                          [-229.618, 154.025],
                          [-200.77100000000002, 176.19199999999998],
                          [-163.332, 224.51999999999998],
                          [-95.894, 220.32199999999997],
                          [-78.72999999999999, 179.859],
                          [-100.218, 163.798],
                          [-143.671, 150.10299999999998],
                          [-186.88899999999998, 122.54299999999999],
                          [-215.304, 80.82300000000001],
                          [-231.434, 16.281],
                          [-218.995, -81.012],
                          [-213.979, -150.126],
                        ],
                        o: [
                          [-61.400000000000006, -174.993],
                          [31.163, -179.084],
                          [167.87400000000002, -216.726],
                          [213.727, -148.773],
                          [218.98499999999999, -81.007],
                          [231.429, 16.286],
                          [215.295, 81.23],
                          [186.486, 122.633],
                          [143.192, 150.10199999999998],
                          [99.73499999999999, 163.80100000000002],
                          [82.023, 182.696],
                          [90.208, 235.593],
                          [90.208, 340.899],
                          [100.05199999999999, 353.173],
                          [187.826, 328.463],
                          [339.659, 158.518],
                          [362.71, -57.385000000000005],
                          [281.633, -229.21499999999997],
                          [126.487, -338.081],
                          [-65.81, -354.296],
                          [-237.647, -273.216],
                          [-346.51099999999997, -118.06599999999999],
                          [-362.727, 87.458],
                          [-247.409, 284.78999999999996],
                          [-106.272, 354.29499999999996],
                          [-91.79100000000001, 345.64000000000004],
                          [-89.747, 334.308],
                          [-90.147, 293.689],
                          [-90.223, 267.723],
                          [-130.639, 271.656],
                          [-175.067, 265.75],
                          [-201.524, 246.391],
                          [-240.861, 168.401],
                          [-264.346, 160.775],
                          [-266.095, 153.045],
                          [-240.508, 149.844],
                          [-209.523, 167.93],
                          [-181.685, 209.433],
                          [-114.09700000000001, 228.314],
                          [-86.44500000000001, 196.071],
                          [-84.084, 166.639],
                          [-128.871, 156.239],
                          [-174.21599999999998, 133.096],
                          [-207.036, 97.359],
                          [-228.207, 39.893],
                          [-231.434, -48.586],
                          [-194.12, -107.777],
                          [-190.155, -204.656],
                        ],
                        v: [
                          [-90.688, -166.809],
                          [-0.006, -179.084],
                          [90.683, -166.809],
                          [190.198, -203.95],
                          [194.112, -107.772],
                          [231.429, -10.475],
                          [221.748, 60.6],
                          [196.727, 110.192],
                          [158.463, 141.599],
                          [114.064, 160.02],
                          [65.657, 168.533],
                          [90.208, 235.593],
                          [90.208, 335.238],
                          [96.118, 349.402],
                          [114.77, 352.702],
                          [293.54, 221.645],
                          [362.727, 8.404],
                          [314.07, -173.64],
                          [182.066, -305.647],
                          [-0.003, -354.296],
                          [-182.072, -305.647],
                          [-314.08, -173.64],
                          [-362.727, 8.419],
                          [-293.536, 221.658],
                          [-114.775, 352.717],
                          [-95.885, 349.415],
                          [-89.747, 335.253],
                          [-89.985, 309.749],
                          [-90.223, 267.723],
                          [-119.126, 271.197],
                          [-153.449, 268.901],
                          [-191.768, 253.79],
                          [-217.268, 213.88],
                          [-262.132, 163.812],
                          [-266.567, 154.659],
                          [-250.322, 149.649],
                          [-218.368, 161.81],
                          [-194.596, 186.944],
                          [-142.501, 226.35],
                          [-89.278, 217.176],
                          [-66.139, 168.525],
                          [-114.548, 160.022],
                          [-158.939, 141.593],
                          [-196.962, 109.954],
                          [-221.754, 60.362],
                          [-231.434, -10.48],
                          [-194.12, -107.777],
                          [-190.155, -204.656],
                        ],
                      },
                    ],
                    t: 178,
                  },
                ],
                ix: 2,
              },
              _render: !0,
            },
            {
              ty: "fl",
              bm: 0,
              cl: "",
              ln: "",
              hd: !1,
              mn: "ADBE Vector Graphic - Fill",
              nm: "Fill 1",
              c: { a: 0, k: [0.6078, 0.6039, 0.6078, 1], ix: 4 },
              r: 1,
              o: { a: 0, k: 100, ix: 5 },
              _render: !0,
            },
            {
              ty: "tr",
              a: { a: 0, k: [0, 0], ix: 1 },
              s: { a: 0, k: [100, 100], ix: 3 },
              sk: { a: 0, k: 0, ix: 4 },
              p: { a: 0, k: [399.635, 400.77], ix: 2 },
              r: { a: 0, k: 0, ix: 6 },
              sa: { a: 0, k: 0, ix: 5 },
              o: { a: 0, k: 100, ix: 7 },
              _render: !0,
            },
          ],
          _render: !0,
        },
      ],
      ind: 0,
      completed: !0,
    },
  ],
  ddd$3 = 0,
  h$3 = 800,
  w$4 = 800,
  meta$2 = {
    a: "",
    k: "",
    d: "",
    g: "@lottiefiles/toolkit-js 0.17.3",
    tc: "#ffffff",
  },
  v$3 = "5.4.3",
  fr$3 = 60,
  op$3 = 180,
  ip$3 = 0,
  assets$3 = [],
  __complete$2 = !0,
  git = {
    nm: nm$3,
    mn: mn$1,
    layers: layers$3,
    ddd: ddd$3,
    h: h$3,
    w: w$4,
    meta: meta$2,
    v: v$3,
    fr: fr$3,
    op: op$3,
    ip: ip$3,
    assets: assets$3,
    __complete: __complete$2,
  },
  TopNav = () => {
    const [s, e] = React.useState(!1);
    return jsxRuntimeExports.jsxs(motion.div, {
      variants: { hidden: { opacity: 0, y: -50 }, show: { opacity: 1, y: 0 } },
      transition: { duration: 0.5, ease: "easeOut", delay: 0 },
      initial: "hidden",
      animate: "show",
      className: "topnav",
      children: [
        jsxRuntimeExports.jsxs("div", {
          className: "topnavsocialbutton",
          children: [
            jsxRuntimeExports.jsx(motion.a, {
              href: "https://github.com/Hemo-abolarin",
              variants: {
                hidden: { opacity: 0, y: -100 },
                show: { opacity: 1, y: 0 },
              },
              initial: "hidden",
              animate: "show",
              transition: { duration: 0.2, ease: "easeOut", delay: 0 },
              className: "ShotCostomButton",
              children: jsxRuntimeExports.jsx(Lottie, { animationData: git }),
            }),
            jsxRuntimeExports.jsx(motion.a, {
              href: "https://web.facebook.com/login.php/?_rdc=1&_rdr",
              variants: {
                hidden: { opacity: 0, y: -100 },
                show: { opacity: 1, y: 0 },
              },
              initial: "hidden",
              animate: "show",
              transition: { duration: 0.2, ease: "easeOut", delay: 0.1 },
              className: "ShotCostomButtonn",
              children: jsxRuntimeExports.jsx(Lottie, { animationData: fb }),
            }),
            jsxRuntimeExports.jsx(motion.a, {
              href: "https://x.com/i/flow/login?input_flow_data=%7B%22requested_variant%22%3A%22eyJteCI6IjIifQ%3D%3D%22%7D",
              variants: {
                hidden: { opacity: 0, y: -100 },
                show: { opacity: 1, y: 0 },
              },
              initial: "hidden",
              animate: "show",
              transition: { duration: 0.2, ease: "easeOut", delay: 0.2 },
              className: "ShotCostomButton",
              children: jsxRuntimeExports.jsx(Lottie, { animationData: twt }),
            }),
            " ",
            jsxRuntimeExports.jsx(motion.a, {
              href: "https://www.linkedin.com/login",
              variants: {
                hidden: { opacity: 0, y: -100 },
                show: { opacity: 1, y: 0 },
              },
              initial: "hidden",
              animate: "show",
              transition: { duration: 0.2, ease: "easeOut", delay: 0.3 },
              className: "ShotCostomButton",
              children: jsxRuntimeExports.jsx(Lottie, { animationData: ln }),
            }),
          ],
        }),
        jsxRuntimeExports.jsx(motion.div, {
          variants: {
            hidden: { opacity: 0, y: -100 },
            show: { opacity: 1, y: 0 },
          },
          transition: { duration: 0.5, ease: "easeOut", delay: 0.4 },
          initial: "hidden",
          animate: "show",
          className: "topnavcontactbutton",
          children: jsxRuntimeExports.jsx(CustomButtonOne, {
            text: "Contact Me",
          }),
        }),
        jsxRuntimeExports.jsxs("div", {
          className: "topnavmobile",
          children: [
            jsxRuntimeExports.jsx(motion.div, {
              variants: {
                hidden: { opacity: 0, y: -100 },
                show: { opacity: 1, y: 0 },
              },
              transition: { duration: 0.5, ease: "easeOut", delay: 0.2 },
              initial: "hidden",
              animate: "show",
              className: "logocon",
              children: jsxRuntimeExports.jsx("img", {
                className: "logoemage",
                src: logo,
              }),
            }),
            jsxRuntimeExports.jsx(motion.div, {
              variants: {
                hidden: { opacity: 0, y: -100 },
                show: { opacity: 1, y: 0 },
              },
              transition: { duration: 0.5, ease: "easeOut", delay: 0.2 },
              initial: "hidden",
              animate: "show",
              className: "ShotCostomButton",
              onClick: () => {
                e(!s);
              },
              children: s
                ? jsxRuntimeExports.jsx(RiCloseLine, {
                    className: "iconnav",
                    size: "1.5rem",
                  })
                : jsxRuntimeExports.jsx(RiMenu3Line, {
                    className: "iconnav",
                    size: "1.5rem",
                  }),
            }),
          ],
        }),
        s &&
          jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {
            children: [
              jsxRuntimeExports.jsx("div", {
                className: "topnavmodilemenu",
                children: jsxRuntimeExports.jsx(Textasbuttom, {
                  children: jsxRuntimeExports.jsxs(TextAnimation, {
                    children: [
                      jsxRuntimeExports.jsxs("div", {
                        className: "mobilemenulinkitems",
                        children: [
                          jsxRuntimeExports.jsx("div", {
                            className: "mlncitem",
                            children: jsxRuntimeExports.jsx(TextAnimation, {
                              children: jsxRuntimeExports.jsx("a", {
                                href: "#hero",
                                children: "Hero",
                              }),
                            }),
                          }),
                          jsxRuntimeExports.jsx("div", {
                            className: "mlncitem",
                            children: jsxRuntimeExports.jsx(TextAnimation, {
                              children: jsxRuntimeExports.jsx("a", {
                                href: "#about",
                                children: "About me",
                              }),
                            }),
                          }),
                          jsxRuntimeExports.jsx("div", {
                            className: "mlncitem",
                            children: jsxRuntimeExports.jsx(TextAnimation, {
                              children: jsxRuntimeExports.jsx("a", {
                                href: "#works",
                                children: "Projects",
                              }),
                            }),
                          }),
                        ],
                      }),
                      jsxRuntimeExports.jsxs("div", {
                        className: "mobilesocialcon",
                        children: [
                          jsxRuntimeExports.jsx(TextAnimation, {
                            children: jsxRuntimeExports.jsx("a", {
                              href: "https://github.com/Hemo-abolarin",
                              className: "ShotCostomButton",
                              children: jsxRuntimeExports.jsx(Lottie, {
                                animationData: git,
                              }),
                            }),
                          }),
                          jsxRuntimeExports.jsx(TextAnimation, {
                            children: jsxRuntimeExports.jsx("a", {
                              href: "https://web.facebook.com/login.php/?_rdc=1&_rdr",
                              className: "ShotCostomButtonn",
                              children: jsxRuntimeExports.jsx(Lottie, {
                                animationData: fb,
                              }),
                            }),
                          }),
                          jsxRuntimeExports.jsx(TextAnimation, {
                            children: jsxRuntimeExports.jsx("a", {
                              href: "https://x.com/i/flow/login?input_flow_data=%7B%22requested_variant%22%3A%22eyJteCI6IjIifQ%3D%3D%22%7D",
                              className: "ShotCostomButton",
                              children: jsxRuntimeExports.jsx(Lottie, {
                                animationData: twt,
                              }),
                            }),
                          }),
                          jsxRuntimeExports.jsx(TextAnimation, {
                            children: jsxRuntimeExports.jsx("a", {
                              href: "https://www.linkedin.com/login",
                              className: "ShotCostomButton",
                              children: jsxRuntimeExports.jsx(Lottie, {
                                animationData: ln,
                              }),
                            }),
                          }),
                        ],
                      }),
                      jsxRuntimeExports.jsx(CustomButtonOne, {
                        text: "Contact Me",
                      }),
                    ],
                  }),
                }),
              }),
              jsxRuntimeExports.jsx("div", {
                className: "overlay",
                onClick: () => {
                  e(!s);
                },
              }),
            ],
          }),
      ],
    });
  },
  bg = "./assets/bg-w1BgNNqR.mp4";
var react = { exports: {} };
(function (s, e) {
  (function (o, a) {
    s.exports = a(reactExports$1);
  })(typeof self < "u" ? self : commonjsGlobal, (o) =>
    (() => {
      var a = {
          7403: (_, b, j) => {
            j.d(b, { default: () => mt });
            var $ = j(4087),
              _e = j.n($);
            const et = function (vt) {
                return new RegExp(/<[a-z][\s\S]*>/i).test(vt);
              },
              rt = function (vt, Ct) {
                return Math.floor(Math.random() * (Ct - vt + 1)) + vt;
              };
            var st = "TYPE_CHARACTER",
              at = "REMOVE_CHARACTER",
              ct = "REMOVE_ALL",
              it = "REMOVE_LAST_VISIBLE_NODE",
              lt = "PAUSE_FOR",
              ot = "CALL_FUNCTION",
              ut = "ADD_HTML_TAG_ELEMENT",
              pt = "CHANGE_DELETE_SPEED",
              ft = "CHANGE_DELAY",
              gt = "CHANGE_CURSOR",
              xt = "PASTE_STRING",
              _t = "HTML_TAG";
            function St(vt) {
              return (
                (St =
                  typeof Symbol == "function" &&
                  typeof Symbol.iterator == "symbol"
                    ? function (Ct) {
                        return typeof Ct;
                      }
                    : function (Ct) {
                        return Ct &&
                          typeof Symbol == "function" &&
                          Ct.constructor === Symbol &&
                          Ct !== Symbol.prototype
                          ? "symbol"
                          : typeof Ct;
                      }),
                St(vt)
              );
            }
            function Mt(vt, Ct) {
              var Tt = Object.keys(vt);
              if (Object.getOwnPropertySymbols) {
                var Dt = Object.getOwnPropertySymbols(vt);
                Ct &&
                  (Dt = Dt.filter(function (Wt) {
                    return Object.getOwnPropertyDescriptor(vt, Wt).enumerable;
                  })),
                  Tt.push.apply(Tt, Dt);
              }
              return Tt;
            }
            function Rt(vt) {
              for (var Ct = 1; Ct < arguments.length; Ct++) {
                var Tt = arguments[Ct] != null ? arguments[Ct] : {};
                Ct % 2
                  ? Mt(Object(Tt), !0).forEach(function (Dt) {
                      Et(vt, Dt, Tt[Dt]);
                    })
                  : Object.getOwnPropertyDescriptors
                  ? Object.defineProperties(
                      vt,
                      Object.getOwnPropertyDescriptors(Tt)
                    )
                  : Mt(Object(Tt)).forEach(function (Dt) {
                      Object.defineProperty(
                        vt,
                        Dt,
                        Object.getOwnPropertyDescriptor(Tt, Dt)
                      );
                    });
              }
              return vt;
            }
            function Ft(vt) {
              return (
                (function (Ct) {
                  if (Array.isArray(Ct)) return Ot(Ct);
                })(vt) ||
                (function (Ct) {
                  if (
                    (typeof Symbol < "u" && Ct[Symbol.iterator] != null) ||
                    Ct["@@iterator"] != null
                  )
                    return Array.from(Ct);
                })(vt) ||
                (function (Ct, Tt) {
                  if (Ct) {
                    if (typeof Ct == "string") return Ot(Ct, Tt);
                    var Dt = Object.prototype.toString.call(Ct).slice(8, -1);
                    return (
                      Dt === "Object" &&
                        Ct.constructor &&
                        (Dt = Ct.constructor.name),
                      Dt === "Map" || Dt === "Set"
                        ? Array.from(Ct)
                        : Dt === "Arguments" ||
                          /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(Dt)
                        ? Ot(Ct, Tt)
                        : void 0
                    );
                  }
                })(vt) ||
                (function () {
                  throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
                })()
              );
            }
            function Ot(vt, Ct) {
              (Ct == null || Ct > vt.length) && (Ct = vt.length);
              for (var Tt = 0, Dt = new Array(Ct); Tt < Ct; Tt++)
                Dt[Tt] = vt[Tt];
              return Dt;
            }
            function Lt(vt, Ct) {
              for (var Tt = 0; Tt < Ct.length; Tt++) {
                var Dt = Ct[Tt];
                (Dt.enumerable = Dt.enumerable || !1),
                  (Dt.configurable = !0),
                  "value" in Dt && (Dt.writable = !0),
                  Object.defineProperty(vt, bt(Dt.key), Dt);
              }
            }
            function Et(vt, Ct, Tt) {
              return (
                (Ct = bt(Ct)) in vt
                  ? Object.defineProperty(vt, Ct, {
                      value: Tt,
                      enumerable: !0,
                      configurable: !0,
                      writable: !0,
                    })
                  : (vt[Ct] = Tt),
                vt
              );
            }
            function bt(vt) {
              var Ct = (function (Tt, Dt) {
                if (St(Tt) !== "object" || Tt === null) return Tt;
                var Wt = Tt[Symbol.toPrimitive];
                if (Wt !== void 0) {
                  var Pt = Wt.call(Tt, "string");
                  if (St(Pt) !== "object") return Pt;
                  throw new TypeError(
                    "@@toPrimitive must return a primitive value."
                  );
                }
                return String(Tt);
              })(vt);
              return St(Ct) === "symbol" ? Ct : String(Ct);
            }
            const mt = (function () {
              function vt(Dt, Wt) {
                var Pt = this;
                if (
                  ((function (Gt, en) {
                    if (!(Gt instanceof en))
                      throw new TypeError("Cannot call a class as a function");
                  })(this, vt),
                  Et(this, "state", {
                    cursorAnimation: null,
                    lastFrameTime: null,
                    pauseUntil: null,
                    eventQueue: [],
                    eventLoop: null,
                    eventLoopPaused: !1,
                    reverseCalledEvents: [],
                    calledEvents: [],
                    visibleNodes: [],
                    initialOptions: null,
                    elements: {
                      container: null,
                      wrapper: document.createElement("span"),
                      cursor: document.createElement("span"),
                    },
                  }),
                  Et(this, "options", {
                    strings: null,
                    cursor: "|",
                    delay: "natural",
                    pauseFor: 1500,
                    deleteSpeed: "natural",
                    loop: !1,
                    autoStart: !1,
                    devMode: !1,
                    skipAddStyles: !1,
                    wrapperClassName: "Typewriter__wrapper",
                    cursorClassName: "Typewriter__cursor",
                    stringSplitter: null,
                    onCreateTextNode: null,
                    onRemoveNode: null,
                  }),
                  Et(this, "setupWrapperElement", function () {
                    Pt.state.elements.container &&
                      ((Pt.state.elements.wrapper.className =
                        Pt.options.wrapperClassName),
                      (Pt.state.elements.cursor.className =
                        Pt.options.cursorClassName),
                      (Pt.state.elements.cursor.innerHTML = Pt.options.cursor),
                      (Pt.state.elements.container.innerHTML = ""),
                      Pt.state.elements.container.appendChild(
                        Pt.state.elements.wrapper
                      ),
                      Pt.state.elements.container.appendChild(
                        Pt.state.elements.cursor
                      ));
                  }),
                  Et(this, "start", function () {
                    return (
                      (Pt.state.eventLoopPaused = !1), Pt.runEventLoop(), Pt
                    );
                  }),
                  Et(this, "pause", function () {
                    return (Pt.state.eventLoopPaused = !0), Pt;
                  }),
                  Et(this, "stop", function () {
                    return (
                      Pt.state.eventLoop &&
                        ((0, $.cancel)(Pt.state.eventLoop),
                        (Pt.state.eventLoop = null)),
                      Pt
                    );
                  }),
                  Et(this, "pauseFor", function (Gt) {
                    return Pt.addEventToQueue(lt, { ms: Gt }), Pt;
                  }),
                  Et(this, "typeOutAllStrings", function () {
                    return typeof Pt.options.strings == "string"
                      ? (Pt.typeString(Pt.options.strings).pauseFor(
                          Pt.options.pauseFor
                        ),
                        Pt)
                      : (Pt.options.strings.forEach(function (Gt) {
                          Pt.typeString(Gt)
                            .pauseFor(Pt.options.pauseFor)
                            .deleteAll(Pt.options.deleteSpeed);
                        }),
                        Pt);
                  }),
                  Et(this, "typeString", function (Gt) {
                    var en =
                      arguments.length > 1 && arguments[1] !== void 0
                        ? arguments[1]
                        : null;
                    if (et(Gt)) return Pt.typeOutHTMLString(Gt, en);
                    if (Gt) {
                      var _n = (Pt.options || {}).stringSplitter,
                        Tn = typeof _n == "function" ? _n(Gt) : Gt.split("");
                      Pt.typeCharacters(Tn, en);
                    }
                    return Pt;
                  }),
                  Et(this, "pasteString", function (Gt) {
                    var en =
                      arguments.length > 1 && arguments[1] !== void 0
                        ? arguments[1]
                        : null;
                    return et(Gt)
                      ? Pt.typeOutHTMLString(Gt, en, !0)
                      : (Gt &&
                          Pt.addEventToQueue(xt, { character: Gt, node: en }),
                        Pt);
                  }),
                  Et(this, "typeOutHTMLString", function (Gt) {
                    var en =
                        arguments.length > 1 && arguments[1] !== void 0
                          ? arguments[1]
                          : null,
                      _n = arguments.length > 2 ? arguments[2] : void 0,
                      Tn = (function (qt) {
                        var $t = document.createElement("div");
                        return ($t.innerHTML = qt), $t.childNodes;
                      })(Gt);
                    if (Tn.length > 0)
                      for (var fn = 0; fn < Tn.length; fn++) {
                        var pn = Tn[fn],
                          Bt = pn.innerHTML;
                        pn && pn.nodeType !== 3
                          ? ((pn.innerHTML = ""),
                            Pt.addEventToQueue(ut, {
                              node: pn,
                              parentNode: en,
                            }),
                            _n ? Pt.pasteString(Bt, pn) : Pt.typeString(Bt, pn))
                          : pn.textContent &&
                            (_n
                              ? Pt.pasteString(pn.textContent, en)
                              : Pt.typeString(pn.textContent, en));
                      }
                    return Pt;
                  }),
                  Et(this, "deleteAll", function () {
                    var Gt =
                      arguments.length > 0 && arguments[0] !== void 0
                        ? arguments[0]
                        : "natural";
                    return Pt.addEventToQueue(ct, { speed: Gt }), Pt;
                  }),
                  Et(this, "changeDeleteSpeed", function (Gt) {
                    if (!Gt) throw new Error("Must provide new delete speed");
                    return Pt.addEventToQueue(pt, { speed: Gt }), Pt;
                  }),
                  Et(this, "changeDelay", function (Gt) {
                    if (!Gt) throw new Error("Must provide new delay");
                    return Pt.addEventToQueue(ft, { delay: Gt }), Pt;
                  }),
                  Et(this, "changeCursor", function (Gt) {
                    if (!Gt) throw new Error("Must provide new cursor");
                    return Pt.addEventToQueue(gt, { cursor: Gt }), Pt;
                  }),
                  Et(this, "deleteChars", function (Gt) {
                    if (!Gt)
                      throw new Error(
                        "Must provide amount of characters to delete"
                      );
                    for (var en = 0; en < Gt; en++) Pt.addEventToQueue(at);
                    return Pt;
                  }),
                  Et(this, "callFunction", function (Gt, en) {
                    if (!Gt || typeof Gt != "function")
                      throw new Error("Callback must be a function");
                    return Pt.addEventToQueue(ot, { cb: Gt, thisArg: en }), Pt;
                  }),
                  Et(this, "typeCharacters", function (Gt) {
                    var en =
                      arguments.length > 1 && arguments[1] !== void 0
                        ? arguments[1]
                        : null;
                    if (!Gt || !Array.isArray(Gt))
                      throw new Error("Characters must be an array");
                    return (
                      Gt.forEach(function (_n) {
                        Pt.addEventToQueue(st, { character: _n, node: en });
                      }),
                      Pt
                    );
                  }),
                  Et(this, "removeCharacters", function (Gt) {
                    if (!Gt || !Array.isArray(Gt))
                      throw new Error("Characters must be an array");
                    return (
                      Gt.forEach(function () {
                        Pt.addEventToQueue(at);
                      }),
                      Pt
                    );
                  }),
                  Et(this, "addEventToQueue", function (Gt, en) {
                    var _n =
                      arguments.length > 2 &&
                      arguments[2] !== void 0 &&
                      arguments[2];
                    return Pt.addEventToStateProperty(Gt, en, _n, "eventQueue");
                  }),
                  Et(this, "addReverseCalledEvent", function (Gt, en) {
                    var _n =
                      arguments.length > 2 &&
                      arguments[2] !== void 0 &&
                      arguments[2];
                    return Pt.options.loop
                      ? Pt.addEventToStateProperty(
                          Gt,
                          en,
                          _n,
                          "reverseCalledEvents"
                        )
                      : Pt;
                  }),
                  Et(this, "addEventToStateProperty", function (Gt, en) {
                    var _n =
                        arguments.length > 2 &&
                        arguments[2] !== void 0 &&
                        arguments[2],
                      Tn = arguments.length > 3 ? arguments[3] : void 0,
                      fn = { eventName: Gt, eventArgs: en || {} };
                    return (
                      (Pt.state[Tn] = _n
                        ? [fn].concat(Ft(Pt.state[Tn]))
                        : [].concat(Ft(Pt.state[Tn]), [fn])),
                      Pt
                    );
                  }),
                  Et(this, "runEventLoop", function () {
                    Pt.state.lastFrameTime ||
                      (Pt.state.lastFrameTime = Date.now());
                    var Gt = Date.now(),
                      en = Gt - Pt.state.lastFrameTime;
                    if (!Pt.state.eventQueue.length) {
                      if (!Pt.options.loop) return;
                      (Pt.state.eventQueue = Ft(Pt.state.calledEvents)),
                        (Pt.state.calledEvents = []),
                        (Pt.options = Rt({}, Pt.state.initialOptions));
                    }
                    if (
                      ((Pt.state.eventLoop = _e()(Pt.runEventLoop)),
                      !Pt.state.eventLoopPaused)
                    ) {
                      if (Pt.state.pauseUntil) {
                        if (Gt < Pt.state.pauseUntil) return;
                        Pt.state.pauseUntil = null;
                      }
                      var _n,
                        Tn = Ft(Pt.state.eventQueue),
                        fn = Tn.shift();
                      if (
                        !(
                          en <=
                          (_n =
                            fn.eventName === it || fn.eventName === at
                              ? Pt.options.deleteSpeed === "natural"
                                ? rt(40, 80)
                                : Pt.options.deleteSpeed
                              : Pt.options.delay === "natural"
                              ? rt(120, 160)
                              : Pt.options.delay)
                        )
                      ) {
                        var pn = fn.eventName,
                          Bt = fn.eventArgs;
                        switch (
                          (Pt.logInDevMode({
                            currentEvent: fn,
                            state: Pt.state,
                            delay: _n,
                          }),
                          pn)
                        ) {
                          case xt:
                          case st:
                            var qt = Bt.character,
                              $t = Bt.node,
                              yn = document.createTextNode(qt),
                              nn = yn;
                            Pt.options.onCreateTextNode &&
                              typeof Pt.options.onCreateTextNode ==
                                "function" &&
                              (nn = Pt.options.onCreateTextNode(qt, yn)),
                              nn &&
                                ($t
                                  ? $t.appendChild(nn)
                                  : Pt.state.elements.wrapper.appendChild(nn)),
                              (Pt.state.visibleNodes = [].concat(
                                Ft(Pt.state.visibleNodes),
                                [{ type: "TEXT_NODE", character: qt, node: nn }]
                              ));
                            break;
                          case at:
                            Tn.unshift({
                              eventName: it,
                              eventArgs: { removingCharacterNode: !0 },
                            });
                            break;
                          case lt:
                            var Pn = fn.eventArgs.ms;
                            Pt.state.pauseUntil = Date.now() + parseInt(Pn);
                            break;
                          case ot:
                            var xn = fn.eventArgs,
                              An = xn.cb,
                              kt = xn.thisArg;
                            An.call(kt, { elements: Pt.state.elements });
                            break;
                          case ut:
                            var wt = fn.eventArgs,
                              Kt = wt.node,
                              on = wt.parentNode;
                            on
                              ? on.appendChild(Kt)
                              : Pt.state.elements.wrapper.appendChild(Kt),
                              (Pt.state.visibleNodes = [].concat(
                                Ft(Pt.state.visibleNodes),
                                [
                                  {
                                    type: _t,
                                    node: Kt,
                                    parentNode: on || Pt.state.elements.wrapper,
                                  },
                                ]
                              ));
                            break;
                          case ct:
                            var sn = Pt.state.visibleNodes,
                              cn = Bt.speed,
                              bn = [];
                            cn &&
                              bn.push({
                                eventName: pt,
                                eventArgs: { speed: cn, temp: !0 },
                              });
                            for (var vn = 0, wn = sn.length; vn < wn; vn++)
                              bn.push({
                                eventName: it,
                                eventArgs: { removingCharacterNode: !1 },
                              });
                            cn &&
                              bn.push({
                                eventName: pt,
                                eventArgs: {
                                  speed: Pt.options.deleteSpeed,
                                  temp: !0,
                                },
                              }),
                              Tn.unshift.apply(Tn, bn);
                            break;
                          case it:
                            var zn = fn.eventArgs.removingCharacterNode;
                            if (Pt.state.visibleNodes.length) {
                              var gn = Pt.state.visibleNodes.pop(),
                                Rn = gn.type,
                                qn = gn.node,
                                Wn = gn.character;
                              Pt.options.onRemoveNode &&
                                typeof Pt.options.onRemoveNode == "function" &&
                                Pt.options.onRemoveNode({
                                  node: qn,
                                  character: Wn,
                                }),
                                qn && qn.parentNode.removeChild(qn),
                                Rn === _t &&
                                  zn &&
                                  Tn.unshift({ eventName: it, eventArgs: {} });
                            }
                            break;
                          case pt:
                            Pt.options.deleteSpeed = fn.eventArgs.speed;
                            break;
                          case ft:
                            Pt.options.delay = fn.eventArgs.delay;
                            break;
                          case gt:
                            (Pt.options.cursor = fn.eventArgs.cursor),
                              (Pt.state.elements.cursor.innerHTML =
                                fn.eventArgs.cursor);
                        }
                        Pt.options.loop &&
                          (fn.eventName === it ||
                            (fn.eventArgs && fn.eventArgs.temp) ||
                            (Pt.state.calledEvents = [].concat(
                              Ft(Pt.state.calledEvents),
                              [fn]
                            ))),
                          (Pt.state.eventQueue = Tn),
                          (Pt.state.lastFrameTime = Gt);
                      }
                    }
                  }),
                  Dt)
                )
                  if (typeof Dt == "string") {
                    var Jt = document.querySelector(Dt);
                    if (!Jt)
                      throw new Error("Could not find container element");
                    this.state.elements.container = Jt;
                  } else this.state.elements.container = Dt;
                Wt && (this.options = Rt(Rt({}, this.options), Wt)),
                  (this.state.initialOptions = Rt({}, this.options)),
                  this.init();
              }
              var Ct, Tt;
              return (
                (Ct = vt),
                (Tt = [
                  {
                    key: "init",
                    value: function () {
                      var Dt, Wt;
                      this.setupWrapperElement(),
                        this.addEventToQueue(
                          gt,
                          { cursor: this.options.cursor },
                          !0
                        ),
                        this.addEventToQueue(ct, null, !0),
                        !window ||
                          window.___TYPEWRITER_JS_STYLES_ADDED___ ||
                          this.options.skipAddStyles ||
                          ((Dt =
                            ".Typewriter__cursor{-webkit-animation:Typewriter-cursor 1s infinite;animation:Typewriter-cursor 1s infinite;margin-left:1px}@-webkit-keyframes Typewriter-cursor{0%{opacity:0}50%{opacity:1}100%{opacity:0}}@keyframes Typewriter-cursor{0%{opacity:0}50%{opacity:1}100%{opacity:0}}"),
                          (Wt = document.createElement("style")).appendChild(
                            document.createTextNode(Dt)
                          ),
                          document.head.appendChild(Wt),
                          (window.___TYPEWRITER_JS_STYLES_ADDED___ = !0)),
                        this.options.autoStart === !0 &&
                          this.options.strings &&
                          this.typeOutAllStrings().start();
                    },
                  },
                  {
                    key: "logInDevMode",
                    value: function (Dt) {
                      this.options.devMode && console.log(Dt);
                    },
                  },
                ]) && Lt(Ct.prototype, Tt),
                Object.defineProperty(Ct, "prototype", { writable: !1 }),
                vt
              );
            })();
          },
          8552: (_, b, j) => {
            var $ = j(852)(j(5639), "DataView");
            _.exports = $;
          },
          1989: (_, b, j) => {
            var $ = j(1789),
              _e = j(401),
              et = j(7667),
              rt = j(1327),
              st = j(1866);
            function at(ct) {
              var it = -1,
                lt = ct == null ? 0 : ct.length;
              for (this.clear(); ++it < lt; ) {
                var ot = ct[it];
                this.set(ot[0], ot[1]);
              }
            }
            (at.prototype.clear = $),
              (at.prototype.delete = _e),
              (at.prototype.get = et),
              (at.prototype.has = rt),
              (at.prototype.set = st),
              (_.exports = at);
          },
          8407: (_, b, j) => {
            var $ = j(7040),
              _e = j(4125),
              et = j(2117),
              rt = j(7518),
              st = j(4705);
            function at(ct) {
              var it = -1,
                lt = ct == null ? 0 : ct.length;
              for (this.clear(); ++it < lt; ) {
                var ot = ct[it];
                this.set(ot[0], ot[1]);
              }
            }
            (at.prototype.clear = $),
              (at.prototype.delete = _e),
              (at.prototype.get = et),
              (at.prototype.has = rt),
              (at.prototype.set = st),
              (_.exports = at);
          },
          7071: (_, b, j) => {
            var $ = j(852)(j(5639), "Map");
            _.exports = $;
          },
          3369: (_, b, j) => {
            var $ = j(4785),
              _e = j(1285),
              et = j(6e3),
              rt = j(9916),
              st = j(5265);
            function at(ct) {
              var it = -1,
                lt = ct == null ? 0 : ct.length;
              for (this.clear(); ++it < lt; ) {
                var ot = ct[it];
                this.set(ot[0], ot[1]);
              }
            }
            (at.prototype.clear = $),
              (at.prototype.delete = _e),
              (at.prototype.get = et),
              (at.prototype.has = rt),
              (at.prototype.set = st),
              (_.exports = at);
          },
          3818: (_, b, j) => {
            var $ = j(852)(j(5639), "Promise");
            _.exports = $;
          },
          8525: (_, b, j) => {
            var $ = j(852)(j(5639), "Set");
            _.exports = $;
          },
          8668: (_, b, j) => {
            var $ = j(3369),
              _e = j(619),
              et = j(2385);
            function rt(st) {
              var at = -1,
                ct = st == null ? 0 : st.length;
              for (this.__data__ = new $(); ++at < ct; ) this.add(st[at]);
            }
            (rt.prototype.add = rt.prototype.push = _e),
              (rt.prototype.has = et),
              (_.exports = rt);
          },
          6384: (_, b, j) => {
            var $ = j(8407),
              _e = j(7465),
              et = j(3779),
              rt = j(7599),
              st = j(4758),
              at = j(4309);
            function ct(it) {
              var lt = (this.__data__ = new $(it));
              this.size = lt.size;
            }
            (ct.prototype.clear = _e),
              (ct.prototype.delete = et),
              (ct.prototype.get = rt),
              (ct.prototype.has = st),
              (ct.prototype.set = at),
              (_.exports = ct);
          },
          2705: (_, b, j) => {
            var $ = j(5639).Symbol;
            _.exports = $;
          },
          1149: (_, b, j) => {
            var $ = j(5639).Uint8Array;
            _.exports = $;
          },
          577: (_, b, j) => {
            var $ = j(852)(j(5639), "WeakMap");
            _.exports = $;
          },
          4963: (_) => {
            _.exports = function (b, j) {
              for (
                var $ = -1, _e = b == null ? 0 : b.length, et = 0, rt = [];
                ++$ < _e;

              ) {
                var st = b[$];
                j(st, $, b) && (rt[et++] = st);
              }
              return rt;
            };
          },
          4636: (_, b, j) => {
            var $ = j(2545),
              _e = j(5694),
              et = j(1469),
              rt = j(4144),
              st = j(5776),
              at = j(6719),
              ct = Object.prototype.hasOwnProperty;
            _.exports = function (it, lt) {
              var ot = et(it),
                ut = !ot && _e(it),
                pt = !ot && !ut && rt(it),
                ft = !ot && !ut && !pt && at(it),
                gt = ot || ut || pt || ft,
                xt = gt ? $(it.length, String) : [],
                _t = xt.length;
              for (var St in it)
                (!lt && !ct.call(it, St)) ||
                  (gt &&
                    (St == "length" ||
                      (pt && (St == "offset" || St == "parent")) ||
                      (ft &&
                        (St == "buffer" ||
                          St == "byteLength" ||
                          St == "byteOffset")) ||
                      st(St, _t))) ||
                  xt.push(St);
              return xt;
            };
          },
          2488: (_) => {
            _.exports = function (b, j) {
              for (var $ = -1, _e = j.length, et = b.length; ++$ < _e; )
                b[et + $] = j[$];
              return b;
            };
          },
          2908: (_) => {
            _.exports = function (b, j) {
              for (var $ = -1, _e = b == null ? 0 : b.length; ++$ < _e; )
                if (j(b[$], $, b)) return !0;
              return !1;
            };
          },
          8470: (_, b, j) => {
            var $ = j(7813);
            _.exports = function (_e, et) {
              for (var rt = _e.length; rt--; ) if ($(_e[rt][0], et)) return rt;
              return -1;
            };
          },
          8866: (_, b, j) => {
            var $ = j(2488),
              _e = j(1469);
            _.exports = function (et, rt, st) {
              var at = rt(et);
              return _e(et) ? at : $(at, st(et));
            };
          },
          4239: (_, b, j) => {
            var $ = j(2705),
              _e = j(9607),
              et = j(2333),
              rt = $ ? $.toStringTag : void 0;
            _.exports = function (st) {
              return st == null
                ? st === void 0
                  ? "[object Undefined]"
                  : "[object Null]"
                : rt && rt in Object(st)
                ? _e(st)
                : et(st);
            };
          },
          9454: (_, b, j) => {
            var $ = j(4239),
              _e = j(7005);
            _.exports = function (et) {
              return _e(et) && $(et) == "[object Arguments]";
            };
          },
          939: (_, b, j) => {
            var $ = j(2492),
              _e = j(7005);
            _.exports = function et(rt, st, at, ct, it) {
              return (
                rt === st ||
                (rt == null || st == null || (!_e(rt) && !_e(st))
                  ? rt != rt && st != st
                  : $(rt, st, at, ct, et, it))
              );
            };
          },
          2492: (_, b, j) => {
            var $ = j(6384),
              _e = j(7114),
              et = j(8351),
              rt = j(6096),
              st = j(4160),
              at = j(1469),
              ct = j(4144),
              it = j(6719),
              lt = "[object Arguments]",
              ot = "[object Array]",
              ut = "[object Object]",
              pt = Object.prototype.hasOwnProperty;
            _.exports = function (ft, gt, xt, _t, St, Mt) {
              var Rt = at(ft),
                Ft = at(gt),
                Ot = Rt ? ot : st(ft),
                Lt = Ft ? ot : st(gt),
                Et = (Ot = Ot == lt ? ut : Ot) == ut,
                bt = (Lt = Lt == lt ? ut : Lt) == ut,
                mt = Ot == Lt;
              if (mt && ct(ft)) {
                if (!ct(gt)) return !1;
                (Rt = !0), (Et = !1);
              }
              if (mt && !Et)
                return (
                  Mt || (Mt = new $()),
                  Rt || it(ft)
                    ? _e(ft, gt, xt, _t, St, Mt)
                    : et(ft, gt, Ot, xt, _t, St, Mt)
                );
              if (!(1 & xt)) {
                var vt = Et && pt.call(ft, "__wrapped__"),
                  Ct = bt && pt.call(gt, "__wrapped__");
                if (vt || Ct) {
                  var Tt = vt ? ft.value() : ft,
                    Dt = Ct ? gt.value() : gt;
                  return Mt || (Mt = new $()), St(Tt, Dt, xt, _t, Mt);
                }
              }
              return !!mt && (Mt || (Mt = new $()), rt(ft, gt, xt, _t, St, Mt));
            };
          },
          8458: (_, b, j) => {
            var $ = j(3560),
              _e = j(5346),
              et = j(3218),
              rt = j(346),
              st = /^\[object .+?Constructor\]$/,
              at = Function.prototype,
              ct = Object.prototype,
              it = at.toString,
              lt = ct.hasOwnProperty,
              ot = RegExp(
                "^" +
                  it
                    .call(lt)
                    .replace(/[\\^$.*+?()[\]{}|]/g, "\\$&")
                    .replace(
                      /hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,
                      "$1.*?"
                    ) +
                  "$"
              );
            _.exports = function (ut) {
              return !(!et(ut) || _e(ut)) && ($(ut) ? ot : st).test(rt(ut));
            };
          },
          8749: (_, b, j) => {
            var $ = j(4239),
              _e = j(1780),
              et = j(7005),
              rt = {};
            (rt["[object Float32Array]"] =
              rt["[object Float64Array]"] =
              rt["[object Int8Array]"] =
              rt["[object Int16Array]"] =
              rt["[object Int32Array]"] =
              rt["[object Uint8Array]"] =
              rt["[object Uint8ClampedArray]"] =
              rt["[object Uint16Array]"] =
              rt["[object Uint32Array]"] =
                !0),
              (rt["[object Arguments]"] =
                rt["[object Array]"] =
                rt["[object ArrayBuffer]"] =
                rt["[object Boolean]"] =
                rt["[object DataView]"] =
                rt["[object Date]"] =
                rt["[object Error]"] =
                rt["[object Function]"] =
                rt["[object Map]"] =
                rt["[object Number]"] =
                rt["[object Object]"] =
                rt["[object RegExp]"] =
                rt["[object Set]"] =
                rt["[object String]"] =
                rt["[object WeakMap]"] =
                  !1),
              (_.exports = function (st) {
                return et(st) && _e(st.length) && !!rt[$(st)];
              });
          },
          280: (_, b, j) => {
            var $ = j(5726),
              _e = j(6916),
              et = Object.prototype.hasOwnProperty;
            _.exports = function (rt) {
              if (!$(rt)) return _e(rt);
              var st = [];
              for (var at in Object(rt))
                et.call(rt, at) && at != "constructor" && st.push(at);
              return st;
            };
          },
          2545: (_) => {
            _.exports = function (b, j) {
              for (var $ = -1, _e = Array(b); ++$ < b; ) _e[$] = j($);
              return _e;
            };
          },
          1717: (_) => {
            _.exports = function (b) {
              return function (j) {
                return b(j);
              };
            };
          },
          4757: (_) => {
            _.exports = function (b, j) {
              return b.has(j);
            };
          },
          4429: (_, b, j) => {
            var $ = j(5639)["__core-js_shared__"];
            _.exports = $;
          },
          7114: (_, b, j) => {
            var $ = j(8668),
              _e = j(2908),
              et = j(4757);
            _.exports = function (rt, st, at, ct, it, lt) {
              var ot = 1 & at,
                ut = rt.length,
                pt = st.length;
              if (ut != pt && !(ot && pt > ut)) return !1;
              var ft = lt.get(rt),
                gt = lt.get(st);
              if (ft && gt) return ft == st && gt == rt;
              var xt = -1,
                _t = !0,
                St = 2 & at ? new $() : void 0;
              for (lt.set(rt, st), lt.set(st, rt); ++xt < ut; ) {
                var Mt = rt[xt],
                  Rt = st[xt];
                if (ct)
                  var Ft = ot
                    ? ct(Rt, Mt, xt, st, rt, lt)
                    : ct(Mt, Rt, xt, rt, st, lt);
                if (Ft !== void 0) {
                  if (Ft) continue;
                  _t = !1;
                  break;
                }
                if (St) {
                  if (
                    !_e(st, function (Ot, Lt) {
                      if (!et(St, Lt) && (Mt === Ot || it(Mt, Ot, at, ct, lt)))
                        return St.push(Lt);
                    })
                  ) {
                    _t = !1;
                    break;
                  }
                } else if (Mt !== Rt && !it(Mt, Rt, at, ct, lt)) {
                  _t = !1;
                  break;
                }
              }
              return lt.delete(rt), lt.delete(st), _t;
            };
          },
          8351: (_, b, j) => {
            var $ = j(2705),
              _e = j(1149),
              et = j(7813),
              rt = j(7114),
              st = j(8776),
              at = j(1814),
              ct = $ ? $.prototype : void 0,
              it = ct ? ct.valueOf : void 0;
            _.exports = function (lt, ot, ut, pt, ft, gt, xt) {
              switch (ut) {
                case "[object DataView]":
                  if (
                    lt.byteLength != ot.byteLength ||
                    lt.byteOffset != ot.byteOffset
                  )
                    return !1;
                  (lt = lt.buffer), (ot = ot.buffer);
                case "[object ArrayBuffer]":
                  return !(
                    lt.byteLength != ot.byteLength ||
                    !gt(new _e(lt), new _e(ot))
                  );
                case "[object Boolean]":
                case "[object Date]":
                case "[object Number]":
                  return et(+lt, +ot);
                case "[object Error]":
                  return lt.name == ot.name && lt.message == ot.message;
                case "[object RegExp]":
                case "[object String]":
                  return lt == ot + "";
                case "[object Map]":
                  var _t = st;
                case "[object Set]":
                  var St = 1 & pt;
                  if ((_t || (_t = at), lt.size != ot.size && !St)) return !1;
                  var Mt = xt.get(lt);
                  if (Mt) return Mt == ot;
                  (pt |= 2), xt.set(lt, ot);
                  var Rt = rt(_t(lt), _t(ot), pt, ft, gt, xt);
                  return xt.delete(lt), Rt;
                case "[object Symbol]":
                  if (it) return it.call(lt) == it.call(ot);
              }
              return !1;
            };
          },
          6096: (_, b, j) => {
            var $ = j(8234),
              _e = Object.prototype.hasOwnProperty;
            _.exports = function (et, rt, st, at, ct, it) {
              var lt = 1 & st,
                ot = $(et),
                ut = ot.length;
              if (ut != $(rt).length && !lt) return !1;
              for (var pt = ut; pt--; ) {
                var ft = ot[pt];
                if (!(lt ? ft in rt : _e.call(rt, ft))) return !1;
              }
              var gt = it.get(et),
                xt = it.get(rt);
              if (gt && xt) return gt == rt && xt == et;
              var _t = !0;
              it.set(et, rt), it.set(rt, et);
              for (var St = lt; ++pt < ut; ) {
                var Mt = et[(ft = ot[pt])],
                  Rt = rt[ft];
                if (at)
                  var Ft = lt
                    ? at(Rt, Mt, ft, rt, et, it)
                    : at(Mt, Rt, ft, et, rt, it);
                if (
                  !(Ft === void 0 ? Mt === Rt || ct(Mt, Rt, st, at, it) : Ft)
                ) {
                  _t = !1;
                  break;
                }
                St || (St = ft == "constructor");
              }
              if (_t && !St) {
                var Ot = et.constructor,
                  Lt = rt.constructor;
                Ot == Lt ||
                  !("constructor" in et) ||
                  !("constructor" in rt) ||
                  (typeof Ot == "function" &&
                    Ot instanceof Ot &&
                    typeof Lt == "function" &&
                    Lt instanceof Lt) ||
                  (_t = !1);
              }
              return it.delete(et), it.delete(rt), _t;
            };
          },
          1957: (_, b, j) => {
            var $ =
              typeof j.g == "object" && j.g && j.g.Object === Object && j.g;
            _.exports = $;
          },
          8234: (_, b, j) => {
            var $ = j(8866),
              _e = j(9551),
              et = j(3674);
            _.exports = function (rt) {
              return $(rt, et, _e);
            };
          },
          5050: (_, b, j) => {
            var $ = j(7019);
            _.exports = function (_e, et) {
              var rt = _e.__data__;
              return $(et)
                ? rt[typeof et == "string" ? "string" : "hash"]
                : rt.map;
            };
          },
          852: (_, b, j) => {
            var $ = j(8458),
              _e = j(7801);
            _.exports = function (et, rt) {
              var st = _e(et, rt);
              return $(st) ? st : void 0;
            };
          },
          9607: (_, b, j) => {
            var $ = j(2705),
              _e = Object.prototype,
              et = _e.hasOwnProperty,
              rt = _e.toString,
              st = $ ? $.toStringTag : void 0;
            _.exports = function (at) {
              var ct = et.call(at, st),
                it = at[st];
              try {
                at[st] = void 0;
                var lt = !0;
              } catch {}
              var ot = rt.call(at);
              return lt && (ct ? (at[st] = it) : delete at[st]), ot;
            };
          },
          9551: (_, b, j) => {
            var $ = j(4963),
              _e = j(479),
              et = Object.prototype.propertyIsEnumerable,
              rt = Object.getOwnPropertySymbols,
              st = rt
                ? function (at) {
                    return at == null
                      ? []
                      : ((at = Object(at)),
                        $(rt(at), function (ct) {
                          return et.call(at, ct);
                        }));
                  }
                : _e;
            _.exports = st;
          },
          4160: (_, b, j) => {
            var $ = j(8552),
              _e = j(7071),
              et = j(3818),
              rt = j(8525),
              st = j(577),
              at = j(4239),
              ct = j(346),
              it = "[object Map]",
              lt = "[object Promise]",
              ot = "[object Set]",
              ut = "[object WeakMap]",
              pt = "[object DataView]",
              ft = ct($),
              gt = ct(_e),
              xt = ct(et),
              _t = ct(rt),
              St = ct(st),
              Mt = at;
            (($ && Mt(new $(new ArrayBuffer(1))) != pt) ||
              (_e && Mt(new _e()) != it) ||
              (et && Mt(et.resolve()) != lt) ||
              (rt && Mt(new rt()) != ot) ||
              (st && Mt(new st()) != ut)) &&
              (Mt = function (Rt) {
                var Ft = at(Rt),
                  Ot = Ft == "[object Object]" ? Rt.constructor : void 0,
                  Lt = Ot ? ct(Ot) : "";
                if (Lt)
                  switch (Lt) {
                    case ft:
                      return pt;
                    case gt:
                      return it;
                    case xt:
                      return lt;
                    case _t:
                      return ot;
                    case St:
                      return ut;
                  }
                return Ft;
              }),
              (_.exports = Mt);
          },
          7801: (_) => {
            _.exports = function (b, j) {
              return b == null ? void 0 : b[j];
            };
          },
          1789: (_, b, j) => {
            var $ = j(4536);
            _.exports = function () {
              (this.__data__ = $ ? $(null) : {}), (this.size = 0);
            };
          },
          401: (_) => {
            _.exports = function (b) {
              var j = this.has(b) && delete this.__data__[b];
              return (this.size -= j ? 1 : 0), j;
            };
          },
          7667: (_, b, j) => {
            var $ = j(4536),
              _e = Object.prototype.hasOwnProperty;
            _.exports = function (et) {
              var rt = this.__data__;
              if ($) {
                var st = rt[et];
                return st === "__lodash_hash_undefined__" ? void 0 : st;
              }
              return _e.call(rt, et) ? rt[et] : void 0;
            };
          },
          1327: (_, b, j) => {
            var $ = j(4536),
              _e = Object.prototype.hasOwnProperty;
            _.exports = function (et) {
              var rt = this.__data__;
              return $ ? rt[et] !== void 0 : _e.call(rt, et);
            };
          },
          1866: (_, b, j) => {
            var $ = j(4536);
            _.exports = function (_e, et) {
              var rt = this.__data__;
              return (
                (this.size += this.has(_e) ? 0 : 1),
                (rt[_e] =
                  $ && et === void 0 ? "__lodash_hash_undefined__" : et),
                this
              );
            };
          },
          5776: (_) => {
            var b = /^(?:0|[1-9]\d*)$/;
            _.exports = function (j, $) {
              var _e = typeof j;
              return (
                !!($ = $ ?? 9007199254740991) &&
                (_e == "number" || (_e != "symbol" && b.test(j))) &&
                j > -1 &&
                j % 1 == 0 &&
                j < $
              );
            };
          },
          7019: (_) => {
            _.exports = function (b) {
              var j = typeof b;
              return j == "string" ||
                j == "number" ||
                j == "symbol" ||
                j == "boolean"
                ? b !== "__proto__"
                : b === null;
            };
          },
          5346: (_, b, j) => {
            var $,
              _e = j(4429),
              et = ($ = /[^.]+$/.exec(
                (_e && _e.keys && _e.keys.IE_PROTO) || ""
              ))
                ? "Symbol(src)_1." + $
                : "";
            _.exports = function (rt) {
              return !!et && et in rt;
            };
          },
          5726: (_) => {
            var b = Object.prototype;
            _.exports = function (j) {
              var $ = j && j.constructor;
              return j === ((typeof $ == "function" && $.prototype) || b);
            };
          },
          7040: (_) => {
            _.exports = function () {
              (this.__data__ = []), (this.size = 0);
            };
          },
          4125: (_, b, j) => {
            var $ = j(8470),
              _e = Array.prototype.splice;
            _.exports = function (et) {
              var rt = this.__data__,
                st = $(rt, et);
              return !(
                st < 0 ||
                (st == rt.length - 1 ? rt.pop() : _e.call(rt, st, 1),
                --this.size,
                0)
              );
            };
          },
          2117: (_, b, j) => {
            var $ = j(8470);
            _.exports = function (_e) {
              var et = this.__data__,
                rt = $(et, _e);
              return rt < 0 ? void 0 : et[rt][1];
            };
          },
          7518: (_, b, j) => {
            var $ = j(8470);
            _.exports = function (_e) {
              return $(this.__data__, _e) > -1;
            };
          },
          4705: (_, b, j) => {
            var $ = j(8470);
            _.exports = function (_e, et) {
              var rt = this.__data__,
                st = $(rt, _e);
              return (
                st < 0 ? (++this.size, rt.push([_e, et])) : (rt[st][1] = et),
                this
              );
            };
          },
          4785: (_, b, j) => {
            var $ = j(1989),
              _e = j(8407),
              et = j(7071);
            _.exports = function () {
              (this.size = 0),
                (this.__data__ = {
                  hash: new $(),
                  map: new (et || _e)(),
                  string: new $(),
                });
            };
          },
          1285: (_, b, j) => {
            var $ = j(5050);
            _.exports = function (_e) {
              var et = $(this, _e).delete(_e);
              return (this.size -= et ? 1 : 0), et;
            };
          },
          6e3: (_, b, j) => {
            var $ = j(5050);
            _.exports = function (_e) {
              return $(this, _e).get(_e);
            };
          },
          9916: (_, b, j) => {
            var $ = j(5050);
            _.exports = function (_e) {
              return $(this, _e).has(_e);
            };
          },
          5265: (_, b, j) => {
            var $ = j(5050);
            _.exports = function (_e, et) {
              var rt = $(this, _e),
                st = rt.size;
              return rt.set(_e, et), (this.size += rt.size == st ? 0 : 1), this;
            };
          },
          8776: (_) => {
            _.exports = function (b) {
              var j = -1,
                $ = Array(b.size);
              return (
                b.forEach(function (_e, et) {
                  $[++j] = [et, _e];
                }),
                $
              );
            };
          },
          4536: (_, b, j) => {
            var $ = j(852)(Object, "create");
            _.exports = $;
          },
          6916: (_, b, j) => {
            var $ = j(5569)(Object.keys, Object);
            _.exports = $;
          },
          1167: (_, b, j) => {
            _ = j.nmd(_);
            var $ = j(1957),
              _e = b && !b.nodeType && b,
              et = _e && _ && !_.nodeType && _,
              rt = et && et.exports === _e && $.process,
              st = (function () {
                try {
                  return (
                    (et && et.require && et.require("util").types) ||
                    (rt && rt.binding && rt.binding("util"))
                  );
                } catch {}
              })();
            _.exports = st;
          },
          2333: (_) => {
            var b = Object.prototype.toString;
            _.exports = function (j) {
              return b.call(j);
            };
          },
          5569: (_) => {
            _.exports = function (b, j) {
              return function ($) {
                return b(j($));
              };
            };
          },
          5639: (_, b, j) => {
            var $ = j(1957),
              _e =
                typeof self == "object" &&
                self &&
                self.Object === Object &&
                self,
              et = $ || _e || Function("return this")();
            _.exports = et;
          },
          619: (_) => {
            _.exports = function (b) {
              return this.__data__.set(b, "__lodash_hash_undefined__"), this;
            };
          },
          2385: (_) => {
            _.exports = function (b) {
              return this.__data__.has(b);
            };
          },
          1814: (_) => {
            _.exports = function (b) {
              var j = -1,
                $ = Array(b.size);
              return (
                b.forEach(function (_e) {
                  $[++j] = _e;
                }),
                $
              );
            };
          },
          7465: (_, b, j) => {
            var $ = j(8407);
            _.exports = function () {
              (this.__data__ = new $()), (this.size = 0);
            };
          },
          3779: (_) => {
            _.exports = function (b) {
              var j = this.__data__,
                $ = j.delete(b);
              return (this.size = j.size), $;
            };
          },
          7599: (_) => {
            _.exports = function (b) {
              return this.__data__.get(b);
            };
          },
          4758: (_) => {
            _.exports = function (b) {
              return this.__data__.has(b);
            };
          },
          4309: (_, b, j) => {
            var $ = j(8407),
              _e = j(7071),
              et = j(3369);
            _.exports = function (rt, st) {
              var at = this.__data__;
              if (at instanceof $) {
                var ct = at.__data__;
                if (!_e || ct.length < 199)
                  return ct.push([rt, st]), (this.size = ++at.size), this;
                at = this.__data__ = new et(ct);
              }
              return at.set(rt, st), (this.size = at.size), this;
            };
          },
          346: (_) => {
            var b = Function.prototype.toString;
            _.exports = function (j) {
              if (j != null) {
                try {
                  return b.call(j);
                } catch {}
                try {
                  return j + "";
                } catch {}
              }
              return "";
            };
          },
          7813: (_) => {
            _.exports = function (b, j) {
              return b === j || (b != b && j != j);
            };
          },
          5694: (_, b, j) => {
            var $ = j(9454),
              _e = j(7005),
              et = Object.prototype,
              rt = et.hasOwnProperty,
              st = et.propertyIsEnumerable,
              at = $(
                (function () {
                  return arguments;
                })()
              )
                ? $
                : function (ct) {
                    return (
                      _e(ct) && rt.call(ct, "callee") && !st.call(ct, "callee")
                    );
                  };
            _.exports = at;
          },
          1469: (_) => {
            var b = Array.isArray;
            _.exports = b;
          },
          8612: (_, b, j) => {
            var $ = j(3560),
              _e = j(1780);
            _.exports = function (et) {
              return et != null && _e(et.length) && !$(et);
            };
          },
          4144: (_, b, j) => {
            _ = j.nmd(_);
            var $ = j(5639),
              _e = j(5062),
              et = b && !b.nodeType && b,
              rt = et && _ && !_.nodeType && _,
              st = rt && rt.exports === et ? $.Buffer : void 0,
              at = (st ? st.isBuffer : void 0) || _e;
            _.exports = at;
          },
          8446: (_, b, j) => {
            var $ = j(939);
            _.exports = function (_e, et) {
              return $(_e, et);
            };
          },
          3560: (_, b, j) => {
            var $ = j(4239),
              _e = j(3218);
            _.exports = function (et) {
              if (!_e(et)) return !1;
              var rt = $(et);
              return (
                rt == "[object Function]" ||
                rt == "[object GeneratorFunction]" ||
                rt == "[object AsyncFunction]" ||
                rt == "[object Proxy]"
              );
            };
          },
          1780: (_) => {
            _.exports = function (b) {
              return (
                typeof b == "number" &&
                b > -1 &&
                b % 1 == 0 &&
                b <= 9007199254740991
              );
            };
          },
          3218: (_) => {
            _.exports = function (b) {
              var j = typeof b;
              return b != null && (j == "object" || j == "function");
            };
          },
          7005: (_) => {
            _.exports = function (b) {
              return b != null && typeof b == "object";
            };
          },
          6719: (_, b, j) => {
            var $ = j(8749),
              _e = j(1717),
              et = j(1167),
              rt = et && et.isTypedArray,
              st = rt ? _e(rt) : $;
            _.exports = st;
          },
          3674: (_, b, j) => {
            var $ = j(4636),
              _e = j(280),
              et = j(8612);
            _.exports = function (rt) {
              return et(rt) ? $(rt) : _e(rt);
            };
          },
          479: (_) => {
            _.exports = function () {
              return [];
            };
          },
          5062: (_) => {
            _.exports = function () {
              return !1;
            };
          },
          75: function (_) {
            (function () {
              var b, j, $, _e, et, rt;
              typeof performance < "u" &&
              performance !== null &&
              performance.now
                ? (_.exports = function () {
                    return performance.now();
                  })
                : typeof process < "u" && process !== null && process.hrtime
                ? ((_.exports = function () {
                    return (b() - et) / 1e6;
                  }),
                  (j = process.hrtime),
                  (_e = (b = function () {
                    var st;
                    return 1e9 * (st = j())[0] + st[1];
                  })()),
                  (rt = 1e9 * process.uptime()),
                  (et = _e - rt))
                : Date.now
                ? ((_.exports = function () {
                    return Date.now() - $;
                  }),
                  ($ = Date.now()))
                : ((_.exports = function () {
                    return new Date().getTime() - $;
                  }),
                  ($ = new Date().getTime()));
            }).call(this);
          },
          4087: (_, b, j) => {
            for (
              var $ = j(75),
                _e = typeof window > "u" ? j.g : window,
                et = ["moz", "webkit"],
                rt = "AnimationFrame",
                st = _e["request" + rt],
                at = _e["cancel" + rt] || _e["cancelRequest" + rt],
                ct = 0;
              !st && ct < et.length;
              ct++
            )
              (st = _e[et[ct] + "Request" + rt]),
                (at =
                  _e[et[ct] + "Cancel" + rt] ||
                  _e[et[ct] + "CancelRequest" + rt]);
            if (!st || !at) {
              var it = 0,
                lt = 0,
                ot = [];
              (st = function (ut) {
                if (ot.length === 0) {
                  var pt = $(),
                    ft = Math.max(0, 16.666666666666668 - (pt - it));
                  (it = ft + pt),
                    setTimeout(function () {
                      var gt = ot.slice(0);
                      ot.length = 0;
                      for (var xt = 0; xt < gt.length; xt++)
                        if (!gt[xt].cancelled)
                          try {
                            gt[xt].callback(it);
                          } catch (_t) {
                            setTimeout(function () {
                              throw _t;
                            }, 0);
                          }
                    }, Math.round(ft));
                }
                return (
                  ot.push({ handle: ++lt, callback: ut, cancelled: !1 }), lt
                );
              }),
                (at = function (ut) {
                  for (var pt = 0; pt < ot.length; pt++)
                    ot[pt].handle === ut && (ot[pt].cancelled = !0);
                });
            }
            (_.exports = function (ut) {
              return st.call(_e, ut);
            }),
              (_.exports.cancel = function () {
                at.apply(_e, arguments);
              }),
              (_.exports.polyfill = function (ut) {
                ut || (ut = _e),
                  (ut.requestAnimationFrame = st),
                  (ut.cancelAnimationFrame = at);
              });
          },
          8156: (_) => {
            _.exports = o;
          },
        },
        c = {};
      function d(_) {
        var b = c[_];
        if (b !== void 0) return b.exports;
        var j = (c[_] = { id: _, loaded: !1, exports: {} });
        return (
          a[_].call(j.exports, j, j.exports, d), (j.loaded = !0), j.exports
        );
      }
      (d.n = (_) => {
        var b = _ && _.__esModule ? () => _.default : () => _;
        return d.d(b, { a: b }), b;
      }),
        (d.d = (_, b) => {
          for (var j in b)
            d.o(b, j) &&
              !d.o(_, j) &&
              Object.defineProperty(_, j, { enumerable: !0, get: b[j] });
        }),
        (d.g = (function () {
          if (typeof globalThis == "object") return globalThis;
          try {
            return this || new Function("return this")();
          } catch {
            if (typeof window == "object") return window;
          }
        })()),
        (d.o = (_, b) => Object.prototype.hasOwnProperty.call(_, b)),
        (d.nmd = (_) => ((_.paths = []), _.children || (_.children = []), _));
      var g = {};
      return (
        (() => {
          d.d(g, { default: () => ot });
          var _ = d(8156),
            b = d.n(_),
            j = d(7403),
            $ = d(8446),
            _e = d.n($);
          function et(ut) {
            return (
              (et =
                typeof Symbol == "function" &&
                typeof Symbol.iterator == "symbol"
                  ? function (pt) {
                      return typeof pt;
                    }
                  : function (pt) {
                      return pt &&
                        typeof Symbol == "function" &&
                        pt.constructor === Symbol &&
                        pt !== Symbol.prototype
                        ? "symbol"
                        : typeof pt;
                    }),
              et(ut)
            );
          }
          function rt(ut, pt) {
            for (var ft = 0; ft < pt.length; ft++) {
              var gt = pt[ft];
              (gt.enumerable = gt.enumerable || !1),
                (gt.configurable = !0),
                "value" in gt && (gt.writable = !0),
                Object.defineProperty(ut, it(gt.key), gt);
            }
          }
          function st(ut, pt) {
            return (
              (st = Object.setPrototypeOf
                ? Object.setPrototypeOf.bind()
                : function (ft, gt) {
                    return (ft.__proto__ = gt), ft;
                  }),
              st(ut, pt)
            );
          }
          function at(ut) {
            if (ut === void 0)
              throw new ReferenceError(
                "this hasn't been initialised - super() hasn't been called"
              );
            return ut;
          }
          function ct(ut) {
            return (
              (ct = Object.setPrototypeOf
                ? Object.getPrototypeOf.bind()
                : function (pt) {
                    return pt.__proto__ || Object.getPrototypeOf(pt);
                  }),
              ct(ut)
            );
          }
          function it(ut) {
            var pt = (function (ft, gt) {
              if (et(ft) !== "object" || ft === null) return ft;
              var xt = ft[Symbol.toPrimitive];
              if (xt !== void 0) {
                var _t = xt.call(ft, "string");
                if (et(_t) !== "object") return _t;
                throw new TypeError(
                  "@@toPrimitive must return a primitive value."
                );
              }
              return String(ft);
            })(ut);
            return et(pt) === "symbol" ? pt : String(pt);
          }
          var lt = (function (ut) {
            (function (Mt, Rt) {
              if (typeof Rt != "function" && Rt !== null)
                throw new TypeError(
                  "Super expression must either be null or a function"
                );
              (Mt.prototype = Object.create(Rt && Rt.prototype, {
                constructor: { value: Mt, writable: !0, configurable: !0 },
              })),
                Object.defineProperty(Mt, "prototype", { writable: !1 }),
                Rt && st(Mt, Rt);
            })(St, ut);
            var pt,
              ft,
              gt,
              xt,
              _t =
                ((gt = St),
                (xt = (function () {
                  if (
                    typeof Reflect > "u" ||
                    !Reflect.construct ||
                    Reflect.construct.sham
                  )
                    return !1;
                  if (typeof Proxy == "function") return !0;
                  try {
                    return (
                      Boolean.prototype.valueOf.call(
                        Reflect.construct(Boolean, [], function () {})
                      ),
                      !0
                    );
                  } catch {
                    return !1;
                  }
                })()),
                function () {
                  var Mt,
                    Rt = ct(gt);
                  if (xt) {
                    var Ft = ct(this).constructor;
                    Mt = Reflect.construct(Rt, arguments, Ft);
                  } else Mt = Rt.apply(this, arguments);
                  return (function (Ot, Lt) {
                    if (Lt && (et(Lt) === "object" || typeof Lt == "function"))
                      return Lt;
                    if (Lt !== void 0)
                      throw new TypeError(
                        "Derived constructors may only return object or undefined"
                      );
                    return at(Ot);
                  })(this, Mt);
                });
            function St() {
              var Mt, Rt, Ft, Ot;
              (function (mt, vt) {
                if (!(mt instanceof vt))
                  throw new TypeError("Cannot call a class as a function");
              })(this, St);
              for (
                var Lt = arguments.length, Et = new Array(Lt), bt = 0;
                bt < Lt;
                bt++
              )
                Et[bt] = arguments[bt];
              return (
                (Rt = at((Mt = _t.call.apply(_t, [this].concat(Et))))),
                (Ot = { instance: null }),
                (Ft = it((Ft = "state"))) in Rt
                  ? Object.defineProperty(Rt, Ft, {
                      value: Ot,
                      enumerable: !0,
                      configurable: !0,
                      writable: !0,
                    })
                  : (Rt[Ft] = Ot),
                Mt
              );
            }
            return (
              (pt = St),
              (ft = [
                {
                  key: "componentDidMount",
                  value: function () {
                    var Mt = this,
                      Rt = new j.default(this.typewriter, this.props.options);
                    this.setState({ instance: Rt }, function () {
                      var Ft = Mt.props.onInit;
                      Ft && Ft(Rt);
                    });
                  },
                },
                {
                  key: "componentDidUpdate",
                  value: function (Mt) {
                    _e()(this.props.options, Mt.options) ||
                      this.setState({
                        instance: new j.default(
                          this.typewriter,
                          this.props.options
                        ),
                      });
                  },
                },
                {
                  key: "componentWillUnmount",
                  value: function () {
                    this.state.instance && this.state.instance.stop();
                  },
                },
                {
                  key: "render",
                  value: function () {
                    var Mt = this,
                      Rt = this.props.component;
                    return b().createElement(Rt, {
                      ref: function (Ft) {
                        return (Mt.typewriter = Ft);
                      },
                      className: "Typewriter",
                      "data-testid": "typewriter-wrapper",
                    });
                  },
                },
              ]) && rt(pt.prototype, ft),
              Object.defineProperty(pt, "prototype", { writable: !1 }),
              St
            );
          })(_.Component);
          lt.defaultProps = { component: "div" };
          const ot = lt;
        })(),
        g.default
      );
    })()
  );
})(react);
var reactExports = react.exports;
const Typewriter = getDefaultExportFromCjs(reactExports);
/**
 * @license
 * Copyright 2010-2024 Three.js Authors
 * SPDX-License-Identifier: MIT
 */ const REVISION = "167",
  MOUSE = { LEFT: 0, MIDDLE: 1, RIGHT: 2, ROTATE: 0, DOLLY: 1, PAN: 2 },
  TOUCH = { ROTATE: 0, PAN: 1, DOLLY_PAN: 2, DOLLY_ROTATE: 3 },
  CullFaceNone = 0,
  CullFaceBack = 1,
  CullFaceFront = 2,
  CullFaceFrontBack = 3,
  BasicShadowMap = 0,
  PCFShadowMap = 1,
  PCFSoftShadowMap = 2,
  VSMShadowMap = 3,
  FrontSide = 0,
  BackSide = 1,
  DoubleSide = 2,
  NoBlending = 0,
  NormalBlending = 1,
  AdditiveBlending = 2,
  SubtractiveBlending = 3,
  MultiplyBlending = 4,
  CustomBlending = 5,
  AddEquation = 100,
  SubtractEquation = 101,
  ReverseSubtractEquation = 102,
  MinEquation = 103,
  MaxEquation = 104,
  ZeroFactor = 200,
  OneFactor = 201,
  SrcColorFactor = 202,
  OneMinusSrcColorFactor = 203,
  SrcAlphaFactor = 204,
  OneMinusSrcAlphaFactor = 205,
  DstAlphaFactor = 206,
  OneMinusDstAlphaFactor = 207,
  DstColorFactor = 208,
  OneMinusDstColorFactor = 209,
  SrcAlphaSaturateFactor = 210,
  ConstantColorFactor = 211,
  OneMinusConstantColorFactor = 212,
  ConstantAlphaFactor = 213,
  OneMinusConstantAlphaFactor = 214,
  NeverDepth = 0,
  AlwaysDepth = 1,
  LessDepth = 2,
  LessEqualDepth = 3,
  EqualDepth = 4,
  GreaterEqualDepth = 5,
  GreaterDepth = 6,
  NotEqualDepth = 7,
  MultiplyOperation = 0,
  MixOperation = 1,
  AddOperation = 2,
  NoToneMapping = 0,
  LinearToneMapping = 1,
  ReinhardToneMapping = 2,
  CineonToneMapping = 3,
  ACESFilmicToneMapping = 4,
  CustomToneMapping = 5,
  AgXToneMapping = 6,
  NeutralToneMapping = 7,
  AttachedBindMode = "attached",
  DetachedBindMode = "detached",
  UVMapping = 300,
  CubeReflectionMapping = 301,
  CubeRefractionMapping = 302,
  EquirectangularReflectionMapping = 303,
  EquirectangularRefractionMapping = 304,
  CubeUVReflectionMapping = 306,
  RepeatWrapping = 1e3,
  ClampToEdgeWrapping = 1001,
  MirroredRepeatWrapping = 1002,
  NearestFilter = 1003,
  NearestMipmapNearestFilter = 1004,
  NearestMipMapNearestFilter = 1004,
  NearestMipmapLinearFilter = 1005,
  NearestMipMapLinearFilter = 1005,
  LinearFilter = 1006,
  LinearMipmapNearestFilter = 1007,
  LinearMipMapNearestFilter = 1007,
  LinearMipmapLinearFilter = 1008,
  LinearMipMapLinearFilter = 1008,
  UnsignedByteType = 1009,
  ByteType = 1010,
  ShortType = 1011,
  UnsignedShortType = 1012,
  IntType = 1013,
  UnsignedIntType = 1014,
  FloatType = 1015,
  HalfFloatType = 1016,
  UnsignedShort4444Type = 1017,
  UnsignedShort5551Type = 1018,
  UnsignedInt248Type = 1020,
  UnsignedInt5999Type = 35902,
  AlphaFormat = 1021,
  RGBFormat = 1022,
  RGBAFormat = 1023,
  LuminanceFormat = 1024,
  LuminanceAlphaFormat = 1025,
  DepthFormat = 1026,
  DepthStencilFormat = 1027,
  RedFormat = 1028,
  RedIntegerFormat = 1029,
  RGFormat = 1030,
  RGIntegerFormat = 1031,
  RGBIntegerFormat = 1032,
  RGBAIntegerFormat = 1033,
  RGB_S3TC_DXT1_Format = 33776,
  RGBA_S3TC_DXT1_Format = 33777,
  RGBA_S3TC_DXT3_Format = 33778,
  RGBA_S3TC_DXT5_Format = 33779,
  RGB_PVRTC_4BPPV1_Format = 35840,
  RGB_PVRTC_2BPPV1_Format = 35841,
  RGBA_PVRTC_4BPPV1_Format = 35842,
  RGBA_PVRTC_2BPPV1_Format = 35843,
  RGB_ETC1_Format = 36196,
  RGB_ETC2_Format = 37492,
  RGBA_ETC2_EAC_Format = 37496,
  RGBA_ASTC_4x4_Format = 37808,
  RGBA_ASTC_5x4_Format = 37809,
  RGBA_ASTC_5x5_Format = 37810,
  RGBA_ASTC_6x5_Format = 37811,
  RGBA_ASTC_6x6_Format = 37812,
  RGBA_ASTC_8x5_Format = 37813,
  RGBA_ASTC_8x6_Format = 37814,
  RGBA_ASTC_8x8_Format = 37815,
  RGBA_ASTC_10x5_Format = 37816,
  RGBA_ASTC_10x6_Format = 37817,
  RGBA_ASTC_10x8_Format = 37818,
  RGBA_ASTC_10x10_Format = 37819,
  RGBA_ASTC_12x10_Format = 37820,
  RGBA_ASTC_12x12_Format = 37821,
  RGBA_BPTC_Format = 36492,
  RGB_BPTC_SIGNED_Format = 36494,
  RGB_BPTC_UNSIGNED_Format = 36495,
  RED_RGTC1_Format = 36283,
  SIGNED_RED_RGTC1_Format = 36284,
  RED_GREEN_RGTC2_Format = 36285,
  SIGNED_RED_GREEN_RGTC2_Format = 36286,
  LoopOnce = 2200,
  LoopRepeat = 2201,
  LoopPingPong = 2202,
  InterpolateDiscrete = 2300,
  InterpolateLinear = 2301,
  InterpolateSmooth = 2302,
  ZeroCurvatureEnding = 2400,
  ZeroSlopeEnding = 2401,
  WrapAroundEnding = 2402,
  NormalAnimationBlendMode = 2500,
  AdditiveAnimationBlendMode = 2501,
  TrianglesDrawMode = 0,
  TriangleStripDrawMode = 1,
  TriangleFanDrawMode = 2,
  BasicDepthPacking = 3200,
  RGBADepthPacking = 3201,
  RGBDepthPacking = 3202,
  RGDepthPacking = 3203,
  TangentSpaceNormalMap = 0,
  ObjectSpaceNormalMap = 1,
  NoColorSpace = "",
  SRGBColorSpace$1 = "srgb",
  LinearSRGBColorSpace$1 = "srgb-linear",
  DisplayP3ColorSpace = "display-p3",
  LinearDisplayP3ColorSpace = "display-p3-linear",
  LinearTransfer = "linear",
  SRGBTransfer = "srgb",
  Rec709Primaries = "rec709",
  P3Primaries = "p3",
  ZeroStencilOp = 0,
  KeepStencilOp = 7680,
  ReplaceStencilOp = 7681,
  IncrementStencilOp = 7682,
  DecrementStencilOp = 7683,
  IncrementWrapStencilOp = 34055,
  DecrementWrapStencilOp = 34056,
  InvertStencilOp = 5386,
  NeverStencilFunc = 512,
  LessStencilFunc = 513,
  EqualStencilFunc = 514,
  LessEqualStencilFunc = 515,
  GreaterStencilFunc = 516,
  NotEqualStencilFunc = 517,
  GreaterEqualStencilFunc = 518,
  AlwaysStencilFunc = 519,
  NeverCompare = 512,
  LessCompare = 513,
  EqualCompare = 514,
  LessEqualCompare = 515,
  GreaterCompare = 516,
  NotEqualCompare = 517,
  GreaterEqualCompare = 518,
  AlwaysCompare = 519,
  StaticDrawUsage = 35044,
  DynamicDrawUsage = 35048,
  StreamDrawUsage = 35040,
  StaticReadUsage = 35045,
  DynamicReadUsage = 35049,
  StreamReadUsage = 35041,
  StaticCopyUsage = 35046,
  DynamicCopyUsage = 35050,
  StreamCopyUsage = 35042,
  GLSL1 = "100",
  GLSL3 = "300 es",
  WebGLCoordinateSystem = 2e3,
  WebGPUCoordinateSystem = 2001;
class EventDispatcher {
  addEventListener(e, o) {
    this._listeners === void 0 && (this._listeners = {});
    const a = this._listeners;
    a[e] === void 0 && (a[e] = []), a[e].indexOf(o) === -1 && a[e].push(o);
  }
  hasEventListener(e, o) {
    if (this._listeners === void 0) return !1;
    const a = this._listeners;
    return a[e] !== void 0 && a[e].indexOf(o) !== -1;
  }
  removeEventListener(e, o) {
    if (this._listeners === void 0) return;
    const c = this._listeners[e];
    if (c !== void 0) {
      const d = c.indexOf(o);
      d !== -1 && c.splice(d, 1);
    }
  }
  dispatchEvent(e) {
    if (this._listeners === void 0) return;
    const a = this._listeners[e.type];
    if (a !== void 0) {
      e.target = this;
      const c = a.slice(0);
      for (let d = 0, g = c.length; d < g; d++) c[d].call(this, e);
      e.target = null;
    }
  }
}
const _lut = [
  "00",
  "01",
  "02",
  "03",
  "04",
  "05",
  "06",
  "07",
  "08",
  "09",
  "0a",
  "0b",
  "0c",
  "0d",
  "0e",
  "0f",
  "10",
  "11",
  "12",
  "13",
  "14",
  "15",
  "16",
  "17",
  "18",
  "19",
  "1a",
  "1b",
  "1c",
  "1d",
  "1e",
  "1f",
  "20",
  "21",
  "22",
  "23",
  "24",
  "25",
  "26",
  "27",
  "28",
  "29",
  "2a",
  "2b",
  "2c",
  "2d",
  "2e",
  "2f",
  "30",
  "31",
  "32",
  "33",
  "34",
  "35",
  "36",
  "37",
  "38",
  "39",
  "3a",
  "3b",
  "3c",
  "3d",
  "3e",
  "3f",
  "40",
  "41",
  "42",
  "43",
  "44",
  "45",
  "46",
  "47",
  "48",
  "49",
  "4a",
  "4b",
  "4c",
  "4d",
  "4e",
  "4f",
  "50",
  "51",
  "52",
  "53",
  "54",
  "55",
  "56",
  "57",
  "58",
  "59",
  "5a",
  "5b",
  "5c",
  "5d",
  "5e",
  "5f",
  "60",
  "61",
  "62",
  "63",
  "64",
  "65",
  "66",
  "67",
  "68",
  "69",
  "6a",
  "6b",
  "6c",
  "6d",
  "6e",
  "6f",
  "70",
  "71",
  "72",
  "73",
  "74",
  "75",
  "76",
  "77",
  "78",
  "79",
  "7a",
  "7b",
  "7c",
  "7d",
  "7e",
  "7f",
  "80",
  "81",
  "82",
  "83",
  "84",
  "85",
  "86",
  "87",
  "88",
  "89",
  "8a",
  "8b",
  "8c",
  "8d",
  "8e",
  "8f",
  "90",
  "91",
  "92",
  "93",
  "94",
  "95",
  "96",
  "97",
  "98",
  "99",
  "9a",
  "9b",
  "9c",
  "9d",
  "9e",
  "9f",
  "a0",
  "a1",
  "a2",
  "a3",
  "a4",
  "a5",
  "a6",
  "a7",
  "a8",
  "a9",
  "aa",
  "ab",
  "ac",
  "ad",
  "ae",
  "af",
  "b0",
  "b1",
  "b2",
  "b3",
  "b4",
  "b5",
  "b6",
  "b7",
  "b8",
  "b9",
  "ba",
  "bb",
  "bc",
  "bd",
  "be",
  "bf",
  "c0",
  "c1",
  "c2",
  "c3",
  "c4",
  "c5",
  "c6",
  "c7",
  "c8",
  "c9",
  "ca",
  "cb",
  "cc",
  "cd",
  "ce",
  "cf",
  "d0",
  "d1",
  "d2",
  "d3",
  "d4",
  "d5",
  "d6",
  "d7",
  "d8",
  "d9",
  "da",
  "db",
  "dc",
  "dd",
  "de",
  "df",
  "e0",
  "e1",
  "e2",
  "e3",
  "e4",
  "e5",
  "e6",
  "e7",
  "e8",
  "e9",
  "ea",
  "eb",
  "ec",
  "ed",
  "ee",
  "ef",
  "f0",
  "f1",
  "f2",
  "f3",
  "f4",
  "f5",
  "f6",
  "f7",
  "f8",
  "f9",
  "fa",
  "fb",
  "fc",
  "fd",
  "fe",
  "ff",
];
let _seed = 1234567;
const DEG2RAD = Math.PI / 180,
  RAD2DEG = 180 / Math.PI;
function generateUUID() {
  const s = (Math.random() * 4294967295) | 0,
    e = (Math.random() * 4294967295) | 0,
    o = (Math.random() * 4294967295) | 0,
    a = (Math.random() * 4294967295) | 0;
  return (
    _lut[s & 255] +
    _lut[(s >> 8) & 255] +
    _lut[(s >> 16) & 255] +
    _lut[(s >> 24) & 255] +
    "-" +
    _lut[e & 255] +
    _lut[(e >> 8) & 255] +
    "-" +
    _lut[((e >> 16) & 15) | 64] +
    _lut[(e >> 24) & 255] +
    "-" +
    _lut[(o & 63) | 128] +
    _lut[(o >> 8) & 255] +
    "-" +
    _lut[(o >> 16) & 255] +
    _lut[(o >> 24) & 255] +
    _lut[a & 255] +
    _lut[(a >> 8) & 255] +
    _lut[(a >> 16) & 255] +
    _lut[(a >> 24) & 255]
  ).toLowerCase();
}
function clamp(s, e, o) {
  return Math.max(e, Math.min(o, s));
}
function euclideanModulo(s, e) {
  return ((s % e) + e) % e;
}
function mapLinear(s, e, o, a, c) {
  return a + ((s - e) * (c - a)) / (o - e);
}
function inverseLerp(s, e, o) {
  return s !== e ? (o - s) / (e - s) : 0;
}
function lerp(s, e, o) {
  return (1 - o) * s + o * e;
}
function damp(s, e, o, a) {
  return lerp(s, e, 1 - Math.exp(-o * a));
}
function pingpong(s, e = 1) {
  return e - Math.abs(euclideanModulo(s, e * 2) - e);
}
function smoothstep(s, e, o) {
  return s <= e
    ? 0
    : s >= o
    ? 1
    : ((s = (s - e) / (o - e)), s * s * (3 - 2 * s));
}
function smootherstep(s, e, o) {
  return s <= e
    ? 0
    : s >= o
    ? 1
    : ((s = (s - e) / (o - e)), s * s * s * (s * (s * 6 - 15) + 10));
}
function randInt(s, e) {
  return s + Math.floor(Math.random() * (e - s + 1));
}
function randFloat(s, e) {
  return s + Math.random() * (e - s);
}
function randFloatSpread(s) {
  return s * (0.5 - Math.random());
}
function seededRandom(s) {
  s !== void 0 && (_seed = s);
  let e = (_seed += 1831565813);
  return (
    (e = Math.imul(e ^ (e >>> 15), e | 1)),
    (e ^= e + Math.imul(e ^ (e >>> 7), e | 61)),
    ((e ^ (e >>> 14)) >>> 0) / 4294967296
  );
}
function degToRad(s) {
  return s * DEG2RAD;
}
function radToDeg(s) {
  return s * RAD2DEG;
}
function isPowerOfTwo(s) {
  return (s & (s - 1)) === 0 && s !== 0;
}
function ceilPowerOfTwo(s) {
  return Math.pow(2, Math.ceil(Math.log(s) / Math.LN2));
}
function floorPowerOfTwo(s) {
  return Math.pow(2, Math.floor(Math.log(s) / Math.LN2));
}
function setQuaternionFromProperEuler(s, e, o, a, c) {
  const d = Math.cos,
    g = Math.sin,
    _ = d(o / 2),
    b = g(o / 2),
    j = d((e + a) / 2),
    $ = g((e + a) / 2),
    _e = d((e - a) / 2),
    et = g((e - a) / 2),
    rt = d((a - e) / 2),
    st = g((a - e) / 2);
  switch (c) {
    case "XYX":
      s.set(_ * $, b * _e, b * et, _ * j);
      break;
    case "YZY":
      s.set(b * et, _ * $, b * _e, _ * j);
      break;
    case "ZXZ":
      s.set(b * _e, b * et, _ * $, _ * j);
      break;
    case "XZX":
      s.set(_ * $, b * st, b * rt, _ * j);
      break;
    case "YXY":
      s.set(b * rt, _ * $, b * st, _ * j);
      break;
    case "ZYZ":
      s.set(b * st, b * rt, _ * $, _ * j);
      break;
    default:
      console.warn(
        "THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " +
          c
      );
  }
}
function denormalize(s, e) {
  switch (e.constructor) {
    case Float32Array:
      return s;
    case Uint32Array:
      return s / 4294967295;
    case Uint16Array:
      return s / 65535;
    case Uint8Array:
      return s / 255;
    case Int32Array:
      return Math.max(s / 2147483647, -1);
    case Int16Array:
      return Math.max(s / 32767, -1);
    case Int8Array:
      return Math.max(s / 127, -1);
    default:
      throw new Error("Invalid component type.");
  }
}
function normalize(s, e) {
  switch (e.constructor) {
    case Float32Array:
      return s;
    case Uint32Array:
      return Math.round(s * 4294967295);
    case Uint16Array:
      return Math.round(s * 65535);
    case Uint8Array:
      return Math.round(s * 255);
    case Int32Array:
      return Math.round(s * 2147483647);
    case Int16Array:
      return Math.round(s * 32767);
    case Int8Array:
      return Math.round(s * 127);
    default:
      throw new Error("Invalid component type.");
  }
}
const MathUtils = {
  DEG2RAD,
  RAD2DEG,
  generateUUID,
  clamp,
  euclideanModulo,
  mapLinear,
  inverseLerp,
  lerp,
  damp,
  pingpong,
  smoothstep,
  smootherstep,
  randInt,
  randFloat,
  randFloatSpread,
  seededRandom,
  degToRad,
  radToDeg,
  isPowerOfTwo,
  ceilPowerOfTwo,
  floorPowerOfTwo,
  setQuaternionFromProperEuler,
  normalize,
  denormalize,
};
class Vector2 {
  constructor(e = 0, o = 0) {
    (Vector2.prototype.isVector2 = !0), (this.x = e), (this.y = o);
  }
  get width() {
    return this.x;
  }
  set width(e) {
    this.x = e;
  }
  get height() {
    return this.y;
  }
  set height(e) {
    this.y = e;
  }
  set(e, o) {
    return (this.x = e), (this.y = o), this;
  }
  setScalar(e) {
    return (this.x = e), (this.y = e), this;
  }
  setX(e) {
    return (this.x = e), this;
  }
  setY(e) {
    return (this.y = e), this;
  }
  setComponent(e, o) {
    switch (e) {
      case 0:
        this.x = o;
        break;
      case 1:
        this.y = o;
        break;
      default:
        throw new Error("index is out of range: " + e);
    }
    return this;
  }
  getComponent(e) {
    switch (e) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      default:
        throw new Error("index is out of range: " + e);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y);
  }
  copy(e) {
    return (this.x = e.x), (this.y = e.y), this;
  }
  add(e) {
    return (this.x += e.x), (this.y += e.y), this;
  }
  addScalar(e) {
    return (this.x += e), (this.y += e), this;
  }
  addVectors(e, o) {
    return (this.x = e.x + o.x), (this.y = e.y + o.y), this;
  }
  addScaledVector(e, o) {
    return (this.x += e.x * o), (this.y += e.y * o), this;
  }
  sub(e) {
    return (this.x -= e.x), (this.y -= e.y), this;
  }
  subScalar(e) {
    return (this.x -= e), (this.y -= e), this;
  }
  subVectors(e, o) {
    return (this.x = e.x - o.x), (this.y = e.y - o.y), this;
  }
  multiply(e) {
    return (this.x *= e.x), (this.y *= e.y), this;
  }
  multiplyScalar(e) {
    return (this.x *= e), (this.y *= e), this;
  }
  divide(e) {
    return (this.x /= e.x), (this.y /= e.y), this;
  }
  divideScalar(e) {
    return this.multiplyScalar(1 / e);
  }
  applyMatrix3(e) {
    const o = this.x,
      a = this.y,
      c = e.elements;
    return (
      (this.x = c[0] * o + c[3] * a + c[6]),
      (this.y = c[1] * o + c[4] * a + c[7]),
      this
    );
  }
  min(e) {
    return (
      (this.x = Math.min(this.x, e.x)), (this.y = Math.min(this.y, e.y)), this
    );
  }
  max(e) {
    return (
      (this.x = Math.max(this.x, e.x)), (this.y = Math.max(this.y, e.y)), this
    );
  }
  clamp(e, o) {
    return (
      (this.x = Math.max(e.x, Math.min(o.x, this.x))),
      (this.y = Math.max(e.y, Math.min(o.y, this.y))),
      this
    );
  }
  clampScalar(e, o) {
    return (
      (this.x = Math.max(e, Math.min(o, this.x))),
      (this.y = Math.max(e, Math.min(o, this.y))),
      this
    );
  }
  clampLength(e, o) {
    const a = this.length();
    return this.divideScalar(a || 1).multiplyScalar(
      Math.max(e, Math.min(o, a))
    );
  }
  floor() {
    return (this.x = Math.floor(this.x)), (this.y = Math.floor(this.y)), this;
  }
  ceil() {
    return (this.x = Math.ceil(this.x)), (this.y = Math.ceil(this.y)), this;
  }
  round() {
    return (this.x = Math.round(this.x)), (this.y = Math.round(this.y)), this;
  }
  roundToZero() {
    return (this.x = Math.trunc(this.x)), (this.y = Math.trunc(this.y)), this;
  }
  negate() {
    return (this.x = -this.x), (this.y = -this.y), this;
  }
  dot(e) {
    return this.x * e.x + this.y * e.y;
  }
  cross(e) {
    return this.x * e.y - this.y * e.x;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  angle() {
    return Math.atan2(-this.y, -this.x) + Math.PI;
  }
  angleTo(e) {
    const o = Math.sqrt(this.lengthSq() * e.lengthSq());
    if (o === 0) return Math.PI / 2;
    const a = this.dot(e) / o;
    return Math.acos(clamp(a, -1, 1));
  }
  distanceTo(e) {
    return Math.sqrt(this.distanceToSquared(e));
  }
  distanceToSquared(e) {
    const o = this.x - e.x,
      a = this.y - e.y;
    return o * o + a * a;
  }
  manhattanDistanceTo(e) {
    return Math.abs(this.x - e.x) + Math.abs(this.y - e.y);
  }
  setLength(e) {
    return this.normalize().multiplyScalar(e);
  }
  lerp(e, o) {
    return (this.x += (e.x - this.x) * o), (this.y += (e.y - this.y) * o), this;
  }
  lerpVectors(e, o, a) {
    return (
      (this.x = e.x + (o.x - e.x) * a), (this.y = e.y + (o.y - e.y) * a), this
    );
  }
  equals(e) {
    return e.x === this.x && e.y === this.y;
  }
  fromArray(e, o = 0) {
    return (this.x = e[o]), (this.y = e[o + 1]), this;
  }
  toArray(e = [], o = 0) {
    return (e[o] = this.x), (e[o + 1] = this.y), e;
  }
  fromBufferAttribute(e, o) {
    return (this.x = e.getX(o)), (this.y = e.getY(o)), this;
  }
  rotateAround(e, o) {
    const a = Math.cos(o),
      c = Math.sin(o),
      d = this.x - e.x,
      g = this.y - e.y;
    return (this.x = d * a - g * c + e.x), (this.y = d * c + g * a + e.y), this;
  }
  random() {
    return (this.x = Math.random()), (this.y = Math.random()), this;
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y;
  }
}
class Matrix3 {
  constructor(e, o, a, c, d, g, _, b, j) {
    (Matrix3.prototype.isMatrix3 = !0),
      (this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1]),
      e !== void 0 && this.set(e, o, a, c, d, g, _, b, j);
  }
  set(e, o, a, c, d, g, _, b, j) {
    const $ = this.elements;
    return (
      ($[0] = e),
      ($[1] = c),
      ($[2] = _),
      ($[3] = o),
      ($[4] = d),
      ($[5] = b),
      ($[6] = a),
      ($[7] = g),
      ($[8] = j),
      this
    );
  }
  identity() {
    return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this;
  }
  copy(e) {
    const o = this.elements,
      a = e.elements;
    return (
      (o[0] = a[0]),
      (o[1] = a[1]),
      (o[2] = a[2]),
      (o[3] = a[3]),
      (o[4] = a[4]),
      (o[5] = a[5]),
      (o[6] = a[6]),
      (o[7] = a[7]),
      (o[8] = a[8]),
      this
    );
  }
  extractBasis(e, o, a) {
    return (
      e.setFromMatrix3Column(this, 0),
      o.setFromMatrix3Column(this, 1),
      a.setFromMatrix3Column(this, 2),
      this
    );
  }
  setFromMatrix4(e) {
    const o = e.elements;
    return (
      this.set(o[0], o[4], o[8], o[1], o[5], o[9], o[2], o[6], o[10]), this
    );
  }
  multiply(e) {
    return this.multiplyMatrices(this, e);
  }
  premultiply(e) {
    return this.multiplyMatrices(e, this);
  }
  multiplyMatrices(e, o) {
    const a = e.elements,
      c = o.elements,
      d = this.elements,
      g = a[0],
      _ = a[3],
      b = a[6],
      j = a[1],
      $ = a[4],
      _e = a[7],
      et = a[2],
      rt = a[5],
      st = a[8],
      at = c[0],
      ct = c[3],
      it = c[6],
      lt = c[1],
      ot = c[4],
      ut = c[7],
      pt = c[2],
      ft = c[5],
      gt = c[8];
    return (
      (d[0] = g * at + _ * lt + b * pt),
      (d[3] = g * ct + _ * ot + b * ft),
      (d[6] = g * it + _ * ut + b * gt),
      (d[1] = j * at + $ * lt + _e * pt),
      (d[4] = j * ct + $ * ot + _e * ft),
      (d[7] = j * it + $ * ut + _e * gt),
      (d[2] = et * at + rt * lt + st * pt),
      (d[5] = et * ct + rt * ot + st * ft),
      (d[8] = et * it + rt * ut + st * gt),
      this
    );
  }
  multiplyScalar(e) {
    const o = this.elements;
    return (
      (o[0] *= e),
      (o[3] *= e),
      (o[6] *= e),
      (o[1] *= e),
      (o[4] *= e),
      (o[7] *= e),
      (o[2] *= e),
      (o[5] *= e),
      (o[8] *= e),
      this
    );
  }
  determinant() {
    const e = this.elements,
      o = e[0],
      a = e[1],
      c = e[2],
      d = e[3],
      g = e[4],
      _ = e[5],
      b = e[6],
      j = e[7],
      $ = e[8];
    return (
      o * g * $ - o * _ * j - a * d * $ + a * _ * b + c * d * j - c * g * b
    );
  }
  invert() {
    const e = this.elements,
      o = e[0],
      a = e[1],
      c = e[2],
      d = e[3],
      g = e[4],
      _ = e[5],
      b = e[6],
      j = e[7],
      $ = e[8],
      _e = $ * g - _ * j,
      et = _ * b - $ * d,
      rt = j * d - g * b,
      st = o * _e + a * et + c * rt;
    if (st === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
    const at = 1 / st;
    return (
      (e[0] = _e * at),
      (e[1] = (c * j - $ * a) * at),
      (e[2] = (_ * a - c * g) * at),
      (e[3] = et * at),
      (e[4] = ($ * o - c * b) * at),
      (e[5] = (c * d - _ * o) * at),
      (e[6] = rt * at),
      (e[7] = (a * b - j * o) * at),
      (e[8] = (g * o - a * d) * at),
      this
    );
  }
  transpose() {
    let e;
    const o = this.elements;
    return (
      (e = o[1]),
      (o[1] = o[3]),
      (o[3] = e),
      (e = o[2]),
      (o[2] = o[6]),
      (o[6] = e),
      (e = o[5]),
      (o[5] = o[7]),
      (o[7] = e),
      this
    );
  }
  getNormalMatrix(e) {
    return this.setFromMatrix4(e).invert().transpose();
  }
  transposeIntoArray(e) {
    const o = this.elements;
    return (
      (e[0] = o[0]),
      (e[1] = o[3]),
      (e[2] = o[6]),
      (e[3] = o[1]),
      (e[4] = o[4]),
      (e[5] = o[7]),
      (e[6] = o[2]),
      (e[7] = o[5]),
      (e[8] = o[8]),
      this
    );
  }
  setUvTransform(e, o, a, c, d, g, _) {
    const b = Math.cos(d),
      j = Math.sin(d);
    return (
      this.set(
        a * b,
        a * j,
        -a * (b * g + j * _) + g + e,
        -c * j,
        c * b,
        -c * (-j * g + b * _) + _ + o,
        0,
        0,
        1
      ),
      this
    );
  }
  scale(e, o) {
    return this.premultiply(_m3.makeScale(e, o)), this;
  }
  rotate(e) {
    return this.premultiply(_m3.makeRotation(-e)), this;
  }
  translate(e, o) {
    return this.premultiply(_m3.makeTranslation(e, o)), this;
  }
  makeTranslation(e, o) {
    return (
      e.isVector2
        ? this.set(1, 0, e.x, 0, 1, e.y, 0, 0, 1)
        : this.set(1, 0, e, 0, 1, o, 0, 0, 1),
      this
    );
  }
  makeRotation(e) {
    const o = Math.cos(e),
      a = Math.sin(e);
    return this.set(o, -a, 0, a, o, 0, 0, 0, 1), this;
  }
  makeScale(e, o) {
    return this.set(e, 0, 0, 0, o, 0, 0, 0, 1), this;
  }
  equals(e) {
    const o = this.elements,
      a = e.elements;
    for (let c = 0; c < 9; c++) if (o[c] !== a[c]) return !1;
    return !0;
  }
  fromArray(e, o = 0) {
    for (let a = 0; a < 9; a++) this.elements[a] = e[a + o];
    return this;
  }
  toArray(e = [], o = 0) {
    const a = this.elements;
    return (
      (e[o] = a[0]),
      (e[o + 1] = a[1]),
      (e[o + 2] = a[2]),
      (e[o + 3] = a[3]),
      (e[o + 4] = a[4]),
      (e[o + 5] = a[5]),
      (e[o + 6] = a[6]),
      (e[o + 7] = a[7]),
      (e[o + 8] = a[8]),
      e
    );
  }
  clone() {
    return new this.constructor().fromArray(this.elements);
  }
}
const _m3 = new Matrix3();
function arrayNeedsUint32(s) {
  for (let e = s.length - 1; e >= 0; --e) if (s[e] >= 65535) return !0;
  return !1;
}
const TYPED_ARRAYS = {
  Int8Array,
  Uint8Array,
  Uint8ClampedArray,
  Int16Array,
  Uint16Array,
  Int32Array,
  Uint32Array,
  Float32Array,
  Float64Array,
};
function getTypedArray(s, e) {
  return new TYPED_ARRAYS[s](e);
}
function createElementNS(s) {
  return document.createElementNS("http://www.w3.org/1999/xhtml", s);
}
function createCanvasElement() {
  const s = createElementNS("canvas");
  return (s.style.display = "block"), s;
}
const _cache = {};
function warnOnce(s) {
  s in _cache || ((_cache[s] = !0), console.warn(s));
}
function probeAsync(s, e, o) {
  return new Promise(function (a, c) {
    function d() {
      switch (s.clientWaitSync(e, s.SYNC_FLUSH_COMMANDS_BIT, 0)) {
        case s.WAIT_FAILED:
          c();
          break;
        case s.TIMEOUT_EXPIRED:
          setTimeout(d, o);
          break;
        default:
          a();
      }
    }
    setTimeout(d, o);
  });
}
const LINEAR_SRGB_TO_LINEAR_DISPLAY_P3 = new Matrix3().set(
    0.8224621,
    0.177538,
    0,
    0.0331941,
    0.9668058,
    0,
    0.0170827,
    0.0723974,
    0.9105199
  ),
  LINEAR_DISPLAY_P3_TO_LINEAR_SRGB = new Matrix3().set(
    1.2249401,
    -0.2249404,
    0,
    -0.0420569,
    1.0420571,
    0,
    -0.0196376,
    -0.0786361,
    1.0982735
  ),
  COLOR_SPACES = {
    [LinearSRGBColorSpace$1]: {
      transfer: LinearTransfer,
      primaries: Rec709Primaries,
      luminanceCoefficients: [0.2126, 0.7152, 0.0722],
      toReference: (s) => s,
      fromReference: (s) => s,
    },
    [SRGBColorSpace$1]: {
      transfer: SRGBTransfer,
      primaries: Rec709Primaries,
      luminanceCoefficients: [0.2126, 0.7152, 0.0722],
      toReference: (s) => s.convertSRGBToLinear(),
      fromReference: (s) => s.convertLinearToSRGB(),
    },
    [LinearDisplayP3ColorSpace]: {
      transfer: LinearTransfer,
      primaries: P3Primaries,
      luminanceCoefficients: [0.2289, 0.6917, 0.0793],
      toReference: (s) => s.applyMatrix3(LINEAR_DISPLAY_P3_TO_LINEAR_SRGB),
      fromReference: (s) => s.applyMatrix3(LINEAR_SRGB_TO_LINEAR_DISPLAY_P3),
    },
    [DisplayP3ColorSpace]: {
      transfer: SRGBTransfer,
      primaries: P3Primaries,
      luminanceCoefficients: [0.2289, 0.6917, 0.0793],
      toReference: (s) =>
        s.convertSRGBToLinear().applyMatrix3(LINEAR_DISPLAY_P3_TO_LINEAR_SRGB),
      fromReference: (s) =>
        s.applyMatrix3(LINEAR_SRGB_TO_LINEAR_DISPLAY_P3).convertLinearToSRGB(),
    },
  },
  SUPPORTED_WORKING_COLOR_SPACES = new Set([
    LinearSRGBColorSpace$1,
    LinearDisplayP3ColorSpace,
  ]),
  ColorManagement = {
    enabled: !0,
    _workingColorSpace: LinearSRGBColorSpace$1,
    get workingColorSpace() {
      return this._workingColorSpace;
    },
    set workingColorSpace(s) {
      if (!SUPPORTED_WORKING_COLOR_SPACES.has(s))
        throw new Error(`Unsupported working color space, "${s}".`);
      this._workingColorSpace = s;
    },
    convert: function (s, e, o) {
      if (this.enabled === !1 || e === o || !e || !o) return s;
      const a = COLOR_SPACES[e].toReference,
        c = COLOR_SPACES[o].fromReference;
      return c(a(s));
    },
    fromWorkingColorSpace: function (s, e) {
      return this.convert(s, this._workingColorSpace, e);
    },
    toWorkingColorSpace: function (s, e) {
      return this.convert(s, e, this._workingColorSpace);
    },
    getPrimaries: function (s) {
      return COLOR_SPACES[s].primaries;
    },
    getTransfer: function (s) {
      return s === NoColorSpace ? LinearTransfer : COLOR_SPACES[s].transfer;
    },
    getLuminanceCoefficients: function (s, e = this._workingColorSpace) {
      return s.fromArray(COLOR_SPACES[e].luminanceCoefficients);
    },
  };
function SRGBToLinear(s) {
  return s < 0.04045
    ? s * 0.0773993808
    : Math.pow(s * 0.9478672986 + 0.0521327014, 2.4);
}
function LinearToSRGB(s) {
  return s < 0.0031308 ? s * 12.92 : 1.055 * Math.pow(s, 0.41666) - 0.055;
}
let _canvas;
class ImageUtils {
  static getDataURL(e) {
    if (/^data:/i.test(e.src) || typeof HTMLCanvasElement > "u") return e.src;
    let o;
    if (e instanceof HTMLCanvasElement) o = e;
    else {
      _canvas === void 0 && (_canvas = createElementNS("canvas")),
        (_canvas.width = e.width),
        (_canvas.height = e.height);
      const a = _canvas.getContext("2d");
      e instanceof ImageData
        ? a.putImageData(e, 0, 0)
        : a.drawImage(e, 0, 0, e.width, e.height),
        (o = _canvas);
    }
    return o.width > 2048 || o.height > 2048
      ? (console.warn(
          "THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons",
          e
        ),
        o.toDataURL("image/jpeg", 0.6))
      : o.toDataURL("image/png");
  }
  static sRGBToLinear(e) {
    if (
      (typeof HTMLImageElement < "u" && e instanceof HTMLImageElement) ||
      (typeof HTMLCanvasElement < "u" && e instanceof HTMLCanvasElement) ||
      (typeof ImageBitmap < "u" && e instanceof ImageBitmap)
    ) {
      const o = createElementNS("canvas");
      (o.width = e.width), (o.height = e.height);
      const a = o.getContext("2d");
      a.drawImage(e, 0, 0, e.width, e.height);
      const c = a.getImageData(0, 0, e.width, e.height),
        d = c.data;
      for (let g = 0; g < d.length; g++) d[g] = SRGBToLinear(d[g] / 255) * 255;
      return a.putImageData(c, 0, 0), o;
    } else if (e.data) {
      const o = e.data.slice(0);
      for (let a = 0; a < o.length; a++)
        o instanceof Uint8Array || o instanceof Uint8ClampedArray
          ? (o[a] = Math.floor(SRGBToLinear(o[a] / 255) * 255))
          : (o[a] = SRGBToLinear(o[a]));
      return { data: o, width: e.width, height: e.height };
    } else
      return (
        console.warn(
          "THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."
        ),
        e
      );
  }
}
let _sourceId = 0;
class Source {
  constructor(e = null) {
    (this.isSource = !0),
      Object.defineProperty(this, "id", { value: _sourceId++ }),
      (this.uuid = generateUUID()),
      (this.data = e),
      (this.dataReady = !0),
      (this.version = 0);
  }
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  toJSON(e) {
    const o = e === void 0 || typeof e == "string";
    if (!o && e.images[this.uuid] !== void 0) return e.images[this.uuid];
    const a = { uuid: this.uuid, url: "" },
      c = this.data;
    if (c !== null) {
      let d;
      if (Array.isArray(c)) {
        d = [];
        for (let g = 0, _ = c.length; g < _; g++)
          c[g].isDataTexture
            ? d.push(serializeImage(c[g].image))
            : d.push(serializeImage(c[g]));
      } else d = serializeImage(c);
      a.url = d;
    }
    return o || (e.images[this.uuid] = a), a;
  }
}
function serializeImage(s) {
  return (typeof HTMLImageElement < "u" && s instanceof HTMLImageElement) ||
    (typeof HTMLCanvasElement < "u" && s instanceof HTMLCanvasElement) ||
    (typeof ImageBitmap < "u" && s instanceof ImageBitmap)
    ? ImageUtils.getDataURL(s)
    : s.data
    ? {
        data: Array.from(s.data),
        width: s.width,
        height: s.height,
        type: s.data.constructor.name,
      }
    : (console.warn("THREE.Texture: Unable to serialize Texture."), {});
}
let _textureId = 0;
class Texture extends EventDispatcher {
  constructor(
    e = Texture.DEFAULT_IMAGE,
    o = Texture.DEFAULT_MAPPING,
    a = ClampToEdgeWrapping,
    c = ClampToEdgeWrapping,
    d = LinearFilter,
    g = LinearMipmapLinearFilter,
    _ = RGBAFormat,
    b = UnsignedByteType,
    j = Texture.DEFAULT_ANISOTROPY,
    $ = NoColorSpace
  ) {
    super(),
      (this.isTexture = !0),
      Object.defineProperty(this, "id", { value: _textureId++ }),
      (this.uuid = generateUUID()),
      (this.name = ""),
      (this.source = new Source(e)),
      (this.mipmaps = []),
      (this.mapping = o),
      (this.channel = 0),
      (this.wrapS = a),
      (this.wrapT = c),
      (this.magFilter = d),
      (this.minFilter = g),
      (this.anisotropy = j),
      (this.format = _),
      (this.internalFormat = null),
      (this.type = b),
      (this.offset = new Vector2(0, 0)),
      (this.repeat = new Vector2(1, 1)),
      (this.center = new Vector2(0, 0)),
      (this.rotation = 0),
      (this.matrixAutoUpdate = !0),
      (this.matrix = new Matrix3()),
      (this.generateMipmaps = !0),
      (this.premultiplyAlpha = !1),
      (this.flipY = !0),
      (this.unpackAlignment = 4),
      (this.colorSpace = $),
      (this.userData = {}),
      (this.version = 0),
      (this.onUpdate = null),
      (this.isRenderTargetTexture = !1),
      (this.pmremVersion = 0);
  }
  get image() {
    return this.source.data;
  }
  set image(e = null) {
    this.source.data = e;
  }
  updateMatrix() {
    this.matrix.setUvTransform(
      this.offset.x,
      this.offset.y,
      this.repeat.x,
      this.repeat.y,
      this.rotation,
      this.center.x,
      this.center.y
    );
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return (
      (this.name = e.name),
      (this.source = e.source),
      (this.mipmaps = e.mipmaps.slice(0)),
      (this.mapping = e.mapping),
      (this.channel = e.channel),
      (this.wrapS = e.wrapS),
      (this.wrapT = e.wrapT),
      (this.magFilter = e.magFilter),
      (this.minFilter = e.minFilter),
      (this.anisotropy = e.anisotropy),
      (this.format = e.format),
      (this.internalFormat = e.internalFormat),
      (this.type = e.type),
      this.offset.copy(e.offset),
      this.repeat.copy(e.repeat),
      this.center.copy(e.center),
      (this.rotation = e.rotation),
      (this.matrixAutoUpdate = e.matrixAutoUpdate),
      this.matrix.copy(e.matrix),
      (this.generateMipmaps = e.generateMipmaps),
      (this.premultiplyAlpha = e.premultiplyAlpha),
      (this.flipY = e.flipY),
      (this.unpackAlignment = e.unpackAlignment),
      (this.colorSpace = e.colorSpace),
      (this.userData = JSON.parse(JSON.stringify(e.userData))),
      (this.needsUpdate = !0),
      this
    );
  }
  toJSON(e) {
    const o = e === void 0 || typeof e == "string";
    if (!o && e.textures[this.uuid] !== void 0) return e.textures[this.uuid];
    const a = {
      metadata: { version: 4.6, type: "Texture", generator: "Texture.toJSON" },
      uuid: this.uuid,
      name: this.name,
      image: this.source.toJSON(e).uuid,
      mapping: this.mapping,
      channel: this.channel,
      repeat: [this.repeat.x, this.repeat.y],
      offset: [this.offset.x, this.offset.y],
      center: [this.center.x, this.center.y],
      rotation: this.rotation,
      wrap: [this.wrapS, this.wrapT],
      format: this.format,
      internalFormat: this.internalFormat,
      type: this.type,
      colorSpace: this.colorSpace,
      minFilter: this.minFilter,
      magFilter: this.magFilter,
      anisotropy: this.anisotropy,
      flipY: this.flipY,
      generateMipmaps: this.generateMipmaps,
      premultiplyAlpha: this.premultiplyAlpha,
      unpackAlignment: this.unpackAlignment,
    };
    return (
      Object.keys(this.userData).length > 0 && (a.userData = this.userData),
      o || (e.textures[this.uuid] = a),
      a
    );
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  transformUv(e) {
    if (this.mapping !== UVMapping) return e;
    if ((e.applyMatrix3(this.matrix), e.x < 0 || e.x > 1))
      switch (this.wrapS) {
        case RepeatWrapping:
          e.x = e.x - Math.floor(e.x);
          break;
        case ClampToEdgeWrapping:
          e.x = e.x < 0 ? 0 : 1;
          break;
        case MirroredRepeatWrapping:
          Math.abs(Math.floor(e.x) % 2) === 1
            ? (e.x = Math.ceil(e.x) - e.x)
            : (e.x = e.x - Math.floor(e.x));
          break;
      }
    if (e.y < 0 || e.y > 1)
      switch (this.wrapT) {
        case RepeatWrapping:
          e.y = e.y - Math.floor(e.y);
          break;
        case ClampToEdgeWrapping:
          e.y = e.y < 0 ? 0 : 1;
          break;
        case MirroredRepeatWrapping:
          Math.abs(Math.floor(e.y) % 2) === 1
            ? (e.y = Math.ceil(e.y) - e.y)
            : (e.y = e.y - Math.floor(e.y));
          break;
      }
    return this.flipY && (e.y = 1 - e.y), e;
  }
  set needsUpdate(e) {
    e === !0 && (this.version++, (this.source.needsUpdate = !0));
  }
  set needsPMREMUpdate(e) {
    e === !0 && this.pmremVersion++;
  }
}
Texture.DEFAULT_IMAGE = null;
Texture.DEFAULT_MAPPING = UVMapping;
Texture.DEFAULT_ANISOTROPY = 1;
class Vector4 {
  constructor(e = 0, o = 0, a = 0, c = 1) {
    (Vector4.prototype.isVector4 = !0),
      (this.x = e),
      (this.y = o),
      (this.z = a),
      (this.w = c);
  }
  get width() {
    return this.z;
  }
  set width(e) {
    this.z = e;
  }
  get height() {
    return this.w;
  }
  set height(e) {
    this.w = e;
  }
  set(e, o, a, c) {
    return (this.x = e), (this.y = o), (this.z = a), (this.w = c), this;
  }
  setScalar(e) {
    return (this.x = e), (this.y = e), (this.z = e), (this.w = e), this;
  }
  setX(e) {
    return (this.x = e), this;
  }
  setY(e) {
    return (this.y = e), this;
  }
  setZ(e) {
    return (this.z = e), this;
  }
  setW(e) {
    return (this.w = e), this;
  }
  setComponent(e, o) {
    switch (e) {
      case 0:
        this.x = o;
        break;
      case 1:
        this.y = o;
        break;
      case 2:
        this.z = o;
        break;
      case 3:
        this.w = o;
        break;
      default:
        throw new Error("index is out of range: " + e);
    }
    return this;
  }
  getComponent(e) {
    switch (e) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      case 3:
        return this.w;
      default:
        throw new Error("index is out of range: " + e);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y, this.z, this.w);
  }
  copy(e) {
    return (
      (this.x = e.x),
      (this.y = e.y),
      (this.z = e.z),
      (this.w = e.w !== void 0 ? e.w : 1),
      this
    );
  }
  add(e) {
    return (
      (this.x += e.x), (this.y += e.y), (this.z += e.z), (this.w += e.w), this
    );
  }
  addScalar(e) {
    return (this.x += e), (this.y += e), (this.z += e), (this.w += e), this;
  }
  addVectors(e, o) {
    return (
      (this.x = e.x + o.x),
      (this.y = e.y + o.y),
      (this.z = e.z + o.z),
      (this.w = e.w + o.w),
      this
    );
  }
  addScaledVector(e, o) {
    return (
      (this.x += e.x * o),
      (this.y += e.y * o),
      (this.z += e.z * o),
      (this.w += e.w * o),
      this
    );
  }
  sub(e) {
    return (
      (this.x -= e.x), (this.y -= e.y), (this.z -= e.z), (this.w -= e.w), this
    );
  }
  subScalar(e) {
    return (this.x -= e), (this.y -= e), (this.z -= e), (this.w -= e), this;
  }
  subVectors(e, o) {
    return (
      (this.x = e.x - o.x),
      (this.y = e.y - o.y),
      (this.z = e.z - o.z),
      (this.w = e.w - o.w),
      this
    );
  }
  multiply(e) {
    return (
      (this.x *= e.x), (this.y *= e.y), (this.z *= e.z), (this.w *= e.w), this
    );
  }
  multiplyScalar(e) {
    return (this.x *= e), (this.y *= e), (this.z *= e), (this.w *= e), this;
  }
  applyMatrix4(e) {
    const o = this.x,
      a = this.y,
      c = this.z,
      d = this.w,
      g = e.elements;
    return (
      (this.x = g[0] * o + g[4] * a + g[8] * c + g[12] * d),
      (this.y = g[1] * o + g[5] * a + g[9] * c + g[13] * d),
      (this.z = g[2] * o + g[6] * a + g[10] * c + g[14] * d),
      (this.w = g[3] * o + g[7] * a + g[11] * c + g[15] * d),
      this
    );
  }
  divideScalar(e) {
    return this.multiplyScalar(1 / e);
  }
  setAxisAngleFromQuaternion(e) {
    this.w = 2 * Math.acos(e.w);
    const o = Math.sqrt(1 - e.w * e.w);
    return (
      o < 1e-4
        ? ((this.x = 1), (this.y = 0), (this.z = 0))
        : ((this.x = e.x / o), (this.y = e.y / o), (this.z = e.z / o)),
      this
    );
  }
  setAxisAngleFromRotationMatrix(e) {
    let o, a, c, d;
    const b = e.elements,
      j = b[0],
      $ = b[4],
      _e = b[8],
      et = b[1],
      rt = b[5],
      st = b[9],
      at = b[2],
      ct = b[6],
      it = b[10];
    if (
      Math.abs($ - et) < 0.01 &&
      Math.abs(_e - at) < 0.01 &&
      Math.abs(st - ct) < 0.01
    ) {
      if (
        Math.abs($ + et) < 0.1 &&
        Math.abs(_e + at) < 0.1 &&
        Math.abs(st + ct) < 0.1 &&
        Math.abs(j + rt + it - 3) < 0.1
      )
        return this.set(1, 0, 0, 0), this;
      o = Math.PI;
      const ot = (j + 1) / 2,
        ut = (rt + 1) / 2,
        pt = (it + 1) / 2,
        ft = ($ + et) / 4,
        gt = (_e + at) / 4,
        xt = (st + ct) / 4;
      return (
        ot > ut && ot > pt
          ? ot < 0.01
            ? ((a = 0), (c = 0.707106781), (d = 0.707106781))
            : ((a = Math.sqrt(ot)), (c = ft / a), (d = gt / a))
          : ut > pt
          ? ut < 0.01
            ? ((a = 0.707106781), (c = 0), (d = 0.707106781))
            : ((c = Math.sqrt(ut)), (a = ft / c), (d = xt / c))
          : pt < 0.01
          ? ((a = 0.707106781), (c = 0.707106781), (d = 0))
          : ((d = Math.sqrt(pt)), (a = gt / d), (c = xt / d)),
        this.set(a, c, d, o),
        this
      );
    }
    let lt = Math.sqrt(
      (ct - st) * (ct - st) + (_e - at) * (_e - at) + (et - $) * (et - $)
    );
    return (
      Math.abs(lt) < 0.001 && (lt = 1),
      (this.x = (ct - st) / lt),
      (this.y = (_e - at) / lt),
      (this.z = (et - $) / lt),
      (this.w = Math.acos((j + rt + it - 1) / 2)),
      this
    );
  }
  setFromMatrixPosition(e) {
    const o = e.elements;
    return (
      (this.x = o[12]),
      (this.y = o[13]),
      (this.z = o[14]),
      (this.w = o[15]),
      this
    );
  }
  min(e) {
    return (
      (this.x = Math.min(this.x, e.x)),
      (this.y = Math.min(this.y, e.y)),
      (this.z = Math.min(this.z, e.z)),
      (this.w = Math.min(this.w, e.w)),
      this
    );
  }
  max(e) {
    return (
      (this.x = Math.max(this.x, e.x)),
      (this.y = Math.max(this.y, e.y)),
      (this.z = Math.max(this.z, e.z)),
      (this.w = Math.max(this.w, e.w)),
      this
    );
  }
  clamp(e, o) {
    return (
      (this.x = Math.max(e.x, Math.min(o.x, this.x))),
      (this.y = Math.max(e.y, Math.min(o.y, this.y))),
      (this.z = Math.max(e.z, Math.min(o.z, this.z))),
      (this.w = Math.max(e.w, Math.min(o.w, this.w))),
      this
    );
  }
  clampScalar(e, o) {
    return (
      (this.x = Math.max(e, Math.min(o, this.x))),
      (this.y = Math.max(e, Math.min(o, this.y))),
      (this.z = Math.max(e, Math.min(o, this.z))),
      (this.w = Math.max(e, Math.min(o, this.w))),
      this
    );
  }
  clampLength(e, o) {
    const a = this.length();
    return this.divideScalar(a || 1).multiplyScalar(
      Math.max(e, Math.min(o, a))
    );
  }
  floor() {
    return (
      (this.x = Math.floor(this.x)),
      (this.y = Math.floor(this.y)),
      (this.z = Math.floor(this.z)),
      (this.w = Math.floor(this.w)),
      this
    );
  }
  ceil() {
    return (
      (this.x = Math.ceil(this.x)),
      (this.y = Math.ceil(this.y)),
      (this.z = Math.ceil(this.z)),
      (this.w = Math.ceil(this.w)),
      this
    );
  }
  round() {
    return (
      (this.x = Math.round(this.x)),
      (this.y = Math.round(this.y)),
      (this.z = Math.round(this.z)),
      (this.w = Math.round(this.w)),
      this
    );
  }
  roundToZero() {
    return (
      (this.x = Math.trunc(this.x)),
      (this.y = Math.trunc(this.y)),
      (this.z = Math.trunc(this.z)),
      (this.w = Math.trunc(this.w)),
      this
    );
  }
  negate() {
    return (
      (this.x = -this.x),
      (this.y = -this.y),
      (this.z = -this.z),
      (this.w = -this.w),
      this
    );
  }
  dot(e) {
    return this.x * e.x + this.y * e.y + this.z * e.z + this.w * e.w;
  }
  lengthSq() {
    return (
      this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
    );
  }
  length() {
    return Math.sqrt(
      this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
    );
  }
  manhattanLength() {
    return (
      Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w)
    );
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  setLength(e) {
    return this.normalize().multiplyScalar(e);
  }
  lerp(e, o) {
    return (
      (this.x += (e.x - this.x) * o),
      (this.y += (e.y - this.y) * o),
      (this.z += (e.z - this.z) * o),
      (this.w += (e.w - this.w) * o),
      this
    );
  }
  lerpVectors(e, o, a) {
    return (
      (this.x = e.x + (o.x - e.x) * a),
      (this.y = e.y + (o.y - e.y) * a),
      (this.z = e.z + (o.z - e.z) * a),
      (this.w = e.w + (o.w - e.w) * a),
      this
    );
  }
  equals(e) {
    return e.x === this.x && e.y === this.y && e.z === this.z && e.w === this.w;
  }
  fromArray(e, o = 0) {
    return (
      (this.x = e[o]),
      (this.y = e[o + 1]),
      (this.z = e[o + 2]),
      (this.w = e[o + 3]),
      this
    );
  }
  toArray(e = [], o = 0) {
    return (
      (e[o] = this.x),
      (e[o + 1] = this.y),
      (e[o + 2] = this.z),
      (e[o + 3] = this.w),
      e
    );
  }
  fromBufferAttribute(e, o) {
    return (
      (this.x = e.getX(o)),
      (this.y = e.getY(o)),
      (this.z = e.getZ(o)),
      (this.w = e.getW(o)),
      this
    );
  }
  random() {
    return (
      (this.x = Math.random()),
      (this.y = Math.random()),
      (this.z = Math.random()),
      (this.w = Math.random()),
      this
    );
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y, yield this.z, yield this.w;
  }
}
class RenderTarget extends EventDispatcher {
  constructor(e = 1, o = 1, a = {}) {
    super(),
      (this.isRenderTarget = !0),
      (this.width = e),
      (this.height = o),
      (this.depth = 1),
      (this.scissor = new Vector4(0, 0, e, o)),
      (this.scissorTest = !1),
      (this.viewport = new Vector4(0, 0, e, o));
    const c = { width: e, height: o, depth: 1 };
    a = Object.assign(
      {
        generateMipmaps: !1,
        internalFormat: null,
        minFilter: LinearFilter,
        depthBuffer: !0,
        stencilBuffer: !1,
        resolveDepthBuffer: !0,
        resolveStencilBuffer: !0,
        depthTexture: null,
        samples: 0,
        count: 1,
      },
      a
    );
    const d = new Texture(
      c,
      a.mapping,
      a.wrapS,
      a.wrapT,
      a.magFilter,
      a.minFilter,
      a.format,
      a.type,
      a.anisotropy,
      a.colorSpace
    );
    (d.flipY = !1),
      (d.generateMipmaps = a.generateMipmaps),
      (d.internalFormat = a.internalFormat),
      (this.textures = []);
    const g = a.count;
    for (let _ = 0; _ < g; _++)
      (this.textures[_] = d.clone()),
        (this.textures[_].isRenderTargetTexture = !0);
    (this.depthBuffer = a.depthBuffer),
      (this.stencilBuffer = a.stencilBuffer),
      (this.resolveDepthBuffer = a.resolveDepthBuffer),
      (this.resolveStencilBuffer = a.resolveStencilBuffer),
      (this.depthTexture = a.depthTexture),
      (this.samples = a.samples);
  }
  get texture() {
    return this.textures[0];
  }
  set texture(e) {
    this.textures[0] = e;
  }
  setSize(e, o, a = 1) {
    if (this.width !== e || this.height !== o || this.depth !== a) {
      (this.width = e), (this.height = o), (this.depth = a);
      for (let c = 0, d = this.textures.length; c < d; c++)
        (this.textures[c].image.width = e),
          (this.textures[c].image.height = o),
          (this.textures[c].image.depth = a);
      this.dispose();
    }
    this.viewport.set(0, 0, e, o), this.scissor.set(0, 0, e, o);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    (this.width = e.width),
      (this.height = e.height),
      (this.depth = e.depth),
      this.scissor.copy(e.scissor),
      (this.scissorTest = e.scissorTest),
      this.viewport.copy(e.viewport),
      (this.textures.length = 0);
    for (let a = 0, c = e.textures.length; a < c; a++)
      (this.textures[a] = e.textures[a].clone()),
        (this.textures[a].isRenderTargetTexture = !0);
    const o = Object.assign({}, e.texture.image);
    return (
      (this.texture.source = new Source(o)),
      (this.depthBuffer = e.depthBuffer),
      (this.stencilBuffer = e.stencilBuffer),
      (this.resolveDepthBuffer = e.resolveDepthBuffer),
      (this.resolveStencilBuffer = e.resolveStencilBuffer),
      e.depthTexture !== null && (this.depthTexture = e.depthTexture.clone()),
      (this.samples = e.samples),
      this
    );
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
}
class WebGLRenderTarget extends RenderTarget {
  constructor(e = 1, o = 1, a = {}) {
    super(e, o, a), (this.isWebGLRenderTarget = !0);
  }
}
class DataArrayTexture extends Texture {
  constructor(e = null, o = 1, a = 1, c = 1) {
    super(null),
      (this.isDataArrayTexture = !0),
      (this.image = { data: e, width: o, height: a, depth: c }),
      (this.magFilter = NearestFilter),
      (this.minFilter = NearestFilter),
      (this.wrapR = ClampToEdgeWrapping),
      (this.generateMipmaps = !1),
      (this.flipY = !1),
      (this.unpackAlignment = 1),
      (this.layerUpdates = new Set());
  }
  addLayerUpdate(e) {
    this.layerUpdates.add(e);
  }
  clearLayerUpdates() {
    this.layerUpdates.clear();
  }
}
class WebGLArrayRenderTarget extends WebGLRenderTarget {
  constructor(e = 1, o = 1, a = 1, c = {}) {
    super(e, o, c),
      (this.isWebGLArrayRenderTarget = !0),
      (this.depth = a),
      (this.texture = new DataArrayTexture(null, e, o, a)),
      (this.texture.isRenderTargetTexture = !0);
  }
}
class Data3DTexture extends Texture {
  constructor(e = null, o = 1, a = 1, c = 1) {
    super(null),
      (this.isData3DTexture = !0),
      (this.image = { data: e, width: o, height: a, depth: c }),
      (this.magFilter = NearestFilter),
      (this.minFilter = NearestFilter),
      (this.wrapR = ClampToEdgeWrapping),
      (this.generateMipmaps = !1),
      (this.flipY = !1),
      (this.unpackAlignment = 1);
  }
}
class WebGL3DRenderTarget extends WebGLRenderTarget {
  constructor(e = 1, o = 1, a = 1, c = {}) {
    super(e, o, c),
      (this.isWebGL3DRenderTarget = !0),
      (this.depth = a),
      (this.texture = new Data3DTexture(null, e, o, a)),
      (this.texture.isRenderTargetTexture = !0);
  }
}
class Quaternion {
  constructor(e = 0, o = 0, a = 0, c = 1) {
    (this.isQuaternion = !0),
      (this._x = e),
      (this._y = o),
      (this._z = a),
      (this._w = c);
  }
  static slerpFlat(e, o, a, c, d, g, _) {
    let b = a[c + 0],
      j = a[c + 1],
      $ = a[c + 2],
      _e = a[c + 3];
    const et = d[g + 0],
      rt = d[g + 1],
      st = d[g + 2],
      at = d[g + 3];
    if (_ === 0) {
      (e[o + 0] = b), (e[o + 1] = j), (e[o + 2] = $), (e[o + 3] = _e);
      return;
    }
    if (_ === 1) {
      (e[o + 0] = et), (e[o + 1] = rt), (e[o + 2] = st), (e[o + 3] = at);
      return;
    }
    if (_e !== at || b !== et || j !== rt || $ !== st) {
      let ct = 1 - _;
      const it = b * et + j * rt + $ * st + _e * at,
        lt = it >= 0 ? 1 : -1,
        ot = 1 - it * it;
      if (ot > Number.EPSILON) {
        const pt = Math.sqrt(ot),
          ft = Math.atan2(pt, it * lt);
        (ct = Math.sin(ct * ft) / pt), (_ = Math.sin(_ * ft) / pt);
      }
      const ut = _ * lt;
      if (
        ((b = b * ct + et * ut),
        (j = j * ct + rt * ut),
        ($ = $ * ct + st * ut),
        (_e = _e * ct + at * ut),
        ct === 1 - _)
      ) {
        const pt = 1 / Math.sqrt(b * b + j * j + $ * $ + _e * _e);
        (b *= pt), (j *= pt), ($ *= pt), (_e *= pt);
      }
    }
    (e[o] = b), (e[o + 1] = j), (e[o + 2] = $), (e[o + 3] = _e);
  }
  static multiplyQuaternionsFlat(e, o, a, c, d, g) {
    const _ = a[c],
      b = a[c + 1],
      j = a[c + 2],
      $ = a[c + 3],
      _e = d[g],
      et = d[g + 1],
      rt = d[g + 2],
      st = d[g + 3];
    return (
      (e[o] = _ * st + $ * _e + b * rt - j * et),
      (e[o + 1] = b * st + $ * et + j * _e - _ * rt),
      (e[o + 2] = j * st + $ * rt + _ * et - b * _e),
      (e[o + 3] = $ * st - _ * _e - b * et - j * rt),
      e
    );
  }
  get x() {
    return this._x;
  }
  set x(e) {
    (this._x = e), this._onChangeCallback();
  }
  get y() {
    return this._y;
  }
  set y(e) {
    (this._y = e), this._onChangeCallback();
  }
  get z() {
    return this._z;
  }
  set z(e) {
    (this._z = e), this._onChangeCallback();
  }
  get w() {
    return this._w;
  }
  set w(e) {
    (this._w = e), this._onChangeCallback();
  }
  set(e, o, a, c) {
    return (
      (this._x = e),
      (this._y = o),
      (this._z = a),
      (this._w = c),
      this._onChangeCallback(),
      this
    );
  }
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._w);
  }
  copy(e) {
    return (
      (this._x = e.x),
      (this._y = e.y),
      (this._z = e.z),
      (this._w = e.w),
      this._onChangeCallback(),
      this
    );
  }
  setFromEuler(e, o = !0) {
    const a = e._x,
      c = e._y,
      d = e._z,
      g = e._order,
      _ = Math.cos,
      b = Math.sin,
      j = _(a / 2),
      $ = _(c / 2),
      _e = _(d / 2),
      et = b(a / 2),
      rt = b(c / 2),
      st = b(d / 2);
    switch (g) {
      case "XYZ":
        (this._x = et * $ * _e + j * rt * st),
          (this._y = j * rt * _e - et * $ * st),
          (this._z = j * $ * st + et * rt * _e),
          (this._w = j * $ * _e - et * rt * st);
        break;
      case "YXZ":
        (this._x = et * $ * _e + j * rt * st),
          (this._y = j * rt * _e - et * $ * st),
          (this._z = j * $ * st - et * rt * _e),
          (this._w = j * $ * _e + et * rt * st);
        break;
      case "ZXY":
        (this._x = et * $ * _e - j * rt * st),
          (this._y = j * rt * _e + et * $ * st),
          (this._z = j * $ * st + et * rt * _e),
          (this._w = j * $ * _e - et * rt * st);
        break;
      case "ZYX":
        (this._x = et * $ * _e - j * rt * st),
          (this._y = j * rt * _e + et * $ * st),
          (this._z = j * $ * st - et * rt * _e),
          (this._w = j * $ * _e + et * rt * st);
        break;
      case "YZX":
        (this._x = et * $ * _e + j * rt * st),
          (this._y = j * rt * _e + et * $ * st),
          (this._z = j * $ * st - et * rt * _e),
          (this._w = j * $ * _e - et * rt * st);
        break;
      case "XZY":
        (this._x = et * $ * _e - j * rt * st),
          (this._y = j * rt * _e - et * $ * st),
          (this._z = j * $ * st + et * rt * _e),
          (this._w = j * $ * _e + et * rt * st);
        break;
      default:
        console.warn(
          "THREE.Quaternion: .setFromEuler() encountered an unknown order: " + g
        );
    }
    return o === !0 && this._onChangeCallback(), this;
  }
  setFromAxisAngle(e, o) {
    const a = o / 2,
      c = Math.sin(a);
    return (
      (this._x = e.x * c),
      (this._y = e.y * c),
      (this._z = e.z * c),
      (this._w = Math.cos(a)),
      this._onChangeCallback(),
      this
    );
  }
  setFromRotationMatrix(e) {
    const o = e.elements,
      a = o[0],
      c = o[4],
      d = o[8],
      g = o[1],
      _ = o[5],
      b = o[9],
      j = o[2],
      $ = o[6],
      _e = o[10],
      et = a + _ + _e;
    if (et > 0) {
      const rt = 0.5 / Math.sqrt(et + 1);
      (this._w = 0.25 / rt),
        (this._x = ($ - b) * rt),
        (this._y = (d - j) * rt),
        (this._z = (g - c) * rt);
    } else if (a > _ && a > _e) {
      const rt = 2 * Math.sqrt(1 + a - _ - _e);
      (this._w = ($ - b) / rt),
        (this._x = 0.25 * rt),
        (this._y = (c + g) / rt),
        (this._z = (d + j) / rt);
    } else if (_ > _e) {
      const rt = 2 * Math.sqrt(1 + _ - a - _e);
      (this._w = (d - j) / rt),
        (this._x = (c + g) / rt),
        (this._y = 0.25 * rt),
        (this._z = (b + $) / rt);
    } else {
      const rt = 2 * Math.sqrt(1 + _e - a - _);
      (this._w = (g - c) / rt),
        (this._x = (d + j) / rt),
        (this._y = (b + $) / rt),
        (this._z = 0.25 * rt);
    }
    return this._onChangeCallback(), this;
  }
  setFromUnitVectors(e, o) {
    let a = e.dot(o) + 1;
    return (
      a < Number.EPSILON
        ? ((a = 0),
          Math.abs(e.x) > Math.abs(e.z)
            ? ((this._x = -e.y), (this._y = e.x), (this._z = 0), (this._w = a))
            : ((this._x = 0), (this._y = -e.z), (this._z = e.y), (this._w = a)))
        : ((this._x = e.y * o.z - e.z * o.y),
          (this._y = e.z * o.x - e.x * o.z),
          (this._z = e.x * o.y - e.y * o.x),
          (this._w = a)),
      this.normalize()
    );
  }
  angleTo(e) {
    return 2 * Math.acos(Math.abs(clamp(this.dot(e), -1, 1)));
  }
  rotateTowards(e, o) {
    const a = this.angleTo(e);
    if (a === 0) return this;
    const c = Math.min(1, o / a);
    return this.slerp(e, c), this;
  }
  identity() {
    return this.set(0, 0, 0, 1);
  }
  invert() {
    return this.conjugate();
  }
  conjugate() {
    return (
      (this._x *= -1),
      (this._y *= -1),
      (this._z *= -1),
      this._onChangeCallback(),
      this
    );
  }
  dot(e) {
    return this._x * e._x + this._y * e._y + this._z * e._z + this._w * e._w;
  }
  lengthSq() {
    return (
      this._x * this._x +
      this._y * this._y +
      this._z * this._z +
      this._w * this._w
    );
  }
  length() {
    return Math.sqrt(
      this._x * this._x +
        this._y * this._y +
        this._z * this._z +
        this._w * this._w
    );
  }
  normalize() {
    let e = this.length();
    return (
      e === 0
        ? ((this._x = 0), (this._y = 0), (this._z = 0), (this._w = 1))
        : ((e = 1 / e),
          (this._x = this._x * e),
          (this._y = this._y * e),
          (this._z = this._z * e),
          (this._w = this._w * e)),
      this._onChangeCallback(),
      this
    );
  }
  multiply(e) {
    return this.multiplyQuaternions(this, e);
  }
  premultiply(e) {
    return this.multiplyQuaternions(e, this);
  }
  multiplyQuaternions(e, o) {
    const a = e._x,
      c = e._y,
      d = e._z,
      g = e._w,
      _ = o._x,
      b = o._y,
      j = o._z,
      $ = o._w;
    return (
      (this._x = a * $ + g * _ + c * j - d * b),
      (this._y = c * $ + g * b + d * _ - a * j),
      (this._z = d * $ + g * j + a * b - c * _),
      (this._w = g * $ - a * _ - c * b - d * j),
      this._onChangeCallback(),
      this
    );
  }
  slerp(e, o) {
    if (o === 0) return this;
    if (o === 1) return this.copy(e);
    const a = this._x,
      c = this._y,
      d = this._z,
      g = this._w;
    let _ = g * e._w + a * e._x + c * e._y + d * e._z;
    if (
      (_ < 0
        ? ((this._w = -e._w),
          (this._x = -e._x),
          (this._y = -e._y),
          (this._z = -e._z),
          (_ = -_))
        : this.copy(e),
      _ >= 1)
    )
      return (this._w = g), (this._x = a), (this._y = c), (this._z = d), this;
    const b = 1 - _ * _;
    if (b <= Number.EPSILON) {
      const rt = 1 - o;
      return (
        (this._w = rt * g + o * this._w),
        (this._x = rt * a + o * this._x),
        (this._y = rt * c + o * this._y),
        (this._z = rt * d + o * this._z),
        this.normalize(),
        this
      );
    }
    const j = Math.sqrt(b),
      $ = Math.atan2(j, _),
      _e = Math.sin((1 - o) * $) / j,
      et = Math.sin(o * $) / j;
    return (
      (this._w = g * _e + this._w * et),
      (this._x = a * _e + this._x * et),
      (this._y = c * _e + this._y * et),
      (this._z = d * _e + this._z * et),
      this._onChangeCallback(),
      this
    );
  }
  slerpQuaternions(e, o, a) {
    return this.copy(e).slerp(o, a);
  }
  random() {
    const e = 2 * Math.PI * Math.random(),
      o = 2 * Math.PI * Math.random(),
      a = Math.random(),
      c = Math.sqrt(1 - a),
      d = Math.sqrt(a);
    return this.set(
      c * Math.sin(e),
      c * Math.cos(e),
      d * Math.sin(o),
      d * Math.cos(o)
    );
  }
  equals(e) {
    return (
      e._x === this._x &&
      e._y === this._y &&
      e._z === this._z &&
      e._w === this._w
    );
  }
  fromArray(e, o = 0) {
    return (
      (this._x = e[o]),
      (this._y = e[o + 1]),
      (this._z = e[o + 2]),
      (this._w = e[o + 3]),
      this._onChangeCallback(),
      this
    );
  }
  toArray(e = [], o = 0) {
    return (
      (e[o] = this._x),
      (e[o + 1] = this._y),
      (e[o + 2] = this._z),
      (e[o + 3] = this._w),
      e
    );
  }
  fromBufferAttribute(e, o) {
    return (
      (this._x = e.getX(o)),
      (this._y = e.getY(o)),
      (this._z = e.getZ(o)),
      (this._w = e.getW(o)),
      this._onChangeCallback(),
      this
    );
  }
  toJSON() {
    return this.toArray();
  }
  _onChange(e) {
    return (this._onChangeCallback = e), this;
  }
  _onChangeCallback() {}
  *[Symbol.iterator]() {
    yield this._x, yield this._y, yield this._z, yield this._w;
  }
}
class Vector3 {
  constructor(e = 0, o = 0, a = 0) {
    (Vector3.prototype.isVector3 = !0),
      (this.x = e),
      (this.y = o),
      (this.z = a);
  }
  set(e, o, a) {
    return (
      a === void 0 && (a = this.z),
      (this.x = e),
      (this.y = o),
      (this.z = a),
      this
    );
  }
  setScalar(e) {
    return (this.x = e), (this.y = e), (this.z = e), this;
  }
  setX(e) {
    return (this.x = e), this;
  }
  setY(e) {
    return (this.y = e), this;
  }
  setZ(e) {
    return (this.z = e), this;
  }
  setComponent(e, o) {
    switch (e) {
      case 0:
        this.x = o;
        break;
      case 1:
        this.y = o;
        break;
      case 2:
        this.z = o;
        break;
      default:
        throw new Error("index is out of range: " + e);
    }
    return this;
  }
  getComponent(e) {
    switch (e) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      default:
        throw new Error("index is out of range: " + e);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y, this.z);
  }
  copy(e) {
    return (this.x = e.x), (this.y = e.y), (this.z = e.z), this;
  }
  add(e) {
    return (this.x += e.x), (this.y += e.y), (this.z += e.z), this;
  }
  addScalar(e) {
    return (this.x += e), (this.y += e), (this.z += e), this;
  }
  addVectors(e, o) {
    return (
      (this.x = e.x + o.x), (this.y = e.y + o.y), (this.z = e.z + o.z), this
    );
  }
  addScaledVector(e, o) {
    return (this.x += e.x * o), (this.y += e.y * o), (this.z += e.z * o), this;
  }
  sub(e) {
    return (this.x -= e.x), (this.y -= e.y), (this.z -= e.z), this;
  }
  subScalar(e) {
    return (this.x -= e), (this.y -= e), (this.z -= e), this;
  }
  subVectors(e, o) {
    return (
      (this.x = e.x - o.x), (this.y = e.y - o.y), (this.z = e.z - o.z), this
    );
  }
  multiply(e) {
    return (this.x *= e.x), (this.y *= e.y), (this.z *= e.z), this;
  }
  multiplyScalar(e) {
    return (this.x *= e), (this.y *= e), (this.z *= e), this;
  }
  multiplyVectors(e, o) {
    return (
      (this.x = e.x * o.x), (this.y = e.y * o.y), (this.z = e.z * o.z), this
    );
  }
  applyEuler(e) {
    return this.applyQuaternion(_quaternion$4.setFromEuler(e));
  }
  applyAxisAngle(e, o) {
    return this.applyQuaternion(_quaternion$4.setFromAxisAngle(e, o));
  }
  applyMatrix3(e) {
    const o = this.x,
      a = this.y,
      c = this.z,
      d = e.elements;
    return (
      (this.x = d[0] * o + d[3] * a + d[6] * c),
      (this.y = d[1] * o + d[4] * a + d[7] * c),
      (this.z = d[2] * o + d[5] * a + d[8] * c),
      this
    );
  }
  applyNormalMatrix(e) {
    return this.applyMatrix3(e).normalize();
  }
  applyMatrix4(e) {
    const o = this.x,
      a = this.y,
      c = this.z,
      d = e.elements,
      g = 1 / (d[3] * o + d[7] * a + d[11] * c + d[15]);
    return (
      (this.x = (d[0] * o + d[4] * a + d[8] * c + d[12]) * g),
      (this.y = (d[1] * o + d[5] * a + d[9] * c + d[13]) * g),
      (this.z = (d[2] * o + d[6] * a + d[10] * c + d[14]) * g),
      this
    );
  }
  applyQuaternion(e) {
    const o = this.x,
      a = this.y,
      c = this.z,
      d = e.x,
      g = e.y,
      _ = e.z,
      b = e.w,
      j = 2 * (g * c - _ * a),
      $ = 2 * (_ * o - d * c),
      _e = 2 * (d * a - g * o);
    return (
      (this.x = o + b * j + g * _e - _ * $),
      (this.y = a + b * $ + _ * j - d * _e),
      (this.z = c + b * _e + d * $ - g * j),
      this
    );
  }
  project(e) {
    return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(
      e.projectionMatrix
    );
  }
  unproject(e) {
    return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(
      e.matrixWorld
    );
  }
  transformDirection(e) {
    const o = this.x,
      a = this.y,
      c = this.z,
      d = e.elements;
    return (
      (this.x = d[0] * o + d[4] * a + d[8] * c),
      (this.y = d[1] * o + d[5] * a + d[9] * c),
      (this.z = d[2] * o + d[6] * a + d[10] * c),
      this.normalize()
    );
  }
  divide(e) {
    return (this.x /= e.x), (this.y /= e.y), (this.z /= e.z), this;
  }
  divideScalar(e) {
    return this.multiplyScalar(1 / e);
  }
  min(e) {
    return (
      (this.x = Math.min(this.x, e.x)),
      (this.y = Math.min(this.y, e.y)),
      (this.z = Math.min(this.z, e.z)),
      this
    );
  }
  max(e) {
    return (
      (this.x = Math.max(this.x, e.x)),
      (this.y = Math.max(this.y, e.y)),
      (this.z = Math.max(this.z, e.z)),
      this
    );
  }
  clamp(e, o) {
    return (
      (this.x = Math.max(e.x, Math.min(o.x, this.x))),
      (this.y = Math.max(e.y, Math.min(o.y, this.y))),
      (this.z = Math.max(e.z, Math.min(o.z, this.z))),
      this
    );
  }
  clampScalar(e, o) {
    return (
      (this.x = Math.max(e, Math.min(o, this.x))),
      (this.y = Math.max(e, Math.min(o, this.y))),
      (this.z = Math.max(e, Math.min(o, this.z))),
      this
    );
  }
  clampLength(e, o) {
    const a = this.length();
    return this.divideScalar(a || 1).multiplyScalar(
      Math.max(e, Math.min(o, a))
    );
  }
  floor() {
    return (
      (this.x = Math.floor(this.x)),
      (this.y = Math.floor(this.y)),
      (this.z = Math.floor(this.z)),
      this
    );
  }
  ceil() {
    return (
      (this.x = Math.ceil(this.x)),
      (this.y = Math.ceil(this.y)),
      (this.z = Math.ceil(this.z)),
      this
    );
  }
  round() {
    return (
      (this.x = Math.round(this.x)),
      (this.y = Math.round(this.y)),
      (this.z = Math.round(this.z)),
      this
    );
  }
  roundToZero() {
    return (
      (this.x = Math.trunc(this.x)),
      (this.y = Math.trunc(this.y)),
      (this.z = Math.trunc(this.z)),
      this
    );
  }
  negate() {
    return (this.x = -this.x), (this.y = -this.y), (this.z = -this.z), this;
  }
  dot(e) {
    return this.x * e.x + this.y * e.y + this.z * e.z;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y + this.z * this.z;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  setLength(e) {
    return this.normalize().multiplyScalar(e);
  }
  lerp(e, o) {
    return (
      (this.x += (e.x - this.x) * o),
      (this.y += (e.y - this.y) * o),
      (this.z += (e.z - this.z) * o),
      this
    );
  }
  lerpVectors(e, o, a) {
    return (
      (this.x = e.x + (o.x - e.x) * a),
      (this.y = e.y + (o.y - e.y) * a),
      (this.z = e.z + (o.z - e.z) * a),
      this
    );
  }
  cross(e) {
    return this.crossVectors(this, e);
  }
  crossVectors(e, o) {
    const a = e.x,
      c = e.y,
      d = e.z,
      g = o.x,
      _ = o.y,
      b = o.z;
    return (
      (this.x = c * b - d * _),
      (this.y = d * g - a * b),
      (this.z = a * _ - c * g),
      this
    );
  }
  projectOnVector(e) {
    const o = e.lengthSq();
    if (o === 0) return this.set(0, 0, 0);
    const a = e.dot(this) / o;
    return this.copy(e).multiplyScalar(a);
  }
  projectOnPlane(e) {
    return _vector$c.copy(this).projectOnVector(e), this.sub(_vector$c);
  }
  reflect(e) {
    return this.sub(_vector$c.copy(e).multiplyScalar(2 * this.dot(e)));
  }
  angleTo(e) {
    const o = Math.sqrt(this.lengthSq() * e.lengthSq());
    if (o === 0) return Math.PI / 2;
    const a = this.dot(e) / o;
    return Math.acos(clamp(a, -1, 1));
  }
  distanceTo(e) {
    return Math.sqrt(this.distanceToSquared(e));
  }
  distanceToSquared(e) {
    const o = this.x - e.x,
      a = this.y - e.y,
      c = this.z - e.z;
    return o * o + a * a + c * c;
  }
  manhattanDistanceTo(e) {
    return (
      Math.abs(this.x - e.x) + Math.abs(this.y - e.y) + Math.abs(this.z - e.z)
    );
  }
  setFromSpherical(e) {
    return this.setFromSphericalCoords(e.radius, e.phi, e.theta);
  }
  setFromSphericalCoords(e, o, a) {
    const c = Math.sin(o) * e;
    return (
      (this.x = c * Math.sin(a)),
      (this.y = Math.cos(o) * e),
      (this.z = c * Math.cos(a)),
      this
    );
  }
  setFromCylindrical(e) {
    return this.setFromCylindricalCoords(e.radius, e.theta, e.y);
  }
  setFromCylindricalCoords(e, o, a) {
    return (
      (this.x = e * Math.sin(o)), (this.y = a), (this.z = e * Math.cos(o)), this
    );
  }
  setFromMatrixPosition(e) {
    const o = e.elements;
    return (this.x = o[12]), (this.y = o[13]), (this.z = o[14]), this;
  }
  setFromMatrixScale(e) {
    const o = this.setFromMatrixColumn(e, 0).length(),
      a = this.setFromMatrixColumn(e, 1).length(),
      c = this.setFromMatrixColumn(e, 2).length();
    return (this.x = o), (this.y = a), (this.z = c), this;
  }
  setFromMatrixColumn(e, o) {
    return this.fromArray(e.elements, o * 4);
  }
  setFromMatrix3Column(e, o) {
    return this.fromArray(e.elements, o * 3);
  }
  setFromEuler(e) {
    return (this.x = e._x), (this.y = e._y), (this.z = e._z), this;
  }
  setFromColor(e) {
    return (this.x = e.r), (this.y = e.g), (this.z = e.b), this;
  }
  equals(e) {
    return e.x === this.x && e.y === this.y && e.z === this.z;
  }
  fromArray(e, o = 0) {
    return (this.x = e[o]), (this.y = e[o + 1]), (this.z = e[o + 2]), this;
  }
  toArray(e = [], o = 0) {
    return (e[o] = this.x), (e[o + 1] = this.y), (e[o + 2] = this.z), e;
  }
  fromBufferAttribute(e, o) {
    return (
      (this.x = e.getX(o)), (this.y = e.getY(o)), (this.z = e.getZ(o)), this
    );
  }
  random() {
    return (
      (this.x = Math.random()),
      (this.y = Math.random()),
      (this.z = Math.random()),
      this
    );
  }
  randomDirection() {
    const e = Math.random() * Math.PI * 2,
      o = Math.random() * 2 - 1,
      a = Math.sqrt(1 - o * o);
    return (
      (this.x = a * Math.cos(e)), (this.y = o), (this.z = a * Math.sin(e)), this
    );
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y, yield this.z;
  }
}
const _vector$c = new Vector3(),
  _quaternion$4 = new Quaternion();
class Box3 {
  constructor(
    e = new Vector3(1 / 0, 1 / 0, 1 / 0),
    o = new Vector3(-1 / 0, -1 / 0, -1 / 0)
  ) {
    (this.isBox3 = !0), (this.min = e), (this.max = o);
  }
  set(e, o) {
    return this.min.copy(e), this.max.copy(o), this;
  }
  setFromArray(e) {
    this.makeEmpty();
    for (let o = 0, a = e.length; o < a; o += 3)
      this.expandByPoint(_vector$b.fromArray(e, o));
    return this;
  }
  setFromBufferAttribute(e) {
    this.makeEmpty();
    for (let o = 0, a = e.count; o < a; o++)
      this.expandByPoint(_vector$b.fromBufferAttribute(e, o));
    return this;
  }
  setFromPoints(e) {
    this.makeEmpty();
    for (let o = 0, a = e.length; o < a; o++) this.expandByPoint(e[o]);
    return this;
  }
  setFromCenterAndSize(e, o) {
    const a = _vector$b.copy(o).multiplyScalar(0.5);
    return this.min.copy(e).sub(a), this.max.copy(e).add(a), this;
  }
  setFromObject(e, o = !1) {
    return this.makeEmpty(), this.expandByObject(e, o);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.min.copy(e.min), this.max.copy(e.max), this;
  }
  makeEmpty() {
    return (
      (this.min.x = this.min.y = this.min.z = 1 / 0),
      (this.max.x = this.max.y = this.max.z = -1 / 0),
      this
    );
  }
  isEmpty() {
    return (
      this.max.x < this.min.x ||
      this.max.y < this.min.y ||
      this.max.z < this.min.z
    );
  }
  getCenter(e) {
    return this.isEmpty()
      ? e.set(0, 0, 0)
      : e.addVectors(this.min, this.max).multiplyScalar(0.5);
  }
  getSize(e) {
    return this.isEmpty() ? e.set(0, 0, 0) : e.subVectors(this.max, this.min);
  }
  expandByPoint(e) {
    return this.min.min(e), this.max.max(e), this;
  }
  expandByVector(e) {
    return this.min.sub(e), this.max.add(e), this;
  }
  expandByScalar(e) {
    return this.min.addScalar(-e), this.max.addScalar(e), this;
  }
  expandByObject(e, o = !1) {
    e.updateWorldMatrix(!1, !1);
    const a = e.geometry;
    if (a !== void 0) {
      const d = a.getAttribute("position");
      if (o === !0 && d !== void 0 && e.isInstancedMesh !== !0)
        for (let g = 0, _ = d.count; g < _; g++)
          e.isMesh === !0
            ? e.getVertexPosition(g, _vector$b)
            : _vector$b.fromBufferAttribute(d, g),
            _vector$b.applyMatrix4(e.matrixWorld),
            this.expandByPoint(_vector$b);
      else
        e.boundingBox !== void 0
          ? (e.boundingBox === null && e.computeBoundingBox(),
            _box$4.copy(e.boundingBox))
          : (a.boundingBox === null && a.computeBoundingBox(),
            _box$4.copy(a.boundingBox)),
          _box$4.applyMatrix4(e.matrixWorld),
          this.union(_box$4);
    }
    const c = e.children;
    for (let d = 0, g = c.length; d < g; d++) this.expandByObject(c[d], o);
    return this;
  }
  containsPoint(e) {
    return (
      e.x >= this.min.x &&
      e.x <= this.max.x &&
      e.y >= this.min.y &&
      e.y <= this.max.y &&
      e.z >= this.min.z &&
      e.z <= this.max.z
    );
  }
  containsBox(e) {
    return (
      this.min.x <= e.min.x &&
      e.max.x <= this.max.x &&
      this.min.y <= e.min.y &&
      e.max.y <= this.max.y &&
      this.min.z <= e.min.z &&
      e.max.z <= this.max.z
    );
  }
  getParameter(e, o) {
    return o.set(
      (e.x - this.min.x) / (this.max.x - this.min.x),
      (e.y - this.min.y) / (this.max.y - this.min.y),
      (e.z - this.min.z) / (this.max.z - this.min.z)
    );
  }
  intersectsBox(e) {
    return (
      e.max.x >= this.min.x &&
      e.min.x <= this.max.x &&
      e.max.y >= this.min.y &&
      e.min.y <= this.max.y &&
      e.max.z >= this.min.z &&
      e.min.z <= this.max.z
    );
  }
  intersectsSphere(e) {
    return (
      this.clampPoint(e.center, _vector$b),
      _vector$b.distanceToSquared(e.center) <= e.radius * e.radius
    );
  }
  intersectsPlane(e) {
    let o, a;
    return (
      e.normal.x > 0
        ? ((o = e.normal.x * this.min.x), (a = e.normal.x * this.max.x))
        : ((o = e.normal.x * this.max.x), (a = e.normal.x * this.min.x)),
      e.normal.y > 0
        ? ((o += e.normal.y * this.min.y), (a += e.normal.y * this.max.y))
        : ((o += e.normal.y * this.max.y), (a += e.normal.y * this.min.y)),
      e.normal.z > 0
        ? ((o += e.normal.z * this.min.z), (a += e.normal.z * this.max.z))
        : ((o += e.normal.z * this.max.z), (a += e.normal.z * this.min.z)),
      o <= -e.constant && a >= -e.constant
    );
  }
  intersectsTriangle(e) {
    if (this.isEmpty()) return !1;
    this.getCenter(_center),
      _extents.subVectors(this.max, _center),
      _v0$3.subVectors(e.a, _center),
      _v1$7.subVectors(e.b, _center),
      _v2$4.subVectors(e.c, _center),
      _f0.subVectors(_v1$7, _v0$3),
      _f1.subVectors(_v2$4, _v1$7),
      _f2.subVectors(_v0$3, _v2$4);
    let o = [
      0,
      -_f0.z,
      _f0.y,
      0,
      -_f1.z,
      _f1.y,
      0,
      -_f2.z,
      _f2.y,
      _f0.z,
      0,
      -_f0.x,
      _f1.z,
      0,
      -_f1.x,
      _f2.z,
      0,
      -_f2.x,
      -_f0.y,
      _f0.x,
      0,
      -_f1.y,
      _f1.x,
      0,
      -_f2.y,
      _f2.x,
      0,
    ];
    return !satForAxes(o, _v0$3, _v1$7, _v2$4, _extents) ||
      ((o = [1, 0, 0, 0, 1, 0, 0, 0, 1]),
      !satForAxes(o, _v0$3, _v1$7, _v2$4, _extents))
      ? !1
      : (_triangleNormal.crossVectors(_f0, _f1),
        (o = [_triangleNormal.x, _triangleNormal.y, _triangleNormal.z]),
        satForAxes(o, _v0$3, _v1$7, _v2$4, _extents));
  }
  clampPoint(e, o) {
    return o.copy(e).clamp(this.min, this.max);
  }
  distanceToPoint(e) {
    return this.clampPoint(e, _vector$b).distanceTo(e);
  }
  getBoundingSphere(e) {
    return (
      this.isEmpty()
        ? e.makeEmpty()
        : (this.getCenter(e.center),
          (e.radius = this.getSize(_vector$b).length() * 0.5)),
      e
    );
  }
  intersect(e) {
    return (
      this.min.max(e.min),
      this.max.min(e.max),
      this.isEmpty() && this.makeEmpty(),
      this
    );
  }
  union(e) {
    return this.min.min(e.min), this.max.max(e.max), this;
  }
  applyMatrix4(e) {
    return this.isEmpty()
      ? this
      : (_points[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(e),
        _points[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(e),
        _points[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(e),
        _points[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(e),
        _points[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(e),
        _points[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(e),
        _points[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(e),
        _points[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(e),
        this.setFromPoints(_points),
        this);
  }
  translate(e) {
    return this.min.add(e), this.max.add(e), this;
  }
  equals(e) {
    return e.min.equals(this.min) && e.max.equals(this.max);
  }
}
const _points = [
    new Vector3(),
    new Vector3(),
    new Vector3(),
    new Vector3(),
    new Vector3(),
    new Vector3(),
    new Vector3(),
    new Vector3(),
  ],
  _vector$b = new Vector3(),
  _box$4 = new Box3(),
  _v0$3 = new Vector3(),
  _v1$7 = new Vector3(),
  _v2$4 = new Vector3(),
  _f0 = new Vector3(),
  _f1 = new Vector3(),
  _f2 = new Vector3(),
  _center = new Vector3(),
  _extents = new Vector3(),
  _triangleNormal = new Vector3(),
  _testAxis = new Vector3();
function satForAxes(s, e, o, a, c) {
  for (let d = 0, g = s.length - 3; d <= g; d += 3) {
    _testAxis.fromArray(s, d);
    const _ =
        c.x * Math.abs(_testAxis.x) +
        c.y * Math.abs(_testAxis.y) +
        c.z * Math.abs(_testAxis.z),
      b = e.dot(_testAxis),
      j = o.dot(_testAxis),
      $ = a.dot(_testAxis);
    if (Math.max(-Math.max(b, j, $), Math.min(b, j, $)) > _) return !1;
  }
  return !0;
}
const _box$3 = new Box3(),
  _v1$6 = new Vector3(),
  _v2$3 = new Vector3();
class Sphere {
  constructor(e = new Vector3(), o = -1) {
    (this.isSphere = !0), (this.center = e), (this.radius = o);
  }
  set(e, o) {
    return this.center.copy(e), (this.radius = o), this;
  }
  setFromPoints(e, o) {
    const a = this.center;
    o !== void 0 ? a.copy(o) : _box$3.setFromPoints(e).getCenter(a);
    let c = 0;
    for (let d = 0, g = e.length; d < g; d++)
      c = Math.max(c, a.distanceToSquared(e[d]));
    return (this.radius = Math.sqrt(c)), this;
  }
  copy(e) {
    return this.center.copy(e.center), (this.radius = e.radius), this;
  }
  isEmpty() {
    return this.radius < 0;
  }
  makeEmpty() {
    return this.center.set(0, 0, 0), (this.radius = -1), this;
  }
  containsPoint(e) {
    return e.distanceToSquared(this.center) <= this.radius * this.radius;
  }
  distanceToPoint(e) {
    return e.distanceTo(this.center) - this.radius;
  }
  intersectsSphere(e) {
    const o = this.radius + e.radius;
    return e.center.distanceToSquared(this.center) <= o * o;
  }
  intersectsBox(e) {
    return e.intersectsSphere(this);
  }
  intersectsPlane(e) {
    return Math.abs(e.distanceToPoint(this.center)) <= this.radius;
  }
  clampPoint(e, o) {
    const a = this.center.distanceToSquared(e);
    return (
      o.copy(e),
      a > this.radius * this.radius &&
        (o.sub(this.center).normalize(),
        o.multiplyScalar(this.radius).add(this.center)),
      o
    );
  }
  getBoundingBox(e) {
    return this.isEmpty()
      ? (e.makeEmpty(), e)
      : (e.set(this.center, this.center), e.expandByScalar(this.radius), e);
  }
  applyMatrix4(e) {
    return (
      this.center.applyMatrix4(e),
      (this.radius = this.radius * e.getMaxScaleOnAxis()),
      this
    );
  }
  translate(e) {
    return this.center.add(e), this;
  }
  expandByPoint(e) {
    if (this.isEmpty()) return this.center.copy(e), (this.radius = 0), this;
    _v1$6.subVectors(e, this.center);
    const o = _v1$6.lengthSq();
    if (o > this.radius * this.radius) {
      const a = Math.sqrt(o),
        c = (a - this.radius) * 0.5;
      this.center.addScaledVector(_v1$6, c / a), (this.radius += c);
    }
    return this;
  }
  union(e) {
    return e.isEmpty()
      ? this
      : this.isEmpty()
      ? (this.copy(e), this)
      : (this.center.equals(e.center) === !0
          ? (this.radius = Math.max(this.radius, e.radius))
          : (_v2$3.subVectors(e.center, this.center).setLength(e.radius),
            this.expandByPoint(_v1$6.copy(e.center).add(_v2$3)),
            this.expandByPoint(_v1$6.copy(e.center).sub(_v2$3))),
        this);
  }
  equals(e) {
    return e.center.equals(this.center) && e.radius === this.radius;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const _vector$a = new Vector3(),
  _segCenter = new Vector3(),
  _segDir = new Vector3(),
  _diff = new Vector3(),
  _edge1 = new Vector3(),
  _edge2 = new Vector3(),
  _normal$1 = new Vector3();
class Ray {
  constructor(e = new Vector3(), o = new Vector3(0, 0, -1)) {
    (this.origin = e), (this.direction = o);
  }
  set(e, o) {
    return this.origin.copy(e), this.direction.copy(o), this;
  }
  copy(e) {
    return this.origin.copy(e.origin), this.direction.copy(e.direction), this;
  }
  at(e, o) {
    return o.copy(this.origin).addScaledVector(this.direction, e);
  }
  lookAt(e) {
    return this.direction.copy(e).sub(this.origin).normalize(), this;
  }
  recast(e) {
    return this.origin.copy(this.at(e, _vector$a)), this;
  }
  closestPointToPoint(e, o) {
    o.subVectors(e, this.origin);
    const a = o.dot(this.direction);
    return a < 0
      ? o.copy(this.origin)
      : o.copy(this.origin).addScaledVector(this.direction, a);
  }
  distanceToPoint(e) {
    return Math.sqrt(this.distanceSqToPoint(e));
  }
  distanceSqToPoint(e) {
    const o = _vector$a.subVectors(e, this.origin).dot(this.direction);
    return o < 0
      ? this.origin.distanceToSquared(e)
      : (_vector$a.copy(this.origin).addScaledVector(this.direction, o),
        _vector$a.distanceToSquared(e));
  }
  distanceSqToSegment(e, o, a, c) {
    _segCenter.copy(e).add(o).multiplyScalar(0.5),
      _segDir.copy(o).sub(e).normalize(),
      _diff.copy(this.origin).sub(_segCenter);
    const d = e.distanceTo(o) * 0.5,
      g = -this.direction.dot(_segDir),
      _ = _diff.dot(this.direction),
      b = -_diff.dot(_segDir),
      j = _diff.lengthSq(),
      $ = Math.abs(1 - g * g);
    let _e, et, rt, st;
    if ($ > 0)
      if (((_e = g * b - _), (et = g * _ - b), (st = d * $), _e >= 0))
        if (et >= -st)
          if (et <= st) {
            const at = 1 / $;
            (_e *= at),
              (et *= at),
              (rt =
                _e * (_e + g * et + 2 * _) + et * (g * _e + et + 2 * b) + j);
          } else
            (et = d),
              (_e = Math.max(0, -(g * et + _))),
              (rt = -_e * _e + et * (et + 2 * b) + j);
        else
          (et = -d),
            (_e = Math.max(0, -(g * et + _))),
            (rt = -_e * _e + et * (et + 2 * b) + j);
      else
        et <= -st
          ? ((_e = Math.max(0, -(-g * d + _))),
            (et = _e > 0 ? -d : Math.min(Math.max(-d, -b), d)),
            (rt = -_e * _e + et * (et + 2 * b) + j))
          : et <= st
          ? ((_e = 0),
            (et = Math.min(Math.max(-d, -b), d)),
            (rt = et * (et + 2 * b) + j))
          : ((_e = Math.max(0, -(g * d + _))),
            (et = _e > 0 ? d : Math.min(Math.max(-d, -b), d)),
            (rt = -_e * _e + et * (et + 2 * b) + j));
    else
      (et = g > 0 ? -d : d),
        (_e = Math.max(0, -(g * et + _))),
        (rt = -_e * _e + et * (et + 2 * b) + j);
    return (
      a && a.copy(this.origin).addScaledVector(this.direction, _e),
      c && c.copy(_segCenter).addScaledVector(_segDir, et),
      rt
    );
  }
  intersectSphere(e, o) {
    _vector$a.subVectors(e.center, this.origin);
    const a = _vector$a.dot(this.direction),
      c = _vector$a.dot(_vector$a) - a * a,
      d = e.radius * e.radius;
    if (c > d) return null;
    const g = Math.sqrt(d - c),
      _ = a - g,
      b = a + g;
    return b < 0 ? null : _ < 0 ? this.at(b, o) : this.at(_, o);
  }
  intersectsSphere(e) {
    return this.distanceSqToPoint(e.center) <= e.radius * e.radius;
  }
  distanceToPlane(e) {
    const o = e.normal.dot(this.direction);
    if (o === 0) return e.distanceToPoint(this.origin) === 0 ? 0 : null;
    const a = -(this.origin.dot(e.normal) + e.constant) / o;
    return a >= 0 ? a : null;
  }
  intersectPlane(e, o) {
    const a = this.distanceToPlane(e);
    return a === null ? null : this.at(a, o);
  }
  intersectsPlane(e) {
    const o = e.distanceToPoint(this.origin);
    return o === 0 || e.normal.dot(this.direction) * o < 0;
  }
  intersectBox(e, o) {
    let a, c, d, g, _, b;
    const j = 1 / this.direction.x,
      $ = 1 / this.direction.y,
      _e = 1 / this.direction.z,
      et = this.origin;
    return (
      j >= 0
        ? ((a = (e.min.x - et.x) * j), (c = (e.max.x - et.x) * j))
        : ((a = (e.max.x - et.x) * j), (c = (e.min.x - et.x) * j)),
      $ >= 0
        ? ((d = (e.min.y - et.y) * $), (g = (e.max.y - et.y) * $))
        : ((d = (e.max.y - et.y) * $), (g = (e.min.y - et.y) * $)),
      a > g ||
      d > c ||
      ((d > a || isNaN(a)) && (a = d),
      (g < c || isNaN(c)) && (c = g),
      _e >= 0
        ? ((_ = (e.min.z - et.z) * _e), (b = (e.max.z - et.z) * _e))
        : ((_ = (e.max.z - et.z) * _e), (b = (e.min.z - et.z) * _e)),
      a > b || _ > c) ||
      ((_ > a || a !== a) && (a = _), (b < c || c !== c) && (c = b), c < 0)
        ? null
        : this.at(a >= 0 ? a : c, o)
    );
  }
  intersectsBox(e) {
    return this.intersectBox(e, _vector$a) !== null;
  }
  intersectTriangle(e, o, a, c, d) {
    _edge1.subVectors(o, e),
      _edge2.subVectors(a, e),
      _normal$1.crossVectors(_edge1, _edge2);
    let g = this.direction.dot(_normal$1),
      _;
    if (g > 0) {
      if (c) return null;
      _ = 1;
    } else if (g < 0) (_ = -1), (g = -g);
    else return null;
    _diff.subVectors(this.origin, e);
    const b = _ * this.direction.dot(_edge2.crossVectors(_diff, _edge2));
    if (b < 0) return null;
    const j = _ * this.direction.dot(_edge1.cross(_diff));
    if (j < 0 || b + j > g) return null;
    const $ = -_ * _diff.dot(_normal$1);
    return $ < 0 ? null : this.at($ / g, d);
  }
  applyMatrix4(e) {
    return (
      this.origin.applyMatrix4(e), this.direction.transformDirection(e), this
    );
  }
  equals(e) {
    return e.origin.equals(this.origin) && e.direction.equals(this.direction);
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
class Matrix4 {
  constructor(e, o, a, c, d, g, _, b, j, $, _e, et, rt, st, at, ct) {
    (Matrix4.prototype.isMatrix4 = !0),
      (this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]),
      e !== void 0 &&
        this.set(e, o, a, c, d, g, _, b, j, $, _e, et, rt, st, at, ct);
  }
  set(e, o, a, c, d, g, _, b, j, $, _e, et, rt, st, at, ct) {
    const it = this.elements;
    return (
      (it[0] = e),
      (it[4] = o),
      (it[8] = a),
      (it[12] = c),
      (it[1] = d),
      (it[5] = g),
      (it[9] = _),
      (it[13] = b),
      (it[2] = j),
      (it[6] = $),
      (it[10] = _e),
      (it[14] = et),
      (it[3] = rt),
      (it[7] = st),
      (it[11] = at),
      (it[15] = ct),
      this
    );
  }
  identity() {
    return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
  }
  clone() {
    return new Matrix4().fromArray(this.elements);
  }
  copy(e) {
    const o = this.elements,
      a = e.elements;
    return (
      (o[0] = a[0]),
      (o[1] = a[1]),
      (o[2] = a[2]),
      (o[3] = a[3]),
      (o[4] = a[4]),
      (o[5] = a[5]),
      (o[6] = a[6]),
      (o[7] = a[7]),
      (o[8] = a[8]),
      (o[9] = a[9]),
      (o[10] = a[10]),
      (o[11] = a[11]),
      (o[12] = a[12]),
      (o[13] = a[13]),
      (o[14] = a[14]),
      (o[15] = a[15]),
      this
    );
  }
  copyPosition(e) {
    const o = this.elements,
      a = e.elements;
    return (o[12] = a[12]), (o[13] = a[13]), (o[14] = a[14]), this;
  }
  setFromMatrix3(e) {
    const o = e.elements;
    return (
      this.set(
        o[0],
        o[3],
        o[6],
        0,
        o[1],
        o[4],
        o[7],
        0,
        o[2],
        o[5],
        o[8],
        0,
        0,
        0,
        0,
        1
      ),
      this
    );
  }
  extractBasis(e, o, a) {
    return (
      e.setFromMatrixColumn(this, 0),
      o.setFromMatrixColumn(this, 1),
      a.setFromMatrixColumn(this, 2),
      this
    );
  }
  makeBasis(e, o, a) {
    return (
      this.set(
        e.x,
        o.x,
        a.x,
        0,
        e.y,
        o.y,
        a.y,
        0,
        e.z,
        o.z,
        a.z,
        0,
        0,
        0,
        0,
        1
      ),
      this
    );
  }
  extractRotation(e) {
    const o = this.elements,
      a = e.elements,
      c = 1 / _v1$5.setFromMatrixColumn(e, 0).length(),
      d = 1 / _v1$5.setFromMatrixColumn(e, 1).length(),
      g = 1 / _v1$5.setFromMatrixColumn(e, 2).length();
    return (
      (o[0] = a[0] * c),
      (o[1] = a[1] * c),
      (o[2] = a[2] * c),
      (o[3] = 0),
      (o[4] = a[4] * d),
      (o[5] = a[5] * d),
      (o[6] = a[6] * d),
      (o[7] = 0),
      (o[8] = a[8] * g),
      (o[9] = a[9] * g),
      (o[10] = a[10] * g),
      (o[11] = 0),
      (o[12] = 0),
      (o[13] = 0),
      (o[14] = 0),
      (o[15] = 1),
      this
    );
  }
  makeRotationFromEuler(e) {
    const o = this.elements,
      a = e.x,
      c = e.y,
      d = e.z,
      g = Math.cos(a),
      _ = Math.sin(a),
      b = Math.cos(c),
      j = Math.sin(c),
      $ = Math.cos(d),
      _e = Math.sin(d);
    if (e.order === "XYZ") {
      const et = g * $,
        rt = g * _e,
        st = _ * $,
        at = _ * _e;
      (o[0] = b * $),
        (o[4] = -b * _e),
        (o[8] = j),
        (o[1] = rt + st * j),
        (o[5] = et - at * j),
        (o[9] = -_ * b),
        (o[2] = at - et * j),
        (o[6] = st + rt * j),
        (o[10] = g * b);
    } else if (e.order === "YXZ") {
      const et = b * $,
        rt = b * _e,
        st = j * $,
        at = j * _e;
      (o[0] = et + at * _),
        (o[4] = st * _ - rt),
        (o[8] = g * j),
        (o[1] = g * _e),
        (o[5] = g * $),
        (o[9] = -_),
        (o[2] = rt * _ - st),
        (o[6] = at + et * _),
        (o[10] = g * b);
    } else if (e.order === "ZXY") {
      const et = b * $,
        rt = b * _e,
        st = j * $,
        at = j * _e;
      (o[0] = et - at * _),
        (o[4] = -g * _e),
        (o[8] = st + rt * _),
        (o[1] = rt + st * _),
        (o[5] = g * $),
        (o[9] = at - et * _),
        (o[2] = -g * j),
        (o[6] = _),
        (o[10] = g * b);
    } else if (e.order === "ZYX") {
      const et = g * $,
        rt = g * _e,
        st = _ * $,
        at = _ * _e;
      (o[0] = b * $),
        (o[4] = st * j - rt),
        (o[8] = et * j + at),
        (o[1] = b * _e),
        (o[5] = at * j + et),
        (o[9] = rt * j - st),
        (o[2] = -j),
        (o[6] = _ * b),
        (o[10] = g * b);
    } else if (e.order === "YZX") {
      const et = g * b,
        rt = g * j,
        st = _ * b,
        at = _ * j;
      (o[0] = b * $),
        (o[4] = at - et * _e),
        (o[8] = st * _e + rt),
        (o[1] = _e),
        (o[5] = g * $),
        (o[9] = -_ * $),
        (o[2] = -j * $),
        (o[6] = rt * _e + st),
        (o[10] = et - at * _e);
    } else if (e.order === "XZY") {
      const et = g * b,
        rt = g * j,
        st = _ * b,
        at = _ * j;
      (o[0] = b * $),
        (o[4] = -_e),
        (o[8] = j * $),
        (o[1] = et * _e + at),
        (o[5] = g * $),
        (o[9] = rt * _e - st),
        (o[2] = st * _e - rt),
        (o[6] = _ * $),
        (o[10] = at * _e + et);
    }
    return (
      (o[3] = 0),
      (o[7] = 0),
      (o[11] = 0),
      (o[12] = 0),
      (o[13] = 0),
      (o[14] = 0),
      (o[15] = 1),
      this
    );
  }
  makeRotationFromQuaternion(e) {
    return this.compose(_zero, e, _one);
  }
  lookAt(e, o, a) {
    const c = this.elements;
    return (
      _z.subVectors(e, o),
      _z.lengthSq() === 0 && (_z.z = 1),
      _z.normalize(),
      _x.crossVectors(a, _z),
      _x.lengthSq() === 0 &&
        (Math.abs(a.z) === 1 ? (_z.x += 1e-4) : (_z.z += 1e-4),
        _z.normalize(),
        _x.crossVectors(a, _z)),
      _x.normalize(),
      _y.crossVectors(_z, _x),
      (c[0] = _x.x),
      (c[4] = _y.x),
      (c[8] = _z.x),
      (c[1] = _x.y),
      (c[5] = _y.y),
      (c[9] = _z.y),
      (c[2] = _x.z),
      (c[6] = _y.z),
      (c[10] = _z.z),
      this
    );
  }
  multiply(e) {
    return this.multiplyMatrices(this, e);
  }
  premultiply(e) {
    return this.multiplyMatrices(e, this);
  }
  multiplyMatrices(e, o) {
    const a = e.elements,
      c = o.elements,
      d = this.elements,
      g = a[0],
      _ = a[4],
      b = a[8],
      j = a[12],
      $ = a[1],
      _e = a[5],
      et = a[9],
      rt = a[13],
      st = a[2],
      at = a[6],
      ct = a[10],
      it = a[14],
      lt = a[3],
      ot = a[7],
      ut = a[11],
      pt = a[15],
      ft = c[0],
      gt = c[4],
      xt = c[8],
      _t = c[12],
      St = c[1],
      Mt = c[5],
      Rt = c[9],
      Ft = c[13],
      Ot = c[2],
      Lt = c[6],
      Et = c[10],
      bt = c[14],
      mt = c[3],
      vt = c[7],
      Ct = c[11],
      Tt = c[15];
    return (
      (d[0] = g * ft + _ * St + b * Ot + j * mt),
      (d[4] = g * gt + _ * Mt + b * Lt + j * vt),
      (d[8] = g * xt + _ * Rt + b * Et + j * Ct),
      (d[12] = g * _t + _ * Ft + b * bt + j * Tt),
      (d[1] = $ * ft + _e * St + et * Ot + rt * mt),
      (d[5] = $ * gt + _e * Mt + et * Lt + rt * vt),
      (d[9] = $ * xt + _e * Rt + et * Et + rt * Ct),
      (d[13] = $ * _t + _e * Ft + et * bt + rt * Tt),
      (d[2] = st * ft + at * St + ct * Ot + it * mt),
      (d[6] = st * gt + at * Mt + ct * Lt + it * vt),
      (d[10] = st * xt + at * Rt + ct * Et + it * Ct),
      (d[14] = st * _t + at * Ft + ct * bt + it * Tt),
      (d[3] = lt * ft + ot * St + ut * Ot + pt * mt),
      (d[7] = lt * gt + ot * Mt + ut * Lt + pt * vt),
      (d[11] = lt * xt + ot * Rt + ut * Et + pt * Ct),
      (d[15] = lt * _t + ot * Ft + ut * bt + pt * Tt),
      this
    );
  }
  multiplyScalar(e) {
    const o = this.elements;
    return (
      (o[0] *= e),
      (o[4] *= e),
      (o[8] *= e),
      (o[12] *= e),
      (o[1] *= e),
      (o[5] *= e),
      (o[9] *= e),
      (o[13] *= e),
      (o[2] *= e),
      (o[6] *= e),
      (o[10] *= e),
      (o[14] *= e),
      (o[3] *= e),
      (o[7] *= e),
      (o[11] *= e),
      (o[15] *= e),
      this
    );
  }
  determinant() {
    const e = this.elements,
      o = e[0],
      a = e[4],
      c = e[8],
      d = e[12],
      g = e[1],
      _ = e[5],
      b = e[9],
      j = e[13],
      $ = e[2],
      _e = e[6],
      et = e[10],
      rt = e[14],
      st = e[3],
      at = e[7],
      ct = e[11],
      it = e[15];
    return (
      st *
        (+d * b * _e -
          c * j * _e -
          d * _ * et +
          a * j * et +
          c * _ * rt -
          a * b * rt) +
      at *
        (+o * b * rt -
          o * j * et +
          d * g * et -
          c * g * rt +
          c * j * $ -
          d * b * $) +
      ct *
        (+o * j * _e -
          o * _ * rt -
          d * g * _e +
          a * g * rt +
          d * _ * $ -
          a * j * $) +
      it *
        (-c * _ * $ -
          o * b * _e +
          o * _ * et +
          c * g * _e -
          a * g * et +
          a * b * $)
    );
  }
  transpose() {
    const e = this.elements;
    let o;
    return (
      (o = e[1]),
      (e[1] = e[4]),
      (e[4] = o),
      (o = e[2]),
      (e[2] = e[8]),
      (e[8] = o),
      (o = e[6]),
      (e[6] = e[9]),
      (e[9] = o),
      (o = e[3]),
      (e[3] = e[12]),
      (e[12] = o),
      (o = e[7]),
      (e[7] = e[13]),
      (e[13] = o),
      (o = e[11]),
      (e[11] = e[14]),
      (e[14] = o),
      this
    );
  }
  setPosition(e, o, a) {
    const c = this.elements;
    return (
      e.isVector3
        ? ((c[12] = e.x), (c[13] = e.y), (c[14] = e.z))
        : ((c[12] = e), (c[13] = o), (c[14] = a)),
      this
    );
  }
  invert() {
    const e = this.elements,
      o = e[0],
      a = e[1],
      c = e[2],
      d = e[3],
      g = e[4],
      _ = e[5],
      b = e[6],
      j = e[7],
      $ = e[8],
      _e = e[9],
      et = e[10],
      rt = e[11],
      st = e[12],
      at = e[13],
      ct = e[14],
      it = e[15],
      lt =
        _e * ct * j -
        at * et * j +
        at * b * rt -
        _ * ct * rt -
        _e * b * it +
        _ * et * it,
      ot =
        st * et * j -
        $ * ct * j -
        st * b * rt +
        g * ct * rt +
        $ * b * it -
        g * et * it,
      ut =
        $ * at * j -
        st * _e * j +
        st * _ * rt -
        g * at * rt -
        $ * _ * it +
        g * _e * it,
      pt =
        st * _e * b -
        $ * at * b -
        st * _ * et +
        g * at * et +
        $ * _ * ct -
        g * _e * ct,
      ft = o * lt + a * ot + c * ut + d * pt;
    if (ft === 0)
      return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    const gt = 1 / ft;
    return (
      (e[0] = lt * gt),
      (e[1] =
        (at * et * d -
          _e * ct * d -
          at * c * rt +
          a * ct * rt +
          _e * c * it -
          a * et * it) *
        gt),
      (e[2] =
        (_ * ct * d -
          at * b * d +
          at * c * j -
          a * ct * j -
          _ * c * it +
          a * b * it) *
        gt),
      (e[3] =
        (_e * b * d -
          _ * et * d -
          _e * c * j +
          a * et * j +
          _ * c * rt -
          a * b * rt) *
        gt),
      (e[4] = ot * gt),
      (e[5] =
        ($ * ct * d -
          st * et * d +
          st * c * rt -
          o * ct * rt -
          $ * c * it +
          o * et * it) *
        gt),
      (e[6] =
        (st * b * d -
          g * ct * d -
          st * c * j +
          o * ct * j +
          g * c * it -
          o * b * it) *
        gt),
      (e[7] =
        (g * et * d -
          $ * b * d +
          $ * c * j -
          o * et * j -
          g * c * rt +
          o * b * rt) *
        gt),
      (e[8] = ut * gt),
      (e[9] =
        (st * _e * d -
          $ * at * d -
          st * a * rt +
          o * at * rt +
          $ * a * it -
          o * _e * it) *
        gt),
      (e[10] =
        (g * at * d -
          st * _ * d +
          st * a * j -
          o * at * j -
          g * a * it +
          o * _ * it) *
        gt),
      (e[11] =
        ($ * _ * d -
          g * _e * d -
          $ * a * j +
          o * _e * j +
          g * a * rt -
          o * _ * rt) *
        gt),
      (e[12] = pt * gt),
      (e[13] =
        ($ * at * c -
          st * _e * c +
          st * a * et -
          o * at * et -
          $ * a * ct +
          o * _e * ct) *
        gt),
      (e[14] =
        (st * _ * c -
          g * at * c -
          st * a * b +
          o * at * b +
          g * a * ct -
          o * _ * ct) *
        gt),
      (e[15] =
        (g * _e * c -
          $ * _ * c +
          $ * a * b -
          o * _e * b -
          g * a * et +
          o * _ * et) *
        gt),
      this
    );
  }
  scale(e) {
    const o = this.elements,
      a = e.x,
      c = e.y,
      d = e.z;
    return (
      (o[0] *= a),
      (o[4] *= c),
      (o[8] *= d),
      (o[1] *= a),
      (o[5] *= c),
      (o[9] *= d),
      (o[2] *= a),
      (o[6] *= c),
      (o[10] *= d),
      (o[3] *= a),
      (o[7] *= c),
      (o[11] *= d),
      this
    );
  }
  getMaxScaleOnAxis() {
    const e = this.elements,
      o = e[0] * e[0] + e[1] * e[1] + e[2] * e[2],
      a = e[4] * e[4] + e[5] * e[5] + e[6] * e[6],
      c = e[8] * e[8] + e[9] * e[9] + e[10] * e[10];
    return Math.sqrt(Math.max(o, a, c));
  }
  makeTranslation(e, o, a) {
    return (
      e.isVector3
        ? this.set(1, 0, 0, e.x, 0, 1, 0, e.y, 0, 0, 1, e.z, 0, 0, 0, 1)
        : this.set(1, 0, 0, e, 0, 1, 0, o, 0, 0, 1, a, 0, 0, 0, 1),
      this
    );
  }
  makeRotationX(e) {
    const o = Math.cos(e),
      a = Math.sin(e);
    return this.set(1, 0, 0, 0, 0, o, -a, 0, 0, a, o, 0, 0, 0, 0, 1), this;
  }
  makeRotationY(e) {
    const o = Math.cos(e),
      a = Math.sin(e);
    return this.set(o, 0, a, 0, 0, 1, 0, 0, -a, 0, o, 0, 0, 0, 0, 1), this;
  }
  makeRotationZ(e) {
    const o = Math.cos(e),
      a = Math.sin(e);
    return this.set(o, -a, 0, 0, a, o, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
  }
  makeRotationAxis(e, o) {
    const a = Math.cos(o),
      c = Math.sin(o),
      d = 1 - a,
      g = e.x,
      _ = e.y,
      b = e.z,
      j = d * g,
      $ = d * _;
    return (
      this.set(
        j * g + a,
        j * _ - c * b,
        j * b + c * _,
        0,
        j * _ + c * b,
        $ * _ + a,
        $ * b - c * g,
        0,
        j * b - c * _,
        $ * b + c * g,
        d * b * b + a,
        0,
        0,
        0,
        0,
        1
      ),
      this
    );
  }
  makeScale(e, o, a) {
    return this.set(e, 0, 0, 0, 0, o, 0, 0, 0, 0, a, 0, 0, 0, 0, 1), this;
  }
  makeShear(e, o, a, c, d, g) {
    return this.set(1, a, d, 0, e, 1, g, 0, o, c, 1, 0, 0, 0, 0, 1), this;
  }
  compose(e, o, a) {
    const c = this.elements,
      d = o._x,
      g = o._y,
      _ = o._z,
      b = o._w,
      j = d + d,
      $ = g + g,
      _e = _ + _,
      et = d * j,
      rt = d * $,
      st = d * _e,
      at = g * $,
      ct = g * _e,
      it = _ * _e,
      lt = b * j,
      ot = b * $,
      ut = b * _e,
      pt = a.x,
      ft = a.y,
      gt = a.z;
    return (
      (c[0] = (1 - (at + it)) * pt),
      (c[1] = (rt + ut) * pt),
      (c[2] = (st - ot) * pt),
      (c[3] = 0),
      (c[4] = (rt - ut) * ft),
      (c[5] = (1 - (et + it)) * ft),
      (c[6] = (ct + lt) * ft),
      (c[7] = 0),
      (c[8] = (st + ot) * gt),
      (c[9] = (ct - lt) * gt),
      (c[10] = (1 - (et + at)) * gt),
      (c[11] = 0),
      (c[12] = e.x),
      (c[13] = e.y),
      (c[14] = e.z),
      (c[15] = 1),
      this
    );
  }
  decompose(e, o, a) {
    const c = this.elements;
    let d = _v1$5.set(c[0], c[1], c[2]).length();
    const g = _v1$5.set(c[4], c[5], c[6]).length(),
      _ = _v1$5.set(c[8], c[9], c[10]).length();
    this.determinant() < 0 && (d = -d),
      (e.x = c[12]),
      (e.y = c[13]),
      (e.z = c[14]),
      _m1$4.copy(this);
    const j = 1 / d,
      $ = 1 / g,
      _e = 1 / _;
    return (
      (_m1$4.elements[0] *= j),
      (_m1$4.elements[1] *= j),
      (_m1$4.elements[2] *= j),
      (_m1$4.elements[4] *= $),
      (_m1$4.elements[5] *= $),
      (_m1$4.elements[6] *= $),
      (_m1$4.elements[8] *= _e),
      (_m1$4.elements[9] *= _e),
      (_m1$4.elements[10] *= _e),
      o.setFromRotationMatrix(_m1$4),
      (a.x = d),
      (a.y = g),
      (a.z = _),
      this
    );
  }
  makePerspective(e, o, a, c, d, g, _ = WebGLCoordinateSystem) {
    const b = this.elements,
      j = (2 * d) / (o - e),
      $ = (2 * d) / (a - c),
      _e = (o + e) / (o - e),
      et = (a + c) / (a - c);
    let rt, st;
    if (_ === WebGLCoordinateSystem)
      (rt = -(g + d) / (g - d)), (st = (-2 * g * d) / (g - d));
    else if (_ === WebGPUCoordinateSystem)
      (rt = -g / (g - d)), (st = (-g * d) / (g - d));
    else
      throw new Error(
        "THREE.Matrix4.makePerspective(): Invalid coordinate system: " + _
      );
    return (
      (b[0] = j),
      (b[4] = 0),
      (b[8] = _e),
      (b[12] = 0),
      (b[1] = 0),
      (b[5] = $),
      (b[9] = et),
      (b[13] = 0),
      (b[2] = 0),
      (b[6] = 0),
      (b[10] = rt),
      (b[14] = st),
      (b[3] = 0),
      (b[7] = 0),
      (b[11] = -1),
      (b[15] = 0),
      this
    );
  }
  makeOrthographic(e, o, a, c, d, g, _ = WebGLCoordinateSystem) {
    const b = this.elements,
      j = 1 / (o - e),
      $ = 1 / (a - c),
      _e = 1 / (g - d),
      et = (o + e) * j,
      rt = (a + c) * $;
    let st, at;
    if (_ === WebGLCoordinateSystem) (st = (g + d) * _e), (at = -2 * _e);
    else if (_ === WebGPUCoordinateSystem) (st = d * _e), (at = -1 * _e);
    else
      throw new Error(
        "THREE.Matrix4.makeOrthographic(): Invalid coordinate system: " + _
      );
    return (
      (b[0] = 2 * j),
      (b[4] = 0),
      (b[8] = 0),
      (b[12] = -et),
      (b[1] = 0),
      (b[5] = 2 * $),
      (b[9] = 0),
      (b[13] = -rt),
      (b[2] = 0),
      (b[6] = 0),
      (b[10] = at),
      (b[14] = -st),
      (b[3] = 0),
      (b[7] = 0),
      (b[11] = 0),
      (b[15] = 1),
      this
    );
  }
  equals(e) {
    const o = this.elements,
      a = e.elements;
    for (let c = 0; c < 16; c++) if (o[c] !== a[c]) return !1;
    return !0;
  }
  fromArray(e, o = 0) {
    for (let a = 0; a < 16; a++) this.elements[a] = e[a + o];
    return this;
  }
  toArray(e = [], o = 0) {
    const a = this.elements;
    return (
      (e[o] = a[0]),
      (e[o + 1] = a[1]),
      (e[o + 2] = a[2]),
      (e[o + 3] = a[3]),
      (e[o + 4] = a[4]),
      (e[o + 5] = a[5]),
      (e[o + 6] = a[6]),
      (e[o + 7] = a[7]),
      (e[o + 8] = a[8]),
      (e[o + 9] = a[9]),
      (e[o + 10] = a[10]),
      (e[o + 11] = a[11]),
      (e[o + 12] = a[12]),
      (e[o + 13] = a[13]),
      (e[o + 14] = a[14]),
      (e[o + 15] = a[15]),
      e
    );
  }
}
const _v1$5 = new Vector3(),
  _m1$4 = new Matrix4(),
  _zero = new Vector3(0, 0, 0),
  _one = new Vector3(1, 1, 1),
  _x = new Vector3(),
  _y = new Vector3(),
  _z = new Vector3(),
  _matrix$2 = new Matrix4(),
  _quaternion$3 = new Quaternion();
class Euler {
  constructor(e = 0, o = 0, a = 0, c = Euler.DEFAULT_ORDER) {
    (this.isEuler = !0),
      (this._x = e),
      (this._y = o),
      (this._z = a),
      (this._order = c);
  }
  get x() {
    return this._x;
  }
  set x(e) {
    (this._x = e), this._onChangeCallback();
  }
  get y() {
    return this._y;
  }
  set y(e) {
    (this._y = e), this._onChangeCallback();
  }
  get z() {
    return this._z;
  }
  set z(e) {
    (this._z = e), this._onChangeCallback();
  }
  get order() {
    return this._order;
  }
  set order(e) {
    (this._order = e), this._onChangeCallback();
  }
  set(e, o, a, c = this._order) {
    return (
      (this._x = e),
      (this._y = o),
      (this._z = a),
      (this._order = c),
      this._onChangeCallback(),
      this
    );
  }
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._order);
  }
  copy(e) {
    return (
      (this._x = e._x),
      (this._y = e._y),
      (this._z = e._z),
      (this._order = e._order),
      this._onChangeCallback(),
      this
    );
  }
  setFromRotationMatrix(e, o = this._order, a = !0) {
    const c = e.elements,
      d = c[0],
      g = c[4],
      _ = c[8],
      b = c[1],
      j = c[5],
      $ = c[9],
      _e = c[2],
      et = c[6],
      rt = c[10];
    switch (o) {
      case "XYZ":
        (this._y = Math.asin(clamp(_, -1, 1))),
          Math.abs(_) < 0.9999999
            ? ((this._x = Math.atan2(-$, rt)), (this._z = Math.atan2(-g, d)))
            : ((this._x = Math.atan2(et, j)), (this._z = 0));
        break;
      case "YXZ":
        (this._x = Math.asin(-clamp($, -1, 1))),
          Math.abs($) < 0.9999999
            ? ((this._y = Math.atan2(_, rt)), (this._z = Math.atan2(b, j)))
            : ((this._y = Math.atan2(-_e, d)), (this._z = 0));
        break;
      case "ZXY":
        (this._x = Math.asin(clamp(et, -1, 1))),
          Math.abs(et) < 0.9999999
            ? ((this._y = Math.atan2(-_e, rt)), (this._z = Math.atan2(-g, j)))
            : ((this._y = 0), (this._z = Math.atan2(b, d)));
        break;
      case "ZYX":
        (this._y = Math.asin(-clamp(_e, -1, 1))),
          Math.abs(_e) < 0.9999999
            ? ((this._x = Math.atan2(et, rt)), (this._z = Math.atan2(b, d)))
            : ((this._x = 0), (this._z = Math.atan2(-g, j)));
        break;
      case "YZX":
        (this._z = Math.asin(clamp(b, -1, 1))),
          Math.abs(b) < 0.9999999
            ? ((this._x = Math.atan2(-$, j)), (this._y = Math.atan2(-_e, d)))
            : ((this._x = 0), (this._y = Math.atan2(_, rt)));
        break;
      case "XZY":
        (this._z = Math.asin(-clamp(g, -1, 1))),
          Math.abs(g) < 0.9999999
            ? ((this._x = Math.atan2(et, j)), (this._y = Math.atan2(_, d)))
            : ((this._x = Math.atan2(-$, rt)), (this._y = 0));
        break;
      default:
        console.warn(
          "THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " +
            o
        );
    }
    return (this._order = o), a === !0 && this._onChangeCallback(), this;
  }
  setFromQuaternion(e, o, a) {
    return (
      _matrix$2.makeRotationFromQuaternion(e),
      this.setFromRotationMatrix(_matrix$2, o, a)
    );
  }
  setFromVector3(e, o = this._order) {
    return this.set(e.x, e.y, e.z, o);
  }
  reorder(e) {
    return (
      _quaternion$3.setFromEuler(this), this.setFromQuaternion(_quaternion$3, e)
    );
  }
  equals(e) {
    return (
      e._x === this._x &&
      e._y === this._y &&
      e._z === this._z &&
      e._order === this._order
    );
  }
  fromArray(e) {
    return (
      (this._x = e[0]),
      (this._y = e[1]),
      (this._z = e[2]),
      e[3] !== void 0 && (this._order = e[3]),
      this._onChangeCallback(),
      this
    );
  }
  toArray(e = [], o = 0) {
    return (
      (e[o] = this._x),
      (e[o + 1] = this._y),
      (e[o + 2] = this._z),
      (e[o + 3] = this._order),
      e
    );
  }
  _onChange(e) {
    return (this._onChangeCallback = e), this;
  }
  _onChangeCallback() {}
  *[Symbol.iterator]() {
    yield this._x, yield this._y, yield this._z, yield this._order;
  }
}
Euler.DEFAULT_ORDER = "XYZ";
class Layers {
  constructor() {
    this.mask = 1;
  }
  set(e) {
    this.mask = ((1 << e) | 0) >>> 0;
  }
  enable(e) {
    this.mask |= (1 << e) | 0;
  }
  enableAll() {
    this.mask = -1;
  }
  toggle(e) {
    this.mask ^= (1 << e) | 0;
  }
  disable(e) {
    this.mask &= ~((1 << e) | 0);
  }
  disableAll() {
    this.mask = 0;
  }
  test(e) {
    return (this.mask & e.mask) !== 0;
  }
  isEnabled(e) {
    return (this.mask & ((1 << e) | 0)) !== 0;
  }
}
let _object3DId = 0;
const _v1$4 = new Vector3(),
  _q1 = new Quaternion(),
  _m1$3 = new Matrix4(),
  _target = new Vector3(),
  _position$3 = new Vector3(),
  _scale$2 = new Vector3(),
  _quaternion$2 = new Quaternion(),
  _xAxis = new Vector3(1, 0, 0),
  _yAxis = new Vector3(0, 1, 0),
  _zAxis = new Vector3(0, 0, 1),
  _addedEvent = { type: "added" },
  _removedEvent = { type: "removed" },
  _childaddedEvent = { type: "childadded", child: null },
  _childremovedEvent = { type: "childremoved", child: null };
class Object3D extends EventDispatcher {
  constructor() {
    super(),
      (this.isObject3D = !0),
      Object.defineProperty(this, "id", { value: _object3DId++ }),
      (this.uuid = generateUUID()),
      (this.name = ""),
      (this.type = "Object3D"),
      (this.parent = null),
      (this.children = []),
      (this.up = Object3D.DEFAULT_UP.clone());
    const e = new Vector3(),
      o = new Euler(),
      a = new Quaternion(),
      c = new Vector3(1, 1, 1);
    function d() {
      a.setFromEuler(o, !1);
    }
    function g() {
      o.setFromQuaternion(a, void 0, !1);
    }
    o._onChange(d),
      a._onChange(g),
      Object.defineProperties(this, {
        position: { configurable: !0, enumerable: !0, value: e },
        rotation: { configurable: !0, enumerable: !0, value: o },
        quaternion: { configurable: !0, enumerable: !0, value: a },
        scale: { configurable: !0, enumerable: !0, value: c },
        modelViewMatrix: { value: new Matrix4() },
        normalMatrix: { value: new Matrix3() },
      }),
      (this.matrix = new Matrix4()),
      (this.matrixWorld = new Matrix4()),
      (this.matrixAutoUpdate = Object3D.DEFAULT_MATRIX_AUTO_UPDATE),
      (this.matrixWorldAutoUpdate = Object3D.DEFAULT_MATRIX_WORLD_AUTO_UPDATE),
      (this.matrixWorldNeedsUpdate = !1),
      (this.layers = new Layers()),
      (this.visible = !0),
      (this.castShadow = !1),
      (this.receiveShadow = !1),
      (this.frustumCulled = !0),
      (this.renderOrder = 0),
      (this.animations = []),
      (this.userData = {});
  }
  onBeforeShadow() {}
  onAfterShadow() {}
  onBeforeRender() {}
  onAfterRender() {}
  applyMatrix4(e) {
    this.matrixAutoUpdate && this.updateMatrix(),
      this.matrix.premultiply(e),
      this.matrix.decompose(this.position, this.quaternion, this.scale);
  }
  applyQuaternion(e) {
    return this.quaternion.premultiply(e), this;
  }
  setRotationFromAxisAngle(e, o) {
    this.quaternion.setFromAxisAngle(e, o);
  }
  setRotationFromEuler(e) {
    this.quaternion.setFromEuler(e, !0);
  }
  setRotationFromMatrix(e) {
    this.quaternion.setFromRotationMatrix(e);
  }
  setRotationFromQuaternion(e) {
    this.quaternion.copy(e);
  }
  rotateOnAxis(e, o) {
    return _q1.setFromAxisAngle(e, o), this.quaternion.multiply(_q1), this;
  }
  rotateOnWorldAxis(e, o) {
    return _q1.setFromAxisAngle(e, o), this.quaternion.premultiply(_q1), this;
  }
  rotateX(e) {
    return this.rotateOnAxis(_xAxis, e);
  }
  rotateY(e) {
    return this.rotateOnAxis(_yAxis, e);
  }
  rotateZ(e) {
    return this.rotateOnAxis(_zAxis, e);
  }
  translateOnAxis(e, o) {
    return (
      _v1$4.copy(e).applyQuaternion(this.quaternion),
      this.position.add(_v1$4.multiplyScalar(o)),
      this
    );
  }
  translateX(e) {
    return this.translateOnAxis(_xAxis, e);
  }
  translateY(e) {
    return this.translateOnAxis(_yAxis, e);
  }
  translateZ(e) {
    return this.translateOnAxis(_zAxis, e);
  }
  localToWorld(e) {
    return this.updateWorldMatrix(!0, !1), e.applyMatrix4(this.matrixWorld);
  }
  worldToLocal(e) {
    return (
      this.updateWorldMatrix(!0, !1),
      e.applyMatrix4(_m1$3.copy(this.matrixWorld).invert())
    );
  }
  lookAt(e, o, a) {
    e.isVector3 ? _target.copy(e) : _target.set(e, o, a);
    const c = this.parent;
    this.updateWorldMatrix(!0, !1),
      _position$3.setFromMatrixPosition(this.matrixWorld),
      this.isCamera || this.isLight
        ? _m1$3.lookAt(_position$3, _target, this.up)
        : _m1$3.lookAt(_target, _position$3, this.up),
      this.quaternion.setFromRotationMatrix(_m1$3),
      c &&
        (_m1$3.extractRotation(c.matrixWorld),
        _q1.setFromRotationMatrix(_m1$3),
        this.quaternion.premultiply(_q1.invert()));
  }
  add(e) {
    if (arguments.length > 1) {
      for (let o = 0; o < arguments.length; o++) this.add(arguments[o]);
      return this;
    }
    return e === this
      ? (console.error(
          "THREE.Object3D.add: object can't be added as a child of itself.",
          e
        ),
        this)
      : (e && e.isObject3D
          ? (e.removeFromParent(),
            (e.parent = this),
            this.children.push(e),
            e.dispatchEvent(_addedEvent),
            (_childaddedEvent.child = e),
            this.dispatchEvent(_childaddedEvent),
            (_childaddedEvent.child = null))
          : console.error(
              "THREE.Object3D.add: object not an instance of THREE.Object3D.",
              e
            ),
        this);
  }
  remove(e) {
    if (arguments.length > 1) {
      for (let a = 0; a < arguments.length; a++) this.remove(arguments[a]);
      return this;
    }
    const o = this.children.indexOf(e);
    return (
      o !== -1 &&
        ((e.parent = null),
        this.children.splice(o, 1),
        e.dispatchEvent(_removedEvent),
        (_childremovedEvent.child = e),
        this.dispatchEvent(_childremovedEvent),
        (_childremovedEvent.child = null)),
      this
    );
  }
  removeFromParent() {
    const e = this.parent;
    return e !== null && e.remove(this), this;
  }
  clear() {
    return this.remove(...this.children);
  }
  attach(e) {
    return (
      this.updateWorldMatrix(!0, !1),
      _m1$3.copy(this.matrixWorld).invert(),
      e.parent !== null &&
        (e.parent.updateWorldMatrix(!0, !1),
        _m1$3.multiply(e.parent.matrixWorld)),
      e.applyMatrix4(_m1$3),
      e.removeFromParent(),
      (e.parent = this),
      this.children.push(e),
      e.updateWorldMatrix(!1, !0),
      e.dispatchEvent(_addedEvent),
      (_childaddedEvent.child = e),
      this.dispatchEvent(_childaddedEvent),
      (_childaddedEvent.child = null),
      this
    );
  }
  getObjectById(e) {
    return this.getObjectByProperty("id", e);
  }
  getObjectByName(e) {
    return this.getObjectByProperty("name", e);
  }
  getObjectByProperty(e, o) {
    if (this[e] === o) return this;
    for (let a = 0, c = this.children.length; a < c; a++) {
      const g = this.children[a].getObjectByProperty(e, o);
      if (g !== void 0) return g;
    }
  }
  getObjectsByProperty(e, o, a = []) {
    this[e] === o && a.push(this);
    const c = this.children;
    for (let d = 0, g = c.length; d < g; d++)
      c[d].getObjectsByProperty(e, o, a);
    return a;
  }
  getWorldPosition(e) {
    return (
      this.updateWorldMatrix(!0, !1), e.setFromMatrixPosition(this.matrixWorld)
    );
  }
  getWorldQuaternion(e) {
    return (
      this.updateWorldMatrix(!0, !1),
      this.matrixWorld.decompose(_position$3, e, _scale$2),
      e
    );
  }
  getWorldScale(e) {
    return (
      this.updateWorldMatrix(!0, !1),
      this.matrixWorld.decompose(_position$3, _quaternion$2, e),
      e
    );
  }
  getWorldDirection(e) {
    this.updateWorldMatrix(!0, !1);
    const o = this.matrixWorld.elements;
    return e.set(o[8], o[9], o[10]).normalize();
  }
  raycast() {}
  traverse(e) {
    e(this);
    const o = this.children;
    for (let a = 0, c = o.length; a < c; a++) o[a].traverse(e);
  }
  traverseVisible(e) {
    if (this.visible === !1) return;
    e(this);
    const o = this.children;
    for (let a = 0, c = o.length; a < c; a++) o[a].traverseVisible(e);
  }
  traverseAncestors(e) {
    const o = this.parent;
    o !== null && (e(o), o.traverseAncestors(e));
  }
  updateMatrix() {
    this.matrix.compose(this.position, this.quaternion, this.scale),
      (this.matrixWorldNeedsUpdate = !0);
  }
  updateMatrixWorld(e) {
    this.matrixAutoUpdate && this.updateMatrix(),
      (this.matrixWorldNeedsUpdate || e) &&
        (this.matrixWorldAutoUpdate === !0 &&
          (this.parent === null
            ? this.matrixWorld.copy(this.matrix)
            : this.matrixWorld.multiplyMatrices(
                this.parent.matrixWorld,
                this.matrix
              )),
        (this.matrixWorldNeedsUpdate = !1),
        (e = !0));
    const o = this.children;
    for (let a = 0, c = o.length; a < c; a++) o[a].updateMatrixWorld(e);
  }
  updateWorldMatrix(e, o) {
    const a = this.parent;
    if (
      (e === !0 && a !== null && a.updateWorldMatrix(!0, !1),
      this.matrixAutoUpdate && this.updateMatrix(),
      this.matrixWorldAutoUpdate === !0 &&
        (this.parent === null
          ? this.matrixWorld.copy(this.matrix)
          : this.matrixWorld.multiplyMatrices(
              this.parent.matrixWorld,
              this.matrix
            )),
      o === !0)
    ) {
      const c = this.children;
      for (let d = 0, g = c.length; d < g; d++) c[d].updateWorldMatrix(!1, !0);
    }
  }
  toJSON(e) {
    const o = e === void 0 || typeof e == "string",
      a = {};
    o &&
      ((e = {
        geometries: {},
        materials: {},
        textures: {},
        images: {},
        shapes: {},
        skeletons: {},
        animations: {},
        nodes: {},
      }),
      (a.metadata = {
        version: 4.6,
        type: "Object",
        generator: "Object3D.toJSON",
      }));
    const c = {};
    (c.uuid = this.uuid),
      (c.type = this.type),
      this.name !== "" && (c.name = this.name),
      this.castShadow === !0 && (c.castShadow = !0),
      this.receiveShadow === !0 && (c.receiveShadow = !0),
      this.visible === !1 && (c.visible = !1),
      this.frustumCulled === !1 && (c.frustumCulled = !1),
      this.renderOrder !== 0 && (c.renderOrder = this.renderOrder),
      Object.keys(this.userData).length > 0 && (c.userData = this.userData),
      (c.layers = this.layers.mask),
      (c.matrix = this.matrix.toArray()),
      (c.up = this.up.toArray()),
      this.matrixAutoUpdate === !1 && (c.matrixAutoUpdate = !1),
      this.isInstancedMesh &&
        ((c.type = "InstancedMesh"),
        (c.count = this.count),
        (c.instanceMatrix = this.instanceMatrix.toJSON()),
        this.instanceColor !== null &&
          (c.instanceColor = this.instanceColor.toJSON())),
      this.isBatchedMesh &&
        ((c.type = "BatchedMesh"),
        (c.perObjectFrustumCulled = this.perObjectFrustumCulled),
        (c.sortObjects = this.sortObjects),
        (c.drawRanges = this._drawRanges),
        (c.reservedRanges = this._reservedRanges),
        (c.visibility = this._visibility),
        (c.active = this._active),
        (c.bounds = this._bounds.map((_) => ({
          boxInitialized: _.boxInitialized,
          boxMin: _.box.min.toArray(),
          boxMax: _.box.max.toArray(),
          sphereInitialized: _.sphereInitialized,
          sphereRadius: _.sphere.radius,
          sphereCenter: _.sphere.center.toArray(),
        }))),
        (c.maxInstanceCount = this._maxInstanceCount),
        (c.maxVertexCount = this._maxVertexCount),
        (c.maxIndexCount = this._maxIndexCount),
        (c.geometryInitialized = this._geometryInitialized),
        (c.geometryCount = this._geometryCount),
        (c.matricesTexture = this._matricesTexture.toJSON(e)),
        this._colorsTexture !== null &&
          (c.colorsTexture = this._colorsTexture.toJSON(e)),
        this.boundingSphere !== null &&
          (c.boundingSphere = {
            center: c.boundingSphere.center.toArray(),
            radius: c.boundingSphere.radius,
          }),
        this.boundingBox !== null &&
          (c.boundingBox = {
            min: c.boundingBox.min.toArray(),
            max: c.boundingBox.max.toArray(),
          }));
    function d(_, b) {
      return _[b.uuid] === void 0 && (_[b.uuid] = b.toJSON(e)), b.uuid;
    }
    if (this.isScene)
      this.background &&
        (this.background.isColor
          ? (c.background = this.background.toJSON())
          : this.background.isTexture &&
            (c.background = this.background.toJSON(e).uuid)),
        this.environment &&
          this.environment.isTexture &&
          this.environment.isRenderTargetTexture !== !0 &&
          (c.environment = this.environment.toJSON(e).uuid);
    else if (this.isMesh || this.isLine || this.isPoints) {
      c.geometry = d(e.geometries, this.geometry);
      const _ = this.geometry.parameters;
      if (_ !== void 0 && _.shapes !== void 0) {
        const b = _.shapes;
        if (Array.isArray(b))
          for (let j = 0, $ = b.length; j < $; j++) {
            const _e = b[j];
            d(e.shapes, _e);
          }
        else d(e.shapes, b);
      }
    }
    if (
      (this.isSkinnedMesh &&
        ((c.bindMode = this.bindMode),
        (c.bindMatrix = this.bindMatrix.toArray()),
        this.skeleton !== void 0 &&
          (d(e.skeletons, this.skeleton), (c.skeleton = this.skeleton.uuid))),
      this.material !== void 0)
    )
      if (Array.isArray(this.material)) {
        const _ = [];
        for (let b = 0, j = this.material.length; b < j; b++)
          _.push(d(e.materials, this.material[b]));
        c.material = _;
      } else c.material = d(e.materials, this.material);
    if (this.children.length > 0) {
      c.children = [];
      for (let _ = 0; _ < this.children.length; _++)
        c.children.push(this.children[_].toJSON(e).object);
    }
    if (this.animations.length > 0) {
      c.animations = [];
      for (let _ = 0; _ < this.animations.length; _++) {
        const b = this.animations[_];
        c.animations.push(d(e.animations, b));
      }
    }
    if (o) {
      const _ = g(e.geometries),
        b = g(e.materials),
        j = g(e.textures),
        $ = g(e.images),
        _e = g(e.shapes),
        et = g(e.skeletons),
        rt = g(e.animations),
        st = g(e.nodes);
      _.length > 0 && (a.geometries = _),
        b.length > 0 && (a.materials = b),
        j.length > 0 && (a.textures = j),
        $.length > 0 && (a.images = $),
        _e.length > 0 && (a.shapes = _e),
        et.length > 0 && (a.skeletons = et),
        rt.length > 0 && (a.animations = rt),
        st.length > 0 && (a.nodes = st);
    }
    return (a.object = c), a;
    function g(_) {
      const b = [];
      for (const j in _) {
        const $ = _[j];
        delete $.metadata, b.push($);
      }
      return b;
    }
  }
  clone(e) {
    return new this.constructor().copy(this, e);
  }
  copy(e, o = !0) {
    if (
      ((this.name = e.name),
      this.up.copy(e.up),
      this.position.copy(e.position),
      (this.rotation.order = e.rotation.order),
      this.quaternion.copy(e.quaternion),
      this.scale.copy(e.scale),
      this.matrix.copy(e.matrix),
      this.matrixWorld.copy(e.matrixWorld),
      (this.matrixAutoUpdate = e.matrixAutoUpdate),
      (this.matrixWorldAutoUpdate = e.matrixWorldAutoUpdate),
      (this.matrixWorldNeedsUpdate = e.matrixWorldNeedsUpdate),
      (this.layers.mask = e.layers.mask),
      (this.visible = e.visible),
      (this.castShadow = e.castShadow),
      (this.receiveShadow = e.receiveShadow),
      (this.frustumCulled = e.frustumCulled),
      (this.renderOrder = e.renderOrder),
      (this.animations = e.animations.slice()),
      (this.userData = JSON.parse(JSON.stringify(e.userData))),
      o === !0)
    )
      for (let a = 0; a < e.children.length; a++) {
        const c = e.children[a];
        this.add(c.clone());
      }
    return this;
  }
}
Object3D.DEFAULT_UP = new Vector3(0, 1, 0);
Object3D.DEFAULT_MATRIX_AUTO_UPDATE = !0;
Object3D.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = !0;
const _v0$2 = new Vector3(),
  _v1$3 = new Vector3(),
  _v2$2 = new Vector3(),
  _v3$2 = new Vector3(),
  _vab = new Vector3(),
  _vac = new Vector3(),
  _vbc = new Vector3(),
  _vap = new Vector3(),
  _vbp = new Vector3(),
  _vcp = new Vector3();
class Triangle {
  constructor(e = new Vector3(), o = new Vector3(), a = new Vector3()) {
    (this.a = e), (this.b = o), (this.c = a);
  }
  static getNormal(e, o, a, c) {
    c.subVectors(a, o), _v0$2.subVectors(e, o), c.cross(_v0$2);
    const d = c.lengthSq();
    return d > 0 ? c.multiplyScalar(1 / Math.sqrt(d)) : c.set(0, 0, 0);
  }
  static getBarycoord(e, o, a, c, d) {
    _v0$2.subVectors(c, o), _v1$3.subVectors(a, o), _v2$2.subVectors(e, o);
    const g = _v0$2.dot(_v0$2),
      _ = _v0$2.dot(_v1$3),
      b = _v0$2.dot(_v2$2),
      j = _v1$3.dot(_v1$3),
      $ = _v1$3.dot(_v2$2),
      _e = g * j - _ * _;
    if (_e === 0) return d.set(0, 0, 0), null;
    const et = 1 / _e,
      rt = (j * b - _ * $) * et,
      st = (g * $ - _ * b) * et;
    return d.set(1 - rt - st, st, rt);
  }
  static containsPoint(e, o, a, c) {
    return this.getBarycoord(e, o, a, c, _v3$2) === null
      ? !1
      : _v3$2.x >= 0 && _v3$2.y >= 0 && _v3$2.x + _v3$2.y <= 1;
  }
  static getInterpolation(e, o, a, c, d, g, _, b) {
    return this.getBarycoord(e, o, a, c, _v3$2) === null
      ? ((b.x = 0),
        (b.y = 0),
        "z" in b && (b.z = 0),
        "w" in b && (b.w = 0),
        null)
      : (b.setScalar(0),
        b.addScaledVector(d, _v3$2.x),
        b.addScaledVector(g, _v3$2.y),
        b.addScaledVector(_, _v3$2.z),
        b);
  }
  static isFrontFacing(e, o, a, c) {
    return (
      _v0$2.subVectors(a, o),
      _v1$3.subVectors(e, o),
      _v0$2.cross(_v1$3).dot(c) < 0
    );
  }
  set(e, o, a) {
    return this.a.copy(e), this.b.copy(o), this.c.copy(a), this;
  }
  setFromPointsAndIndices(e, o, a, c) {
    return this.a.copy(e[o]), this.b.copy(e[a]), this.c.copy(e[c]), this;
  }
  setFromAttributeAndIndices(e, o, a, c) {
    return (
      this.a.fromBufferAttribute(e, o),
      this.b.fromBufferAttribute(e, a),
      this.c.fromBufferAttribute(e, c),
      this
    );
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.a.copy(e.a), this.b.copy(e.b), this.c.copy(e.c), this;
  }
  getArea() {
    return (
      _v0$2.subVectors(this.c, this.b),
      _v1$3.subVectors(this.a, this.b),
      _v0$2.cross(_v1$3).length() * 0.5
    );
  }
  getMidpoint(e) {
    return e
      .addVectors(this.a, this.b)
      .add(this.c)
      .multiplyScalar(1 / 3);
  }
  getNormal(e) {
    return Triangle.getNormal(this.a, this.b, this.c, e);
  }
  getPlane(e) {
    return e.setFromCoplanarPoints(this.a, this.b, this.c);
  }
  getBarycoord(e, o) {
    return Triangle.getBarycoord(e, this.a, this.b, this.c, o);
  }
  getInterpolation(e, o, a, c, d) {
    return Triangle.getInterpolation(e, this.a, this.b, this.c, o, a, c, d);
  }
  containsPoint(e) {
    return Triangle.containsPoint(e, this.a, this.b, this.c);
  }
  isFrontFacing(e) {
    return Triangle.isFrontFacing(this.a, this.b, this.c, e);
  }
  intersectsBox(e) {
    return e.intersectsTriangle(this);
  }
  closestPointToPoint(e, o) {
    const a = this.a,
      c = this.b,
      d = this.c;
    let g, _;
    _vab.subVectors(c, a), _vac.subVectors(d, a), _vap.subVectors(e, a);
    const b = _vab.dot(_vap),
      j = _vac.dot(_vap);
    if (b <= 0 && j <= 0) return o.copy(a);
    _vbp.subVectors(e, c);
    const $ = _vab.dot(_vbp),
      _e = _vac.dot(_vbp);
    if ($ >= 0 && _e <= $) return o.copy(c);
    const et = b * _e - $ * j;
    if (et <= 0 && b >= 0 && $ <= 0)
      return (g = b / (b - $)), o.copy(a).addScaledVector(_vab, g);
    _vcp.subVectors(e, d);
    const rt = _vab.dot(_vcp),
      st = _vac.dot(_vcp);
    if (st >= 0 && rt <= st) return o.copy(d);
    const at = rt * j - b * st;
    if (at <= 0 && j >= 0 && st <= 0)
      return (_ = j / (j - st)), o.copy(a).addScaledVector(_vac, _);
    const ct = $ * st - rt * _e;
    if (ct <= 0 && _e - $ >= 0 && rt - st >= 0)
      return (
        _vbc.subVectors(d, c),
        (_ = (_e - $) / (_e - $ + (rt - st))),
        o.copy(c).addScaledVector(_vbc, _)
      );
    const it = 1 / (ct + at + et);
    return (
      (g = at * it),
      (_ = et * it),
      o.copy(a).addScaledVector(_vab, g).addScaledVector(_vac, _)
    );
  }
  equals(e) {
    return e.a.equals(this.a) && e.b.equals(this.b) && e.c.equals(this.c);
  }
}
const _colorKeywords = {
    aliceblue: 15792383,
    antiquewhite: 16444375,
    aqua: 65535,
    aquamarine: 8388564,
    azure: 15794175,
    beige: 16119260,
    bisque: 16770244,
    black: 0,
    blanchedalmond: 16772045,
    blue: 255,
    blueviolet: 9055202,
    brown: 10824234,
    burlywood: 14596231,
    cadetblue: 6266528,
    chartreuse: 8388352,
    chocolate: 13789470,
    coral: 16744272,
    cornflowerblue: 6591981,
    cornsilk: 16775388,
    crimson: 14423100,
    cyan: 65535,
    darkblue: 139,
    darkcyan: 35723,
    darkgoldenrod: 12092939,
    darkgray: 11119017,
    darkgreen: 25600,
    darkgrey: 11119017,
    darkkhaki: 12433259,
    darkmagenta: 9109643,
    darkolivegreen: 5597999,
    darkorange: 16747520,
    darkorchid: 10040012,
    darkred: 9109504,
    darksalmon: 15308410,
    darkseagreen: 9419919,
    darkslateblue: 4734347,
    darkslategray: 3100495,
    darkslategrey: 3100495,
    darkturquoise: 52945,
    darkviolet: 9699539,
    deeppink: 16716947,
    deepskyblue: 49151,
    dimgray: 6908265,
    dimgrey: 6908265,
    dodgerblue: 2003199,
    firebrick: 11674146,
    floralwhite: 16775920,
    forestgreen: 2263842,
    fuchsia: 16711935,
    gainsboro: 14474460,
    ghostwhite: 16316671,
    gold: 16766720,
    goldenrod: 14329120,
    gray: 8421504,
    green: 32768,
    greenyellow: 11403055,
    grey: 8421504,
    honeydew: 15794160,
    hotpink: 16738740,
    indianred: 13458524,
    indigo: 4915330,
    ivory: 16777200,
    khaki: 15787660,
    lavender: 15132410,
    lavenderblush: 16773365,
    lawngreen: 8190976,
    lemonchiffon: 16775885,
    lightblue: 11393254,
    lightcoral: 15761536,
    lightcyan: 14745599,
    lightgoldenrodyellow: 16448210,
    lightgray: 13882323,
    lightgreen: 9498256,
    lightgrey: 13882323,
    lightpink: 16758465,
    lightsalmon: 16752762,
    lightseagreen: 2142890,
    lightskyblue: 8900346,
    lightslategray: 7833753,
    lightslategrey: 7833753,
    lightsteelblue: 11584734,
    lightyellow: 16777184,
    lime: 65280,
    limegreen: 3329330,
    linen: 16445670,
    magenta: 16711935,
    maroon: 8388608,
    mediumaquamarine: 6737322,
    mediumblue: 205,
    mediumorchid: 12211667,
    mediumpurple: 9662683,
    mediumseagreen: 3978097,
    mediumslateblue: 8087790,
    mediumspringgreen: 64154,
    mediumturquoise: 4772300,
    mediumvioletred: 13047173,
    midnightblue: 1644912,
    mintcream: 16121850,
    mistyrose: 16770273,
    moccasin: 16770229,
    navajowhite: 16768685,
    navy: 128,
    oldlace: 16643558,
    olive: 8421376,
    olivedrab: 7048739,
    orange: 16753920,
    orangered: 16729344,
    orchid: 14315734,
    palegoldenrod: 15657130,
    palegreen: 10025880,
    paleturquoise: 11529966,
    palevioletred: 14381203,
    papayawhip: 16773077,
    peachpuff: 16767673,
    peru: 13468991,
    pink: 16761035,
    plum: 14524637,
    powderblue: 11591910,
    purple: 8388736,
    rebeccapurple: 6697881,
    red: 16711680,
    rosybrown: 12357519,
    royalblue: 4286945,
    saddlebrown: 9127187,
    salmon: 16416882,
    sandybrown: 16032864,
    seagreen: 3050327,
    seashell: 16774638,
    sienna: 10506797,
    silver: 12632256,
    skyblue: 8900331,
    slateblue: 6970061,
    slategray: 7372944,
    slategrey: 7372944,
    snow: 16775930,
    springgreen: 65407,
    steelblue: 4620980,
    tan: 13808780,
    teal: 32896,
    thistle: 14204888,
    tomato: 16737095,
    turquoise: 4251856,
    violet: 15631086,
    wheat: 16113331,
    white: 16777215,
    whitesmoke: 16119285,
    yellow: 16776960,
    yellowgreen: 10145074,
  },
  _hslA = { h: 0, s: 0, l: 0 },
  _hslB = { h: 0, s: 0, l: 0 };
function hue2rgb(s, e, o) {
  return (
    o < 0 && (o += 1),
    o > 1 && (o -= 1),
    o < 1 / 6
      ? s + (e - s) * 6 * o
      : o < 1 / 2
      ? e
      : o < 2 / 3
      ? s + (e - s) * 6 * (2 / 3 - o)
      : s
  );
}
class Color {
  constructor(e, o, a) {
    return (
      (this.isColor = !0),
      (this.r = 1),
      (this.g = 1),
      (this.b = 1),
      this.set(e, o, a)
    );
  }
  set(e, o, a) {
    if (o === void 0 && a === void 0) {
      const c = e;
      c && c.isColor
        ? this.copy(c)
        : typeof c == "number"
        ? this.setHex(c)
        : typeof c == "string" && this.setStyle(c);
    } else this.setRGB(e, o, a);
    return this;
  }
  setScalar(e) {
    return (this.r = e), (this.g = e), (this.b = e), this;
  }
  setHex(e, o = SRGBColorSpace$1) {
    return (
      (e = Math.floor(e)),
      (this.r = ((e >> 16) & 255) / 255),
      (this.g = ((e >> 8) & 255) / 255),
      (this.b = (e & 255) / 255),
      ColorManagement.toWorkingColorSpace(this, o),
      this
    );
  }
  setRGB(e, o, a, c = ColorManagement.workingColorSpace) {
    return (
      (this.r = e),
      (this.g = o),
      (this.b = a),
      ColorManagement.toWorkingColorSpace(this, c),
      this
    );
  }
  setHSL(e, o, a, c = ColorManagement.workingColorSpace) {
    if (
      ((e = euclideanModulo(e, 1)),
      (o = clamp(o, 0, 1)),
      (a = clamp(a, 0, 1)),
      o === 0)
    )
      this.r = this.g = this.b = a;
    else {
      const d = a <= 0.5 ? a * (1 + o) : a + o - a * o,
        g = 2 * a - d;
      (this.r = hue2rgb(g, d, e + 1 / 3)),
        (this.g = hue2rgb(g, d, e)),
        (this.b = hue2rgb(g, d, e - 1 / 3));
    }
    return ColorManagement.toWorkingColorSpace(this, c), this;
  }
  setStyle(e, o = SRGBColorSpace$1) {
    function a(d) {
      d !== void 0 &&
        parseFloat(d) < 1 &&
        console.warn(
          "THREE.Color: Alpha component of " + e + " will be ignored."
        );
    }
    let c;
    if ((c = /^(\w+)\(([^\)]*)\)/.exec(e))) {
      let d;
      const g = c[1],
        _ = c[2];
      switch (g) {
        case "rgb":
        case "rgba":
          if (
            (d =
              /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                _
              ))
          )
            return (
              a(d[4]),
              this.setRGB(
                Math.min(255, parseInt(d[1], 10)) / 255,
                Math.min(255, parseInt(d[2], 10)) / 255,
                Math.min(255, parseInt(d[3], 10)) / 255,
                o
              )
            );
          if (
            (d =
              /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                _
              ))
          )
            return (
              a(d[4]),
              this.setRGB(
                Math.min(100, parseInt(d[1], 10)) / 100,
                Math.min(100, parseInt(d[2], 10)) / 100,
                Math.min(100, parseInt(d[3], 10)) / 100,
                o
              )
            );
          break;
        case "hsl":
        case "hsla":
          if (
            (d =
              /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                _
              ))
          )
            return (
              a(d[4]),
              this.setHSL(
                parseFloat(d[1]) / 360,
                parseFloat(d[2]) / 100,
                parseFloat(d[3]) / 100,
                o
              )
            );
          break;
        default:
          console.warn("THREE.Color: Unknown color model " + e);
      }
    } else if ((c = /^\#([A-Fa-f\d]+)$/.exec(e))) {
      const d = c[1],
        g = d.length;
      if (g === 3)
        return this.setRGB(
          parseInt(d.charAt(0), 16) / 15,
          parseInt(d.charAt(1), 16) / 15,
          parseInt(d.charAt(2), 16) / 15,
          o
        );
      if (g === 6) return this.setHex(parseInt(d, 16), o);
      console.warn("THREE.Color: Invalid hex color " + e);
    } else if (e && e.length > 0) return this.setColorName(e, o);
    return this;
  }
  setColorName(e, o = SRGBColorSpace$1) {
    const a = _colorKeywords[e.toLowerCase()];
    return (
      a !== void 0
        ? this.setHex(a, o)
        : console.warn("THREE.Color: Unknown color " + e),
      this
    );
  }
  clone() {
    return new this.constructor(this.r, this.g, this.b);
  }
  copy(e) {
    return (this.r = e.r), (this.g = e.g), (this.b = e.b), this;
  }
  copySRGBToLinear(e) {
    return (
      (this.r = SRGBToLinear(e.r)),
      (this.g = SRGBToLinear(e.g)),
      (this.b = SRGBToLinear(e.b)),
      this
    );
  }
  copyLinearToSRGB(e) {
    return (
      (this.r = LinearToSRGB(e.r)),
      (this.g = LinearToSRGB(e.g)),
      (this.b = LinearToSRGB(e.b)),
      this
    );
  }
  convertSRGBToLinear() {
    return this.copySRGBToLinear(this), this;
  }
  convertLinearToSRGB() {
    return this.copyLinearToSRGB(this), this;
  }
  getHex(e = SRGBColorSpace$1) {
    return (
      ColorManagement.fromWorkingColorSpace(_color.copy(this), e),
      Math.round(clamp(_color.r * 255, 0, 255)) * 65536 +
        Math.round(clamp(_color.g * 255, 0, 255)) * 256 +
        Math.round(clamp(_color.b * 255, 0, 255))
    );
  }
  getHexString(e = SRGBColorSpace$1) {
    return ("000000" + this.getHex(e).toString(16)).slice(-6);
  }
  getHSL(e, o = ColorManagement.workingColorSpace) {
    ColorManagement.fromWorkingColorSpace(_color.copy(this), o);
    const a = _color.r,
      c = _color.g,
      d = _color.b,
      g = Math.max(a, c, d),
      _ = Math.min(a, c, d);
    let b, j;
    const $ = (_ + g) / 2;
    if (_ === g) (b = 0), (j = 0);
    else {
      const _e = g - _;
      switch (((j = $ <= 0.5 ? _e / (g + _) : _e / (2 - g - _)), g)) {
        case a:
          b = (c - d) / _e + (c < d ? 6 : 0);
          break;
        case c:
          b = (d - a) / _e + 2;
          break;
        case d:
          b = (a - c) / _e + 4;
          break;
      }
      b /= 6;
    }
    return (e.h = b), (e.s = j), (e.l = $), e;
  }
  getRGB(e, o = ColorManagement.workingColorSpace) {
    return (
      ColorManagement.fromWorkingColorSpace(_color.copy(this), o),
      (e.r = _color.r),
      (e.g = _color.g),
      (e.b = _color.b),
      e
    );
  }
  getStyle(e = SRGBColorSpace$1) {
    ColorManagement.fromWorkingColorSpace(_color.copy(this), e);
    const o = _color.r,
      a = _color.g,
      c = _color.b;
    return e !== SRGBColorSpace$1
      ? `color(${e} ${o.toFixed(3)} ${a.toFixed(3)} ${c.toFixed(3)})`
      : `rgb(${Math.round(o * 255)},${Math.round(a * 255)},${Math.round(
          c * 255
        )})`;
  }
  offsetHSL(e, o, a) {
    return (
      this.getHSL(_hslA), this.setHSL(_hslA.h + e, _hslA.s + o, _hslA.l + a)
    );
  }
  add(e) {
    return (this.r += e.r), (this.g += e.g), (this.b += e.b), this;
  }
  addColors(e, o) {
    return (
      (this.r = e.r + o.r), (this.g = e.g + o.g), (this.b = e.b + o.b), this
    );
  }
  addScalar(e) {
    return (this.r += e), (this.g += e), (this.b += e), this;
  }
  sub(e) {
    return (
      (this.r = Math.max(0, this.r - e.r)),
      (this.g = Math.max(0, this.g - e.g)),
      (this.b = Math.max(0, this.b - e.b)),
      this
    );
  }
  multiply(e) {
    return (this.r *= e.r), (this.g *= e.g), (this.b *= e.b), this;
  }
  multiplyScalar(e) {
    return (this.r *= e), (this.g *= e), (this.b *= e), this;
  }
  lerp(e, o) {
    return (
      (this.r += (e.r - this.r) * o),
      (this.g += (e.g - this.g) * o),
      (this.b += (e.b - this.b) * o),
      this
    );
  }
  lerpColors(e, o, a) {
    return (
      (this.r = e.r + (o.r - e.r) * a),
      (this.g = e.g + (o.g - e.g) * a),
      (this.b = e.b + (o.b - e.b) * a),
      this
    );
  }
  lerpHSL(e, o) {
    this.getHSL(_hslA), e.getHSL(_hslB);
    const a = lerp(_hslA.h, _hslB.h, o),
      c = lerp(_hslA.s, _hslB.s, o),
      d = lerp(_hslA.l, _hslB.l, o);
    return this.setHSL(a, c, d), this;
  }
  setFromVector3(e) {
    return (this.r = e.x), (this.g = e.y), (this.b = e.z), this;
  }
  applyMatrix3(e) {
    const o = this.r,
      a = this.g,
      c = this.b,
      d = e.elements;
    return (
      (this.r = d[0] * o + d[3] * a + d[6] * c),
      (this.g = d[1] * o + d[4] * a + d[7] * c),
      (this.b = d[2] * o + d[5] * a + d[8] * c),
      this
    );
  }
  equals(e) {
    return e.r === this.r && e.g === this.g && e.b === this.b;
  }
  fromArray(e, o = 0) {
    return (this.r = e[o]), (this.g = e[o + 1]), (this.b = e[o + 2]), this;
  }
  toArray(e = [], o = 0) {
    return (e[o] = this.r), (e[o + 1] = this.g), (e[o + 2] = this.b), e;
  }
  fromBufferAttribute(e, o) {
    return (
      (this.r = e.getX(o)), (this.g = e.getY(o)), (this.b = e.getZ(o)), this
    );
  }
  toJSON() {
    return this.getHex();
  }
  *[Symbol.iterator]() {
    yield this.r, yield this.g, yield this.b;
  }
}
const _color = new Color();
Color.NAMES = _colorKeywords;
let _materialId = 0;
class Material extends EventDispatcher {
  constructor() {
    super(),
      (this.isMaterial = !0),
      Object.defineProperty(this, "id", { value: _materialId++ }),
      (this.uuid = generateUUID()),
      (this.name = ""),
      (this.type = "Material"),
      (this.blending = NormalBlending),
      (this.side = FrontSide),
      (this.vertexColors = !1),
      (this.opacity = 1),
      (this.transparent = !1),
      (this.alphaHash = !1),
      (this.blendSrc = SrcAlphaFactor),
      (this.blendDst = OneMinusSrcAlphaFactor),
      (this.blendEquation = AddEquation),
      (this.blendSrcAlpha = null),
      (this.blendDstAlpha = null),
      (this.blendEquationAlpha = null),
      (this.blendColor = new Color(0, 0, 0)),
      (this.blendAlpha = 0),
      (this.depthFunc = LessEqualDepth),
      (this.depthTest = !0),
      (this.depthWrite = !0),
      (this.stencilWriteMask = 255),
      (this.stencilFunc = AlwaysStencilFunc),
      (this.stencilRef = 0),
      (this.stencilFuncMask = 255),
      (this.stencilFail = KeepStencilOp),
      (this.stencilZFail = KeepStencilOp),
      (this.stencilZPass = KeepStencilOp),
      (this.stencilWrite = !1),
      (this.clippingPlanes = null),
      (this.clipIntersection = !1),
      (this.clipShadows = !1),
      (this.shadowSide = null),
      (this.colorWrite = !0),
      (this.precision = null),
      (this.polygonOffset = !1),
      (this.polygonOffsetFactor = 0),
      (this.polygonOffsetUnits = 0),
      (this.dithering = !1),
      (this.alphaToCoverage = !1),
      (this.premultipliedAlpha = !1),
      (this.forceSinglePass = !1),
      (this.visible = !0),
      (this.toneMapped = !0),
      (this.userData = {}),
      (this.version = 0),
      (this._alphaTest = 0);
  }
  get alphaTest() {
    return this._alphaTest;
  }
  set alphaTest(e) {
    this._alphaTest > 0 != e > 0 && this.version++, (this._alphaTest = e);
  }
  onBeforeCompile() {}
  customProgramCacheKey() {
    return this.onBeforeCompile.toString();
  }
  setValues(e) {
    if (e !== void 0)
      for (const o in e) {
        const a = e[o];
        if (a === void 0) {
          console.warn(
            `THREE.Material: parameter '${o}' has value of undefined.`
          );
          continue;
        }
        const c = this[o];
        if (c === void 0) {
          console.warn(
            `THREE.Material: '${o}' is not a property of THREE.${this.type}.`
          );
          continue;
        }
        c && c.isColor
          ? c.set(a)
          : c && c.isVector3 && a && a.isVector3
          ? c.copy(a)
          : (this[o] = a);
      }
  }
  toJSON(e) {
    const o = e === void 0 || typeof e == "string";
    o && (e = { textures: {}, images: {} });
    const a = {
      metadata: {
        version: 4.6,
        type: "Material",
        generator: "Material.toJSON",
      },
    };
    (a.uuid = this.uuid),
      (a.type = this.type),
      this.name !== "" && (a.name = this.name),
      this.color && this.color.isColor && (a.color = this.color.getHex()),
      this.roughness !== void 0 && (a.roughness = this.roughness),
      this.metalness !== void 0 && (a.metalness = this.metalness),
      this.sheen !== void 0 && (a.sheen = this.sheen),
      this.sheenColor &&
        this.sheenColor.isColor &&
        (a.sheenColor = this.sheenColor.getHex()),
      this.sheenRoughness !== void 0 &&
        (a.sheenRoughness = this.sheenRoughness),
      this.emissive &&
        this.emissive.isColor &&
        (a.emissive = this.emissive.getHex()),
      this.emissiveIntensity !== void 0 &&
        this.emissiveIntensity !== 1 &&
        (a.emissiveIntensity = this.emissiveIntensity),
      this.specular &&
        this.specular.isColor &&
        (a.specular = this.specular.getHex()),
      this.specularIntensity !== void 0 &&
        (a.specularIntensity = this.specularIntensity),
      this.specularColor &&
        this.specularColor.isColor &&
        (a.specularColor = this.specularColor.getHex()),
      this.shininess !== void 0 && (a.shininess = this.shininess),
      this.clearcoat !== void 0 && (a.clearcoat = this.clearcoat),
      this.clearcoatRoughness !== void 0 &&
        (a.clearcoatRoughness = this.clearcoatRoughness),
      this.clearcoatMap &&
        this.clearcoatMap.isTexture &&
        (a.clearcoatMap = this.clearcoatMap.toJSON(e).uuid),
      this.clearcoatRoughnessMap &&
        this.clearcoatRoughnessMap.isTexture &&
        (a.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(e).uuid),
      this.clearcoatNormalMap &&
        this.clearcoatNormalMap.isTexture &&
        ((a.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(e).uuid),
        (a.clearcoatNormalScale = this.clearcoatNormalScale.toArray())),
      this.dispersion !== void 0 && (a.dispersion = this.dispersion),
      this.iridescence !== void 0 && (a.iridescence = this.iridescence),
      this.iridescenceIOR !== void 0 &&
        (a.iridescenceIOR = this.iridescenceIOR),
      this.iridescenceThicknessRange !== void 0 &&
        (a.iridescenceThicknessRange = this.iridescenceThicknessRange),
      this.iridescenceMap &&
        this.iridescenceMap.isTexture &&
        (a.iridescenceMap = this.iridescenceMap.toJSON(e).uuid),
      this.iridescenceThicknessMap &&
        this.iridescenceThicknessMap.isTexture &&
        (a.iridescenceThicknessMap =
          this.iridescenceThicknessMap.toJSON(e).uuid),
      this.anisotropy !== void 0 && (a.anisotropy = this.anisotropy),
      this.anisotropyRotation !== void 0 &&
        (a.anisotropyRotation = this.anisotropyRotation),
      this.anisotropyMap &&
        this.anisotropyMap.isTexture &&
        (a.anisotropyMap = this.anisotropyMap.toJSON(e).uuid),
      this.map && this.map.isTexture && (a.map = this.map.toJSON(e).uuid),
      this.matcap &&
        this.matcap.isTexture &&
        (a.matcap = this.matcap.toJSON(e).uuid),
      this.alphaMap &&
        this.alphaMap.isTexture &&
        (a.alphaMap = this.alphaMap.toJSON(e).uuid),
      this.lightMap &&
        this.lightMap.isTexture &&
        ((a.lightMap = this.lightMap.toJSON(e).uuid),
        (a.lightMapIntensity = this.lightMapIntensity)),
      this.aoMap &&
        this.aoMap.isTexture &&
        ((a.aoMap = this.aoMap.toJSON(e).uuid),
        (a.aoMapIntensity = this.aoMapIntensity)),
      this.bumpMap &&
        this.bumpMap.isTexture &&
        ((a.bumpMap = this.bumpMap.toJSON(e).uuid),
        (a.bumpScale = this.bumpScale)),
      this.normalMap &&
        this.normalMap.isTexture &&
        ((a.normalMap = this.normalMap.toJSON(e).uuid),
        (a.normalMapType = this.normalMapType),
        (a.normalScale = this.normalScale.toArray())),
      this.displacementMap &&
        this.displacementMap.isTexture &&
        ((a.displacementMap = this.displacementMap.toJSON(e).uuid),
        (a.displacementScale = this.displacementScale),
        (a.displacementBias = this.displacementBias)),
      this.roughnessMap &&
        this.roughnessMap.isTexture &&
        (a.roughnessMap = this.roughnessMap.toJSON(e).uuid),
      this.metalnessMap &&
        this.metalnessMap.isTexture &&
        (a.metalnessMap = this.metalnessMap.toJSON(e).uuid),
      this.emissiveMap &&
        this.emissiveMap.isTexture &&
        (a.emissiveMap = this.emissiveMap.toJSON(e).uuid),
      this.specularMap &&
        this.specularMap.isTexture &&
        (a.specularMap = this.specularMap.toJSON(e).uuid),
      this.specularIntensityMap &&
        this.specularIntensityMap.isTexture &&
        (a.specularIntensityMap = this.specularIntensityMap.toJSON(e).uuid),
      this.specularColorMap &&
        this.specularColorMap.isTexture &&
        (a.specularColorMap = this.specularColorMap.toJSON(e).uuid),
      this.envMap &&
        this.envMap.isTexture &&
        ((a.envMap = this.envMap.toJSON(e).uuid),
        this.combine !== void 0 && (a.combine = this.combine)),
      this.envMapRotation !== void 0 &&
        (a.envMapRotation = this.envMapRotation.toArray()),
      this.envMapIntensity !== void 0 &&
        (a.envMapIntensity = this.envMapIntensity),
      this.reflectivity !== void 0 && (a.reflectivity = this.reflectivity),
      this.refractionRatio !== void 0 &&
        (a.refractionRatio = this.refractionRatio),
      this.gradientMap &&
        this.gradientMap.isTexture &&
        (a.gradientMap = this.gradientMap.toJSON(e).uuid),
      this.transmission !== void 0 && (a.transmission = this.transmission),
      this.transmissionMap &&
        this.transmissionMap.isTexture &&
        (a.transmissionMap = this.transmissionMap.toJSON(e).uuid),
      this.thickness !== void 0 && (a.thickness = this.thickness),
      this.thicknessMap &&
        this.thicknessMap.isTexture &&
        (a.thicknessMap = this.thicknessMap.toJSON(e).uuid),
      this.attenuationDistance !== void 0 &&
        this.attenuationDistance !== 1 / 0 &&
        (a.attenuationDistance = this.attenuationDistance),
      this.attenuationColor !== void 0 &&
        (a.attenuationColor = this.attenuationColor.getHex()),
      this.size !== void 0 && (a.size = this.size),
      this.shadowSide !== null && (a.shadowSide = this.shadowSide),
      this.sizeAttenuation !== void 0 &&
        (a.sizeAttenuation = this.sizeAttenuation),
      this.blending !== NormalBlending && (a.blending = this.blending),
      this.side !== FrontSide && (a.side = this.side),
      this.vertexColors === !0 && (a.vertexColors = !0),
      this.opacity < 1 && (a.opacity = this.opacity),
      this.transparent === !0 && (a.transparent = !0),
      this.blendSrc !== SrcAlphaFactor && (a.blendSrc = this.blendSrc),
      this.blendDst !== OneMinusSrcAlphaFactor && (a.blendDst = this.blendDst),
      this.blendEquation !== AddEquation &&
        (a.blendEquation = this.blendEquation),
      this.blendSrcAlpha !== null && (a.blendSrcAlpha = this.blendSrcAlpha),
      this.blendDstAlpha !== null && (a.blendDstAlpha = this.blendDstAlpha),
      this.blendEquationAlpha !== null &&
        (a.blendEquationAlpha = this.blendEquationAlpha),
      this.blendColor &&
        this.blendColor.isColor &&
        (a.blendColor = this.blendColor.getHex()),
      this.blendAlpha !== 0 && (a.blendAlpha = this.blendAlpha),
      this.depthFunc !== LessEqualDepth && (a.depthFunc = this.depthFunc),
      this.depthTest === !1 && (a.depthTest = this.depthTest),
      this.depthWrite === !1 && (a.depthWrite = this.depthWrite),
      this.colorWrite === !1 && (a.colorWrite = this.colorWrite),
      this.stencilWriteMask !== 255 &&
        (a.stencilWriteMask = this.stencilWriteMask),
      this.stencilFunc !== AlwaysStencilFunc &&
        (a.stencilFunc = this.stencilFunc),
      this.stencilRef !== 0 && (a.stencilRef = this.stencilRef),
      this.stencilFuncMask !== 255 &&
        (a.stencilFuncMask = this.stencilFuncMask),
      this.stencilFail !== KeepStencilOp && (a.stencilFail = this.stencilFail),
      this.stencilZFail !== KeepStencilOp &&
        (a.stencilZFail = this.stencilZFail),
      this.stencilZPass !== KeepStencilOp &&
        (a.stencilZPass = this.stencilZPass),
      this.stencilWrite === !0 && (a.stencilWrite = this.stencilWrite),
      this.rotation !== void 0 &&
        this.rotation !== 0 &&
        (a.rotation = this.rotation),
      this.polygonOffset === !0 && (a.polygonOffset = !0),
      this.polygonOffsetFactor !== 0 &&
        (a.polygonOffsetFactor = this.polygonOffsetFactor),
      this.polygonOffsetUnits !== 0 &&
        (a.polygonOffsetUnits = this.polygonOffsetUnits),
      this.linewidth !== void 0 &&
        this.linewidth !== 1 &&
        (a.linewidth = this.linewidth),
      this.dashSize !== void 0 && (a.dashSize = this.dashSize),
      this.gapSize !== void 0 && (a.gapSize = this.gapSize),
      this.scale !== void 0 && (a.scale = this.scale),
      this.dithering === !0 && (a.dithering = !0),
      this.alphaTest > 0 && (a.alphaTest = this.alphaTest),
      this.alphaHash === !0 && (a.alphaHash = !0),
      this.alphaToCoverage === !0 && (a.alphaToCoverage = !0),
      this.premultipliedAlpha === !0 && (a.premultipliedAlpha = !0),
      this.forceSinglePass === !0 && (a.forceSinglePass = !0),
      this.wireframe === !0 && (a.wireframe = !0),
      this.wireframeLinewidth > 1 &&
        (a.wireframeLinewidth = this.wireframeLinewidth),
      this.wireframeLinecap !== "round" &&
        (a.wireframeLinecap = this.wireframeLinecap),
      this.wireframeLinejoin !== "round" &&
        (a.wireframeLinejoin = this.wireframeLinejoin),
      this.flatShading === !0 && (a.flatShading = !0),
      this.visible === !1 && (a.visible = !1),
      this.toneMapped === !1 && (a.toneMapped = !1),
      this.fog === !1 && (a.fog = !1),
      Object.keys(this.userData).length > 0 && (a.userData = this.userData);
    function c(d) {
      const g = [];
      for (const _ in d) {
        const b = d[_];
        delete b.metadata, g.push(b);
      }
      return g;
    }
    if (o) {
      const d = c(e.textures),
        g = c(e.images);
      d.length > 0 && (a.textures = d), g.length > 0 && (a.images = g);
    }
    return a;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    (this.name = e.name),
      (this.blending = e.blending),
      (this.side = e.side),
      (this.vertexColors = e.vertexColors),
      (this.opacity = e.opacity),
      (this.transparent = e.transparent),
      (this.blendSrc = e.blendSrc),
      (this.blendDst = e.blendDst),
      (this.blendEquation = e.blendEquation),
      (this.blendSrcAlpha = e.blendSrcAlpha),
      (this.blendDstAlpha = e.blendDstAlpha),
      (this.blendEquationAlpha = e.blendEquationAlpha),
      this.blendColor.copy(e.blendColor),
      (this.blendAlpha = e.blendAlpha),
      (this.depthFunc = e.depthFunc),
      (this.depthTest = e.depthTest),
      (this.depthWrite = e.depthWrite),
      (this.stencilWriteMask = e.stencilWriteMask),
      (this.stencilFunc = e.stencilFunc),
      (this.stencilRef = e.stencilRef),
      (this.stencilFuncMask = e.stencilFuncMask),
      (this.stencilFail = e.stencilFail),
      (this.stencilZFail = e.stencilZFail),
      (this.stencilZPass = e.stencilZPass),
      (this.stencilWrite = e.stencilWrite);
    const o = e.clippingPlanes;
    let a = null;
    if (o !== null) {
      const c = o.length;
      a = new Array(c);
      for (let d = 0; d !== c; ++d) a[d] = o[d].clone();
    }
    return (
      (this.clippingPlanes = a),
      (this.clipIntersection = e.clipIntersection),
      (this.clipShadows = e.clipShadows),
      (this.shadowSide = e.shadowSide),
      (this.colorWrite = e.colorWrite),
      (this.precision = e.precision),
      (this.polygonOffset = e.polygonOffset),
      (this.polygonOffsetFactor = e.polygonOffsetFactor),
      (this.polygonOffsetUnits = e.polygonOffsetUnits),
      (this.dithering = e.dithering),
      (this.alphaTest = e.alphaTest),
      (this.alphaHash = e.alphaHash),
      (this.alphaToCoverage = e.alphaToCoverage),
      (this.premultipliedAlpha = e.premultipliedAlpha),
      (this.forceSinglePass = e.forceSinglePass),
      (this.visible = e.visible),
      (this.toneMapped = e.toneMapped),
      (this.userData = JSON.parse(JSON.stringify(e.userData))),
      this
    );
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  onBuild() {
    console.warn("Material: onBuild() has been removed.");
  }
  onBeforeRender() {
    console.warn("Material: onBeforeRender() has been removed.");
  }
}
class MeshBasicMaterial extends Material {
  constructor(e) {
    super(),
      (this.isMeshBasicMaterial = !0),
      (this.type = "MeshBasicMaterial"),
      (this.color = new Color(16777215)),
      (this.map = null),
      (this.lightMap = null),
      (this.lightMapIntensity = 1),
      (this.aoMap = null),
      (this.aoMapIntensity = 1),
      (this.specularMap = null),
      (this.alphaMap = null),
      (this.envMap = null),
      (this.envMapRotation = new Euler()),
      (this.combine = MultiplyOperation),
      (this.reflectivity = 1),
      (this.refractionRatio = 0.98),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.wireframeLinecap = "round"),
      (this.wireframeLinejoin = "round"),
      (this.fog = !0),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      this.color.copy(e.color),
      (this.map = e.map),
      (this.lightMap = e.lightMap),
      (this.lightMapIntensity = e.lightMapIntensity),
      (this.aoMap = e.aoMap),
      (this.aoMapIntensity = e.aoMapIntensity),
      (this.specularMap = e.specularMap),
      (this.alphaMap = e.alphaMap),
      (this.envMap = e.envMap),
      this.envMapRotation.copy(e.envMapRotation),
      (this.combine = e.combine),
      (this.reflectivity = e.reflectivity),
      (this.refractionRatio = e.refractionRatio),
      (this.wireframe = e.wireframe),
      (this.wireframeLinewidth = e.wireframeLinewidth),
      (this.wireframeLinecap = e.wireframeLinecap),
      (this.wireframeLinejoin = e.wireframeLinejoin),
      (this.fog = e.fog),
      this
    );
  }
}
const _tables = _generateTables();
function _generateTables() {
  const s = new ArrayBuffer(4),
    e = new Float32Array(s),
    o = new Uint32Array(s),
    a = new Uint32Array(512),
    c = new Uint32Array(512);
  for (let b = 0; b < 256; ++b) {
    const j = b - 127;
    j < -27
      ? ((a[b] = 0), (a[b | 256] = 32768), (c[b] = 24), (c[b | 256] = 24))
      : j < -14
      ? ((a[b] = 1024 >> (-j - 14)),
        (a[b | 256] = (1024 >> (-j - 14)) | 32768),
        (c[b] = -j - 1),
        (c[b | 256] = -j - 1))
      : j <= 15
      ? ((a[b] = (j + 15) << 10),
        (a[b | 256] = ((j + 15) << 10) | 32768),
        (c[b] = 13),
        (c[b | 256] = 13))
      : j < 128
      ? ((a[b] = 31744), (a[b | 256] = 64512), (c[b] = 24), (c[b | 256] = 24))
      : ((a[b] = 31744), (a[b | 256] = 64512), (c[b] = 13), (c[b | 256] = 13));
  }
  const d = new Uint32Array(2048),
    g = new Uint32Array(64),
    _ = new Uint32Array(64);
  for (let b = 1; b < 1024; ++b) {
    let j = b << 13,
      $ = 0;
    for (; !(j & 8388608); ) (j <<= 1), ($ -= 8388608);
    (j &= -8388609), ($ += 947912704), (d[b] = j | $);
  }
  for (let b = 1024; b < 2048; ++b) d[b] = 939524096 + ((b - 1024) << 13);
  for (let b = 1; b < 31; ++b) g[b] = b << 23;
  (g[31] = 1199570944), (g[32] = 2147483648);
  for (let b = 33; b < 63; ++b) g[b] = 2147483648 + ((b - 32) << 23);
  g[63] = 3347054592;
  for (let b = 1; b < 64; ++b) b !== 32 && (_[b] = 1024);
  return {
    floatView: e,
    uint32View: o,
    baseTable: a,
    shiftTable: c,
    mantissaTable: d,
    exponentTable: g,
    offsetTable: _,
  };
}
function toHalfFloat(s) {
  Math.abs(s) > 65504 &&
    console.warn("THREE.DataUtils.toHalfFloat(): Value out of range."),
    (s = clamp(s, -65504, 65504)),
    (_tables.floatView[0] = s);
  const e = _tables.uint32View[0],
    o = (e >> 23) & 511;
  return _tables.baseTable[o] + ((e & 8388607) >> _tables.shiftTable[o]);
}
function fromHalfFloat(s) {
  const e = s >> 10;
  return (
    (_tables.uint32View[0] =
      _tables.mantissaTable[_tables.offsetTable[e] + (s & 1023)] +
      _tables.exponentTable[e]),
    _tables.floatView[0]
  );
}
const DataUtils = { toHalfFloat, fromHalfFloat },
  _vector$9 = new Vector3(),
  _vector2$1 = new Vector2();
class BufferAttribute {
  constructor(e, o, a = !1) {
    if (Array.isArray(e))
      throw new TypeError(
        "THREE.BufferAttribute: array should be a Typed Array."
      );
    (this.isBufferAttribute = !0),
      (this.name = ""),
      (this.array = e),
      (this.itemSize = o),
      (this.count = e !== void 0 ? e.length / o : 0),
      (this.normalized = a),
      (this.usage = StaticDrawUsage),
      (this._updateRange = { offset: 0, count: -1 }),
      (this.updateRanges = []),
      (this.gpuType = FloatType),
      (this.version = 0);
  }
  onUploadCallback() {}
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  get updateRange() {
    return (
      warnOnce(
        "THREE.BufferAttribute: updateRange() is deprecated and will be removed in r169. Use addUpdateRange() instead."
      ),
      this._updateRange
    );
  }
  setUsage(e) {
    return (this.usage = e), this;
  }
  addUpdateRange(e, o) {
    this.updateRanges.push({ start: e, count: o });
  }
  clearUpdateRanges() {
    this.updateRanges.length = 0;
  }
  copy(e) {
    return (
      (this.name = e.name),
      (this.array = new e.array.constructor(e.array)),
      (this.itemSize = e.itemSize),
      (this.count = e.count),
      (this.normalized = e.normalized),
      (this.usage = e.usage),
      (this.gpuType = e.gpuType),
      this
    );
  }
  copyAt(e, o, a) {
    (e *= this.itemSize), (a *= o.itemSize);
    for (let c = 0, d = this.itemSize; c < d; c++)
      this.array[e + c] = o.array[a + c];
    return this;
  }
  copyArray(e) {
    return this.array.set(e), this;
  }
  applyMatrix3(e) {
    if (this.itemSize === 2)
      for (let o = 0, a = this.count; o < a; o++)
        _vector2$1.fromBufferAttribute(this, o),
          _vector2$1.applyMatrix3(e),
          this.setXY(o, _vector2$1.x, _vector2$1.y);
    else if (this.itemSize === 3)
      for (let o = 0, a = this.count; o < a; o++)
        _vector$9.fromBufferAttribute(this, o),
          _vector$9.applyMatrix3(e),
          this.setXYZ(o, _vector$9.x, _vector$9.y, _vector$9.z);
    return this;
  }
  applyMatrix4(e) {
    for (let o = 0, a = this.count; o < a; o++)
      _vector$9.fromBufferAttribute(this, o),
        _vector$9.applyMatrix4(e),
        this.setXYZ(o, _vector$9.x, _vector$9.y, _vector$9.z);
    return this;
  }
  applyNormalMatrix(e) {
    for (let o = 0, a = this.count; o < a; o++)
      _vector$9.fromBufferAttribute(this, o),
        _vector$9.applyNormalMatrix(e),
        this.setXYZ(o, _vector$9.x, _vector$9.y, _vector$9.z);
    return this;
  }
  transformDirection(e) {
    for (let o = 0, a = this.count; o < a; o++)
      _vector$9.fromBufferAttribute(this, o),
        _vector$9.transformDirection(e),
        this.setXYZ(o, _vector$9.x, _vector$9.y, _vector$9.z);
    return this;
  }
  set(e, o = 0) {
    return this.array.set(e, o), this;
  }
  getComponent(e, o) {
    let a = this.array[e * this.itemSize + o];
    return this.normalized && (a = denormalize(a, this.array)), a;
  }
  setComponent(e, o, a) {
    return (
      this.normalized && (a = normalize(a, this.array)),
      (this.array[e * this.itemSize + o] = a),
      this
    );
  }
  getX(e) {
    let o = this.array[e * this.itemSize];
    return this.normalized && (o = denormalize(o, this.array)), o;
  }
  setX(e, o) {
    return (
      this.normalized && (o = normalize(o, this.array)),
      (this.array[e * this.itemSize] = o),
      this
    );
  }
  getY(e) {
    let o = this.array[e * this.itemSize + 1];
    return this.normalized && (o = denormalize(o, this.array)), o;
  }
  setY(e, o) {
    return (
      this.normalized && (o = normalize(o, this.array)),
      (this.array[e * this.itemSize + 1] = o),
      this
    );
  }
  getZ(e) {
    let o = this.array[e * this.itemSize + 2];
    return this.normalized && (o = denormalize(o, this.array)), o;
  }
  setZ(e, o) {
    return (
      this.normalized && (o = normalize(o, this.array)),
      (this.array[e * this.itemSize + 2] = o),
      this
    );
  }
  getW(e) {
    let o = this.array[e * this.itemSize + 3];
    return this.normalized && (o = denormalize(o, this.array)), o;
  }
  setW(e, o) {
    return (
      this.normalized && (o = normalize(o, this.array)),
      (this.array[e * this.itemSize + 3] = o),
      this
    );
  }
  setXY(e, o, a) {
    return (
      (e *= this.itemSize),
      this.normalized &&
        ((o = normalize(o, this.array)), (a = normalize(a, this.array))),
      (this.array[e + 0] = o),
      (this.array[e + 1] = a),
      this
    );
  }
  setXYZ(e, o, a, c) {
    return (
      (e *= this.itemSize),
      this.normalized &&
        ((o = normalize(o, this.array)),
        (a = normalize(a, this.array)),
        (c = normalize(c, this.array))),
      (this.array[e + 0] = o),
      (this.array[e + 1] = a),
      (this.array[e + 2] = c),
      this
    );
  }
  setXYZW(e, o, a, c, d) {
    return (
      (e *= this.itemSize),
      this.normalized &&
        ((o = normalize(o, this.array)),
        (a = normalize(a, this.array)),
        (c = normalize(c, this.array)),
        (d = normalize(d, this.array))),
      (this.array[e + 0] = o),
      (this.array[e + 1] = a),
      (this.array[e + 2] = c),
      (this.array[e + 3] = d),
      this
    );
  }
  onUpload(e) {
    return (this.onUploadCallback = e), this;
  }
  clone() {
    return new this.constructor(this.array, this.itemSize).copy(this);
  }
  toJSON() {
    const e = {
      itemSize: this.itemSize,
      type: this.array.constructor.name,
      array: Array.from(this.array),
      normalized: this.normalized,
    };
    return (
      this.name !== "" && (e.name = this.name),
      this.usage !== StaticDrawUsage && (e.usage = this.usage),
      e
    );
  }
}
class Int8BufferAttribute extends BufferAttribute {
  constructor(e, o, a) {
    super(new Int8Array(e), o, a);
  }
}
class Uint8BufferAttribute extends BufferAttribute {
  constructor(e, o, a) {
    super(new Uint8Array(e), o, a);
  }
}
class Uint8ClampedBufferAttribute extends BufferAttribute {
  constructor(e, o, a) {
    super(new Uint8ClampedArray(e), o, a);
  }
}
class Int16BufferAttribute extends BufferAttribute {
  constructor(e, o, a) {
    super(new Int16Array(e), o, a);
  }
}
class Uint16BufferAttribute extends BufferAttribute {
  constructor(e, o, a) {
    super(new Uint16Array(e), o, a);
  }
}
class Int32BufferAttribute extends BufferAttribute {
  constructor(e, o, a) {
    super(new Int32Array(e), o, a);
  }
}
class Uint32BufferAttribute extends BufferAttribute {
  constructor(e, o, a) {
    super(new Uint32Array(e), o, a);
  }
}
class Float16BufferAttribute extends BufferAttribute {
  constructor(e, o, a) {
    super(new Uint16Array(e), o, a), (this.isFloat16BufferAttribute = !0);
  }
  getX(e) {
    let o = fromHalfFloat(this.array[e * this.itemSize]);
    return this.normalized && (o = denormalize(o, this.array)), o;
  }
  setX(e, o) {
    return (
      this.normalized && (o = normalize(o, this.array)),
      (this.array[e * this.itemSize] = toHalfFloat(o)),
      this
    );
  }
  getY(e) {
    let o = fromHalfFloat(this.array[e * this.itemSize + 1]);
    return this.normalized && (o = denormalize(o, this.array)), o;
  }
  setY(e, o) {
    return (
      this.normalized && (o = normalize(o, this.array)),
      (this.array[e * this.itemSize + 1] = toHalfFloat(o)),
      this
    );
  }
  getZ(e) {
    let o = fromHalfFloat(this.array[e * this.itemSize + 2]);
    return this.normalized && (o = denormalize(o, this.array)), o;
  }
  setZ(e, o) {
    return (
      this.normalized && (o = normalize(o, this.array)),
      (this.array[e * this.itemSize + 2] = toHalfFloat(o)),
      this
    );
  }
  getW(e) {
    let o = fromHalfFloat(this.array[e * this.itemSize + 3]);
    return this.normalized && (o = denormalize(o, this.array)), o;
  }
  setW(e, o) {
    return (
      this.normalized && (o = normalize(o, this.array)),
      (this.array[e * this.itemSize + 3] = toHalfFloat(o)),
      this
    );
  }
  setXY(e, o, a) {
    return (
      (e *= this.itemSize),
      this.normalized &&
        ((o = normalize(o, this.array)), (a = normalize(a, this.array))),
      (this.array[e + 0] = toHalfFloat(o)),
      (this.array[e + 1] = toHalfFloat(a)),
      this
    );
  }
  setXYZ(e, o, a, c) {
    return (
      (e *= this.itemSize),
      this.normalized &&
        ((o = normalize(o, this.array)),
        (a = normalize(a, this.array)),
        (c = normalize(c, this.array))),
      (this.array[e + 0] = toHalfFloat(o)),
      (this.array[e + 1] = toHalfFloat(a)),
      (this.array[e + 2] = toHalfFloat(c)),
      this
    );
  }
  setXYZW(e, o, a, c, d) {
    return (
      (e *= this.itemSize),
      this.normalized &&
        ((o = normalize(o, this.array)),
        (a = normalize(a, this.array)),
        (c = normalize(c, this.array)),
        (d = normalize(d, this.array))),
      (this.array[e + 0] = toHalfFloat(o)),
      (this.array[e + 1] = toHalfFloat(a)),
      (this.array[e + 2] = toHalfFloat(c)),
      (this.array[e + 3] = toHalfFloat(d)),
      this
    );
  }
}
class Float32BufferAttribute extends BufferAttribute {
  constructor(e, o, a) {
    super(new Float32Array(e), o, a);
  }
}
let _id$2 = 0;
const _m1$2 = new Matrix4(),
  _obj = new Object3D(),
  _offset = new Vector3(),
  _box$2 = new Box3(),
  _boxMorphTargets = new Box3(),
  _vector$8 = new Vector3();
class BufferGeometry extends EventDispatcher {
  constructor() {
    super(),
      (this.isBufferGeometry = !0),
      Object.defineProperty(this, "id", { value: _id$2++ }),
      (this.uuid = generateUUID()),
      (this.name = ""),
      (this.type = "BufferGeometry"),
      (this.index = null),
      (this.attributes = {}),
      (this.morphAttributes = {}),
      (this.morphTargetsRelative = !1),
      (this.groups = []),
      (this.boundingBox = null),
      (this.boundingSphere = null),
      (this.drawRange = { start: 0, count: 1 / 0 }),
      (this.userData = {});
  }
  getIndex() {
    return this.index;
  }
  setIndex(e) {
    return (
      Array.isArray(e)
        ? (this.index = new (
            arrayNeedsUint32(e) ? Uint32BufferAttribute : Uint16BufferAttribute
          )(e, 1))
        : (this.index = e),
      this
    );
  }
  getAttribute(e) {
    return this.attributes[e];
  }
  setAttribute(e, o) {
    return (this.attributes[e] = o), this;
  }
  deleteAttribute(e) {
    return delete this.attributes[e], this;
  }
  hasAttribute(e) {
    return this.attributes[e] !== void 0;
  }
  addGroup(e, o, a = 0) {
    this.groups.push({ start: e, count: o, materialIndex: a });
  }
  clearGroups() {
    this.groups = [];
  }
  setDrawRange(e, o) {
    (this.drawRange.start = e), (this.drawRange.count = o);
  }
  applyMatrix4(e) {
    const o = this.attributes.position;
    o !== void 0 && (o.applyMatrix4(e), (o.needsUpdate = !0));
    const a = this.attributes.normal;
    if (a !== void 0) {
      const d = new Matrix3().getNormalMatrix(e);
      a.applyNormalMatrix(d), (a.needsUpdate = !0);
    }
    const c = this.attributes.tangent;
    return (
      c !== void 0 && (c.transformDirection(e), (c.needsUpdate = !0)),
      this.boundingBox !== null && this.computeBoundingBox(),
      this.boundingSphere !== null && this.computeBoundingSphere(),
      this
    );
  }
  applyQuaternion(e) {
    return _m1$2.makeRotationFromQuaternion(e), this.applyMatrix4(_m1$2), this;
  }
  rotateX(e) {
    return _m1$2.makeRotationX(e), this.applyMatrix4(_m1$2), this;
  }
  rotateY(e) {
    return _m1$2.makeRotationY(e), this.applyMatrix4(_m1$2), this;
  }
  rotateZ(e) {
    return _m1$2.makeRotationZ(e), this.applyMatrix4(_m1$2), this;
  }
  translate(e, o, a) {
    return _m1$2.makeTranslation(e, o, a), this.applyMatrix4(_m1$2), this;
  }
  scale(e, o, a) {
    return _m1$2.makeScale(e, o, a), this.applyMatrix4(_m1$2), this;
  }
  lookAt(e) {
    return (
      _obj.lookAt(e), _obj.updateMatrix(), this.applyMatrix4(_obj.matrix), this
    );
  }
  center() {
    return (
      this.computeBoundingBox(),
      this.boundingBox.getCenter(_offset).negate(),
      this.translate(_offset.x, _offset.y, _offset.z),
      this
    );
  }
  setFromPoints(e) {
    const o = [];
    for (let a = 0, c = e.length; a < c; a++) {
      const d = e[a];
      o.push(d.x, d.y, d.z || 0);
    }
    return (
      this.setAttribute("position", new Float32BufferAttribute(o, 3)), this
    );
  }
  computeBoundingBox() {
    this.boundingBox === null && (this.boundingBox = new Box3());
    const e = this.attributes.position,
      o = this.morphAttributes.position;
    if (e && e.isGLBufferAttribute) {
      console.error(
        "THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box.",
        this
      ),
        this.boundingBox.set(
          new Vector3(-1 / 0, -1 / 0, -1 / 0),
          new Vector3(1 / 0, 1 / 0, 1 / 0)
        );
      return;
    }
    if (e !== void 0) {
      if ((this.boundingBox.setFromBufferAttribute(e), o))
        for (let a = 0, c = o.length; a < c; a++) {
          const d = o[a];
          _box$2.setFromBufferAttribute(d),
            this.morphTargetsRelative
              ? (_vector$8.addVectors(this.boundingBox.min, _box$2.min),
                this.boundingBox.expandByPoint(_vector$8),
                _vector$8.addVectors(this.boundingBox.max, _box$2.max),
                this.boundingBox.expandByPoint(_vector$8))
              : (this.boundingBox.expandByPoint(_box$2.min),
                this.boundingBox.expandByPoint(_box$2.max));
        }
    } else this.boundingBox.makeEmpty();
    (isNaN(this.boundingBox.min.x) ||
      isNaN(this.boundingBox.min.y) ||
      isNaN(this.boundingBox.min.z)) &&
      console.error(
        'THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',
        this
      );
  }
  computeBoundingSphere() {
    this.boundingSphere === null && (this.boundingSphere = new Sphere());
    const e = this.attributes.position,
      o = this.morphAttributes.position;
    if (e && e.isGLBufferAttribute) {
      console.error(
        "THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere.",
        this
      ),
        this.boundingSphere.set(new Vector3(), 1 / 0);
      return;
    }
    if (e) {
      const a = this.boundingSphere.center;
      if ((_box$2.setFromBufferAttribute(e), o))
        for (let d = 0, g = o.length; d < g; d++) {
          const _ = o[d];
          _boxMorphTargets.setFromBufferAttribute(_),
            this.morphTargetsRelative
              ? (_vector$8.addVectors(_box$2.min, _boxMorphTargets.min),
                _box$2.expandByPoint(_vector$8),
                _vector$8.addVectors(_box$2.max, _boxMorphTargets.max),
                _box$2.expandByPoint(_vector$8))
              : (_box$2.expandByPoint(_boxMorphTargets.min),
                _box$2.expandByPoint(_boxMorphTargets.max));
        }
      _box$2.getCenter(a);
      let c = 0;
      for (let d = 0, g = e.count; d < g; d++)
        _vector$8.fromBufferAttribute(e, d),
          (c = Math.max(c, a.distanceToSquared(_vector$8)));
      if (o)
        for (let d = 0, g = o.length; d < g; d++) {
          const _ = o[d],
            b = this.morphTargetsRelative;
          for (let j = 0, $ = _.count; j < $; j++)
            _vector$8.fromBufferAttribute(_, j),
              b && (_offset.fromBufferAttribute(e, j), _vector$8.add(_offset)),
              (c = Math.max(c, a.distanceToSquared(_vector$8)));
        }
      (this.boundingSphere.radius = Math.sqrt(c)),
        isNaN(this.boundingSphere.radius) &&
          console.error(
            'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',
            this
          );
    }
  }
  computeTangents() {
    const e = this.index,
      o = this.attributes;
    if (
      e === null ||
      o.position === void 0 ||
      o.normal === void 0 ||
      o.uv === void 0
    ) {
      console.error(
        "THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)"
      );
      return;
    }
    const a = o.position,
      c = o.normal,
      d = o.uv;
    this.hasAttribute("tangent") === !1 &&
      this.setAttribute(
        "tangent",
        new BufferAttribute(new Float32Array(4 * a.count), 4)
      );
    const g = this.getAttribute("tangent"),
      _ = [],
      b = [];
    for (let xt = 0; xt < a.count; xt++)
      (_[xt] = new Vector3()), (b[xt] = new Vector3());
    const j = new Vector3(),
      $ = new Vector3(),
      _e = new Vector3(),
      et = new Vector2(),
      rt = new Vector2(),
      st = new Vector2(),
      at = new Vector3(),
      ct = new Vector3();
    function it(xt, _t, St) {
      j.fromBufferAttribute(a, xt),
        $.fromBufferAttribute(a, _t),
        _e.fromBufferAttribute(a, St),
        et.fromBufferAttribute(d, xt),
        rt.fromBufferAttribute(d, _t),
        st.fromBufferAttribute(d, St),
        $.sub(j),
        _e.sub(j),
        rt.sub(et),
        st.sub(et);
      const Mt = 1 / (rt.x * st.y - st.x * rt.y);
      isFinite(Mt) &&
        (at
          .copy($)
          .multiplyScalar(st.y)
          .addScaledVector(_e, -rt.y)
          .multiplyScalar(Mt),
        ct
          .copy(_e)
          .multiplyScalar(rt.x)
          .addScaledVector($, -st.x)
          .multiplyScalar(Mt),
        _[xt].add(at),
        _[_t].add(at),
        _[St].add(at),
        b[xt].add(ct),
        b[_t].add(ct),
        b[St].add(ct));
    }
    let lt = this.groups;
    lt.length === 0 && (lt = [{ start: 0, count: e.count }]);
    for (let xt = 0, _t = lt.length; xt < _t; ++xt) {
      const St = lt[xt],
        Mt = St.start,
        Rt = St.count;
      for (let Ft = Mt, Ot = Mt + Rt; Ft < Ot; Ft += 3)
        it(e.getX(Ft + 0), e.getX(Ft + 1), e.getX(Ft + 2));
    }
    const ot = new Vector3(),
      ut = new Vector3(),
      pt = new Vector3(),
      ft = new Vector3();
    function gt(xt) {
      pt.fromBufferAttribute(c, xt), ft.copy(pt);
      const _t = _[xt];
      ot.copy(_t),
        ot.sub(pt.multiplyScalar(pt.dot(_t))).normalize(),
        ut.crossVectors(ft, _t);
      const Mt = ut.dot(b[xt]) < 0 ? -1 : 1;
      g.setXYZW(xt, ot.x, ot.y, ot.z, Mt);
    }
    for (let xt = 0, _t = lt.length; xt < _t; ++xt) {
      const St = lt[xt],
        Mt = St.start,
        Rt = St.count;
      for (let Ft = Mt, Ot = Mt + Rt; Ft < Ot; Ft += 3)
        gt(e.getX(Ft + 0)), gt(e.getX(Ft + 1)), gt(e.getX(Ft + 2));
    }
  }
  computeVertexNormals() {
    const e = this.index,
      o = this.getAttribute("position");
    if (o !== void 0) {
      let a = this.getAttribute("normal");
      if (a === void 0)
        (a = new BufferAttribute(new Float32Array(o.count * 3), 3)),
          this.setAttribute("normal", a);
      else for (let et = 0, rt = a.count; et < rt; et++) a.setXYZ(et, 0, 0, 0);
      const c = new Vector3(),
        d = new Vector3(),
        g = new Vector3(),
        _ = new Vector3(),
        b = new Vector3(),
        j = new Vector3(),
        $ = new Vector3(),
        _e = new Vector3();
      if (e)
        for (let et = 0, rt = e.count; et < rt; et += 3) {
          const st = e.getX(et + 0),
            at = e.getX(et + 1),
            ct = e.getX(et + 2);
          c.fromBufferAttribute(o, st),
            d.fromBufferAttribute(o, at),
            g.fromBufferAttribute(o, ct),
            $.subVectors(g, d),
            _e.subVectors(c, d),
            $.cross(_e),
            _.fromBufferAttribute(a, st),
            b.fromBufferAttribute(a, at),
            j.fromBufferAttribute(a, ct),
            _.add($),
            b.add($),
            j.add($),
            a.setXYZ(st, _.x, _.y, _.z),
            a.setXYZ(at, b.x, b.y, b.z),
            a.setXYZ(ct, j.x, j.y, j.z);
        }
      else
        for (let et = 0, rt = o.count; et < rt; et += 3)
          c.fromBufferAttribute(o, et + 0),
            d.fromBufferAttribute(o, et + 1),
            g.fromBufferAttribute(o, et + 2),
            $.subVectors(g, d),
            _e.subVectors(c, d),
            $.cross(_e),
            a.setXYZ(et + 0, $.x, $.y, $.z),
            a.setXYZ(et + 1, $.x, $.y, $.z),
            a.setXYZ(et + 2, $.x, $.y, $.z);
      this.normalizeNormals(), (a.needsUpdate = !0);
    }
  }
  normalizeNormals() {
    const e = this.attributes.normal;
    for (let o = 0, a = e.count; o < a; o++)
      _vector$8.fromBufferAttribute(e, o),
        _vector$8.normalize(),
        e.setXYZ(o, _vector$8.x, _vector$8.y, _vector$8.z);
  }
  toNonIndexed() {
    function e(_, b) {
      const j = _.array,
        $ = _.itemSize,
        _e = _.normalized,
        et = new j.constructor(b.length * $);
      let rt = 0,
        st = 0;
      for (let at = 0, ct = b.length; at < ct; at++) {
        _.isInterleavedBufferAttribute
          ? (rt = b[at] * _.data.stride + _.offset)
          : (rt = b[at] * $);
        for (let it = 0; it < $; it++) et[st++] = j[rt++];
      }
      return new BufferAttribute(et, $, _e);
    }
    if (this.index === null)
      return (
        console.warn(
          "THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."
        ),
        this
      );
    const o = new BufferGeometry(),
      a = this.index.array,
      c = this.attributes;
    for (const _ in c) {
      const b = c[_],
        j = e(b, a);
      o.setAttribute(_, j);
    }
    const d = this.morphAttributes;
    for (const _ in d) {
      const b = [],
        j = d[_];
      for (let $ = 0, _e = j.length; $ < _e; $++) {
        const et = j[$],
          rt = e(et, a);
        b.push(rt);
      }
      o.morphAttributes[_] = b;
    }
    o.morphTargetsRelative = this.morphTargetsRelative;
    const g = this.groups;
    for (let _ = 0, b = g.length; _ < b; _++) {
      const j = g[_];
      o.addGroup(j.start, j.count, j.materialIndex);
    }
    return o;
  }
  toJSON() {
    const e = {
      metadata: {
        version: 4.6,
        type: "BufferGeometry",
        generator: "BufferGeometry.toJSON",
      },
    };
    if (
      ((e.uuid = this.uuid),
      (e.type = this.type),
      this.name !== "" && (e.name = this.name),
      Object.keys(this.userData).length > 0 && (e.userData = this.userData),
      this.parameters !== void 0)
    ) {
      const b = this.parameters;
      for (const j in b) b[j] !== void 0 && (e[j] = b[j]);
      return e;
    }
    e.data = { attributes: {} };
    const o = this.index;
    o !== null &&
      (e.data.index = {
        type: o.array.constructor.name,
        array: Array.prototype.slice.call(o.array),
      });
    const a = this.attributes;
    for (const b in a) {
      const j = a[b];
      e.data.attributes[b] = j.toJSON(e.data);
    }
    const c = {};
    let d = !1;
    for (const b in this.morphAttributes) {
      const j = this.morphAttributes[b],
        $ = [];
      for (let _e = 0, et = j.length; _e < et; _e++) {
        const rt = j[_e];
        $.push(rt.toJSON(e.data));
      }
      $.length > 0 && ((c[b] = $), (d = !0));
    }
    d &&
      ((e.data.morphAttributes = c),
      (e.data.morphTargetsRelative = this.morphTargetsRelative));
    const g = this.groups;
    g.length > 0 && (e.data.groups = JSON.parse(JSON.stringify(g)));
    const _ = this.boundingSphere;
    return (
      _ !== null &&
        (e.data.boundingSphere = {
          center: _.center.toArray(),
          radius: _.radius,
        }),
      e
    );
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    (this.index = null),
      (this.attributes = {}),
      (this.morphAttributes = {}),
      (this.groups = []),
      (this.boundingBox = null),
      (this.boundingSphere = null);
    const o = {};
    this.name = e.name;
    const a = e.index;
    a !== null && this.setIndex(a.clone(o));
    const c = e.attributes;
    for (const j in c) {
      const $ = c[j];
      this.setAttribute(j, $.clone(o));
    }
    const d = e.morphAttributes;
    for (const j in d) {
      const $ = [],
        _e = d[j];
      for (let et = 0, rt = _e.length; et < rt; et++) $.push(_e[et].clone(o));
      this.morphAttributes[j] = $;
    }
    this.morphTargetsRelative = e.morphTargetsRelative;
    const g = e.groups;
    for (let j = 0, $ = g.length; j < $; j++) {
      const _e = g[j];
      this.addGroup(_e.start, _e.count, _e.materialIndex);
    }
    const _ = e.boundingBox;
    _ !== null && (this.boundingBox = _.clone());
    const b = e.boundingSphere;
    return (
      b !== null && (this.boundingSphere = b.clone()),
      (this.drawRange.start = e.drawRange.start),
      (this.drawRange.count = e.drawRange.count),
      (this.userData = e.userData),
      this
    );
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
}
const _inverseMatrix$3 = new Matrix4(),
  _ray$3 = new Ray(),
  _sphere$6 = new Sphere(),
  _sphereHitAt = new Vector3(),
  _vA$1 = new Vector3(),
  _vB$1 = new Vector3(),
  _vC$1 = new Vector3(),
  _tempA = new Vector3(),
  _morphA = new Vector3(),
  _uvA$1 = new Vector2(),
  _uvB$1 = new Vector2(),
  _uvC$1 = new Vector2(),
  _normalA = new Vector3(),
  _normalB = new Vector3(),
  _normalC = new Vector3(),
  _intersectionPoint = new Vector3(),
  _intersectionPointWorld = new Vector3();
class Mesh extends Object3D {
  constructor(e = new BufferGeometry(), o = new MeshBasicMaterial()) {
    super(),
      (this.isMesh = !0),
      (this.type = "Mesh"),
      (this.geometry = e),
      (this.material = o),
      this.updateMorphTargets();
  }
  copy(e, o) {
    return (
      super.copy(e, o),
      e.morphTargetInfluences !== void 0 &&
        (this.morphTargetInfluences = e.morphTargetInfluences.slice()),
      e.morphTargetDictionary !== void 0 &&
        (this.morphTargetDictionary = Object.assign(
          {},
          e.morphTargetDictionary
        )),
      (this.material = Array.isArray(e.material)
        ? e.material.slice()
        : e.material),
      (this.geometry = e.geometry),
      this
    );
  }
  updateMorphTargets() {
    const o = this.geometry.morphAttributes,
      a = Object.keys(o);
    if (a.length > 0) {
      const c = o[a[0]];
      if (c !== void 0) {
        (this.morphTargetInfluences = []), (this.morphTargetDictionary = {});
        for (let d = 0, g = c.length; d < g; d++) {
          const _ = c[d].name || String(d);
          this.morphTargetInfluences.push(0),
            (this.morphTargetDictionary[_] = d);
        }
      }
    }
  }
  getVertexPosition(e, o) {
    const a = this.geometry,
      c = a.attributes.position,
      d = a.morphAttributes.position,
      g = a.morphTargetsRelative;
    o.fromBufferAttribute(c, e);
    const _ = this.morphTargetInfluences;
    if (d && _) {
      _morphA.set(0, 0, 0);
      for (let b = 0, j = d.length; b < j; b++) {
        const $ = _[b],
          _e = d[b];
        $ !== 0 &&
          (_tempA.fromBufferAttribute(_e, e),
          g
            ? _morphA.addScaledVector(_tempA, $)
            : _morphA.addScaledVector(_tempA.sub(o), $));
      }
      o.add(_morphA);
    }
    return o;
  }
  raycast(e, o) {
    const a = this.geometry,
      c = this.material,
      d = this.matrixWorld;
    c !== void 0 &&
      (a.boundingSphere === null && a.computeBoundingSphere(),
      _sphere$6.copy(a.boundingSphere),
      _sphere$6.applyMatrix4(d),
      _ray$3.copy(e.ray).recast(e.near),
      !(
        _sphere$6.containsPoint(_ray$3.origin) === !1 &&
        (_ray$3.intersectSphere(_sphere$6, _sphereHitAt) === null ||
          _ray$3.origin.distanceToSquared(_sphereHitAt) > (e.far - e.near) ** 2)
      ) &&
        (_inverseMatrix$3.copy(d).invert(),
        _ray$3.copy(e.ray).applyMatrix4(_inverseMatrix$3),
        !(
          a.boundingBox !== null && _ray$3.intersectsBox(a.boundingBox) === !1
        ) && this._computeIntersections(e, o, _ray$3)));
  }
  _computeIntersections(e, o, a) {
    let c;
    const d = this.geometry,
      g = this.material,
      _ = d.index,
      b = d.attributes.position,
      j = d.attributes.uv,
      $ = d.attributes.uv1,
      _e = d.attributes.normal,
      et = d.groups,
      rt = d.drawRange;
    if (_ !== null)
      if (Array.isArray(g))
        for (let st = 0, at = et.length; st < at; st++) {
          const ct = et[st],
            it = g[ct.materialIndex],
            lt = Math.max(ct.start, rt.start),
            ot = Math.min(
              _.count,
              Math.min(ct.start + ct.count, rt.start + rt.count)
            );
          for (let ut = lt, pt = ot; ut < pt; ut += 3) {
            const ft = _.getX(ut),
              gt = _.getX(ut + 1),
              xt = _.getX(ut + 2);
            (c = checkGeometryIntersection(
              this,
              it,
              e,
              a,
              j,
              $,
              _e,
              ft,
              gt,
              xt
            )),
              c &&
                ((c.faceIndex = Math.floor(ut / 3)),
                (c.face.materialIndex = ct.materialIndex),
                o.push(c));
          }
        }
      else {
        const st = Math.max(0, rt.start),
          at = Math.min(_.count, rt.start + rt.count);
        for (let ct = st, it = at; ct < it; ct += 3) {
          const lt = _.getX(ct),
            ot = _.getX(ct + 1),
            ut = _.getX(ct + 2);
          (c = checkGeometryIntersection(this, g, e, a, j, $, _e, lt, ot, ut)),
            c && ((c.faceIndex = Math.floor(ct / 3)), o.push(c));
        }
      }
    else if (b !== void 0)
      if (Array.isArray(g))
        for (let st = 0, at = et.length; st < at; st++) {
          const ct = et[st],
            it = g[ct.materialIndex],
            lt = Math.max(ct.start, rt.start),
            ot = Math.min(
              b.count,
              Math.min(ct.start + ct.count, rt.start + rt.count)
            );
          for (let ut = lt, pt = ot; ut < pt; ut += 3) {
            const ft = ut,
              gt = ut + 1,
              xt = ut + 2;
            (c = checkGeometryIntersection(
              this,
              it,
              e,
              a,
              j,
              $,
              _e,
              ft,
              gt,
              xt
            )),
              c &&
                ((c.faceIndex = Math.floor(ut / 3)),
                (c.face.materialIndex = ct.materialIndex),
                o.push(c));
          }
        }
      else {
        const st = Math.max(0, rt.start),
          at = Math.min(b.count, rt.start + rt.count);
        for (let ct = st, it = at; ct < it; ct += 3) {
          const lt = ct,
            ot = ct + 1,
            ut = ct + 2;
          (c = checkGeometryIntersection(this, g, e, a, j, $, _e, lt, ot, ut)),
            c && ((c.faceIndex = Math.floor(ct / 3)), o.push(c));
        }
      }
  }
}
function checkIntersection$1(s, e, o, a, c, d, g, _) {
  let b;
  if (
    (e.side === BackSide
      ? (b = a.intersectTriangle(g, d, c, !0, _))
      : (b = a.intersectTriangle(c, d, g, e.side === FrontSide, _)),
    b === null)
  )
    return null;
  _intersectionPointWorld.copy(_),
    _intersectionPointWorld.applyMatrix4(s.matrixWorld);
  const j = o.ray.origin.distanceTo(_intersectionPointWorld);
  return j < o.near || j > o.far
    ? null
    : { distance: j, point: _intersectionPointWorld.clone(), object: s };
}
function checkGeometryIntersection(s, e, o, a, c, d, g, _, b, j) {
  s.getVertexPosition(_, _vA$1),
    s.getVertexPosition(b, _vB$1),
    s.getVertexPosition(j, _vC$1);
  const $ = checkIntersection$1(
    s,
    e,
    o,
    a,
    _vA$1,
    _vB$1,
    _vC$1,
    _intersectionPoint
  );
  if ($) {
    c &&
      (_uvA$1.fromBufferAttribute(c, _),
      _uvB$1.fromBufferAttribute(c, b),
      _uvC$1.fromBufferAttribute(c, j),
      ($.uv = Triangle.getInterpolation(
        _intersectionPoint,
        _vA$1,
        _vB$1,
        _vC$1,
        _uvA$1,
        _uvB$1,
        _uvC$1,
        new Vector2()
      ))),
      d &&
        (_uvA$1.fromBufferAttribute(d, _),
        _uvB$1.fromBufferAttribute(d, b),
        _uvC$1.fromBufferAttribute(d, j),
        ($.uv1 = Triangle.getInterpolation(
          _intersectionPoint,
          _vA$1,
          _vB$1,
          _vC$1,
          _uvA$1,
          _uvB$1,
          _uvC$1,
          new Vector2()
        ))),
      g &&
        (_normalA.fromBufferAttribute(g, _),
        _normalB.fromBufferAttribute(g, b),
        _normalC.fromBufferAttribute(g, j),
        ($.normal = Triangle.getInterpolation(
          _intersectionPoint,
          _vA$1,
          _vB$1,
          _vC$1,
          _normalA,
          _normalB,
          _normalC,
          new Vector3()
        )),
        $.normal.dot(a.direction) > 0 && $.normal.multiplyScalar(-1));
    const _e = { a: _, b, c: j, normal: new Vector3(), materialIndex: 0 };
    Triangle.getNormal(_vA$1, _vB$1, _vC$1, _e.normal), ($.face = _e);
  }
  return $;
}
class BoxGeometry extends BufferGeometry {
  constructor(e = 1, o = 1, a = 1, c = 1, d = 1, g = 1) {
    super(),
      (this.type = "BoxGeometry"),
      (this.parameters = {
        width: e,
        height: o,
        depth: a,
        widthSegments: c,
        heightSegments: d,
        depthSegments: g,
      });
    const _ = this;
    (c = Math.floor(c)), (d = Math.floor(d)), (g = Math.floor(g));
    const b = [],
      j = [],
      $ = [],
      _e = [];
    let et = 0,
      rt = 0;
    st("z", "y", "x", -1, -1, a, o, e, g, d, 0),
      st("z", "y", "x", 1, -1, a, o, -e, g, d, 1),
      st("x", "z", "y", 1, 1, e, a, o, c, g, 2),
      st("x", "z", "y", 1, -1, e, a, -o, c, g, 3),
      st("x", "y", "z", 1, -1, e, o, a, c, d, 4),
      st("x", "y", "z", -1, -1, e, o, -a, c, d, 5),
      this.setIndex(b),
      this.setAttribute("position", new Float32BufferAttribute(j, 3)),
      this.setAttribute("normal", new Float32BufferAttribute($, 3)),
      this.setAttribute("uv", new Float32BufferAttribute(_e, 2));
    function st(at, ct, it, lt, ot, ut, pt, ft, gt, xt, _t) {
      const St = ut / gt,
        Mt = pt / xt,
        Rt = ut / 2,
        Ft = pt / 2,
        Ot = ft / 2,
        Lt = gt + 1,
        Et = xt + 1;
      let bt = 0,
        mt = 0;
      const vt = new Vector3();
      for (let Ct = 0; Ct < Et; Ct++) {
        const Tt = Ct * Mt - Ft;
        for (let Dt = 0; Dt < Lt; Dt++) {
          const Wt = Dt * St - Rt;
          (vt[at] = Wt * lt),
            (vt[ct] = Tt * ot),
            (vt[it] = Ot),
            j.push(vt.x, vt.y, vt.z),
            (vt[at] = 0),
            (vt[ct] = 0),
            (vt[it] = ft > 0 ? 1 : -1),
            $.push(vt.x, vt.y, vt.z),
            _e.push(Dt / gt),
            _e.push(1 - Ct / xt),
            (bt += 1);
        }
      }
      for (let Ct = 0; Ct < xt; Ct++)
        for (let Tt = 0; Tt < gt; Tt++) {
          const Dt = et + Tt + Lt * Ct,
            Wt = et + Tt + Lt * (Ct + 1),
            Pt = et + (Tt + 1) + Lt * (Ct + 1),
            Jt = et + (Tt + 1) + Lt * Ct;
          b.push(Dt, Wt, Jt), b.push(Wt, Pt, Jt), (mt += 6);
        }
      _.addGroup(rt, mt, _t), (rt += mt), (et += bt);
    }
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  static fromJSON(e) {
    return new BoxGeometry(
      e.width,
      e.height,
      e.depth,
      e.widthSegments,
      e.heightSegments,
      e.depthSegments
    );
  }
}
function cloneUniforms(s) {
  const e = {};
  for (const o in s) {
    e[o] = {};
    for (const a in s[o]) {
      const c = s[o][a];
      c &&
      (c.isColor ||
        c.isMatrix3 ||
        c.isMatrix4 ||
        c.isVector2 ||
        c.isVector3 ||
        c.isVector4 ||
        c.isTexture ||
        c.isQuaternion)
        ? c.isRenderTargetTexture
          ? (console.warn(
              "UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms()."
            ),
            (e[o][a] = null))
          : (e[o][a] = c.clone())
        : Array.isArray(c)
        ? (e[o][a] = c.slice())
        : (e[o][a] = c);
    }
  }
  return e;
}
function mergeUniforms(s) {
  const e = {};
  for (let o = 0; o < s.length; o++) {
    const a = cloneUniforms(s[o]);
    for (const c in a) e[c] = a[c];
  }
  return e;
}
function cloneUniformsGroups(s) {
  const e = [];
  for (let o = 0; o < s.length; o++) e.push(s[o].clone());
  return e;
}
function getUnlitUniformColorSpace(s) {
  const e = s.getRenderTarget();
  return e === null
    ? s.outputColorSpace
    : e.isXRRenderTarget === !0
    ? e.texture.colorSpace
    : ColorManagement.workingColorSpace;
}
const UniformsUtils = { clone: cloneUniforms, merge: mergeUniforms };
var default_vertex = `void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`,
  default_fragment = `void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}`;
class ShaderMaterial extends Material {
  constructor(e) {
    super(),
      (this.isShaderMaterial = !0),
      (this.type = "ShaderMaterial"),
      (this.defines = {}),
      (this.uniforms = {}),
      (this.uniformsGroups = []),
      (this.vertexShader = default_vertex),
      (this.fragmentShader = default_fragment),
      (this.linewidth = 1),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.fog = !1),
      (this.lights = !1),
      (this.clipping = !1),
      (this.forceSinglePass = !0),
      (this.extensions = { clipCullDistance: !1, multiDraw: !1 }),
      (this.defaultAttributeValues = {
        color: [1, 1, 1],
        uv: [0, 0],
        uv1: [0, 0],
      }),
      (this.index0AttributeName = void 0),
      (this.uniformsNeedUpdate = !1),
      (this.glslVersion = null),
      e !== void 0 && this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      (this.fragmentShader = e.fragmentShader),
      (this.vertexShader = e.vertexShader),
      (this.uniforms = cloneUniforms(e.uniforms)),
      (this.uniformsGroups = cloneUniformsGroups(e.uniformsGroups)),
      (this.defines = Object.assign({}, e.defines)),
      (this.wireframe = e.wireframe),
      (this.wireframeLinewidth = e.wireframeLinewidth),
      (this.fog = e.fog),
      (this.lights = e.lights),
      (this.clipping = e.clipping),
      (this.extensions = Object.assign({}, e.extensions)),
      (this.glslVersion = e.glslVersion),
      this
    );
  }
  toJSON(e) {
    const o = super.toJSON(e);
    (o.glslVersion = this.glslVersion), (o.uniforms = {});
    for (const c in this.uniforms) {
      const g = this.uniforms[c].value;
      g && g.isTexture
        ? (o.uniforms[c] = { type: "t", value: g.toJSON(e).uuid })
        : g && g.isColor
        ? (o.uniforms[c] = { type: "c", value: g.getHex() })
        : g && g.isVector2
        ? (o.uniforms[c] = { type: "v2", value: g.toArray() })
        : g && g.isVector3
        ? (o.uniforms[c] = { type: "v3", value: g.toArray() })
        : g && g.isVector4
        ? (o.uniforms[c] = { type: "v4", value: g.toArray() })
        : g && g.isMatrix3
        ? (o.uniforms[c] = { type: "m3", value: g.toArray() })
        : g && g.isMatrix4
        ? (o.uniforms[c] = { type: "m4", value: g.toArray() })
        : (o.uniforms[c] = { value: g });
    }
    Object.keys(this.defines).length > 0 && (o.defines = this.defines),
      (o.vertexShader = this.vertexShader),
      (o.fragmentShader = this.fragmentShader),
      (o.lights = this.lights),
      (o.clipping = this.clipping);
    const a = {};
    for (const c in this.extensions) this.extensions[c] === !0 && (a[c] = !0);
    return Object.keys(a).length > 0 && (o.extensions = a), o;
  }
}
class Camera extends Object3D {
  constructor() {
    super(),
      (this.isCamera = !0),
      (this.type = "Camera"),
      (this.matrixWorldInverse = new Matrix4()),
      (this.projectionMatrix = new Matrix4()),
      (this.projectionMatrixInverse = new Matrix4()),
      (this.coordinateSystem = WebGLCoordinateSystem);
  }
  copy(e, o) {
    return (
      super.copy(e, o),
      this.matrixWorldInverse.copy(e.matrixWorldInverse),
      this.projectionMatrix.copy(e.projectionMatrix),
      this.projectionMatrixInverse.copy(e.projectionMatrixInverse),
      (this.coordinateSystem = e.coordinateSystem),
      this
    );
  }
  getWorldDirection(e) {
    return super.getWorldDirection(e).negate();
  }
  updateMatrixWorld(e) {
    super.updateMatrixWorld(e),
      this.matrixWorldInverse.copy(this.matrixWorld).invert();
  }
  updateWorldMatrix(e, o) {
    super.updateWorldMatrix(e, o),
      this.matrixWorldInverse.copy(this.matrixWorld).invert();
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const _v3$1 = new Vector3(),
  _minTarget = new Vector2(),
  _maxTarget = new Vector2();
class PerspectiveCamera extends Camera {
  constructor(e = 50, o = 1, a = 0.1, c = 2e3) {
    super(),
      (this.isPerspectiveCamera = !0),
      (this.type = "PerspectiveCamera"),
      (this.fov = e),
      (this.zoom = 1),
      (this.near = a),
      (this.far = c),
      (this.focus = 10),
      (this.aspect = o),
      (this.view = null),
      (this.filmGauge = 35),
      (this.filmOffset = 0),
      this.updateProjectionMatrix();
  }
  copy(e, o) {
    return (
      super.copy(e, o),
      (this.fov = e.fov),
      (this.zoom = e.zoom),
      (this.near = e.near),
      (this.far = e.far),
      (this.focus = e.focus),
      (this.aspect = e.aspect),
      (this.view = e.view === null ? null : Object.assign({}, e.view)),
      (this.filmGauge = e.filmGauge),
      (this.filmOffset = e.filmOffset),
      this
    );
  }
  setFocalLength(e) {
    const o = (0.5 * this.getFilmHeight()) / e;
    (this.fov = RAD2DEG * 2 * Math.atan(o)), this.updateProjectionMatrix();
  }
  getFocalLength() {
    const e = Math.tan(DEG2RAD * 0.5 * this.fov);
    return (0.5 * this.getFilmHeight()) / e;
  }
  getEffectiveFOV() {
    return (
      RAD2DEG * 2 * Math.atan(Math.tan(DEG2RAD * 0.5 * this.fov) / this.zoom)
    );
  }
  getFilmWidth() {
    return this.filmGauge * Math.min(this.aspect, 1);
  }
  getFilmHeight() {
    return this.filmGauge / Math.max(this.aspect, 1);
  }
  getViewBounds(e, o, a) {
    _v3$1.set(-1, -1, 0.5).applyMatrix4(this.projectionMatrixInverse),
      o.set(_v3$1.x, _v3$1.y).multiplyScalar(-e / _v3$1.z),
      _v3$1.set(1, 1, 0.5).applyMatrix4(this.projectionMatrixInverse),
      a.set(_v3$1.x, _v3$1.y).multiplyScalar(-e / _v3$1.z);
  }
  getViewSize(e, o) {
    return (
      this.getViewBounds(e, _minTarget, _maxTarget),
      o.subVectors(_maxTarget, _minTarget)
    );
  }
  setViewOffset(e, o, a, c, d, g) {
    (this.aspect = e / o),
      this.view === null &&
        (this.view = {
          enabled: !0,
          fullWidth: 1,
          fullHeight: 1,
          offsetX: 0,
          offsetY: 0,
          width: 1,
          height: 1,
        }),
      (this.view.enabled = !0),
      (this.view.fullWidth = e),
      (this.view.fullHeight = o),
      (this.view.offsetX = a),
      (this.view.offsetY = c),
      (this.view.width = d),
      (this.view.height = g),
      this.updateProjectionMatrix();
  }
  clearViewOffset() {
    this.view !== null && (this.view.enabled = !1),
      this.updateProjectionMatrix();
  }
  updateProjectionMatrix() {
    const e = this.near;
    let o = (e * Math.tan(DEG2RAD * 0.5 * this.fov)) / this.zoom,
      a = 2 * o,
      c = this.aspect * a,
      d = -0.5 * c;
    const g = this.view;
    if (this.view !== null && this.view.enabled) {
      const b = g.fullWidth,
        j = g.fullHeight;
      (d += (g.offsetX * c) / b),
        (o -= (g.offsetY * a) / j),
        (c *= g.width / b),
        (a *= g.height / j);
    }
    const _ = this.filmOffset;
    _ !== 0 && (d += (e * _) / this.getFilmWidth()),
      this.projectionMatrix.makePerspective(
        d,
        d + c,
        o,
        o - a,
        e,
        this.far,
        this.coordinateSystem
      ),
      this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
  }
  toJSON(e) {
    const o = super.toJSON(e);
    return (
      (o.object.fov = this.fov),
      (o.object.zoom = this.zoom),
      (o.object.near = this.near),
      (o.object.far = this.far),
      (o.object.focus = this.focus),
      (o.object.aspect = this.aspect),
      this.view !== null && (o.object.view = Object.assign({}, this.view)),
      (o.object.filmGauge = this.filmGauge),
      (o.object.filmOffset = this.filmOffset),
      o
    );
  }
}
const fov = -90,
  aspect = 1;
class CubeCamera extends Object3D {
  constructor(e, o, a) {
    super(),
      (this.type = "CubeCamera"),
      (this.renderTarget = a),
      (this.coordinateSystem = null),
      (this.activeMipmapLevel = 0);
    const c = new PerspectiveCamera(fov, aspect, e, o);
    (c.layers = this.layers), this.add(c);
    const d = new PerspectiveCamera(fov, aspect, e, o);
    (d.layers = this.layers), this.add(d);
    const g = new PerspectiveCamera(fov, aspect, e, o);
    (g.layers = this.layers), this.add(g);
    const _ = new PerspectiveCamera(fov, aspect, e, o);
    (_.layers = this.layers), this.add(_);
    const b = new PerspectiveCamera(fov, aspect, e, o);
    (b.layers = this.layers), this.add(b);
    const j = new PerspectiveCamera(fov, aspect, e, o);
    (j.layers = this.layers), this.add(j);
  }
  updateCoordinateSystem() {
    const e = this.coordinateSystem,
      o = this.children.concat(),
      [a, c, d, g, _, b] = o;
    for (const j of o) this.remove(j);
    if (e === WebGLCoordinateSystem)
      a.up.set(0, 1, 0),
        a.lookAt(1, 0, 0),
        c.up.set(0, 1, 0),
        c.lookAt(-1, 0, 0),
        d.up.set(0, 0, -1),
        d.lookAt(0, 1, 0),
        g.up.set(0, 0, 1),
        g.lookAt(0, -1, 0),
        _.up.set(0, 1, 0),
        _.lookAt(0, 0, 1),
        b.up.set(0, 1, 0),
        b.lookAt(0, 0, -1);
    else if (e === WebGPUCoordinateSystem)
      a.up.set(0, -1, 0),
        a.lookAt(-1, 0, 0),
        c.up.set(0, -1, 0),
        c.lookAt(1, 0, 0),
        d.up.set(0, 0, 1),
        d.lookAt(0, 1, 0),
        g.up.set(0, 0, -1),
        g.lookAt(0, -1, 0),
        _.up.set(0, -1, 0),
        _.lookAt(0, 0, 1),
        b.up.set(0, -1, 0),
        b.lookAt(0, 0, -1);
    else
      throw new Error(
        "THREE.CubeCamera.updateCoordinateSystem(): Invalid coordinate system: " +
          e
      );
    for (const j of o) this.add(j), j.updateMatrixWorld();
  }
  update(e, o) {
    this.parent === null && this.updateMatrixWorld();
    const { renderTarget: a, activeMipmapLevel: c } = this;
    this.coordinateSystem !== e.coordinateSystem &&
      ((this.coordinateSystem = e.coordinateSystem),
      this.updateCoordinateSystem());
    const [d, g, _, b, j, $] = this.children,
      _e = e.getRenderTarget(),
      et = e.getActiveCubeFace(),
      rt = e.getActiveMipmapLevel(),
      st = e.xr.enabled;
    e.xr.enabled = !1;
    const at = a.texture.generateMipmaps;
    (a.texture.generateMipmaps = !1),
      e.setRenderTarget(a, 0, c),
      e.render(o, d),
      e.setRenderTarget(a, 1, c),
      e.render(o, g),
      e.setRenderTarget(a, 2, c),
      e.render(o, _),
      e.setRenderTarget(a, 3, c),
      e.render(o, b),
      e.setRenderTarget(a, 4, c),
      e.render(o, j),
      (a.texture.generateMipmaps = at),
      e.setRenderTarget(a, 5, c),
      e.render(o, $),
      e.setRenderTarget(_e, et, rt),
      (e.xr.enabled = st),
      (a.texture.needsPMREMUpdate = !0);
  }
}
class CubeTexture extends Texture {
  constructor(e, o, a, c, d, g, _, b, j, $) {
    (e = e !== void 0 ? e : []),
      (o = o !== void 0 ? o : CubeReflectionMapping),
      super(e, o, a, c, d, g, _, b, j, $),
      (this.isCubeTexture = !0),
      (this.flipY = !1);
  }
  get images() {
    return this.image;
  }
  set images(e) {
    this.image = e;
  }
}
class WebGLCubeRenderTarget extends WebGLRenderTarget {
  constructor(e = 1, o = {}) {
    super(e, e, o), (this.isWebGLCubeRenderTarget = !0);
    const a = { width: e, height: e, depth: 1 },
      c = [a, a, a, a, a, a];
    (this.texture = new CubeTexture(
      c,
      o.mapping,
      o.wrapS,
      o.wrapT,
      o.magFilter,
      o.minFilter,
      o.format,
      o.type,
      o.anisotropy,
      o.colorSpace
    )),
      (this.texture.isRenderTargetTexture = !0),
      (this.texture.generateMipmaps =
        o.generateMipmaps !== void 0 ? o.generateMipmaps : !1),
      (this.texture.minFilter =
        o.minFilter !== void 0 ? o.minFilter : LinearFilter);
  }
  fromEquirectangularTexture(e, o) {
    (this.texture.type = o.type),
      (this.texture.colorSpace = o.colorSpace),
      (this.texture.generateMipmaps = o.generateMipmaps),
      (this.texture.minFilter = o.minFilter),
      (this.texture.magFilter = o.magFilter);
    const a = {
        uniforms: { tEquirect: { value: null } },
        vertexShader: `

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`,
        fragmentShader: `

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`,
      },
      c = new BoxGeometry(5, 5, 5),
      d = new ShaderMaterial({
        name: "CubemapFromEquirect",
        uniforms: cloneUniforms(a.uniforms),
        vertexShader: a.vertexShader,
        fragmentShader: a.fragmentShader,
        side: BackSide,
        blending: NoBlending,
      });
    d.uniforms.tEquirect.value = o;
    const g = new Mesh(c, d),
      _ = o.minFilter;
    return (
      o.minFilter === LinearMipmapLinearFilter && (o.minFilter = LinearFilter),
      new CubeCamera(1, 10, this).update(e, g),
      (o.minFilter = _),
      g.geometry.dispose(),
      g.material.dispose(),
      this
    );
  }
  clear(e, o, a, c) {
    const d = e.getRenderTarget();
    for (let g = 0; g < 6; g++) e.setRenderTarget(this, g), e.clear(o, a, c);
    e.setRenderTarget(d);
  }
}
const _vector1 = new Vector3(),
  _vector2 = new Vector3(),
  _normalMatrix = new Matrix3();
class Plane {
  constructor(e = new Vector3(1, 0, 0), o = 0) {
    (this.isPlane = !0), (this.normal = e), (this.constant = o);
  }
  set(e, o) {
    return this.normal.copy(e), (this.constant = o), this;
  }
  setComponents(e, o, a, c) {
    return this.normal.set(e, o, a), (this.constant = c), this;
  }
  setFromNormalAndCoplanarPoint(e, o) {
    return this.normal.copy(e), (this.constant = -o.dot(this.normal)), this;
  }
  setFromCoplanarPoints(e, o, a) {
    const c = _vector1
      .subVectors(a, o)
      .cross(_vector2.subVectors(e, o))
      .normalize();
    return this.setFromNormalAndCoplanarPoint(c, e), this;
  }
  copy(e) {
    return this.normal.copy(e.normal), (this.constant = e.constant), this;
  }
  normalize() {
    const e = 1 / this.normal.length();
    return this.normal.multiplyScalar(e), (this.constant *= e), this;
  }
  negate() {
    return (this.constant *= -1), this.normal.negate(), this;
  }
  distanceToPoint(e) {
    return this.normal.dot(e) + this.constant;
  }
  distanceToSphere(e) {
    return this.distanceToPoint(e.center) - e.radius;
  }
  projectPoint(e, o) {
    return o.copy(e).addScaledVector(this.normal, -this.distanceToPoint(e));
  }
  intersectLine(e, o) {
    const a = e.delta(_vector1),
      c = this.normal.dot(a);
    if (c === 0)
      return this.distanceToPoint(e.start) === 0 ? o.copy(e.start) : null;
    const d = -(e.start.dot(this.normal) + this.constant) / c;
    return d < 0 || d > 1 ? null : o.copy(e.start).addScaledVector(a, d);
  }
  intersectsLine(e) {
    const o = this.distanceToPoint(e.start),
      a = this.distanceToPoint(e.end);
    return (o < 0 && a > 0) || (a < 0 && o > 0);
  }
  intersectsBox(e) {
    return e.intersectsPlane(this);
  }
  intersectsSphere(e) {
    return e.intersectsPlane(this);
  }
  coplanarPoint(e) {
    return e.copy(this.normal).multiplyScalar(-this.constant);
  }
  applyMatrix4(e, o) {
    const a = o || _normalMatrix.getNormalMatrix(e),
      c = this.coplanarPoint(_vector1).applyMatrix4(e),
      d = this.normal.applyMatrix3(a).normalize();
    return (this.constant = -c.dot(d)), this;
  }
  translate(e) {
    return (this.constant -= e.dot(this.normal)), this;
  }
  equals(e) {
    return e.normal.equals(this.normal) && e.constant === this.constant;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const _sphere$5 = new Sphere(),
  _vector$7 = new Vector3();
class Frustum {
  constructor(
    e = new Plane(),
    o = new Plane(),
    a = new Plane(),
    c = new Plane(),
    d = new Plane(),
    g = new Plane()
  ) {
    this.planes = [e, o, a, c, d, g];
  }
  set(e, o, a, c, d, g) {
    const _ = this.planes;
    return (
      _[0].copy(e),
      _[1].copy(o),
      _[2].copy(a),
      _[3].copy(c),
      _[4].copy(d),
      _[5].copy(g),
      this
    );
  }
  copy(e) {
    const o = this.planes;
    for (let a = 0; a < 6; a++) o[a].copy(e.planes[a]);
    return this;
  }
  setFromProjectionMatrix(e, o = WebGLCoordinateSystem) {
    const a = this.planes,
      c = e.elements,
      d = c[0],
      g = c[1],
      _ = c[2],
      b = c[3],
      j = c[4],
      $ = c[5],
      _e = c[6],
      et = c[7],
      rt = c[8],
      st = c[9],
      at = c[10],
      ct = c[11],
      it = c[12],
      lt = c[13],
      ot = c[14],
      ut = c[15];
    if (
      (a[0].setComponents(b - d, et - j, ct - rt, ut - it).normalize(),
      a[1].setComponents(b + d, et + j, ct + rt, ut + it).normalize(),
      a[2].setComponents(b + g, et + $, ct + st, ut + lt).normalize(),
      a[3].setComponents(b - g, et - $, ct - st, ut - lt).normalize(),
      a[4].setComponents(b - _, et - _e, ct - at, ut - ot).normalize(),
      o === WebGLCoordinateSystem)
    )
      a[5].setComponents(b + _, et + _e, ct + at, ut + ot).normalize();
    else if (o === WebGPUCoordinateSystem)
      a[5].setComponents(_, _e, at, ot).normalize();
    else
      throw new Error(
        "THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: " +
          o
      );
    return this;
  }
  intersectsObject(e) {
    if (e.boundingSphere !== void 0)
      e.boundingSphere === null && e.computeBoundingSphere(),
        _sphere$5.copy(e.boundingSphere).applyMatrix4(e.matrixWorld);
    else {
      const o = e.geometry;
      o.boundingSphere === null && o.computeBoundingSphere(),
        _sphere$5.copy(o.boundingSphere).applyMatrix4(e.matrixWorld);
    }
    return this.intersectsSphere(_sphere$5);
  }
  intersectsSprite(e) {
    return (
      _sphere$5.center.set(0, 0, 0),
      (_sphere$5.radius = 0.7071067811865476),
      _sphere$5.applyMatrix4(e.matrixWorld),
      this.intersectsSphere(_sphere$5)
    );
  }
  intersectsSphere(e) {
    const o = this.planes,
      a = e.center,
      c = -e.radius;
    for (let d = 0; d < 6; d++) if (o[d].distanceToPoint(a) < c) return !1;
    return !0;
  }
  intersectsBox(e) {
    const o = this.planes;
    for (let a = 0; a < 6; a++) {
      const c = o[a];
      if (
        ((_vector$7.x = c.normal.x > 0 ? e.max.x : e.min.x),
        (_vector$7.y = c.normal.y > 0 ? e.max.y : e.min.y),
        (_vector$7.z = c.normal.z > 0 ? e.max.z : e.min.z),
        c.distanceToPoint(_vector$7) < 0)
      )
        return !1;
    }
    return !0;
  }
  containsPoint(e) {
    const o = this.planes;
    for (let a = 0; a < 6; a++) if (o[a].distanceToPoint(e) < 0) return !1;
    return !0;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
function WebGLAnimation() {
  let s = null,
    e = !1,
    o = null,
    a = null;
  function c(d, g) {
    o(d, g), (a = s.requestAnimationFrame(c));
  }
  return {
    start: function () {
      e !== !0 && o !== null && ((a = s.requestAnimationFrame(c)), (e = !0));
    },
    stop: function () {
      s.cancelAnimationFrame(a), (e = !1);
    },
    setAnimationLoop: function (d) {
      o = d;
    },
    setContext: function (d) {
      s = d;
    },
  };
}
function WebGLAttributes(s) {
  const e = new WeakMap();
  function o(_, b) {
    const j = _.array,
      $ = _.usage,
      _e = j.byteLength,
      et = s.createBuffer();
    s.bindBuffer(b, et), s.bufferData(b, j, $), _.onUploadCallback();
    let rt;
    if (j instanceof Float32Array) rt = s.FLOAT;
    else if (j instanceof Uint16Array)
      _.isFloat16BufferAttribute
        ? (rt = s.HALF_FLOAT)
        : (rt = s.UNSIGNED_SHORT);
    else if (j instanceof Int16Array) rt = s.SHORT;
    else if (j instanceof Uint32Array) rt = s.UNSIGNED_INT;
    else if (j instanceof Int32Array) rt = s.INT;
    else if (j instanceof Int8Array) rt = s.BYTE;
    else if (j instanceof Uint8Array) rt = s.UNSIGNED_BYTE;
    else if (j instanceof Uint8ClampedArray) rt = s.UNSIGNED_BYTE;
    else
      throw new Error(
        "THREE.WebGLAttributes: Unsupported buffer data format: " + j
      );
    return {
      buffer: et,
      type: rt,
      bytesPerElement: j.BYTES_PER_ELEMENT,
      version: _.version,
      size: _e,
    };
  }
  function a(_, b, j) {
    const $ = b.array,
      _e = b._updateRange,
      et = b.updateRanges;
    if (
      (s.bindBuffer(j, _),
      _e.count === -1 && et.length === 0 && s.bufferSubData(j, 0, $),
      et.length !== 0)
    ) {
      for (let rt = 0, st = et.length; rt < st; rt++) {
        const at = et[rt];
        s.bufferSubData(
          j,
          at.start * $.BYTES_PER_ELEMENT,
          $,
          at.start,
          at.count
        );
      }
      b.clearUpdateRanges();
    }
    _e.count !== -1 &&
      (s.bufferSubData(
        j,
        _e.offset * $.BYTES_PER_ELEMENT,
        $,
        _e.offset,
        _e.count
      ),
      (_e.count = -1)),
      b.onUploadCallback();
  }
  function c(_) {
    return _.isInterleavedBufferAttribute && (_ = _.data), e.get(_);
  }
  function d(_) {
    _.isInterleavedBufferAttribute && (_ = _.data);
    const b = e.get(_);
    b && (s.deleteBuffer(b.buffer), e.delete(_));
  }
  function g(_, b) {
    if (
      (_.isInterleavedBufferAttribute && (_ = _.data), _.isGLBufferAttribute)
    ) {
      const $ = e.get(_);
      (!$ || $.version < _.version) &&
        e.set(_, {
          buffer: _.buffer,
          type: _.type,
          bytesPerElement: _.elementSize,
          version: _.version,
        });
      return;
    }
    const j = e.get(_);
    if (j === void 0) e.set(_, o(_, b));
    else if (j.version < _.version) {
      if (j.size !== _.array.byteLength)
        throw new Error(
          "THREE.WebGLAttributes: The size of the buffer attribute's array buffer does not match the original size. Resizing buffer attributes is not supported."
        );
      a(j.buffer, _, b), (j.version = _.version);
    }
  }
  return { get: c, remove: d, update: g };
}
class PlaneGeometry extends BufferGeometry {
  constructor(e = 1, o = 1, a = 1, c = 1) {
    super(),
      (this.type = "PlaneGeometry"),
      (this.parameters = {
        width: e,
        height: o,
        widthSegments: a,
        heightSegments: c,
      });
    const d = e / 2,
      g = o / 2,
      _ = Math.floor(a),
      b = Math.floor(c),
      j = _ + 1,
      $ = b + 1,
      _e = e / _,
      et = o / b,
      rt = [],
      st = [],
      at = [],
      ct = [];
    for (let it = 0; it < $; it++) {
      const lt = it * et - g;
      for (let ot = 0; ot < j; ot++) {
        const ut = ot * _e - d;
        st.push(ut, -lt, 0),
          at.push(0, 0, 1),
          ct.push(ot / _),
          ct.push(1 - it / b);
      }
    }
    for (let it = 0; it < b; it++)
      for (let lt = 0; lt < _; lt++) {
        const ot = lt + j * it,
          ut = lt + j * (it + 1),
          pt = lt + 1 + j * (it + 1),
          ft = lt + 1 + j * it;
        rt.push(ot, ut, ft), rt.push(ut, pt, ft);
      }
    this.setIndex(rt),
      this.setAttribute("position", new Float32BufferAttribute(st, 3)),
      this.setAttribute("normal", new Float32BufferAttribute(at, 3)),
      this.setAttribute("uv", new Float32BufferAttribute(ct, 2));
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  static fromJSON(e) {
    return new PlaneGeometry(
      e.width,
      e.height,
      e.widthSegments,
      e.heightSegments
    );
  }
}
var alphahash_fragment = `#ifdef USE_ALPHAHASH
	if ( diffuseColor.a < getAlphaHashThreshold( vPosition ) ) discard;
#endif`,
  alphahash_pars_fragment = `#ifdef USE_ALPHAHASH
	const float ALPHA_HASH_SCALE = 0.05;
	float hash2D( vec2 value ) {
		return fract( 1.0e4 * sin( 17.0 * value.x + 0.1 * value.y ) * ( 0.1 + abs( sin( 13.0 * value.y + value.x ) ) ) );
	}
	float hash3D( vec3 value ) {
		return hash2D( vec2( hash2D( value.xy ), value.z ) );
	}
	float getAlphaHashThreshold( vec3 position ) {
		float maxDeriv = max(
			length( dFdx( position.xyz ) ),
			length( dFdy( position.xyz ) )
		);
		float pixScale = 1.0 / ( ALPHA_HASH_SCALE * maxDeriv );
		vec2 pixScales = vec2(
			exp2( floor( log2( pixScale ) ) ),
			exp2( ceil( log2( pixScale ) ) )
		);
		vec2 alpha = vec2(
			hash3D( floor( pixScales.x * position.xyz ) ),
			hash3D( floor( pixScales.y * position.xyz ) )
		);
		float lerpFactor = fract( log2( pixScale ) );
		float x = ( 1.0 - lerpFactor ) * alpha.x + lerpFactor * alpha.y;
		float a = min( lerpFactor, 1.0 - lerpFactor );
		vec3 cases = vec3(
			x * x / ( 2.0 * a * ( 1.0 - a ) ),
			( x - 0.5 * a ) / ( 1.0 - a ),
			1.0 - ( ( 1.0 - x ) * ( 1.0 - x ) / ( 2.0 * a * ( 1.0 - a ) ) )
		);
		float threshold = ( x < ( 1.0 - a ) )
			? ( ( x < a ) ? cases.x : cases.y )
			: cases.z;
		return clamp( threshold , 1.0e-6, 1.0 );
	}
#endif`,
  alphamap_fragment = `#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, vAlphaMapUv ).g;
#endif`,
  alphamap_pars_fragment = `#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,
  alphatest_fragment = `#ifdef USE_ALPHATEST
	#ifdef ALPHA_TO_COVERAGE
	diffuseColor.a = smoothstep( alphaTest, alphaTest + fwidth( diffuseColor.a ), diffuseColor.a );
	if ( diffuseColor.a == 0.0 ) discard;
	#else
	if ( diffuseColor.a < alphaTest ) discard;
	#endif
#endif`,
  alphatest_pars_fragment = `#ifdef USE_ALPHATEST
	uniform float alphaTest;
#endif`,
  aomap_fragment = `#ifdef USE_AOMAP
	float ambientOcclusion = ( texture2D( aoMap, vAoMapUv ).r - 1.0 ) * aoMapIntensity + 1.0;
	reflectedLight.indirectDiffuse *= ambientOcclusion;
	#if defined( USE_CLEARCOAT ) 
		clearcoatSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_SHEEN ) 
		sheenSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD )
		float dotNV = saturate( dot( geometryNormal, geometryViewDir ) );
		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );
	#endif
#endif`,
  aomap_pars_fragment = `#ifdef USE_AOMAP
	uniform sampler2D aoMap;
	uniform float aoMapIntensity;
#endif`,
  batching_pars_vertex = `#ifdef USE_BATCHING
	#if ! defined( GL_ANGLE_multi_draw )
	#define gl_DrawID _gl_DrawID
	uniform int _gl_DrawID;
	#endif
	uniform highp sampler2D batchingTexture;
	uniform highp usampler2D batchingIdTexture;
	mat4 getBatchingMatrix( const in float i ) {
		int size = textureSize( batchingTexture, 0 ).x;
		int j = int( i ) * 4;
		int x = j % size;
		int y = j / size;
		vec4 v1 = texelFetch( batchingTexture, ivec2( x, y ), 0 );
		vec4 v2 = texelFetch( batchingTexture, ivec2( x + 1, y ), 0 );
		vec4 v3 = texelFetch( batchingTexture, ivec2( x + 2, y ), 0 );
		vec4 v4 = texelFetch( batchingTexture, ivec2( x + 3, y ), 0 );
		return mat4( v1, v2, v3, v4 );
	}
	float getIndirectIndex( const in int i ) {
		int size = textureSize( batchingIdTexture, 0 ).x;
		int x = i % size;
		int y = i / size;
		return float( texelFetch( batchingIdTexture, ivec2( x, y ), 0 ).r );
	}
#endif
#ifdef USE_BATCHING_COLOR
	uniform sampler2D batchingColorTexture;
	vec3 getBatchingColor( const in float i ) {
		int size = textureSize( batchingColorTexture, 0 ).x;
		int j = int( i );
		int x = j % size;
		int y = j / size;
		return texelFetch( batchingColorTexture, ivec2( x, y ), 0 ).rgb;
	}
#endif`,
  batching_vertex = `#ifdef USE_BATCHING
	mat4 batchingMatrix = getBatchingMatrix( getIndirectIndex( gl_DrawID ) );
#endif`,
  begin_vertex = `vec3 transformed = vec3( position );
#ifdef USE_ALPHAHASH
	vPosition = vec3( position );
#endif`,
  beginnormal_vertex = `vec3 objectNormal = vec3( normal );
#ifdef USE_TANGENT
	vec3 objectTangent = vec3( tangent.xyz );
#endif`,
  bsdfs = `float G_BlinnPhong_Implicit( ) {
	return 0.25;
}
float D_BlinnPhong( const in float shininess, const in float dotNH ) {
	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );
}
vec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( specularColor, 1.0, dotVH );
	float G = G_BlinnPhong_Implicit( );
	float D = D_BlinnPhong( shininess, dotNH );
	return F * ( G * D );
} // validated`,
  iridescence_fragment = `#ifdef USE_IRIDESCENCE
	const mat3 XYZ_TO_REC709 = mat3(
		 3.2404542, -0.9692660,  0.0556434,
		-1.5371385,  1.8760108, -0.2040259,
		-0.4985314,  0.0415560,  1.0572252
	);
	vec3 Fresnel0ToIor( vec3 fresnel0 ) {
		vec3 sqrtF0 = sqrt( fresnel0 );
		return ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );
	}
	vec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );
	}
	float IorToFresnel0( float transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));
	}
	vec3 evalSensitivity( float OPD, vec3 shift ) {
		float phase = 2.0 * PI * OPD * 1.0e-9;
		vec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );
		vec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );
		vec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );
		vec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );
		xyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );
		xyz /= 1.0685e-7;
		vec3 rgb = XYZ_TO_REC709 * xyz;
		return rgb;
	}
	vec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {
		vec3 I;
		float iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );
		float sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );
		float cosTheta2Sq = 1.0 - sinTheta2Sq;
		if ( cosTheta2Sq < 0.0 ) {
			return vec3( 1.0 );
		}
		float cosTheta2 = sqrt( cosTheta2Sq );
		float R0 = IorToFresnel0( iridescenceIOR, outsideIOR );
		float R12 = F_Schlick( R0, 1.0, cosTheta1 );
		float T121 = 1.0 - R12;
		float phi12 = 0.0;
		if ( iridescenceIOR < outsideIOR ) phi12 = PI;
		float phi21 = PI - phi12;
		vec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );		vec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );
		vec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );
		vec3 phi23 = vec3( 0.0 );
		if ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;
		if ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;
		if ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;
		float OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;
		vec3 phi = vec3( phi21 ) + phi23;
		vec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );
		vec3 r123 = sqrt( R123 );
		vec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );
		vec3 C0 = R12 + Rs;
		I = C0;
		vec3 Cm = Rs - T121;
		for ( int m = 1; m <= 2; ++ m ) {
			Cm *= r123;
			vec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );
			I += Cm * Sm;
		}
		return max( I, vec3( 0.0 ) );
	}
#endif`,
  bumpmap_pars_fragment = `#ifdef USE_BUMPMAP
	uniform sampler2D bumpMap;
	uniform float bumpScale;
	vec2 dHdxy_fwd() {
		vec2 dSTdx = dFdx( vBumpMapUv );
		vec2 dSTdy = dFdy( vBumpMapUv );
		float Hll = bumpScale * texture2D( bumpMap, vBumpMapUv ).x;
		float dBx = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdx ).x - Hll;
		float dBy = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdy ).x - Hll;
		return vec2( dBx, dBy );
	}
	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {
		vec3 vSigmaX = normalize( dFdx( surf_pos.xyz ) );
		vec3 vSigmaY = normalize( dFdy( surf_pos.xyz ) );
		vec3 vN = surf_norm;
		vec3 R1 = cross( vSigmaY, vN );
		vec3 R2 = cross( vN, vSigmaX );
		float fDet = dot( vSigmaX, R1 ) * faceDirection;
		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
		return normalize( abs( fDet ) * surf_norm - vGrad );
	}
#endif`,
  clipping_planes_fragment = `#if NUM_CLIPPING_PLANES > 0
	vec4 plane;
	#ifdef ALPHA_TO_COVERAGE
		float distanceToPlane, distanceGradient;
		float clipOpacity = 1.0;
		#pragma unroll_loop_start
		for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			distanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;
			distanceGradient = fwidth( distanceToPlane ) / 2.0;
			clipOpacity *= smoothstep( - distanceGradient, distanceGradient, distanceToPlane );
			if ( clipOpacity == 0.0 ) discard;
		}
		#pragma unroll_loop_end
		#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
			float unionClipOpacity = 1.0;
			#pragma unroll_loop_start
			for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
				plane = clippingPlanes[ i ];
				distanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;
				distanceGradient = fwidth( distanceToPlane ) / 2.0;
				unionClipOpacity *= 1.0 - smoothstep( - distanceGradient, distanceGradient, distanceToPlane );
			}
			#pragma unroll_loop_end
			clipOpacity *= 1.0 - unionClipOpacity;
		#endif
		diffuseColor.a *= clipOpacity;
		if ( diffuseColor.a == 0.0 ) discard;
	#else
		#pragma unroll_loop_start
		for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;
		}
		#pragma unroll_loop_end
		#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
			bool clipped = true;
			#pragma unroll_loop_start
			for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
				plane = clippingPlanes[ i ];
				clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;
			}
			#pragma unroll_loop_end
			if ( clipped ) discard;
		#endif
	#endif
#endif`,
  clipping_planes_pars_fragment = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];
#endif`,
  clipping_planes_pars_vertex = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
#endif`,
  clipping_planes_vertex = `#if NUM_CLIPPING_PLANES > 0
	vClipPosition = - mvPosition.xyz;
#endif`,
  color_fragment = `#if defined( USE_COLOR_ALPHA )
	diffuseColor *= vColor;
#elif defined( USE_COLOR )
	diffuseColor.rgb *= vColor;
#endif`,
  color_pars_fragment = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR )
	varying vec3 vColor;
#endif`,
  color_pars_vertex = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )
	varying vec3 vColor;
#endif`,
  color_vertex = `#if defined( USE_COLOR_ALPHA )
	vColor = vec4( 1.0 );
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )
	vColor = vec3( 1.0 );
#endif
#ifdef USE_COLOR
	vColor *= color;
#endif
#ifdef USE_INSTANCING_COLOR
	vColor.xyz *= instanceColor.xyz;
#endif
#ifdef USE_BATCHING_COLOR
	vec3 batchingColor = getBatchingColor( getIndirectIndex( gl_DrawID ) );
	vColor.xyz *= batchingColor.xyz;
#endif`,
  common = `#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define EPSILON 1e-6
#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
#define whiteComplement( a ) ( 1.0 - saturate( a ) )
float pow2( const in float x ) { return x*x; }
vec3 pow2( const in vec3 x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }
float average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }
highp float rand( const in vec2 uv ) {
	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
	return fract( sin( sn ) * c );
}
#ifdef HIGH_PRECISION
	float precisionSafeLength( vec3 v ) { return length( v ); }
#else
	float precisionSafeLength( vec3 v ) {
		float maxComponent = max3( abs( v ) );
		return length( v / maxComponent ) * maxComponent;
	}
#endif
struct IncidentLight {
	vec3 color;
	vec3 direction;
	bool visible;
};
struct ReflectedLight {
	vec3 directDiffuse;
	vec3 directSpecular;
	vec3 indirectDiffuse;
	vec3 indirectSpecular;
};
#ifdef USE_ALPHAHASH
	varying vec3 vPosition;
#endif
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}
mat3 transposeMat3( const in mat3 m ) {
	mat3 tmp;
	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );
	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );
	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );
	return tmp;
}
bool isPerspectiveMatrix( mat4 m ) {
	return m[ 2 ][ 3 ] == - 1.0;
}
vec2 equirectUv( in vec3 dir ) {
	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;
	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
	return vec2( u, v );
}
vec3 BRDF_Lambert( const in vec3 diffuseColor ) {
	return RECIPROCAL_PI * diffuseColor;
}
vec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
}
float F_Schlick( const in float f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
} // validated`,
  cube_uv_reflection_fragment = `#ifdef ENVMAP_TYPE_CUBE_UV
	#define cubeUV_minMipLevel 4.0
	#define cubeUV_minTileSize 16.0
	float getFace( vec3 direction ) {
		vec3 absDirection = abs( direction );
		float face = - 1.0;
		if ( absDirection.x > absDirection.z ) {
			if ( absDirection.x > absDirection.y )
				face = direction.x > 0.0 ? 0.0 : 3.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		} else {
			if ( absDirection.z > absDirection.y )
				face = direction.z > 0.0 ? 2.0 : 5.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		}
		return face;
	}
	vec2 getUV( vec3 direction, float face ) {
		vec2 uv;
		if ( face == 0.0 ) {
			uv = vec2( direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 1.0 ) {
			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );
		} else if ( face == 2.0 ) {
			uv = vec2( - direction.x, direction.y ) / abs( direction.z );
		} else if ( face == 3.0 ) {
			uv = vec2( - direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 4.0 ) {
			uv = vec2( - direction.x, direction.z ) / abs( direction.y );
		} else {
			uv = vec2( direction.x, direction.y ) / abs( direction.z );
		}
		return 0.5 * ( uv + 1.0 );
	}
	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {
		float face = getFace( direction );
		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );
		mipInt = max( mipInt, cubeUV_minMipLevel );
		float faceSize = exp2( mipInt );
		highp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;
		if ( face > 2.0 ) {
			uv.y += faceSize;
			face -= 3.0;
		}
		uv.x += face * faceSize;
		uv.x += filterInt * 3.0 * cubeUV_minTileSize;
		uv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );
		uv.x *= CUBEUV_TEXEL_WIDTH;
		uv.y *= CUBEUV_TEXEL_HEIGHT;
		#ifdef texture2DGradEXT
			return texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;
		#else
			return texture2D( envMap, uv ).rgb;
		#endif
	}
	#define cubeUV_r0 1.0
	#define cubeUV_m0 - 2.0
	#define cubeUV_r1 0.8
	#define cubeUV_m1 - 1.0
	#define cubeUV_r4 0.4
	#define cubeUV_m4 2.0
	#define cubeUV_r5 0.305
	#define cubeUV_m5 3.0
	#define cubeUV_r6 0.21
	#define cubeUV_m6 4.0
	float roughnessToMip( float roughness ) {
		float mip = 0.0;
		if ( roughness >= cubeUV_r1 ) {
			mip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;
		} else if ( roughness >= cubeUV_r4 ) {
			mip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;
		} else if ( roughness >= cubeUV_r5 ) {
			mip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;
		} else if ( roughness >= cubeUV_r6 ) {
			mip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;
		} else {
			mip = - 2.0 * log2( 1.16 * roughness );		}
		return mip;
	}
	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {
		float mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );
		float mipF = fract( mip );
		float mipInt = floor( mip );
		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );
		if ( mipF == 0.0 ) {
			return vec4( color0, 1.0 );
		} else {
			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );
			return vec4( mix( color0, color1, mipF ), 1.0 );
		}
	}
#endif`,
  defaultnormal_vertex = `vec3 transformedNormal = objectNormal;
#ifdef USE_TANGENT
	vec3 transformedTangent = objectTangent;
#endif
#ifdef USE_BATCHING
	mat3 bm = mat3( batchingMatrix );
	transformedNormal /= vec3( dot( bm[ 0 ], bm[ 0 ] ), dot( bm[ 1 ], bm[ 1 ] ), dot( bm[ 2 ], bm[ 2 ] ) );
	transformedNormal = bm * transformedNormal;
	#ifdef USE_TANGENT
		transformedTangent = bm * transformedTangent;
	#endif
#endif
#ifdef USE_INSTANCING
	mat3 im = mat3( instanceMatrix );
	transformedNormal /= vec3( dot( im[ 0 ], im[ 0 ] ), dot( im[ 1 ], im[ 1 ] ), dot( im[ 2 ], im[ 2 ] ) );
	transformedNormal = im * transformedNormal;
	#ifdef USE_TANGENT
		transformedTangent = im * transformedTangent;
	#endif
#endif
transformedNormal = normalMatrix * transformedNormal;
#ifdef FLIP_SIDED
	transformedNormal = - transformedNormal;
#endif
#ifdef USE_TANGENT
	transformedTangent = ( modelViewMatrix * vec4( transformedTangent, 0.0 ) ).xyz;
	#ifdef FLIP_SIDED
		transformedTangent = - transformedTangent;
	#endif
#endif`,
  displacementmap_pars_vertex = `#ifdef USE_DISPLACEMENTMAP
	uniform sampler2D displacementMap;
	uniform float displacementScale;
	uniform float displacementBias;
#endif`,
  displacementmap_vertex = `#ifdef USE_DISPLACEMENTMAP
	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vDisplacementMapUv ).x * displacementScale + displacementBias );
#endif`,
  emissivemap_fragment = `#ifdef USE_EMISSIVEMAP
	vec4 emissiveColor = texture2D( emissiveMap, vEmissiveMapUv );
	totalEmissiveRadiance *= emissiveColor.rgb;
#endif`,
  emissivemap_pars_fragment = `#ifdef USE_EMISSIVEMAP
	uniform sampler2D emissiveMap;
#endif`,
  colorspace_fragment = "gl_FragColor = linearToOutputTexel( gl_FragColor );",
  colorspace_pars_fragment = `
const mat3 LINEAR_SRGB_TO_LINEAR_DISPLAY_P3 = mat3(
	vec3( 0.8224621, 0.177538, 0.0 ),
	vec3( 0.0331941, 0.9668058, 0.0 ),
	vec3( 0.0170827, 0.0723974, 0.9105199 )
);
const mat3 LINEAR_DISPLAY_P3_TO_LINEAR_SRGB = mat3(
	vec3( 1.2249401, - 0.2249404, 0.0 ),
	vec3( - 0.0420569, 1.0420571, 0.0 ),
	vec3( - 0.0196376, - 0.0786361, 1.0982735 )
);
vec4 LinearSRGBToLinearDisplayP3( in vec4 value ) {
	return vec4( value.rgb * LINEAR_SRGB_TO_LINEAR_DISPLAY_P3, value.a );
}
vec4 LinearDisplayP3ToLinearSRGB( in vec4 value ) {
	return vec4( value.rgb * LINEAR_DISPLAY_P3_TO_LINEAR_SRGB, value.a );
}
vec4 LinearTransferOETF( in vec4 value ) {
	return value;
}
vec4 sRGBTransferOETF( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}`,
  envmap_fragment = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vec3 cameraToFrag;
		if ( isOrthographic ) {
			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToFrag = normalize( vWorldPosition - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( cameraToFrag, worldNormal );
		#else
			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );
		#endif
	#else
		vec3 reflectVec = vReflect;
	#endif
	#ifdef ENVMAP_TYPE_CUBE
		vec4 envColor = textureCube( envMap, envMapRotation * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );
	#else
		vec4 envColor = vec4( 0.0 );
	#endif
	#ifdef ENVMAP_BLENDING_MULTIPLY
		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_MIX )
		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_ADD )
		outgoingLight += envColor.xyz * specularStrength * reflectivity;
	#endif
#endif`,
  envmap_common_pars_fragment = `#ifdef USE_ENVMAP
	uniform float envMapIntensity;
	uniform float flipEnvMap;
	uniform mat3 envMapRotation;
	#ifdef ENVMAP_TYPE_CUBE
		uniform samplerCube envMap;
	#else
		uniform sampler2D envMap;
	#endif
	
#endif`,
  envmap_pars_fragment = `#ifdef USE_ENVMAP
	uniform float reflectivity;
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		varying vec3 vWorldPosition;
		uniform float refractionRatio;
	#else
		varying vec3 vReflect;
	#endif
#endif`,
  envmap_pars_vertex = `#ifdef USE_ENVMAP
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		
		varying vec3 vWorldPosition;
	#else
		varying vec3 vReflect;
		uniform float refractionRatio;
	#endif
#endif`,
  envmap_vertex = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vWorldPosition = worldPosition.xyz;
	#else
		vec3 cameraToVertex;
		if ( isOrthographic ) {
			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vReflect = reflect( cameraToVertex, worldNormal );
		#else
			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );
		#endif
	#endif
#endif`,
  fog_vertex = `#ifdef USE_FOG
	vFogDepth = - mvPosition.z;
#endif`,
  fog_pars_vertex = `#ifdef USE_FOG
	varying float vFogDepth;
#endif`,
  fog_fragment = `#ifdef USE_FOG
	#ifdef FOG_EXP2
		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );
	#else
		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );
	#endif
	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
#endif`,
  fog_pars_fragment = `#ifdef USE_FOG
	uniform vec3 fogColor;
	varying float vFogDepth;
	#ifdef FOG_EXP2
		uniform float fogDensity;
	#else
		uniform float fogNear;
		uniform float fogFar;
	#endif
#endif`,
  gradientmap_pars_fragment = `#ifdef USE_GRADIENTMAP
	uniform sampler2D gradientMap;
#endif
vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {
	float dotNL = dot( normal, lightDirection );
	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );
	#ifdef USE_GRADIENTMAP
		return vec3( texture2D( gradientMap, coord ).r );
	#else
		vec2 fw = fwidth( coord ) * 0.5;
		return mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );
	#endif
}`,
  lightmap_pars_fragment = `#ifdef USE_LIGHTMAP
	uniform sampler2D lightMap;
	uniform float lightMapIntensity;
#endif`,
  lights_lambert_fragment = `LambertMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularStrength = specularStrength;`,
  lights_lambert_pars_fragment = `varying vec3 vViewPosition;
struct LambertMaterial {
	vec3 diffuseColor;
	float specularStrength;
};
void RE_Direct_Lambert( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Lambert
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Lambert`,
  lights_pars_begin = `uniform bool receiveShadow;
uniform vec3 ambientLightColor;
#if defined( USE_LIGHT_PROBES )
	uniform vec3 lightProbe[ 9 ];
#endif
vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {
	float x = normal.x, y = normal.y, z = normal.z;
	vec3 result = shCoefficients[ 0 ] * 0.886227;
	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;
	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;
	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;
	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;
	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;
	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );
	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;
	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );
	return result;
}
vec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {
	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );
	return irradiance;
}
vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {
	vec3 irradiance = ambientLightColor;
	return irradiance;
}
float getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {
	float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );
	if ( cutoffDistance > 0.0 ) {
		distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );
	}
	return distanceFalloff;
}
float getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {
	return smoothstep( coneCosine, penumbraCosine, angleCosine );
}
#if NUM_DIR_LIGHTS > 0
	struct DirectionalLight {
		vec3 direction;
		vec3 color;
	};
	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];
	void getDirectionalLightInfo( const in DirectionalLight directionalLight, out IncidentLight light ) {
		light.color = directionalLight.color;
		light.direction = directionalLight.direction;
		light.visible = true;
	}
#endif
#if NUM_POINT_LIGHTS > 0
	struct PointLight {
		vec3 position;
		vec3 color;
		float distance;
		float decay;
	};
	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];
	void getPointLightInfo( const in PointLight pointLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = pointLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float lightDistance = length( lVector );
		light.color = pointLight.color;
		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );
		light.visible = ( light.color != vec3( 0.0 ) );
	}
#endif
#if NUM_SPOT_LIGHTS > 0
	struct SpotLight {
		vec3 position;
		vec3 direction;
		vec3 color;
		float distance;
		float decay;
		float coneCos;
		float penumbraCos;
	};
	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];
	void getSpotLightInfo( const in SpotLight spotLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = spotLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float angleCos = dot( light.direction, spotLight.direction );
		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );
		if ( spotAttenuation > 0.0 ) {
			float lightDistance = length( lVector );
			light.color = spotLight.color * spotAttenuation;
			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );
			light.visible = ( light.color != vec3( 0.0 ) );
		} else {
			light.color = vec3( 0.0 );
			light.visible = false;
		}
	}
#endif
#if NUM_RECT_AREA_LIGHTS > 0
	struct RectAreaLight {
		vec3 color;
		vec3 position;
		vec3 halfWidth;
		vec3 halfHeight;
	};
	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;
	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];
#endif
#if NUM_HEMI_LIGHTS > 0
	struct HemisphereLight {
		vec3 direction;
		vec3 skyColor;
		vec3 groundColor;
	};
	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];
	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {
		float dotNL = dot( normal, hemiLight.direction );
		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;
		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );
		return irradiance;
	}
#endif`,
  envmap_physical_pars_fragment = `#ifdef USE_ENVMAP
	vec3 getIBLIrradiance( const in vec3 normal ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, envMapRotation * worldNormal, 1.0 );
			return PI * envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 reflectVec = reflect( - viewDir, normal );
			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );
			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, envMapRotation * reflectVec, roughness );
			return envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	#ifdef USE_ANISOTROPY
		vec3 getIBLAnisotropyRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in vec3 bitangent, const in float anisotropy ) {
			#ifdef ENVMAP_TYPE_CUBE_UV
				vec3 bentNormal = cross( bitangent, viewDir );
				bentNormal = normalize( cross( bentNormal, bitangent ) );
				bentNormal = normalize( mix( bentNormal, normal, pow2( pow2( 1.0 - anisotropy * ( 1.0 - roughness ) ) ) ) );
				return getIBLRadiance( viewDir, bentNormal, roughness );
			#else
				return vec3( 0.0 );
			#endif
		}
	#endif
#endif`,
  lights_toon_fragment = `ToonMaterial material;
material.diffuseColor = diffuseColor.rgb;`,
  lights_toon_pars_fragment = `varying vec3 vViewPosition;
struct ToonMaterial {
	vec3 diffuseColor;
};
void RE_Direct_Toon( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	vec3 irradiance = getGradientIrradiance( geometryNormal, directLight.direction ) * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Toon
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon`,
  lights_phong_fragment = `BlinnPhongMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;`,
  lights_phong_pars_fragment = `varying vec3 vViewPosition;
struct BlinnPhongMaterial {
	vec3 diffuseColor;
	vec3 specularColor;
	float specularShininess;
	float specularStrength;
};
void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometryViewDir, geometryNormal, material.specularColor, material.specularShininess ) * material.specularStrength;
}
void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong`,
  lights_physical_fragment = `PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );
vec3 dxy = max( abs( dFdx( nonPerturbedNormal ) ), abs( dFdy( nonPerturbedNormal ) ) );
float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );
material.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;
material.roughness = min( material.roughness, 1.0 );
#ifdef IOR
	material.ior = ior;
	#ifdef USE_SPECULAR
		float specularIntensityFactor = specularIntensity;
		vec3 specularColorFactor = specularColor;
		#ifdef USE_SPECULAR_COLORMAP
			specularColorFactor *= texture2D( specularColorMap, vSpecularColorMapUv ).rgb;
		#endif
		#ifdef USE_SPECULAR_INTENSITYMAP
			specularIntensityFactor *= texture2D( specularIntensityMap, vSpecularIntensityMapUv ).a;
		#endif
		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );
	#else
		float specularIntensityFactor = 1.0;
		vec3 specularColorFactor = vec3( 1.0 );
		material.specularF90 = 1.0;
	#endif
	material.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );
#else
	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );
	material.specularF90 = 1.0;
#endif
#ifdef USE_CLEARCOAT
	material.clearcoat = clearcoat;
	material.clearcoatRoughness = clearcoatRoughness;
	material.clearcoatF0 = vec3( 0.04 );
	material.clearcoatF90 = 1.0;
	#ifdef USE_CLEARCOATMAP
		material.clearcoat *= texture2D( clearcoatMap, vClearcoatMapUv ).x;
	#endif
	#ifdef USE_CLEARCOAT_ROUGHNESSMAP
		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vClearcoatRoughnessMapUv ).y;
	#endif
	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );
	material.clearcoatRoughness += geometryRoughness;
	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );
#endif
#ifdef USE_DISPERSION
	material.dispersion = dispersion;
#endif
#ifdef USE_IRIDESCENCE
	material.iridescence = iridescence;
	material.iridescenceIOR = iridescenceIOR;
	#ifdef USE_IRIDESCENCEMAP
		material.iridescence *= texture2D( iridescenceMap, vIridescenceMapUv ).r;
	#endif
	#ifdef USE_IRIDESCENCE_THICKNESSMAP
		material.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vIridescenceThicknessMapUv ).g + iridescenceThicknessMinimum;
	#else
		material.iridescenceThickness = iridescenceThicknessMaximum;
	#endif
#endif
#ifdef USE_SHEEN
	material.sheenColor = sheenColor;
	#ifdef USE_SHEEN_COLORMAP
		material.sheenColor *= texture2D( sheenColorMap, vSheenColorMapUv ).rgb;
	#endif
	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );
	#ifdef USE_SHEEN_ROUGHNESSMAP
		material.sheenRoughness *= texture2D( sheenRoughnessMap, vSheenRoughnessMapUv ).a;
	#endif
#endif
#ifdef USE_ANISOTROPY
	#ifdef USE_ANISOTROPYMAP
		mat2 anisotropyMat = mat2( anisotropyVector.x, anisotropyVector.y, - anisotropyVector.y, anisotropyVector.x );
		vec3 anisotropyPolar = texture2D( anisotropyMap, vAnisotropyMapUv ).rgb;
		vec2 anisotropyV = anisotropyMat * normalize( 2.0 * anisotropyPolar.rg - vec2( 1.0 ) ) * anisotropyPolar.b;
	#else
		vec2 anisotropyV = anisotropyVector;
	#endif
	material.anisotropy = length( anisotropyV );
	if( material.anisotropy == 0.0 ) {
		anisotropyV = vec2( 1.0, 0.0 );
	} else {
		anisotropyV /= material.anisotropy;
		material.anisotropy = saturate( material.anisotropy );
	}
	material.alphaT = mix( pow2( material.roughness ), 1.0, pow2( material.anisotropy ) );
	material.anisotropyT = tbn[ 0 ] * anisotropyV.x + tbn[ 1 ] * anisotropyV.y;
	material.anisotropyB = tbn[ 1 ] * anisotropyV.x - tbn[ 0 ] * anisotropyV.y;
#endif`,
  lights_physical_pars_fragment = `struct PhysicalMaterial {
	vec3 diffuseColor;
	float roughness;
	vec3 specularColor;
	float specularF90;
	float dispersion;
	#ifdef USE_CLEARCOAT
		float clearcoat;
		float clearcoatRoughness;
		vec3 clearcoatF0;
		float clearcoatF90;
	#endif
	#ifdef USE_IRIDESCENCE
		float iridescence;
		float iridescenceIOR;
		float iridescenceThickness;
		vec3 iridescenceFresnel;
		vec3 iridescenceF0;
	#endif
	#ifdef USE_SHEEN
		vec3 sheenColor;
		float sheenRoughness;
	#endif
	#ifdef IOR
		float ior;
	#endif
	#ifdef USE_TRANSMISSION
		float transmission;
		float transmissionAlpha;
		float thickness;
		float attenuationDistance;
		vec3 attenuationColor;
	#endif
	#ifdef USE_ANISOTROPY
		float anisotropy;
		float alphaT;
		vec3 anisotropyT;
		vec3 anisotropyB;
	#endif
};
vec3 clearcoatSpecularDirect = vec3( 0.0 );
vec3 clearcoatSpecularIndirect = vec3( 0.0 );
vec3 sheenSpecularDirect = vec3( 0.0 );
vec3 sheenSpecularIndirect = vec3(0.0 );
vec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {
    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );
    float x2 = x * x;
    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );
    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );
}
float V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	return 0.5 / max( gv + gl, EPSILON );
}
float D_GGX( const in float alpha, const in float dotNH ) {
	float a2 = pow2( alpha );
	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;
	return RECIPROCAL_PI * a2 / pow2( denom );
}
#ifdef USE_ANISOTROPY
	float V_GGX_SmithCorrelated_Anisotropic( const in float alphaT, const in float alphaB, const in float dotTV, const in float dotBV, const in float dotTL, const in float dotBL, const in float dotNV, const in float dotNL ) {
		float gv = dotNL * length( vec3( alphaT * dotTV, alphaB * dotBV, dotNV ) );
		float gl = dotNV * length( vec3( alphaT * dotTL, alphaB * dotBL, dotNL ) );
		float v = 0.5 / ( gv + gl );
		return saturate(v);
	}
	float D_GGX_Anisotropic( const in float alphaT, const in float alphaB, const in float dotNH, const in float dotTH, const in float dotBH ) {
		float a2 = alphaT * alphaB;
		highp vec3 v = vec3( alphaB * dotTH, alphaT * dotBH, a2 * dotNH );
		highp float v2 = dot( v, v );
		float w2 = a2 / v2;
		return RECIPROCAL_PI * a2 * pow2 ( w2 );
	}
#endif
#ifdef USE_CLEARCOAT
	vec3 BRDF_GGX_Clearcoat( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material) {
		vec3 f0 = material.clearcoatF0;
		float f90 = material.clearcoatF90;
		float roughness = material.clearcoatRoughness;
		float alpha = pow2( roughness );
		vec3 halfDir = normalize( lightDir + viewDir );
		float dotNL = saturate( dot( normal, lightDir ) );
		float dotNV = saturate( dot( normal, viewDir ) );
		float dotNH = saturate( dot( normal, halfDir ) );
		float dotVH = saturate( dot( viewDir, halfDir ) );
		vec3 F = F_Schlick( f0, f90, dotVH );
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
		return F * ( V * D );
	}
#endif
vec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {
	vec3 f0 = material.specularColor;
	float f90 = material.specularF90;
	float roughness = material.roughness;
	float alpha = pow2( roughness );
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( f0, f90, dotVH );
	#ifdef USE_IRIDESCENCE
		F = mix( F, material.iridescenceFresnel, material.iridescence );
	#endif
	#ifdef USE_ANISOTROPY
		float dotTL = dot( material.anisotropyT, lightDir );
		float dotTV = dot( material.anisotropyT, viewDir );
		float dotTH = dot( material.anisotropyT, halfDir );
		float dotBL = dot( material.anisotropyB, lightDir );
		float dotBV = dot( material.anisotropyB, viewDir );
		float dotBH = dot( material.anisotropyB, halfDir );
		float V = V_GGX_SmithCorrelated_Anisotropic( material.alphaT, alpha, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL );
		float D = D_GGX_Anisotropic( material.alphaT, alpha, dotNH, dotTH, dotBH );
	#else
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
	#endif
	return F * ( V * D );
}
vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {
	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;
	float dotNV = saturate( dot( N, V ) );
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );
	uv = uv * LUT_SCALE + LUT_BIAS;
	return uv;
}
float LTC_ClippedSphereFormFactor( const in vec3 f ) {
	float l = length( f );
	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );
}
vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {
	float x = dot( v1, v2 );
	float y = abs( x );
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;
	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;
	return cross( v1, v2 ) * theta_sintheta;
}
vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {
	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
	vec3 lightNormal = cross( v1, v2 );
	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 = - cross( N, T1 );
	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );
	return vec3( result );
}
#if defined( USE_SHEEN )
float D_Charlie( float roughness, float dotNH ) {
	float alpha = pow2( roughness );
	float invAlpha = 1.0 / alpha;
	float cos2h = dotNH * dotNH;
	float sin2h = max( 1.0 - cos2h, 0.0078125 );
	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );
}
float V_Neubelt( float dotNV, float dotNL ) {
	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );
}
vec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float D = D_Charlie( sheenRoughness, dotNH );
	float V = V_Neubelt( dotNV, dotNL );
	return sheenColor * ( D * V );
}
#endif
float IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	float r2 = roughness * roughness;
	float a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;
	float b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;
	float DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );
	return saturate( DG * RECIPROCAL_PI );
}
vec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );
	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );
	vec4 r = roughness * c0 + c1;
	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;
	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;
	return fab;
}
vec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	return specularColor * fab.x + specularF90 * fab.y;
}
#ifdef USE_IRIDESCENCE
void computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#else
void computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#endif
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	#ifdef USE_IRIDESCENCE
		vec3 Fr = mix( specularColor, iridescenceF0, iridescence );
	#else
		vec3 Fr = specularColor;
	#endif
	vec3 FssEss = Fr * fab.x + specularF90 * fab.y;
	float Ess = fab.x + fab.y;
	float Ems = 1.0 - Ess;
	vec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );
	singleScatter += FssEss;
	multiScatter += Fms * Ems;
}
#if NUM_RECT_AREA_LIGHTS > 0
	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
		vec3 normal = geometryNormal;
		vec3 viewDir = geometryViewDir;
		vec3 position = geometryPosition;
		vec3 lightPos = rectAreaLight.position;
		vec3 halfWidth = rectAreaLight.halfWidth;
		vec3 halfHeight = rectAreaLight.halfHeight;
		vec3 lightColor = rectAreaLight.color;
		float roughness = material.roughness;
		vec3 rectCoords[ 4 ];
		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;
		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;
		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;
		vec2 uv = LTC_Uv( normal, viewDir, roughness );
		vec4 t1 = texture2D( ltc_1, uv );
		vec4 t2 = texture2D( ltc_2, uv );
		mat3 mInv = mat3(
			vec3( t1.x, 0, t1.y ),
			vec3(    0, 1,    0 ),
			vec3( t1.z, 0, t1.w )
		);
		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );
		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );
		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );
	}
#endif
void RE_Direct_Physical( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifdef USE_CLEARCOAT
		float dotNLcc = saturate( dot( geometryClearcoatNormal, directLight.direction ) );
		vec3 ccIrradiance = dotNLcc * directLight.color;
		clearcoatSpecularDirect += ccIrradiance * BRDF_GGX_Clearcoat( directLight.direction, geometryViewDir, geometryClearcoatNormal, material );
	#endif
	#ifdef USE_SHEEN
		sheenSpecularDirect += irradiance * BRDF_Sheen( directLight.direction, geometryViewDir, geometryNormal, material.sheenColor, material.sheenRoughness );
	#endif
	reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometryViewDir, geometryNormal, material );
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {
	#ifdef USE_CLEARCOAT
		clearcoatSpecularIndirect += clearcoatRadiance * EnvironmentBRDF( geometryClearcoatNormal, geometryViewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		sheenSpecularIndirect += irradiance * material.sheenColor * IBLSheenBRDF( geometryNormal, geometryViewDir, material.sheenRoughness );
	#endif
	vec3 singleScattering = vec3( 0.0 );
	vec3 multiScattering = vec3( 0.0 );
	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;
	#ifdef USE_IRIDESCENCE
		computeMultiscatteringIridescence( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );
	#else
		computeMultiscattering( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );
	#endif
	vec3 totalScattering = singleScattering + multiScattering;
	vec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );
	reflectedLight.indirectSpecular += radiance * singleScattering;
	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;
	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;
}
#define RE_Direct				RE_Direct_Physical
#define RE_Direct_RectArea		RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular		RE_IndirectSpecular_Physical
float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {
	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );
}`,
  lights_fragment_begin = `
vec3 geometryPosition = - vViewPosition;
vec3 geometryNormal = normal;
vec3 geometryViewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );
vec3 geometryClearcoatNormal = vec3( 0.0 );
#ifdef USE_CLEARCOAT
	geometryClearcoatNormal = clearcoatNormal;
#endif
#ifdef USE_IRIDESCENCE
	float dotNVi = saturate( dot( normal, geometryViewDir ) );
	if ( material.iridescenceThickness == 0.0 ) {
		material.iridescence = 0.0;
	} else {
		material.iridescence = saturate( material.iridescence );
	}
	if ( material.iridescence > 0.0 ) {
		material.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );
		material.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );
	}
#endif
IncidentLight directLight;
#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )
	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		pointLight = pointLights[ i ];
		getPointLightInfo( pointLight, geometryPosition, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowIntensity, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )
	SpotLight spotLight;
	vec4 spotColor;
	vec3 spotLightCoord;
	bool inSpotLightMap;
	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		spotLight = spotLights[ i ];
		getSpotLightInfo( spotLight, geometryPosition, directLight );
		#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX
		#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS
		#else
		#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#endif
		#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )
			spotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;
			inSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );
			spotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );
			directLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;
		#endif
		#undef SPOT_LIGHT_MAP_INDEX
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowIntensity, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )
	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		directionalLight = directionalLights[ i ];
		getDirectionalLightInfo( directionalLight, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowIntensity, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )
	RectAreaLight rectAreaLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {
		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if defined( RE_IndirectDiffuse )
	vec3 iblIrradiance = vec3( 0.0 );
	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );
	#if defined( USE_LIGHT_PROBES )
		irradiance += getLightProbeIrradiance( lightProbe, geometryNormal );
	#endif
	#if ( NUM_HEMI_LIGHTS > 0 )
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometryNormal );
		}
		#pragma unroll_loop_end
	#endif
#endif
#if defined( RE_IndirectSpecular )
	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );
#endif`,
  lights_fragment_maps = `#if defined( RE_IndirectDiffuse )
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
		irradiance += lightMapIrradiance;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )
		iblIrradiance += getIBLIrradiance( geometryNormal );
	#endif
#endif
#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )
	#ifdef USE_ANISOTROPY
		radiance += getIBLAnisotropyRadiance( geometryViewDir, geometryNormal, material.roughness, material.anisotropyB, material.anisotropy );
	#else
		radiance += getIBLRadiance( geometryViewDir, geometryNormal, material.roughness );
	#endif
	#ifdef USE_CLEARCOAT
		clearcoatRadiance += getIBLRadiance( geometryViewDir, geometryClearcoatNormal, material.clearcoatRoughness );
	#endif
#endif`,
  lights_fragment_end = `#if defined( RE_IndirectDiffuse )
	RE_IndirectDiffuse( irradiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif
#if defined( RE_IndirectSpecular )
	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif`,
  logdepthbuf_fragment = `#if defined( USE_LOGDEPTHBUF )
	gl_FragDepth = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;
#endif`,
  logdepthbuf_pars_fragment = `#if defined( USE_LOGDEPTHBUF )
	uniform float logDepthBufFC;
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`,
  logdepthbuf_pars_vertex = `#ifdef USE_LOGDEPTHBUF
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`,
  logdepthbuf_vertex = `#ifdef USE_LOGDEPTHBUF
	vFragDepth = 1.0 + gl_Position.w;
	vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );
#endif`,
  map_fragment = `#ifdef USE_MAP
	vec4 sampledDiffuseColor = texture2D( map, vMapUv );
	#ifdef DECODE_VIDEO_TEXTURE
		sampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );
	
	#endif
	diffuseColor *= sampledDiffuseColor;
#endif`,
  map_pars_fragment = `#ifdef USE_MAP
	uniform sampler2D map;
#endif`,
  map_particle_fragment = `#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	#if defined( USE_POINTS_UV )
		vec2 uv = vUv;
	#else
		vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;
	#endif
#endif
#ifdef USE_MAP
	diffuseColor *= texture2D( map, uv );
#endif
#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, uv ).g;
#endif`,
  map_particle_pars_fragment = `#if defined( USE_POINTS_UV )
	varying vec2 vUv;
#else
	#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
		uniform mat3 uvTransform;
	#endif
#endif
#ifdef USE_MAP
	uniform sampler2D map;
#endif
#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,
  metalnessmap_fragment = `float metalnessFactor = metalness;
#ifdef USE_METALNESSMAP
	vec4 texelMetalness = texture2D( metalnessMap, vMetalnessMapUv );
	metalnessFactor *= texelMetalness.b;
#endif`,
  metalnessmap_pars_fragment = `#ifdef USE_METALNESSMAP
	uniform sampler2D metalnessMap;
#endif`,
  morphinstance_vertex = `#ifdef USE_INSTANCING_MORPH
	float morphTargetInfluences[ MORPHTARGETS_COUNT ];
	float morphTargetBaseInfluence = texelFetch( morphTexture, ivec2( 0, gl_InstanceID ), 0 ).r;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		morphTargetInfluences[i] =  texelFetch( morphTexture, ivec2( i + 1, gl_InstanceID ), 0 ).r;
	}
#endif`,
  morphcolor_vertex = `#if defined( USE_MORPHCOLORS )
	vColor *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		#if defined( USE_COLOR_ALPHA )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];
		#elif defined( USE_COLOR )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];
		#endif
	}
#endif`,
  morphnormal_vertex = `#ifdef USE_MORPHNORMALS
	objectNormal *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		if ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];
	}
#endif`,
  morphtarget_pars_vertex = `#ifdef USE_MORPHTARGETS
	#ifndef USE_INSTANCING_MORPH
		uniform float morphTargetBaseInfluence;
		uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];
	#endif
	uniform sampler2DArray morphTargetsTexture;
	uniform ivec2 morphTargetsTextureSize;
	vec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {
		int texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;
		int y = texelIndex / morphTargetsTextureSize.x;
		int x = texelIndex - y * morphTargetsTextureSize.x;
		ivec3 morphUV = ivec3( x, y, morphTargetIndex );
		return texelFetch( morphTargetsTexture, morphUV, 0 );
	}
#endif`,
  morphtarget_vertex = `#ifdef USE_MORPHTARGETS
	transformed *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		if ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];
	}
#endif`,
  normal_fragment_begin = `float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;
#ifdef FLAT_SHADED
	vec3 fdx = dFdx( vViewPosition );
	vec3 fdy = dFdy( vViewPosition );
	vec3 normal = normalize( cross( fdx, fdy ) );
#else
	vec3 normal = normalize( vNormal );
	#ifdef DOUBLE_SIDED
		normal *= faceDirection;
	#endif
#endif
#if defined( USE_NORMALMAP_TANGENTSPACE ) || defined( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY )
	#ifdef USE_TANGENT
		mat3 tbn = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn = getTangentFrame( - vViewPosition, normal,
		#if defined( USE_NORMALMAP )
			vNormalMapUv
		#elif defined( USE_CLEARCOAT_NORMALMAP )
			vClearcoatNormalMapUv
		#else
			vUv
		#endif
		);
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn[0] *= faceDirection;
		tbn[1] *= faceDirection;
	#endif
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	#ifdef USE_TANGENT
		mat3 tbn2 = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn2 = getTangentFrame( - vViewPosition, normal, vClearcoatNormalMapUv );
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn2[0] *= faceDirection;
		tbn2[1] *= faceDirection;
	#endif
#endif
vec3 nonPerturbedNormal = normal;`,
  normal_fragment_maps = `#ifdef USE_NORMALMAP_OBJECTSPACE
	normal = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	#ifdef FLIP_SIDED
		normal = - normal;
	#endif
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	normal = normalize( normalMatrix * normal );
#elif defined( USE_NORMALMAP_TANGENTSPACE )
	vec3 mapN = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	mapN.xy *= normalScale;
	normal = normalize( tbn * mapN );
#elif defined( USE_BUMPMAP )
	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );
#endif`,
  normal_pars_fragment = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,
  normal_pars_vertex = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,
  normal_vertex = `#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif`,
  normalmap_pars_fragment = `#ifdef USE_NORMALMAP
	uniform sampler2D normalMap;
	uniform vec2 normalScale;
#endif
#ifdef USE_NORMALMAP_OBJECTSPACE
	uniform mat3 normalMatrix;
#endif
#if ! defined ( USE_TANGENT ) && ( defined ( USE_NORMALMAP_TANGENTSPACE ) || defined ( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY ) )
	mat3 getTangentFrame( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {
		vec3 q0 = dFdx( eye_pos.xyz );
		vec3 q1 = dFdy( eye_pos.xyz );
		vec2 st0 = dFdx( uv.st );
		vec2 st1 = dFdy( uv.st );
		vec3 N = surf_norm;
		vec3 q1perp = cross( q1, N );
		vec3 q0perp = cross( N, q0 );
		vec3 T = q1perp * st0.x + q0perp * st1.x;
		vec3 B = q1perp * st0.y + q0perp * st1.y;
		float det = max( dot( T, T ), dot( B, B ) );
		float scale = ( det == 0.0 ) ? 0.0 : inversesqrt( det );
		return mat3( T * scale, B * scale, N );
	}
#endif`,
  clearcoat_normal_fragment_begin = `#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal = nonPerturbedNormal;
#endif`,
  clearcoat_normal_fragment_maps = `#ifdef USE_CLEARCOAT_NORMALMAP
	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vClearcoatNormalMapUv ).xyz * 2.0 - 1.0;
	clearcoatMapN.xy *= clearcoatNormalScale;
	clearcoatNormal = normalize( tbn2 * clearcoatMapN );
#endif`,
  clearcoat_pars_fragment = `#ifdef USE_CLEARCOATMAP
	uniform sampler2D clearcoatMap;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform sampler2D clearcoatNormalMap;
	uniform vec2 clearcoatNormalScale;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform sampler2D clearcoatRoughnessMap;
#endif`,
  iridescence_pars_fragment = `#ifdef USE_IRIDESCENCEMAP
	uniform sampler2D iridescenceMap;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform sampler2D iridescenceThicknessMap;
#endif`,
  opaque_fragment = `#ifdef OPAQUE
diffuseColor.a = 1.0;
#endif
#ifdef USE_TRANSMISSION
diffuseColor.a *= material.transmissionAlpha;
#endif
gl_FragColor = vec4( outgoingLight, diffuseColor.a );`,
  packing = `vec3 packNormalToRGB( const in vec3 normal ) {
	return normalize( normal ) * 0.5 + 0.5;
}
vec3 unpackRGBToNormal( const in vec3 rgb ) {
	return 2.0 * rgb.xyz - 1.0;
}
const float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;const float ShiftRight8 = 1. / 256.;
const float Inv255 = 1. / 255.;
const vec4 PackFactors = vec4( 1.0, 256.0, 256.0 * 256.0, 256.0 * 256.0 * 256.0 );
const vec2 UnpackFactors2 = vec2( UnpackDownscale, 1.0 / PackFactors.g );
const vec3 UnpackFactors3 = vec3( UnpackDownscale / PackFactors.rg, 1.0 / PackFactors.b );
const vec4 UnpackFactors4 = vec4( UnpackDownscale / PackFactors.rgb, 1.0 / PackFactors.a );
vec4 packDepthToRGBA( const in float v ) {
	if( v <= 0.0 )
		return vec4( 0., 0., 0., 0. );
	if( v >= 1.0 )
		return vec4( 1., 1., 1., 1. );
	float vuf;
	float af = modf( v * PackFactors.a, vuf );
	float bf = modf( vuf * ShiftRight8, vuf );
	float gf = modf( vuf * ShiftRight8, vuf );
	return vec4( vuf * Inv255, gf * PackUpscale, bf * PackUpscale, af );
}
vec3 packDepthToRGB( const in float v ) {
	if( v <= 0.0 )
		return vec3( 0., 0., 0. );
	if( v >= 1.0 )
		return vec3( 1., 1., 1. );
	float vuf;
	float bf = modf( v * PackFactors.b, vuf );
	float gf = modf( vuf * ShiftRight8, vuf );
	return vec3( vuf * Inv255, gf * PackUpscale, bf );
}
vec2 packDepthToRG( const in float v ) {
	if( v <= 0.0 )
		return vec2( 0., 0. );
	if( v >= 1.0 )
		return vec2( 1., 1. );
	float vuf;
	float gf = modf( v * 256., vuf );
	return vec2( vuf * Inv255, gf );
}
float unpackRGBAToDepth( const in vec4 v ) {
	return dot( v, UnpackFactors4 );
}
float unpackRGBToDepth( const in vec3 v ) {
	return dot( v, UnpackFactors3 );
}
float unpackRGToDepth( const in vec2 v ) {
	return v.r * UnpackFactors2.r + v.g * UnpackFactors2.g;
}
vec4 pack2HalfToRGBA( const in vec2 v ) {
	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );
	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );
}
vec2 unpackRGBATo2Half( const in vec4 v ) {
	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );
}
float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
	return ( viewZ + near ) / ( near - far );
}
float orthographicDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return depth * ( near - far ) - near;
}
float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );
}
float perspectiveDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return ( near * far ) / ( ( far - near ) * depth - far );
}`,
  premultiplied_alpha_fragment = `#ifdef PREMULTIPLIED_ALPHA
	gl_FragColor.rgb *= gl_FragColor.a;
#endif`,
  project_vertex = `vec4 mvPosition = vec4( transformed, 1.0 );
#ifdef USE_BATCHING
	mvPosition = batchingMatrix * mvPosition;
#endif
#ifdef USE_INSTANCING
	mvPosition = instanceMatrix * mvPosition;
#endif
mvPosition = modelViewMatrix * mvPosition;
gl_Position = projectionMatrix * mvPosition;`,
  dithering_fragment = `#ifdef DITHERING
	gl_FragColor.rgb = dithering( gl_FragColor.rgb );
#endif`,
  dithering_pars_fragment = `#ifdef DITHERING
	vec3 dithering( vec3 color ) {
		float grid_position = rand( gl_FragCoord.xy );
		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );
		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );
		return color + dither_shift_RGB;
	}
#endif`,
  roughnessmap_fragment = `float roughnessFactor = roughness;
#ifdef USE_ROUGHNESSMAP
	vec4 texelRoughness = texture2D( roughnessMap, vRoughnessMapUv );
	roughnessFactor *= texelRoughness.g;
#endif`,
  roughnessmap_pars_fragment = `#ifdef USE_ROUGHNESSMAP
	uniform sampler2D roughnessMap;
#endif`,
  shadowmap_pars_fragment = `#if NUM_SPOT_LIGHT_COORDS > 0
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#if NUM_SPOT_LIGHT_MAPS > 0
	uniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {
		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );
	}
	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {
		return unpackRGBATo2Half( texture2D( shadow, uv ) );
	}
	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){
		float occlusion = 1.0;
		vec2 distribution = texture2DDistribution( shadow, uv );
		float hard_shadow = step( compare , distribution.x );
		if (hard_shadow != 1.0 ) {
			float distance = compare - distribution.x ;
			float variance = max( 0.00000, distribution.y * distribution.y );
			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );
		}
		return occlusion;
	}
	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
		float shadow = 1.0;
		shadowCoord.xyz /= shadowCoord.w;
		shadowCoord.z += shadowBias;
		bool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;
		bool frustumTest = inFrustum && shadowCoord.z <= 1.0;
		if ( frustumTest ) {
		#if defined( SHADOWMAP_TYPE_PCF )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx0 = - texelSize.x * shadowRadius;
			float dy0 = - texelSize.y * shadowRadius;
			float dx1 = + texelSize.x * shadowRadius;
			float dy1 = + texelSize.y * shadowRadius;
			float dx2 = dx0 / 2.0;
			float dy2 = dy0 / 2.0;
			float dx3 = dx1 / 2.0;
			float dy3 = dy1 / 2.0;
			shadow = (
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
			) * ( 1.0 / 17.0 );
		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx = texelSize.x;
			float dy = texelSize.y;
			vec2 uv = shadowCoord.xy;
			vec2 f = fract( uv * shadowMapSize + 0.5 );
			uv -= f * texelSize;
			shadow = (
				texture2DCompare( shadowMap, uv, shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),
						  f.x ),
					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),
						  f.x ),
					 f.y )
			) * ( 1.0 / 9.0 );
		#elif defined( SHADOWMAP_TYPE_VSM )
			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );
		#else
			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );
		#endif
		}
		return mix( 1.0, shadow, shadowIntensity );
	}
	vec2 cubeToUV( vec3 v, float texelSizeY ) {
		vec3 absV = abs( v );
		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
		absV *= scaleToCube;
		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );
		vec2 planar = v.xy;
		float almostATexel = 1.5 * texelSizeY;
		float almostOne = 1.0 - almostATexel;
		if ( absV.z >= almostOne ) {
			if ( v.z > 0.0 )
				planar.x = 4.0 - v.x;
		} else if ( absV.x >= almostOne ) {
			float signX = sign( v.x );
			planar.x = v.z * signX + 2.0 * signX;
		} else if ( absV.y >= almostOne ) {
			float signY = sign( v.y );
			planar.x = v.x + 2.0 * signY + 2.0;
			planar.y = v.z * signY - 2.0;
		}
		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );
	}
	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {
		float shadow = 1.0;
		vec3 lightToPosition = shadowCoord.xyz;
		
		float lightToPositionLength = length( lightToPosition );
		if ( lightToPositionLength - shadowCameraFar <= 0.0 && lightToPositionLength - shadowCameraNear >= 0.0 ) {
			float dp = ( lightToPositionLength - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );			dp += shadowBias;
			vec3 bd3D = normalize( lightToPosition );
			vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );
			#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )
				vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;
				shadow = (
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )
				) * ( 1.0 / 9.0 );
			#else
				shadow = texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );
			#endif
		}
		return mix( 1.0, shadow, shadowIntensity );
	}
#endif`,
  shadowmap_pars_vertex = `#if NUM_SPOT_LIGHT_COORDS > 0
	uniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		struct SpotLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
#endif`,
  shadowmap_vertex = `#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )
	vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
	vec4 shadowWorldPosition;
#endif
#if defined( USE_SHADOWMAP )
	#if NUM_DIR_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );
			vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );
			vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
#endif
#if NUM_SPOT_LIGHT_COORDS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {
		shadowWorldPosition = worldPosition;
		#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
			shadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;
		#endif
		vSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
#endif`,
  shadowmask_pars_fragment = `float getShadowMask() {
	float shadow = 1.0;
	#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		directionalLight = directionalLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowIntensity, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		spotLight = spotLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowIntensity, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		pointLight = pointLightShadows[ i ];
		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowIntensity, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#endif
	return shadow;
}`,
  skinbase_vertex = `#ifdef USE_SKINNING
	mat4 boneMatX = getBoneMatrix( skinIndex.x );
	mat4 boneMatY = getBoneMatrix( skinIndex.y );
	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
	mat4 boneMatW = getBoneMatrix( skinIndex.w );
#endif`,
  skinning_pars_vertex = `#ifdef USE_SKINNING
	uniform mat4 bindMatrix;
	uniform mat4 bindMatrixInverse;
	uniform highp sampler2D boneTexture;
	mat4 getBoneMatrix( const in float i ) {
		int size = textureSize( boneTexture, 0 ).x;
		int j = int( i ) * 4;
		int x = j % size;
		int y = j / size;
		vec4 v1 = texelFetch( boneTexture, ivec2( x, y ), 0 );
		vec4 v2 = texelFetch( boneTexture, ivec2( x + 1, y ), 0 );
		vec4 v3 = texelFetch( boneTexture, ivec2( x + 2, y ), 0 );
		vec4 v4 = texelFetch( boneTexture, ivec2( x + 3, y ), 0 );
		return mat4( v1, v2, v3, v4 );
	}
#endif`,
  skinning_vertex = `#ifdef USE_SKINNING
	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );
	vec4 skinned = vec4( 0.0 );
	skinned += boneMatX * skinVertex * skinWeight.x;
	skinned += boneMatY * skinVertex * skinWeight.y;
	skinned += boneMatZ * skinVertex * skinWeight.z;
	skinned += boneMatW * skinVertex * skinWeight.w;
	transformed = ( bindMatrixInverse * skinned ).xyz;
#endif`,
  skinnormal_vertex = `#ifdef USE_SKINNING
	mat4 skinMatrix = mat4( 0.0 );
	skinMatrix += skinWeight.x * boneMatX;
	skinMatrix += skinWeight.y * boneMatY;
	skinMatrix += skinWeight.z * boneMatZ;
	skinMatrix += skinWeight.w * boneMatW;
	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;
	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;
	#ifdef USE_TANGENT
		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#endif
#endif`,
  specularmap_fragment = `float specularStrength;
#ifdef USE_SPECULARMAP
	vec4 texelSpecular = texture2D( specularMap, vSpecularMapUv );
	specularStrength = texelSpecular.r;
#else
	specularStrength = 1.0;
#endif`,
  specularmap_pars_fragment = `#ifdef USE_SPECULARMAP
	uniform sampler2D specularMap;
#endif`,
  tonemapping_fragment = `#if defined( TONE_MAPPING )
	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
#endif`,
  tonemapping_pars_fragment = `#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
uniform float toneMappingExposure;
vec3 LinearToneMapping( vec3 color ) {
	return saturate( toneMappingExposure * color );
}
vec3 ReinhardToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	return saturate( color / ( vec3( 1.0 ) + color ) );
}
vec3 OptimizedCineonToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	color = max( vec3( 0.0 ), color - 0.004 );
	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );
}
vec3 RRTAndODTFit( vec3 v ) {
	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;
	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;
	return a / b;
}
vec3 ACESFilmicToneMapping( vec3 color ) {
	const mat3 ACESInputMat = mat3(
		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),
		vec3( 0.04823, 0.01566, 0.83777 )
	);
	const mat3 ACESOutputMat = mat3(
		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),
		vec3( -0.07367, -0.00605,  1.07602 )
	);
	color *= toneMappingExposure / 0.6;
	color = ACESInputMat * color;
	color = RRTAndODTFit( color );
	color = ACESOutputMat * color;
	return saturate( color );
}
const mat3 LINEAR_REC2020_TO_LINEAR_SRGB = mat3(
	vec3( 1.6605, - 0.1246, - 0.0182 ),
	vec3( - 0.5876, 1.1329, - 0.1006 ),
	vec3( - 0.0728, - 0.0083, 1.1187 )
);
const mat3 LINEAR_SRGB_TO_LINEAR_REC2020 = mat3(
	vec3( 0.6274, 0.0691, 0.0164 ),
	vec3( 0.3293, 0.9195, 0.0880 ),
	vec3( 0.0433, 0.0113, 0.8956 )
);
vec3 agxDefaultContrastApprox( vec3 x ) {
	vec3 x2 = x * x;
	vec3 x4 = x2 * x2;
	return + 15.5 * x4 * x2
		- 40.14 * x4 * x
		+ 31.96 * x4
		- 6.868 * x2 * x
		+ 0.4298 * x2
		+ 0.1191 * x
		- 0.00232;
}
vec3 AgXToneMapping( vec3 color ) {
	const mat3 AgXInsetMatrix = mat3(
		vec3( 0.856627153315983, 0.137318972929847, 0.11189821299995 ),
		vec3( 0.0951212405381588, 0.761241990602591, 0.0767994186031903 ),
		vec3( 0.0482516061458583, 0.101439036467562, 0.811302368396859 )
	);
	const mat3 AgXOutsetMatrix = mat3(
		vec3( 1.1271005818144368, - 0.1413297634984383, - 0.14132976349843826 ),
		vec3( - 0.11060664309660323, 1.157823702216272, - 0.11060664309660294 ),
		vec3( - 0.016493938717834573, - 0.016493938717834257, 1.2519364065950405 )
	);
	const float AgxMinEv = - 12.47393;	const float AgxMaxEv = 4.026069;
	color *= toneMappingExposure;
	color = LINEAR_SRGB_TO_LINEAR_REC2020 * color;
	color = AgXInsetMatrix * color;
	color = max( color, 1e-10 );	color = log2( color );
	color = ( color - AgxMinEv ) / ( AgxMaxEv - AgxMinEv );
	color = clamp( color, 0.0, 1.0 );
	color = agxDefaultContrastApprox( color );
	color = AgXOutsetMatrix * color;
	color = pow( max( vec3( 0.0 ), color ), vec3( 2.2 ) );
	color = LINEAR_REC2020_TO_LINEAR_SRGB * color;
	color = clamp( color, 0.0, 1.0 );
	return color;
}
vec3 NeutralToneMapping( vec3 color ) {
	const float StartCompression = 0.8 - 0.04;
	const float Desaturation = 0.15;
	color *= toneMappingExposure;
	float x = min( color.r, min( color.g, color.b ) );
	float offset = x < 0.08 ? x - 6.25 * x * x : 0.04;
	color -= offset;
	float peak = max( color.r, max( color.g, color.b ) );
	if ( peak < StartCompression ) return color;
	float d = 1. - StartCompression;
	float newPeak = 1. - d * d / ( peak + d - StartCompression );
	color *= newPeak / peak;
	float g = 1. - 1. / ( Desaturation * ( peak - newPeak ) + 1. );
	return mix( color, vec3( newPeak ), g );
}
vec3 CustomToneMapping( vec3 color ) { return color; }`,
  transmission_fragment = `#ifdef USE_TRANSMISSION
	material.transmission = transmission;
	material.transmissionAlpha = 1.0;
	material.thickness = thickness;
	material.attenuationDistance = attenuationDistance;
	material.attenuationColor = attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		material.transmission *= texture2D( transmissionMap, vTransmissionMapUv ).r;
	#endif
	#ifdef USE_THICKNESSMAP
		material.thickness *= texture2D( thicknessMap, vThicknessMapUv ).g;
	#endif
	vec3 pos = vWorldPosition;
	vec3 v = normalize( cameraPosition - pos );
	vec3 n = inverseTransformDirection( normal, viewMatrix );
	vec4 transmitted = getIBLVolumeRefraction(
		n, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,
		pos, modelMatrix, viewMatrix, projectionMatrix, material.dispersion, material.ior, material.thickness,
		material.attenuationColor, material.attenuationDistance );
	material.transmissionAlpha = mix( material.transmissionAlpha, transmitted.a, material.transmission );
	totalDiffuse = mix( totalDiffuse, transmitted.rgb, material.transmission );
#endif`,
  transmission_pars_fragment = `#ifdef USE_TRANSMISSION
	uniform float transmission;
	uniform float thickness;
	uniform float attenuationDistance;
	uniform vec3 attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		uniform sampler2D transmissionMap;
	#endif
	#ifdef USE_THICKNESSMAP
		uniform sampler2D thicknessMap;
	#endif
	uniform vec2 transmissionSamplerSize;
	uniform sampler2D transmissionSamplerMap;
	uniform mat4 modelMatrix;
	uniform mat4 projectionMatrix;
	varying vec3 vWorldPosition;
	float w0( float a ) {
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );
	}
	float w1( float a ) {
		return ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );
	}
	float w2( float a ){
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );
	}
	float w3( float a ) {
		return ( 1.0 / 6.0 ) * ( a * a * a );
	}
	float g0( float a ) {
		return w0( a ) + w1( a );
	}
	float g1( float a ) {
		return w2( a ) + w3( a );
	}
	float h0( float a ) {
		return - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );
	}
	float h1( float a ) {
		return 1.0 + w3( a ) / ( w2( a ) + w3( a ) );
	}
	vec4 bicubic( sampler2D tex, vec2 uv, vec4 texelSize, float lod ) {
		uv = uv * texelSize.zw + 0.5;
		vec2 iuv = floor( uv );
		vec2 fuv = fract( uv );
		float g0x = g0( fuv.x );
		float g1x = g1( fuv.x );
		float h0x = h0( fuv.x );
		float h1x = h1( fuv.x );
		float h0y = h0( fuv.y );
		float h1y = h1( fuv.y );
		vec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		vec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		return g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) +
			g1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );
	}
	vec4 textureBicubic( sampler2D sampler, vec2 uv, float lod ) {
		vec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );
		vec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );
		vec2 fLodSizeInv = 1.0 / fLodSize;
		vec2 cLodSizeInv = 1.0 / cLodSize;
		vec4 fSample = bicubic( sampler, uv, vec4( fLodSizeInv, fLodSize ), floor( lod ) );
		vec4 cSample = bicubic( sampler, uv, vec4( cLodSizeInv, cLodSize ), ceil( lod ) );
		return mix( fSample, cSample, fract( lod ) );
	}
	vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {
		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );
		vec3 modelScale;
		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );
		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );
		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );
		return normalize( refractionVector ) * thickness * modelScale;
	}
	float applyIorToRoughness( const in float roughness, const in float ior ) {
		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );
	}
	vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {
		float lod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );
		return textureBicubic( transmissionSamplerMap, fragCoord.xy, lod );
	}
	vec3 volumeAttenuation( const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {
		if ( isinf( attenuationDistance ) ) {
			return vec3( 1.0 );
		} else {
			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;
			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance;
		}
	}
	vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,
		const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,
		const in mat4 viewMatrix, const in mat4 projMatrix, const in float dispersion, const in float ior, const in float thickness,
		const in vec3 attenuationColor, const in float attenuationDistance ) {
		vec4 transmittedLight;
		vec3 transmittance;
		#ifdef USE_DISPERSION
			float halfSpread = ( ior - 1.0 ) * 0.025 * dispersion;
			vec3 iors = vec3( ior - halfSpread, ior, ior + halfSpread );
			for ( int i = 0; i < 3; i ++ ) {
				vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, iors[ i ], modelMatrix );
				vec3 refractedRayExit = position + transmissionRay;
		
				vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
				vec2 refractionCoords = ndcPos.xy / ndcPos.w;
				refractionCoords += 1.0;
				refractionCoords /= 2.0;
		
				vec4 transmissionSample = getTransmissionSample( refractionCoords, roughness, iors[ i ] );
				transmittedLight[ i ] = transmissionSample[ i ];
				transmittedLight.a += transmissionSample.a;
				transmittance[ i ] = diffuseColor[ i ] * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance )[ i ];
			}
			transmittedLight.a /= 3.0;
		
		#else
		
			vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );
			vec3 refractedRayExit = position + transmissionRay;
			vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
			vec2 refractionCoords = ndcPos.xy / ndcPos.w;
			refractionCoords += 1.0;
			refractionCoords /= 2.0;
			transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );
			transmittance = diffuseColor * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance );
		
		#endif
		vec3 attenuatedColor = transmittance * transmittedLight.rgb;
		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );
		float transmittanceFactor = ( transmittance.r + transmittance.g + transmittance.b ) / 3.0;
		return vec4( ( 1.0 - F ) * attenuatedColor, 1.0 - ( 1.0 - transmittedLight.a ) * transmittanceFactor );
	}
#endif`,
  uv_pars_fragment = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_SPECULARMAP
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`,
  uv_pars_vertex = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	uniform mat3 mapTransform;
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	uniform mat3 alphaMapTransform;
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	uniform mat3 lightMapTransform;
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	uniform mat3 aoMapTransform;
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	uniform mat3 bumpMapTransform;
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	uniform mat3 normalMapTransform;
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_DISPLACEMENTMAP
	uniform mat3 displacementMapTransform;
	varying vec2 vDisplacementMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	uniform mat3 emissiveMapTransform;
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	uniform mat3 metalnessMapTransform;
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	uniform mat3 roughnessMapTransform;
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	uniform mat3 anisotropyMapTransform;
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	uniform mat3 clearcoatMapTransform;
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform mat3 clearcoatNormalMapTransform;
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform mat3 clearcoatRoughnessMapTransform;
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	uniform mat3 sheenColorMapTransform;
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	uniform mat3 sheenRoughnessMapTransform;
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	uniform mat3 iridescenceMapTransform;
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform mat3 iridescenceThicknessMapTransform;
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SPECULARMAP
	uniform mat3 specularMapTransform;
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	uniform mat3 specularColorMapTransform;
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	uniform mat3 specularIntensityMapTransform;
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`,
  uv_vertex = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	vUv = vec3( uv, 1 ).xy;
#endif
#ifdef USE_MAP
	vMapUv = ( mapTransform * vec3( MAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ALPHAMAP
	vAlphaMapUv = ( alphaMapTransform * vec3( ALPHAMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_LIGHTMAP
	vLightMapUv = ( lightMapTransform * vec3( LIGHTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_AOMAP
	vAoMapUv = ( aoMapTransform * vec3( AOMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_BUMPMAP
	vBumpMapUv = ( bumpMapTransform * vec3( BUMPMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_NORMALMAP
	vNormalMapUv = ( normalMapTransform * vec3( NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_DISPLACEMENTMAP
	vDisplacementMapUv = ( displacementMapTransform * vec3( DISPLACEMENTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_EMISSIVEMAP
	vEmissiveMapUv = ( emissiveMapTransform * vec3( EMISSIVEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_METALNESSMAP
	vMetalnessMapUv = ( metalnessMapTransform * vec3( METALNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ROUGHNESSMAP
	vRoughnessMapUv = ( roughnessMapTransform * vec3( ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ANISOTROPYMAP
	vAnisotropyMapUv = ( anisotropyMapTransform * vec3( ANISOTROPYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOATMAP
	vClearcoatMapUv = ( clearcoatMapTransform * vec3( CLEARCOATMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	vClearcoatNormalMapUv = ( clearcoatNormalMapTransform * vec3( CLEARCOAT_NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	vClearcoatRoughnessMapUv = ( clearcoatRoughnessMapTransform * vec3( CLEARCOAT_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCEMAP
	vIridescenceMapUv = ( iridescenceMapTransform * vec3( IRIDESCENCEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	vIridescenceThicknessMapUv = ( iridescenceThicknessMapTransform * vec3( IRIDESCENCE_THICKNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_COLORMAP
	vSheenColorMapUv = ( sheenColorMapTransform * vec3( SHEEN_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	vSheenRoughnessMapUv = ( sheenRoughnessMapTransform * vec3( SHEEN_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULARMAP
	vSpecularMapUv = ( specularMapTransform * vec3( SPECULARMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_COLORMAP
	vSpecularColorMapUv = ( specularColorMapTransform * vec3( SPECULAR_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	vSpecularIntensityMapUv = ( specularIntensityMapTransform * vec3( SPECULAR_INTENSITYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_TRANSMISSIONMAP
	vTransmissionMapUv = ( transmissionMapTransform * vec3( TRANSMISSIONMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_THICKNESSMAP
	vThicknessMapUv = ( thicknessMapTransform * vec3( THICKNESSMAP_UV, 1 ) ).xy;
#endif`,
  worldpos_vertex = `#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0
	vec4 worldPosition = vec4( transformed, 1.0 );
	#ifdef USE_BATCHING
		worldPosition = batchingMatrix * worldPosition;
	#endif
	#ifdef USE_INSTANCING
		worldPosition = instanceMatrix * worldPosition;
	#endif
	worldPosition = modelMatrix * worldPosition;
#endif`;
const vertex$h = `varying vec2 vUv;
uniform mat3 uvTransform;
void main() {
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	gl_Position = vec4( position.xy, 1.0, 1.0 );
}`,
  fragment$h = `uniform sampler2D t2D;
uniform float backgroundIntensity;
varying vec2 vUv;
void main() {
	vec4 texColor = texture2D( t2D, vUv );
	#ifdef DECODE_VIDEO_TEXTURE
		texColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,
  vertex$g = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`,
  fragment$g = `#ifdef ENVMAP_TYPE_CUBE
	uniform samplerCube envMap;
#elif defined( ENVMAP_TYPE_CUBE_UV )
	uniform sampler2D envMap;
#endif
uniform float flipEnvMap;
uniform float backgroundBlurriness;
uniform float backgroundIntensity;
uniform mat3 backgroundRotation;
varying vec3 vWorldDirection;
#include <cube_uv_reflection_fragment>
void main() {
	#ifdef ENVMAP_TYPE_CUBE
		vec4 texColor = textureCube( envMap, backgroundRotation * vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );
	#elif defined( ENVMAP_TYPE_CUBE_UV )
		vec4 texColor = textureCubeUV( envMap, backgroundRotation * vWorldDirection, backgroundBlurriness );
	#else
		vec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,
  vertex$f = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`,
  fragment$f = `uniform samplerCube tCube;
uniform float tFlip;
uniform float opacity;
varying vec3 vWorldDirection;
void main() {
	vec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );
	gl_FragColor = texColor;
	gl_FragColor.a *= opacity;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,
  vertex$e = `#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
varying vec2 vHighPrecisionZW;
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <skinbase_vertex>
	#include <morphinstance_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vHighPrecisionZW = gl_Position.zw;
}`,
  fragment$e = `#if DEPTH_PACKING == 3200
	uniform float opacity;
#endif
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
varying vec2 vHighPrecisionZW;
void main() {
	vec4 diffuseColor = vec4( 1.0 );
	#include <clipping_planes_fragment>
	#if DEPTH_PACKING == 3200
		diffuseColor.a = opacity;
	#endif
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <logdepthbuf_fragment>
	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;
	#if DEPTH_PACKING == 3200
		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );
	#elif DEPTH_PACKING == 3201
		gl_FragColor = packDepthToRGBA( fragCoordZ );
	#elif DEPTH_PACKING == 3202
		gl_FragColor = vec4( packDepthToRGB( fragCoordZ ), 1.0 );
	#elif DEPTH_PACKING == 3203
		gl_FragColor = vec4( packDepthToRG( fragCoordZ ), 0.0, 1.0 );
	#endif
}`,
  vertex$d = `#define DISTANCE
varying vec3 vWorldPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <skinbase_vertex>
	#include <morphinstance_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	vWorldPosition = worldPosition.xyz;
}`,
  fragment$d = `#define DISTANCE
uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec3 vWorldPosition;
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <clipping_planes_pars_fragment>
void main () {
	vec4 diffuseColor = vec4( 1.0 );
	#include <clipping_planes_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	float dist = length( vWorldPosition - referencePosition );
	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
	dist = saturate( dist );
	gl_FragColor = packDepthToRGBA( dist );
}`,
  vertex$c = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
}`,
  fragment$c = `uniform sampler2D tEquirect;
varying vec3 vWorldDirection;
#include <common>
void main() {
	vec3 direction = normalize( vWorldDirection );
	vec2 sampleUV = equirectUv( direction );
	gl_FragColor = texture2D( tEquirect, sampleUV );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,
  vertex$b = `uniform float scale;
attribute float lineDistance;
varying float vLineDistance;
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	vLineDistance = scale * lineDistance;
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,
  fragment$b = `uniform vec3 diffuse;
uniform float opacity;
uniform float dashSize;
uniform float totalSize;
varying float vLineDistance;
#include <common>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	if ( mod( vLineDistance, totalSize ) > dashSize ) {
		discard;
	}
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,
  vertex$a = `#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinbase_vertex>
		#include <skinnormal_vertex>
		#include <defaultnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>
}`,
  fragment$a = `uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
	#include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
  vertex$9 = `#define LAMBERT
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
  fragment$9 = `#define LAMBERT
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_lambert_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_lambert_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
  vertex$8 = `#define MATCAP
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
	vViewPosition = - mvPosition.xyz;
}`,
  fragment$8 = `#define MATCAP
uniform vec3 diffuse;
uniform float opacity;
uniform sampler2D matcap;
varying vec3 vViewPosition;
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	vec3 viewDir = normalize( vViewPosition );
	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
	vec3 y = cross( viewDir, x );
	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;
	#ifdef USE_MATCAP
		vec4 matcapColor = texture2D( matcap, uv );
	#else
		vec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );
	#endif
	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
  vertex$7 = `#define NORMAL
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	vViewPosition = - mvPosition.xyz;
#endif
}`,
  fragment$7 = `#define NORMAL
uniform float opacity;
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <packing>
#include <uv_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( 0.0, 0.0, 0.0, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	gl_FragColor = vec4( packNormalToRGB( normal ), diffuseColor.a );
	#ifdef OPAQUE
		gl_FragColor.a = 1.0;
	#endif
}`,
  vertex$6 = `#define PHONG
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
  fragment$6 = `#define PHONG
uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_phong_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
  vertex$5 = `#define STANDARD
varying vec3 vViewPosition;
#ifdef USE_TRANSMISSION
	varying vec3 vWorldPosition;
#endif
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
#ifdef USE_TRANSMISSION
	vWorldPosition = worldPosition.xyz;
#endif
}`,
  fragment$5 = `#define STANDARD
#ifdef PHYSICAL
	#define IOR
	#define USE_SPECULAR
#endif
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;
#ifdef IOR
	uniform float ior;
#endif
#ifdef USE_SPECULAR
	uniform float specularIntensity;
	uniform vec3 specularColor;
	#ifdef USE_SPECULAR_COLORMAP
		uniform sampler2D specularColorMap;
	#endif
	#ifdef USE_SPECULAR_INTENSITYMAP
		uniform sampler2D specularIntensityMap;
	#endif
#endif
#ifdef USE_CLEARCOAT
	uniform float clearcoat;
	uniform float clearcoatRoughness;
#endif
#ifdef USE_DISPERSION
	uniform float dispersion;
#endif
#ifdef USE_IRIDESCENCE
	uniform float iridescence;
	uniform float iridescenceIOR;
	uniform float iridescenceThicknessMinimum;
	uniform float iridescenceThicknessMaximum;
#endif
#ifdef USE_SHEEN
	uniform vec3 sheenColor;
	uniform float sheenRoughness;
	#ifdef USE_SHEEN_COLORMAP
		uniform sampler2D sheenColorMap;
	#endif
	#ifdef USE_SHEEN_ROUGHNESSMAP
		uniform sampler2D sheenRoughnessMap;
	#endif
#endif
#ifdef USE_ANISOTROPY
	uniform vec2 anisotropyVector;
	#ifdef USE_ANISOTROPYMAP
		uniform sampler2D anisotropyMap;
	#endif
#endif
varying vec3 vViewPosition;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <iridescence_fragment>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_physical_pars_fragment>
#include <transmission_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <iridescence_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <clearcoat_normal_fragment_begin>
	#include <clearcoat_normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;
	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;
	#include <transmission_fragment>
	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;
	#ifdef USE_SHEEN
		float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );
		outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecularDirect + sheenSpecularIndirect;
	#endif
	#ifdef USE_CLEARCOAT
		float dotNVcc = saturate( dot( geometryClearcoatNormal, geometryViewDir ) );
		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );
		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + ( clearcoatSpecularDirect + clearcoatSpecularIndirect ) * material.clearcoat;
	#endif
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
  vertex$4 = `#define TOON
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
  fragment$4 = `#define TOON
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_toon_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_toon_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
  vertex$3 = `uniform float size;
uniform float scale;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
#ifdef USE_POINTS_UV
	varying vec2 vUv;
	uniform mat3 uvTransform;
#endif
void main() {
	#ifdef USE_POINTS_UV
		vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	#endif
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	gl_PointSize = size;
	#ifdef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );
	#endif
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>
}`,
  fragment$3 = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_particle_fragment>
	#include <color_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,
  vertex$2 = `#include <common>
#include <batching_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <shadowmap_pars_vertex>
void main() {
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
  fragment$2 = `uniform vec3 color;
uniform float opacity;
#include <common>
#include <packing>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <logdepthbuf_pars_fragment>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
void main() {
	#include <logdepthbuf_fragment>
	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`,
  vertex$1 = `uniform float rotation;
uniform vec2 center;
#include <common>
#include <uv_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );
	vec2 scale;
	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );
	#ifndef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) scale *= - mvPosition.z;
	#endif
	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;
	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
	mvPosition.xy += rotatedPosition;
	gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,
  fragment$1 = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`,
  ShaderChunk = {
    alphahash_fragment,
    alphahash_pars_fragment,
    alphamap_fragment,
    alphamap_pars_fragment,
    alphatest_fragment,
    alphatest_pars_fragment,
    aomap_fragment,
    aomap_pars_fragment,
    batching_pars_vertex,
    batching_vertex,
    begin_vertex,
    beginnormal_vertex,
    bsdfs,
    iridescence_fragment,
    bumpmap_pars_fragment,
    clipping_planes_fragment,
    clipping_planes_pars_fragment,
    clipping_planes_pars_vertex,
    clipping_planes_vertex,
    color_fragment,
    color_pars_fragment,
    color_pars_vertex,
    color_vertex,
    common,
    cube_uv_reflection_fragment,
    defaultnormal_vertex,
    displacementmap_pars_vertex,
    displacementmap_vertex,
    emissivemap_fragment,
    emissivemap_pars_fragment,
    colorspace_fragment,
    colorspace_pars_fragment,
    envmap_fragment,
    envmap_common_pars_fragment,
    envmap_pars_fragment,
    envmap_pars_vertex,
    envmap_physical_pars_fragment,
    envmap_vertex,
    fog_vertex,
    fog_pars_vertex,
    fog_fragment,
    fog_pars_fragment,
    gradientmap_pars_fragment,
    lightmap_pars_fragment,
    lights_lambert_fragment,
    lights_lambert_pars_fragment,
    lights_pars_begin,
    lights_toon_fragment,
    lights_toon_pars_fragment,
    lights_phong_fragment,
    lights_phong_pars_fragment,
    lights_physical_fragment,
    lights_physical_pars_fragment,
    lights_fragment_begin,
    lights_fragment_maps,
    lights_fragment_end,
    logdepthbuf_fragment,
    logdepthbuf_pars_fragment,
    logdepthbuf_pars_vertex,
    logdepthbuf_vertex,
    map_fragment,
    map_pars_fragment,
    map_particle_fragment,
    map_particle_pars_fragment,
    metalnessmap_fragment,
    metalnessmap_pars_fragment,
    morphinstance_vertex,
    morphcolor_vertex,
    morphnormal_vertex,
    morphtarget_pars_vertex,
    morphtarget_vertex,
    normal_fragment_begin,
    normal_fragment_maps,
    normal_pars_fragment,
    normal_pars_vertex,
    normal_vertex,
    normalmap_pars_fragment,
    clearcoat_normal_fragment_begin,
    clearcoat_normal_fragment_maps,
    clearcoat_pars_fragment,
    iridescence_pars_fragment,
    opaque_fragment,
    packing,
    premultiplied_alpha_fragment,
    project_vertex,
    dithering_fragment,
    dithering_pars_fragment,
    roughnessmap_fragment,
    roughnessmap_pars_fragment,
    shadowmap_pars_fragment,
    shadowmap_pars_vertex,
    shadowmap_vertex,
    shadowmask_pars_fragment,
    skinbase_vertex,
    skinning_pars_vertex,
    skinning_vertex,
    skinnormal_vertex,
    specularmap_fragment,
    specularmap_pars_fragment,
    tonemapping_fragment,
    tonemapping_pars_fragment,
    transmission_fragment,
    transmission_pars_fragment,
    uv_pars_fragment,
    uv_pars_vertex,
    uv_vertex,
    worldpos_vertex,
    background_vert: vertex$h,
    background_frag: fragment$h,
    backgroundCube_vert: vertex$g,
    backgroundCube_frag: fragment$g,
    cube_vert: vertex$f,
    cube_frag: fragment$f,
    depth_vert: vertex$e,
    depth_frag: fragment$e,
    distanceRGBA_vert: vertex$d,
    distanceRGBA_frag: fragment$d,
    equirect_vert: vertex$c,
    equirect_frag: fragment$c,
    linedashed_vert: vertex$b,
    linedashed_frag: fragment$b,
    meshbasic_vert: vertex$a,
    meshbasic_frag: fragment$a,
    meshlambert_vert: vertex$9,
    meshlambert_frag: fragment$9,
    meshmatcap_vert: vertex$8,
    meshmatcap_frag: fragment$8,
    meshnormal_vert: vertex$7,
    meshnormal_frag: fragment$7,
    meshphong_vert: vertex$6,
    meshphong_frag: fragment$6,
    meshphysical_vert: vertex$5,
    meshphysical_frag: fragment$5,
    meshtoon_vert: vertex$4,
    meshtoon_frag: fragment$4,
    points_vert: vertex$3,
    points_frag: fragment$3,
    shadow_vert: vertex$2,
    shadow_frag: fragment$2,
    sprite_vert: vertex$1,
    sprite_frag: fragment$1,
  },
  UniformsLib = {
    common: {
      diffuse: { value: new Color(16777215) },
      opacity: { value: 1 },
      map: { value: null },
      mapTransform: { value: new Matrix3() },
      alphaMap: { value: null },
      alphaMapTransform: { value: new Matrix3() },
      alphaTest: { value: 0 },
    },
    specularmap: {
      specularMap: { value: null },
      specularMapTransform: { value: new Matrix3() },
    },
    envmap: {
      envMap: { value: null },
      envMapRotation: { value: new Matrix3() },
      flipEnvMap: { value: -1 },
      reflectivity: { value: 1 },
      ior: { value: 1.5 },
      refractionRatio: { value: 0.98 },
    },
    aomap: {
      aoMap: { value: null },
      aoMapIntensity: { value: 1 },
      aoMapTransform: { value: new Matrix3() },
    },
    lightmap: {
      lightMap: { value: null },
      lightMapIntensity: { value: 1 },
      lightMapTransform: { value: new Matrix3() },
    },
    bumpmap: {
      bumpMap: { value: null },
      bumpMapTransform: { value: new Matrix3() },
      bumpScale: { value: 1 },
    },
    normalmap: {
      normalMap: { value: null },
      normalMapTransform: { value: new Matrix3() },
      normalScale: { value: new Vector2(1, 1) },
    },
    displacementmap: {
      displacementMap: { value: null },
      displacementMapTransform: { value: new Matrix3() },
      displacementScale: { value: 1 },
      displacementBias: { value: 0 },
    },
    emissivemap: {
      emissiveMap: { value: null },
      emissiveMapTransform: { value: new Matrix3() },
    },
    metalnessmap: {
      metalnessMap: { value: null },
      metalnessMapTransform: { value: new Matrix3() },
    },
    roughnessmap: {
      roughnessMap: { value: null },
      roughnessMapTransform: { value: new Matrix3() },
    },
    gradientmap: { gradientMap: { value: null } },
    fog: {
      fogDensity: { value: 25e-5 },
      fogNear: { value: 1 },
      fogFar: { value: 2e3 },
      fogColor: { value: new Color(16777215) },
    },
    lights: {
      ambientLightColor: { value: [] },
      lightProbe: { value: [] },
      directionalLights: {
        value: [],
        properties: { direction: {}, color: {} },
      },
      directionalLightShadows: {
        value: [],
        properties: {
          shadowIntensity: 1,
          shadowBias: {},
          shadowNormalBias: {},
          shadowRadius: {},
          shadowMapSize: {},
        },
      },
      directionalShadowMap: { value: [] },
      directionalShadowMatrix: { value: [] },
      spotLights: {
        value: [],
        properties: {
          color: {},
          position: {},
          direction: {},
          distance: {},
          coneCos: {},
          penumbraCos: {},
          decay: {},
        },
      },
      spotLightShadows: {
        value: [],
        properties: {
          shadowIntensity: 1,
          shadowBias: {},
          shadowNormalBias: {},
          shadowRadius: {},
          shadowMapSize: {},
        },
      },
      spotLightMap: { value: [] },
      spotShadowMap: { value: [] },
      spotLightMatrix: { value: [] },
      pointLights: {
        value: [],
        properties: { color: {}, position: {}, decay: {}, distance: {} },
      },
      pointLightShadows: {
        value: [],
        properties: {
          shadowIntensity: 1,
          shadowBias: {},
          shadowNormalBias: {},
          shadowRadius: {},
          shadowMapSize: {},
          shadowCameraNear: {},
          shadowCameraFar: {},
        },
      },
      pointShadowMap: { value: [] },
      pointShadowMatrix: { value: [] },
      hemisphereLights: {
        value: [],
        properties: { direction: {}, skyColor: {}, groundColor: {} },
      },
      rectAreaLights: {
        value: [],
        properties: { color: {}, position: {}, width: {}, height: {} },
      },
      ltc_1: { value: null },
      ltc_2: { value: null },
    },
    points: {
      diffuse: { value: new Color(16777215) },
      opacity: { value: 1 },
      size: { value: 1 },
      scale: { value: 1 },
      map: { value: null },
      alphaMap: { value: null },
      alphaMapTransform: { value: new Matrix3() },
      alphaTest: { value: 0 },
      uvTransform: { value: new Matrix3() },
    },
    sprite: {
      diffuse: { value: new Color(16777215) },
      opacity: { value: 1 },
      center: { value: new Vector2(0.5, 0.5) },
      rotation: { value: 0 },
      map: { value: null },
      mapTransform: { value: new Matrix3() },
      alphaMap: { value: null },
      alphaMapTransform: { value: new Matrix3() },
      alphaTest: { value: 0 },
    },
  },
  ShaderLib = {
    basic: {
      uniforms: mergeUniforms([
        UniformsLib.common,
        UniformsLib.specularmap,
        UniformsLib.envmap,
        UniformsLib.aomap,
        UniformsLib.lightmap,
        UniformsLib.fog,
      ]),
      vertexShader: ShaderChunk.meshbasic_vert,
      fragmentShader: ShaderChunk.meshbasic_frag,
    },
    lambert: {
      uniforms: mergeUniforms([
        UniformsLib.common,
        UniformsLib.specularmap,
        UniformsLib.envmap,
        UniformsLib.aomap,
        UniformsLib.lightmap,
        UniformsLib.emissivemap,
        UniformsLib.bumpmap,
        UniformsLib.normalmap,
        UniformsLib.displacementmap,
        UniformsLib.fog,
        UniformsLib.lights,
        { emissive: { value: new Color(0) } },
      ]),
      vertexShader: ShaderChunk.meshlambert_vert,
      fragmentShader: ShaderChunk.meshlambert_frag,
    },
    phong: {
      uniforms: mergeUniforms([
        UniformsLib.common,
        UniformsLib.specularmap,
        UniformsLib.envmap,
        UniformsLib.aomap,
        UniformsLib.lightmap,
        UniformsLib.emissivemap,
        UniformsLib.bumpmap,
        UniformsLib.normalmap,
        UniformsLib.displacementmap,
        UniformsLib.fog,
        UniformsLib.lights,
        {
          emissive: { value: new Color(0) },
          specular: { value: new Color(1118481) },
          shininess: { value: 30 },
        },
      ]),
      vertexShader: ShaderChunk.meshphong_vert,
      fragmentShader: ShaderChunk.meshphong_frag,
    },
    standard: {
      uniforms: mergeUniforms([
        UniformsLib.common,
        UniformsLib.envmap,
        UniformsLib.aomap,
        UniformsLib.lightmap,
        UniformsLib.emissivemap,
        UniformsLib.bumpmap,
        UniformsLib.normalmap,
        UniformsLib.displacementmap,
        UniformsLib.roughnessmap,
        UniformsLib.metalnessmap,
        UniformsLib.fog,
        UniformsLib.lights,
        {
          emissive: { value: new Color(0) },
          roughness: { value: 1 },
          metalness: { value: 0 },
          envMapIntensity: { value: 1 },
        },
      ]),
      vertexShader: ShaderChunk.meshphysical_vert,
      fragmentShader: ShaderChunk.meshphysical_frag,
    },
    toon: {
      uniforms: mergeUniforms([
        UniformsLib.common,
        UniformsLib.aomap,
        UniformsLib.lightmap,
        UniformsLib.emissivemap,
        UniformsLib.bumpmap,
        UniformsLib.normalmap,
        UniformsLib.displacementmap,
        UniformsLib.gradientmap,
        UniformsLib.fog,
        UniformsLib.lights,
        { emissive: { value: new Color(0) } },
      ]),
      vertexShader: ShaderChunk.meshtoon_vert,
      fragmentShader: ShaderChunk.meshtoon_frag,
    },
    matcap: {
      uniforms: mergeUniforms([
        UniformsLib.common,
        UniformsLib.bumpmap,
        UniformsLib.normalmap,
        UniformsLib.displacementmap,
        UniformsLib.fog,
        { matcap: { value: null } },
      ]),
      vertexShader: ShaderChunk.meshmatcap_vert,
      fragmentShader: ShaderChunk.meshmatcap_frag,
    },
    points: {
      uniforms: mergeUniforms([UniformsLib.points, UniformsLib.fog]),
      vertexShader: ShaderChunk.points_vert,
      fragmentShader: ShaderChunk.points_frag,
    },
    dashed: {
      uniforms: mergeUniforms([
        UniformsLib.common,
        UniformsLib.fog,
        {
          scale: { value: 1 },
          dashSize: { value: 1 },
          totalSize: { value: 2 },
        },
      ]),
      vertexShader: ShaderChunk.linedashed_vert,
      fragmentShader: ShaderChunk.linedashed_frag,
    },
    depth: {
      uniforms: mergeUniforms([
        UniformsLib.common,
        UniformsLib.displacementmap,
      ]),
      vertexShader: ShaderChunk.depth_vert,
      fragmentShader: ShaderChunk.depth_frag,
    },
    normal: {
      uniforms: mergeUniforms([
        UniformsLib.common,
        UniformsLib.bumpmap,
        UniformsLib.normalmap,
        UniformsLib.displacementmap,
        { opacity: { value: 1 } },
      ]),
      vertexShader: ShaderChunk.meshnormal_vert,
      fragmentShader: ShaderChunk.meshnormal_frag,
    },
    sprite: {
      uniforms: mergeUniforms([UniformsLib.sprite, UniformsLib.fog]),
      vertexShader: ShaderChunk.sprite_vert,
      fragmentShader: ShaderChunk.sprite_frag,
    },
    background: {
      uniforms: {
        uvTransform: { value: new Matrix3() },
        t2D: { value: null },
        backgroundIntensity: { value: 1 },
      },
      vertexShader: ShaderChunk.background_vert,
      fragmentShader: ShaderChunk.background_frag,
    },
    backgroundCube: {
      uniforms: {
        envMap: { value: null },
        flipEnvMap: { value: -1 },
        backgroundBlurriness: { value: 0 },
        backgroundIntensity: { value: 1 },
        backgroundRotation: { value: new Matrix3() },
      },
      vertexShader: ShaderChunk.backgroundCube_vert,
      fragmentShader: ShaderChunk.backgroundCube_frag,
    },
    cube: {
      uniforms: {
        tCube: { value: null },
        tFlip: { value: -1 },
        opacity: { value: 1 },
      },
      vertexShader: ShaderChunk.cube_vert,
      fragmentShader: ShaderChunk.cube_frag,
    },
    equirect: {
      uniforms: { tEquirect: { value: null } },
      vertexShader: ShaderChunk.equirect_vert,
      fragmentShader: ShaderChunk.equirect_frag,
    },
    distanceRGBA: {
      uniforms: mergeUniforms([
        UniformsLib.common,
        UniformsLib.displacementmap,
        {
          referencePosition: { value: new Vector3() },
          nearDistance: { value: 1 },
          farDistance: { value: 1e3 },
        },
      ]),
      vertexShader: ShaderChunk.distanceRGBA_vert,
      fragmentShader: ShaderChunk.distanceRGBA_frag,
    },
    shadow: {
      uniforms: mergeUniforms([
        UniformsLib.lights,
        UniformsLib.fog,
        { color: { value: new Color(0) }, opacity: { value: 1 } },
      ]),
      vertexShader: ShaderChunk.shadow_vert,
      fragmentShader: ShaderChunk.shadow_frag,
    },
  };
ShaderLib.physical = {
  uniforms: mergeUniforms([
    ShaderLib.standard.uniforms,
    {
      clearcoat: { value: 0 },
      clearcoatMap: { value: null },
      clearcoatMapTransform: { value: new Matrix3() },
      clearcoatNormalMap: { value: null },
      clearcoatNormalMapTransform: { value: new Matrix3() },
      clearcoatNormalScale: { value: new Vector2(1, 1) },
      clearcoatRoughness: { value: 0 },
      clearcoatRoughnessMap: { value: null },
      clearcoatRoughnessMapTransform: { value: new Matrix3() },
      dispersion: { value: 0 },
      iridescence: { value: 0 },
      iridescenceMap: { value: null },
      iridescenceMapTransform: { value: new Matrix3() },
      iridescenceIOR: { value: 1.3 },
      iridescenceThicknessMinimum: { value: 100 },
      iridescenceThicknessMaximum: { value: 400 },
      iridescenceThicknessMap: { value: null },
      iridescenceThicknessMapTransform: { value: new Matrix3() },
      sheen: { value: 0 },
      sheenColor: { value: new Color(0) },
      sheenColorMap: { value: null },
      sheenColorMapTransform: { value: new Matrix3() },
      sheenRoughness: { value: 1 },
      sheenRoughnessMap: { value: null },
      sheenRoughnessMapTransform: { value: new Matrix3() },
      transmission: { value: 0 },
      transmissionMap: { value: null },
      transmissionMapTransform: { value: new Matrix3() },
      transmissionSamplerSize: { value: new Vector2() },
      transmissionSamplerMap: { value: null },
      thickness: { value: 0 },
      thicknessMap: { value: null },
      thicknessMapTransform: { value: new Matrix3() },
      attenuationDistance: { value: 0 },
      attenuationColor: { value: new Color(0) },
      specularColor: { value: new Color(1, 1, 1) },
      specularColorMap: { value: null },
      specularColorMapTransform: { value: new Matrix3() },
      specularIntensity: { value: 1 },
      specularIntensityMap: { value: null },
      specularIntensityMapTransform: { value: new Matrix3() },
      anisotropyVector: { value: new Vector2() },
      anisotropyMap: { value: null },
      anisotropyMapTransform: { value: new Matrix3() },
    },
  ]),
  vertexShader: ShaderChunk.meshphysical_vert,
  fragmentShader: ShaderChunk.meshphysical_frag,
};
const _rgb = { r: 0, b: 0, g: 0 },
  _e1$1 = new Euler(),
  _m1$1 = new Matrix4();
function WebGLBackground(s, e, o, a, c, d, g) {
  const _ = new Color(0);
  let b = d === !0 ? 0 : 1,
    j,
    $,
    _e = null,
    et = 0,
    rt = null;
  function st(lt) {
    let ot = lt.isScene === !0 ? lt.background : null;
    return (
      ot &&
        ot.isTexture &&
        (ot = (lt.backgroundBlurriness > 0 ? o : e).get(ot)),
      ot
    );
  }
  function at(lt) {
    let ot = !1;
    const ut = st(lt);
    ut === null ? it(_, b) : ut && ut.isColor && (it(ut, 1), (ot = !0));
    const pt = s.xr.getEnvironmentBlendMode();
    pt === "additive"
      ? a.buffers.color.setClear(0, 0, 0, 1, g)
      : pt === "alpha-blend" && a.buffers.color.setClear(0, 0, 0, 0, g),
      (s.autoClear || ot) &&
        (a.buffers.depth.setTest(!0),
        a.buffers.depth.setMask(!0),
        a.buffers.color.setMask(!0),
        s.clear(s.autoClearColor, s.autoClearDepth, s.autoClearStencil));
  }
  function ct(lt, ot) {
    const ut = st(ot);
    ut && (ut.isCubeTexture || ut.mapping === CubeUVReflectionMapping)
      ? ($ === void 0 &&
          (($ = new Mesh(
            new BoxGeometry(1, 1, 1),
            new ShaderMaterial({
              name: "BackgroundCubeMaterial",
              uniforms: cloneUniforms(ShaderLib.backgroundCube.uniforms),
              vertexShader: ShaderLib.backgroundCube.vertexShader,
              fragmentShader: ShaderLib.backgroundCube.fragmentShader,
              side: BackSide,
              depthTest: !1,
              depthWrite: !1,
              fog: !1,
            })
          )),
          $.geometry.deleteAttribute("normal"),
          $.geometry.deleteAttribute("uv"),
          ($.onBeforeRender = function (pt, ft, gt) {
            this.matrixWorld.copyPosition(gt.matrixWorld);
          }),
          Object.defineProperty($.material, "envMap", {
            get: function () {
              return this.uniforms.envMap.value;
            },
          }),
          c.update($)),
        _e1$1.copy(ot.backgroundRotation),
        (_e1$1.x *= -1),
        (_e1$1.y *= -1),
        (_e1$1.z *= -1),
        ut.isCubeTexture &&
          ut.isRenderTargetTexture === !1 &&
          ((_e1$1.y *= -1), (_e1$1.z *= -1)),
        ($.material.uniforms.envMap.value = ut),
        ($.material.uniforms.flipEnvMap.value =
          ut.isCubeTexture && ut.isRenderTargetTexture === !1 ? -1 : 1),
        ($.material.uniforms.backgroundBlurriness.value =
          ot.backgroundBlurriness),
        ($.material.uniforms.backgroundIntensity.value =
          ot.backgroundIntensity),
        $.material.uniforms.backgroundRotation.value.setFromMatrix4(
          _m1$1.makeRotationFromEuler(_e1$1)
        ),
        ($.material.toneMapped =
          ColorManagement.getTransfer(ut.colorSpace) !== SRGBTransfer),
        (_e !== ut || et !== ut.version || rt !== s.toneMapping) &&
          (($.material.needsUpdate = !0),
          (_e = ut),
          (et = ut.version),
          (rt = s.toneMapping)),
        $.layers.enableAll(),
        lt.unshift($, $.geometry, $.material, 0, 0, null))
      : ut &&
        ut.isTexture &&
        (j === void 0 &&
          ((j = new Mesh(
            new PlaneGeometry(2, 2),
            new ShaderMaterial({
              name: "BackgroundMaterial",
              uniforms: cloneUniforms(ShaderLib.background.uniforms),
              vertexShader: ShaderLib.background.vertexShader,
              fragmentShader: ShaderLib.background.fragmentShader,
              side: FrontSide,
              depthTest: !1,
              depthWrite: !1,
              fog: !1,
            })
          )),
          j.geometry.deleteAttribute("normal"),
          Object.defineProperty(j.material, "map", {
            get: function () {
              return this.uniforms.t2D.value;
            },
          }),
          c.update(j)),
        (j.material.uniforms.t2D.value = ut),
        (j.material.uniforms.backgroundIntensity.value =
          ot.backgroundIntensity),
        (j.material.toneMapped =
          ColorManagement.getTransfer(ut.colorSpace) !== SRGBTransfer),
        ut.matrixAutoUpdate === !0 && ut.updateMatrix(),
        j.material.uniforms.uvTransform.value.copy(ut.matrix),
        (_e !== ut || et !== ut.version || rt !== s.toneMapping) &&
          ((j.material.needsUpdate = !0),
          (_e = ut),
          (et = ut.version),
          (rt = s.toneMapping)),
        j.layers.enableAll(),
        lt.unshift(j, j.geometry, j.material, 0, 0, null));
  }
  function it(lt, ot) {
    lt.getRGB(_rgb, getUnlitUniformColorSpace(s)),
      a.buffers.color.setClear(_rgb.r, _rgb.g, _rgb.b, ot, g);
  }
  return {
    getClearColor: function () {
      return _;
    },
    setClearColor: function (lt, ot = 1) {
      _.set(lt), (b = ot), it(_, b);
    },
    getClearAlpha: function () {
      return b;
    },
    setClearAlpha: function (lt) {
      (b = lt), it(_, b);
    },
    render: at,
    addToRenderList: ct,
  };
}
function WebGLBindingStates(s, e) {
  const o = s.getParameter(s.MAX_VERTEX_ATTRIBS),
    a = {},
    c = et(null);
  let d = c,
    g = !1;
  function _(St, Mt, Rt, Ft, Ot) {
    let Lt = !1;
    const Et = _e(Ft, Rt, Mt);
    d !== Et && ((d = Et), j(d.object)),
      (Lt = rt(St, Ft, Rt, Ot)),
      Lt && st(St, Ft, Rt, Ot),
      Ot !== null && e.update(Ot, s.ELEMENT_ARRAY_BUFFER),
      (Lt || g) &&
        ((g = !1),
        ut(St, Mt, Rt, Ft),
        Ot !== null && s.bindBuffer(s.ELEMENT_ARRAY_BUFFER, e.get(Ot).buffer));
  }
  function b() {
    return s.createVertexArray();
  }
  function j(St) {
    return s.bindVertexArray(St);
  }
  function $(St) {
    return s.deleteVertexArray(St);
  }
  function _e(St, Mt, Rt) {
    const Ft = Rt.wireframe === !0;
    let Ot = a[St.id];
    Ot === void 0 && ((Ot = {}), (a[St.id] = Ot));
    let Lt = Ot[Mt.id];
    Lt === void 0 && ((Lt = {}), (Ot[Mt.id] = Lt));
    let Et = Lt[Ft];
    return Et === void 0 && ((Et = et(b())), (Lt[Ft] = Et)), Et;
  }
  function et(St) {
    const Mt = [],
      Rt = [],
      Ft = [];
    for (let Ot = 0; Ot < o; Ot++) (Mt[Ot] = 0), (Rt[Ot] = 0), (Ft[Ot] = 0);
    return {
      geometry: null,
      program: null,
      wireframe: !1,
      newAttributes: Mt,
      enabledAttributes: Rt,
      attributeDivisors: Ft,
      object: St,
      attributes: {},
      index: null,
    };
  }
  function rt(St, Mt, Rt, Ft) {
    const Ot = d.attributes,
      Lt = Mt.attributes;
    let Et = 0;
    const bt = Rt.getAttributes();
    for (const mt in bt)
      if (bt[mt].location >= 0) {
        const Ct = Ot[mt];
        let Tt = Lt[mt];
        if (
          (Tt === void 0 &&
            (mt === "instanceMatrix" &&
              St.instanceMatrix &&
              (Tt = St.instanceMatrix),
            mt === "instanceColor" &&
              St.instanceColor &&
              (Tt = St.instanceColor)),
          Ct === void 0 || Ct.attribute !== Tt || (Tt && Ct.data !== Tt.data))
        )
          return !0;
        Et++;
      }
    return d.attributesNum !== Et || d.index !== Ft;
  }
  function st(St, Mt, Rt, Ft) {
    const Ot = {},
      Lt = Mt.attributes;
    let Et = 0;
    const bt = Rt.getAttributes();
    for (const mt in bt)
      if (bt[mt].location >= 0) {
        let Ct = Lt[mt];
        Ct === void 0 &&
          (mt === "instanceMatrix" &&
            St.instanceMatrix &&
            (Ct = St.instanceMatrix),
          mt === "instanceColor" &&
            St.instanceColor &&
            (Ct = St.instanceColor));
        const Tt = {};
        (Tt.attribute = Ct),
          Ct && Ct.data && (Tt.data = Ct.data),
          (Ot[mt] = Tt),
          Et++;
      }
    (d.attributes = Ot), (d.attributesNum = Et), (d.index = Ft);
  }
  function at() {
    const St = d.newAttributes;
    for (let Mt = 0, Rt = St.length; Mt < Rt; Mt++) St[Mt] = 0;
  }
  function ct(St) {
    it(St, 0);
  }
  function it(St, Mt) {
    const Rt = d.newAttributes,
      Ft = d.enabledAttributes,
      Ot = d.attributeDivisors;
    (Rt[St] = 1),
      Ft[St] === 0 && (s.enableVertexAttribArray(St), (Ft[St] = 1)),
      Ot[St] !== Mt && (s.vertexAttribDivisor(St, Mt), (Ot[St] = Mt));
  }
  function lt() {
    const St = d.newAttributes,
      Mt = d.enabledAttributes;
    for (let Rt = 0, Ft = Mt.length; Rt < Ft; Rt++)
      Mt[Rt] !== St[Rt] && (s.disableVertexAttribArray(Rt), (Mt[Rt] = 0));
  }
  function ot(St, Mt, Rt, Ft, Ot, Lt, Et) {
    Et === !0
      ? s.vertexAttribIPointer(St, Mt, Rt, Ot, Lt)
      : s.vertexAttribPointer(St, Mt, Rt, Ft, Ot, Lt);
  }
  function ut(St, Mt, Rt, Ft) {
    at();
    const Ot = Ft.attributes,
      Lt = Rt.getAttributes(),
      Et = Mt.defaultAttributeValues;
    for (const bt in Lt) {
      const mt = Lt[bt];
      if (mt.location >= 0) {
        let vt = Ot[bt];
        if (
          (vt === void 0 &&
            (bt === "instanceMatrix" &&
              St.instanceMatrix &&
              (vt = St.instanceMatrix),
            bt === "instanceColor" &&
              St.instanceColor &&
              (vt = St.instanceColor)),
          vt !== void 0)
        ) {
          const Ct = vt.normalized,
            Tt = vt.itemSize,
            Dt = e.get(vt);
          if (Dt === void 0) continue;
          const Wt = Dt.buffer,
            Pt = Dt.type,
            Jt = Dt.bytesPerElement,
            Gt =
              Pt === s.INT || Pt === s.UNSIGNED_INT || vt.gpuType === IntType;
          if (vt.isInterleavedBufferAttribute) {
            const en = vt.data,
              _n = en.stride,
              Tn = vt.offset;
            if (en.isInstancedInterleavedBuffer) {
              for (let fn = 0; fn < mt.locationSize; fn++)
                it(mt.location + fn, en.meshPerAttribute);
              St.isInstancedMesh !== !0 &&
                Ft._maxInstanceCount === void 0 &&
                (Ft._maxInstanceCount = en.meshPerAttribute * en.count);
            } else
              for (let fn = 0; fn < mt.locationSize; fn++) ct(mt.location + fn);
            s.bindBuffer(s.ARRAY_BUFFER, Wt);
            for (let fn = 0; fn < mt.locationSize; fn++)
              ot(
                mt.location + fn,
                Tt / mt.locationSize,
                Pt,
                Ct,
                _n * Jt,
                (Tn + (Tt / mt.locationSize) * fn) * Jt,
                Gt
              );
          } else {
            if (vt.isInstancedBufferAttribute) {
              for (let en = 0; en < mt.locationSize; en++)
                it(mt.location + en, vt.meshPerAttribute);
              St.isInstancedMesh !== !0 &&
                Ft._maxInstanceCount === void 0 &&
                (Ft._maxInstanceCount = vt.meshPerAttribute * vt.count);
            } else
              for (let en = 0; en < mt.locationSize; en++) ct(mt.location + en);
            s.bindBuffer(s.ARRAY_BUFFER, Wt);
            for (let en = 0; en < mt.locationSize; en++)
              ot(
                mt.location + en,
                Tt / mt.locationSize,
                Pt,
                Ct,
                Tt * Jt,
                (Tt / mt.locationSize) * en * Jt,
                Gt
              );
          }
        } else if (Et !== void 0) {
          const Ct = Et[bt];
          if (Ct !== void 0)
            switch (Ct.length) {
              case 2:
                s.vertexAttrib2fv(mt.location, Ct);
                break;
              case 3:
                s.vertexAttrib3fv(mt.location, Ct);
                break;
              case 4:
                s.vertexAttrib4fv(mt.location, Ct);
                break;
              default:
                s.vertexAttrib1fv(mt.location, Ct);
            }
        }
      }
    }
    lt();
  }
  function pt() {
    xt();
    for (const St in a) {
      const Mt = a[St];
      for (const Rt in Mt) {
        const Ft = Mt[Rt];
        for (const Ot in Ft) $(Ft[Ot].object), delete Ft[Ot];
        delete Mt[Rt];
      }
      delete a[St];
    }
  }
  function ft(St) {
    if (a[St.id] === void 0) return;
    const Mt = a[St.id];
    for (const Rt in Mt) {
      const Ft = Mt[Rt];
      for (const Ot in Ft) $(Ft[Ot].object), delete Ft[Ot];
      delete Mt[Rt];
    }
    delete a[St.id];
  }
  function gt(St) {
    for (const Mt in a) {
      const Rt = a[Mt];
      if (Rt[St.id] === void 0) continue;
      const Ft = Rt[St.id];
      for (const Ot in Ft) $(Ft[Ot].object), delete Ft[Ot];
      delete Rt[St.id];
    }
  }
  function xt() {
    _t(), (g = !0), d !== c && ((d = c), j(d.object));
  }
  function _t() {
    (c.geometry = null), (c.program = null), (c.wireframe = !1);
  }
  return {
    setup: _,
    reset: xt,
    resetDefaultState: _t,
    dispose: pt,
    releaseStatesOfGeometry: ft,
    releaseStatesOfProgram: gt,
    initAttributes: at,
    enableAttribute: ct,
    disableUnusedAttributes: lt,
  };
}
function WebGLBufferRenderer(s, e, o) {
  let a;
  function c(j) {
    a = j;
  }
  function d(j, $) {
    s.drawArrays(a, j, $), o.update($, a, 1);
  }
  function g(j, $, _e) {
    _e !== 0 && (s.drawArraysInstanced(a, j, $, _e), o.update($, a, _e));
  }
  function _(j, $, _e) {
    if (_e === 0) return;
    e.get("WEBGL_multi_draw").multiDrawArraysWEBGL(a, j, 0, $, 0, _e);
    let rt = 0;
    for (let st = 0; st < _e; st++) rt += $[st];
    o.update(rt, a, 1);
  }
  function b(j, $, _e, et) {
    if (_e === 0) return;
    const rt = e.get("WEBGL_multi_draw");
    if (rt === null)
      for (let st = 0; st < j.length; st++) g(j[st], $[st], et[st]);
    else {
      rt.multiDrawArraysInstancedWEBGL(a, j, 0, $, 0, et, 0, _e);
      let st = 0;
      for (let at = 0; at < _e; at++) st += $[at];
      for (let at = 0; at < et.length; at++) o.update(st, a, et[at]);
    }
  }
  (this.setMode = c),
    (this.render = d),
    (this.renderInstances = g),
    (this.renderMultiDraw = _),
    (this.renderMultiDrawInstances = b);
}
function WebGLCapabilities(s, e, o, a) {
  let c;
  function d() {
    if (c !== void 0) return c;
    if (e.has("EXT_texture_filter_anisotropic") === !0) {
      const ft = e.get("EXT_texture_filter_anisotropic");
      c = s.getParameter(ft.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
    } else c = 0;
    return c;
  }
  function g(ft) {
    return !(
      ft !== RGBAFormat &&
      a.convert(ft) !== s.getParameter(s.IMPLEMENTATION_COLOR_READ_FORMAT)
    );
  }
  function _(ft) {
    const gt =
      ft === HalfFloatType &&
      (e.has("EXT_color_buffer_half_float") || e.has("EXT_color_buffer_float"));
    return !(
      ft !== UnsignedByteType &&
      a.convert(ft) !== s.getParameter(s.IMPLEMENTATION_COLOR_READ_TYPE) &&
      ft !== FloatType &&
      !gt
    );
  }
  function b(ft) {
    if (ft === "highp") {
      if (
        s.getShaderPrecisionFormat(s.VERTEX_SHADER, s.HIGH_FLOAT).precision >
          0 &&
        s.getShaderPrecisionFormat(s.FRAGMENT_SHADER, s.HIGH_FLOAT).precision >
          0
      )
        return "highp";
      ft = "mediump";
    }
    return ft === "mediump" &&
      s.getShaderPrecisionFormat(s.VERTEX_SHADER, s.MEDIUM_FLOAT).precision >
        0 &&
      s.getShaderPrecisionFormat(s.FRAGMENT_SHADER, s.MEDIUM_FLOAT).precision >
        0
      ? "mediump"
      : "lowp";
  }
  let j = o.precision !== void 0 ? o.precision : "highp";
  const $ = b(j);
  $ !== j &&
    (console.warn(
      "THREE.WebGLRenderer:",
      j,
      "not supported, using",
      $,
      "instead."
    ),
    (j = $));
  const _e = o.logarithmicDepthBuffer === !0,
    et = s.getParameter(s.MAX_TEXTURE_IMAGE_UNITS),
    rt = s.getParameter(s.MAX_VERTEX_TEXTURE_IMAGE_UNITS),
    st = s.getParameter(s.MAX_TEXTURE_SIZE),
    at = s.getParameter(s.MAX_CUBE_MAP_TEXTURE_SIZE),
    ct = s.getParameter(s.MAX_VERTEX_ATTRIBS),
    it = s.getParameter(s.MAX_VERTEX_UNIFORM_VECTORS),
    lt = s.getParameter(s.MAX_VARYING_VECTORS),
    ot = s.getParameter(s.MAX_FRAGMENT_UNIFORM_VECTORS),
    ut = rt > 0,
    pt = s.getParameter(s.MAX_SAMPLES);
  return {
    isWebGL2: !0,
    getMaxAnisotropy: d,
    getMaxPrecision: b,
    textureFormatReadable: g,
    textureTypeReadable: _,
    precision: j,
    logarithmicDepthBuffer: _e,
    maxTextures: et,
    maxVertexTextures: rt,
    maxTextureSize: st,
    maxCubemapSize: at,
    maxAttributes: ct,
    maxVertexUniforms: it,
    maxVaryings: lt,
    maxFragmentUniforms: ot,
    vertexTextures: ut,
    maxSamples: pt,
  };
}
function WebGLClipping(s) {
  const e = this;
  let o = null,
    a = 0,
    c = !1,
    d = !1;
  const g = new Plane(),
    _ = new Matrix3(),
    b = { value: null, needsUpdate: !1 };
  (this.uniform = b),
    (this.numPlanes = 0),
    (this.numIntersection = 0),
    (this.init = function (_e, et) {
      const rt = _e.length !== 0 || et || a !== 0 || c;
      return (c = et), (a = _e.length), rt;
    }),
    (this.beginShadows = function () {
      (d = !0), $(null);
    }),
    (this.endShadows = function () {
      d = !1;
    }),
    (this.setGlobalState = function (_e, et) {
      o = $(_e, et, 0);
    }),
    (this.setState = function (_e, et, rt) {
      const st = _e.clippingPlanes,
        at = _e.clipIntersection,
        ct = _e.clipShadows,
        it = s.get(_e);
      if (!c || st === null || st.length === 0 || (d && !ct)) d ? $(null) : j();
      else {
        const lt = d ? 0 : a,
          ot = lt * 4;
        let ut = it.clippingState || null;
        (b.value = ut), (ut = $(st, et, ot, rt));
        for (let pt = 0; pt !== ot; ++pt) ut[pt] = o[pt];
        (it.clippingState = ut),
          (this.numIntersection = at ? this.numPlanes : 0),
          (this.numPlanes += lt);
      }
    });
  function j() {
    b.value !== o && ((b.value = o), (b.needsUpdate = a > 0)),
      (e.numPlanes = a),
      (e.numIntersection = 0);
  }
  function $(_e, et, rt, st) {
    const at = _e !== null ? _e.length : 0;
    let ct = null;
    if (at !== 0) {
      if (((ct = b.value), st !== !0 || ct === null)) {
        const it = rt + at * 4,
          lt = et.matrixWorldInverse;
        _.getNormalMatrix(lt),
          (ct === null || ct.length < it) && (ct = new Float32Array(it));
        for (let ot = 0, ut = rt; ot !== at; ++ot, ut += 4)
          g.copy(_e[ot]).applyMatrix4(lt, _),
            g.normal.toArray(ct, ut),
            (ct[ut + 3] = g.constant);
      }
      (b.value = ct), (b.needsUpdate = !0);
    }
    return (e.numPlanes = at), (e.numIntersection = 0), ct;
  }
}
function WebGLCubeMaps(s) {
  let e = new WeakMap();
  function o(g, _) {
    return (
      _ === EquirectangularReflectionMapping
        ? (g.mapping = CubeReflectionMapping)
        : _ === EquirectangularRefractionMapping &&
          (g.mapping = CubeRefractionMapping),
      g
    );
  }
  function a(g) {
    if (g && g.isTexture) {
      const _ = g.mapping;
      if (
        _ === EquirectangularReflectionMapping ||
        _ === EquirectangularRefractionMapping
      )
        if (e.has(g)) {
          const b = e.get(g).texture;
          return o(b, g.mapping);
        } else {
          const b = g.image;
          if (b && b.height > 0) {
            const j = new WebGLCubeRenderTarget(b.height);
            return (
              j.fromEquirectangularTexture(s, g),
              e.set(g, j),
              g.addEventListener("dispose", c),
              o(j.texture, g.mapping)
            );
          } else return null;
        }
    }
    return g;
  }
  function c(g) {
    const _ = g.target;
    _.removeEventListener("dispose", c);
    const b = e.get(_);
    b !== void 0 && (e.delete(_), b.dispose());
  }
  function d() {
    e = new WeakMap();
  }
  return { get: a, dispose: d };
}
class OrthographicCamera extends Camera {
  constructor(e = -1, o = 1, a = 1, c = -1, d = 0.1, g = 2e3) {
    super(),
      (this.isOrthographicCamera = !0),
      (this.type = "OrthographicCamera"),
      (this.zoom = 1),
      (this.view = null),
      (this.left = e),
      (this.right = o),
      (this.top = a),
      (this.bottom = c),
      (this.near = d),
      (this.far = g),
      this.updateProjectionMatrix();
  }
  copy(e, o) {
    return (
      super.copy(e, o),
      (this.left = e.left),
      (this.right = e.right),
      (this.top = e.top),
      (this.bottom = e.bottom),
      (this.near = e.near),
      (this.far = e.far),
      (this.zoom = e.zoom),
      (this.view = e.view === null ? null : Object.assign({}, e.view)),
      this
    );
  }
  setViewOffset(e, o, a, c, d, g) {
    this.view === null &&
      (this.view = {
        enabled: !0,
        fullWidth: 1,
        fullHeight: 1,
        offsetX: 0,
        offsetY: 0,
        width: 1,
        height: 1,
      }),
      (this.view.enabled = !0),
      (this.view.fullWidth = e),
      (this.view.fullHeight = o),
      (this.view.offsetX = a),
      (this.view.offsetY = c),
      (this.view.width = d),
      (this.view.height = g),
      this.updateProjectionMatrix();
  }
  clearViewOffset() {
    this.view !== null && (this.view.enabled = !1),
      this.updateProjectionMatrix();
  }
  updateProjectionMatrix() {
    const e = (this.right - this.left) / (2 * this.zoom),
      o = (this.top - this.bottom) / (2 * this.zoom),
      a = (this.right + this.left) / 2,
      c = (this.top + this.bottom) / 2;
    let d = a - e,
      g = a + e,
      _ = c + o,
      b = c - o;
    if (this.view !== null && this.view.enabled) {
      const j = (this.right - this.left) / this.view.fullWidth / this.zoom,
        $ = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
      (d += j * this.view.offsetX),
        (g = d + j * this.view.width),
        (_ -= $ * this.view.offsetY),
        (b = _ - $ * this.view.height);
    }
    this.projectionMatrix.makeOrthographic(
      d,
      g,
      _,
      b,
      this.near,
      this.far,
      this.coordinateSystem
    ),
      this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
  }
  toJSON(e) {
    const o = super.toJSON(e);
    return (
      (o.object.zoom = this.zoom),
      (o.object.left = this.left),
      (o.object.right = this.right),
      (o.object.top = this.top),
      (o.object.bottom = this.bottom),
      (o.object.near = this.near),
      (o.object.far = this.far),
      this.view !== null && (o.object.view = Object.assign({}, this.view)),
      o
    );
  }
}
const LOD_MIN = 4,
  EXTRA_LOD_SIGMA = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582],
  MAX_SAMPLES = 20,
  _flatCamera = new OrthographicCamera(),
  _clearColor = new Color();
let _oldTarget = null,
  _oldActiveCubeFace = 0,
  _oldActiveMipmapLevel = 0,
  _oldXrEnabled = !1;
const PHI = (1 + Math.sqrt(5)) / 2,
  INV_PHI = 1 / PHI,
  _axisDirections = [
    new Vector3(-PHI, INV_PHI, 0),
    new Vector3(PHI, INV_PHI, 0),
    new Vector3(-INV_PHI, 0, PHI),
    new Vector3(INV_PHI, 0, PHI),
    new Vector3(0, PHI, -INV_PHI),
    new Vector3(0, PHI, INV_PHI),
    new Vector3(-1, 1, -1),
    new Vector3(1, 1, -1),
    new Vector3(-1, 1, 1),
    new Vector3(1, 1, 1),
  ];
class PMREMGenerator {
  constructor(e) {
    (this._renderer = e),
      (this._pingPongRenderTarget = null),
      (this._lodMax = 0),
      (this._cubeSize = 0),
      (this._lodPlanes = []),
      (this._sizeLods = []),
      (this._sigmas = []),
      (this._blurMaterial = null),
      (this._cubemapMaterial = null),
      (this._equirectMaterial = null),
      this._compileMaterial(this._blurMaterial);
  }
  fromScene(e, o = 0, a = 0.1, c = 100) {
    (_oldTarget = this._renderer.getRenderTarget()),
      (_oldActiveCubeFace = this._renderer.getActiveCubeFace()),
      (_oldActiveMipmapLevel = this._renderer.getActiveMipmapLevel()),
      (_oldXrEnabled = this._renderer.xr.enabled),
      (this._renderer.xr.enabled = !1),
      this._setSize(256);
    const d = this._allocateTargets();
    return (
      (d.depthBuffer = !0),
      this._sceneToCubeUV(e, a, c, d),
      o > 0 && this._blur(d, 0, 0, o),
      this._applyPMREM(d),
      this._cleanup(d),
      d
    );
  }
  fromEquirectangular(e, o = null) {
    return this._fromTexture(e, o);
  }
  fromCubemap(e, o = null) {
    return this._fromTexture(e, o);
  }
  compileCubemapShader() {
    this._cubemapMaterial === null &&
      ((this._cubemapMaterial = _getCubemapMaterial()),
      this._compileMaterial(this._cubemapMaterial));
  }
  compileEquirectangularShader() {
    this._equirectMaterial === null &&
      ((this._equirectMaterial = _getEquirectMaterial()),
      this._compileMaterial(this._equirectMaterial));
  }
  dispose() {
    this._dispose(),
      this._cubemapMaterial !== null && this._cubemapMaterial.dispose(),
      this._equirectMaterial !== null && this._equirectMaterial.dispose();
  }
  _setSize(e) {
    (this._lodMax = Math.floor(Math.log2(e))),
      (this._cubeSize = Math.pow(2, this._lodMax));
  }
  _dispose() {
    this._blurMaterial !== null && this._blurMaterial.dispose(),
      this._pingPongRenderTarget !== null &&
        this._pingPongRenderTarget.dispose();
    for (let e = 0; e < this._lodPlanes.length; e++)
      this._lodPlanes[e].dispose();
  }
  _cleanup(e) {
    this._renderer.setRenderTarget(
      _oldTarget,
      _oldActiveCubeFace,
      _oldActiveMipmapLevel
    ),
      (this._renderer.xr.enabled = _oldXrEnabled),
      (e.scissorTest = !1),
      _setViewport(e, 0, 0, e.width, e.height);
  }
  _fromTexture(e, o) {
    e.mapping === CubeReflectionMapping || e.mapping === CubeRefractionMapping
      ? this._setSize(
          e.image.length === 0 ? 16 : e.image[0].width || e.image[0].image.width
        )
      : this._setSize(e.image.width / 4),
      (_oldTarget = this._renderer.getRenderTarget()),
      (_oldActiveCubeFace = this._renderer.getActiveCubeFace()),
      (_oldActiveMipmapLevel = this._renderer.getActiveMipmapLevel()),
      (_oldXrEnabled = this._renderer.xr.enabled),
      (this._renderer.xr.enabled = !1);
    const a = o || this._allocateTargets();
    return (
      this._textureToCubeUV(e, a), this._applyPMREM(a), this._cleanup(a), a
    );
  }
  _allocateTargets() {
    const e = 3 * Math.max(this._cubeSize, 112),
      o = 4 * this._cubeSize,
      a = {
        magFilter: LinearFilter,
        minFilter: LinearFilter,
        generateMipmaps: !1,
        type: HalfFloatType,
        format: RGBAFormat,
        colorSpace: LinearSRGBColorSpace$1,
        depthBuffer: !1,
      },
      c = _createRenderTarget(e, o, a);
    if (
      this._pingPongRenderTarget === null ||
      this._pingPongRenderTarget.width !== e ||
      this._pingPongRenderTarget.height !== o
    ) {
      this._pingPongRenderTarget !== null && this._dispose(),
        (this._pingPongRenderTarget = _createRenderTarget(e, o, a));
      const { _lodMax: d } = this;
      ({
        sizeLods: this._sizeLods,
        lodPlanes: this._lodPlanes,
        sigmas: this._sigmas,
      } = _createPlanes(d)),
        (this._blurMaterial = _getBlurShader(d, e, o));
    }
    return c;
  }
  _compileMaterial(e) {
    const o = new Mesh(this._lodPlanes[0], e);
    this._renderer.compile(o, _flatCamera);
  }
  _sceneToCubeUV(e, o, a, c) {
    const _ = new PerspectiveCamera(90, 1, o, a),
      b = [1, -1, 1, 1, 1, 1],
      j = [1, 1, 1, -1, -1, -1],
      $ = this._renderer,
      _e = $.autoClear,
      et = $.toneMapping;
    $.getClearColor(_clearColor),
      ($.toneMapping = NoToneMapping),
      ($.autoClear = !1);
    const rt = new MeshBasicMaterial({
        name: "PMREM.Background",
        side: BackSide,
        depthWrite: !1,
        depthTest: !1,
      }),
      st = new Mesh(new BoxGeometry(), rt);
    let at = !1;
    const ct = e.background;
    ct
      ? ct.isColor && (rt.color.copy(ct), (e.background = null), (at = !0))
      : (rt.color.copy(_clearColor), (at = !0));
    for (let it = 0; it < 6; it++) {
      const lt = it % 3;
      lt === 0
        ? (_.up.set(0, b[it], 0), _.lookAt(j[it], 0, 0))
        : lt === 1
        ? (_.up.set(0, 0, b[it]), _.lookAt(0, j[it], 0))
        : (_.up.set(0, b[it], 0), _.lookAt(0, 0, j[it]));
      const ot = this._cubeSize;
      _setViewport(c, lt * ot, it > 2 ? ot : 0, ot, ot),
        $.setRenderTarget(c),
        at && $.render(st, _),
        $.render(e, _);
    }
    st.geometry.dispose(),
      st.material.dispose(),
      ($.toneMapping = et),
      ($.autoClear = _e),
      (e.background = ct);
  }
  _textureToCubeUV(e, o) {
    const a = this._renderer,
      c =
        e.mapping === CubeReflectionMapping ||
        e.mapping === CubeRefractionMapping;
    c
      ? (this._cubemapMaterial === null &&
          (this._cubemapMaterial = _getCubemapMaterial()),
        (this._cubemapMaterial.uniforms.flipEnvMap.value =
          e.isRenderTargetTexture === !1 ? -1 : 1))
      : this._equirectMaterial === null &&
        (this._equirectMaterial = _getEquirectMaterial());
    const d = c ? this._cubemapMaterial : this._equirectMaterial,
      g = new Mesh(this._lodPlanes[0], d),
      _ = d.uniforms;
    _.envMap.value = e;
    const b = this._cubeSize;
    _setViewport(o, 0, 0, 3 * b, 2 * b),
      a.setRenderTarget(o),
      a.render(g, _flatCamera);
  }
  _applyPMREM(e) {
    const o = this._renderer,
      a = o.autoClear;
    o.autoClear = !1;
    const c = this._lodPlanes.length;
    for (let d = 1; d < c; d++) {
      const g = Math.sqrt(
          this._sigmas[d] * this._sigmas[d] -
            this._sigmas[d - 1] * this._sigmas[d - 1]
        ),
        _ = _axisDirections[(c - d - 1) % _axisDirections.length];
      this._blur(e, d - 1, d, g, _);
    }
    o.autoClear = a;
  }
  _blur(e, o, a, c, d) {
    const g = this._pingPongRenderTarget;
    this._halfBlur(e, g, o, a, c, "latitudinal", d),
      this._halfBlur(g, e, a, a, c, "longitudinal", d);
  }
  _halfBlur(e, o, a, c, d, g, _) {
    const b = this._renderer,
      j = this._blurMaterial;
    g !== "latitudinal" &&
      g !== "longitudinal" &&
      console.error(
        "blur direction must be either latitudinal or longitudinal!"
      );
    const $ = 3,
      _e = new Mesh(this._lodPlanes[c], j),
      et = j.uniforms,
      rt = this._sizeLods[a] - 1,
      st = isFinite(d)
        ? Math.PI / (2 * rt)
        : (2 * Math.PI) / (2 * MAX_SAMPLES - 1),
      at = d / st,
      ct = isFinite(d) ? 1 + Math.floor($ * at) : MAX_SAMPLES;
    ct > MAX_SAMPLES &&
      console.warn(
        `sigmaRadians, ${d}, is too large and will clip, as it requested ${ct} samples when the maximum is set to ${MAX_SAMPLES}`
      );
    const it = [];
    let lt = 0;
    for (let gt = 0; gt < MAX_SAMPLES; ++gt) {
      const xt = gt / at,
        _t = Math.exp((-xt * xt) / 2);
      it.push(_t), gt === 0 ? (lt += _t) : gt < ct && (lt += 2 * _t);
    }
    for (let gt = 0; gt < it.length; gt++) it[gt] = it[gt] / lt;
    (et.envMap.value = e.texture),
      (et.samples.value = ct),
      (et.weights.value = it),
      (et.latitudinal.value = g === "latitudinal"),
      _ && (et.poleAxis.value = _);
    const { _lodMax: ot } = this;
    (et.dTheta.value = st), (et.mipInt.value = ot - a);
    const ut = this._sizeLods[c],
      pt = 3 * ut * (c > ot - LOD_MIN ? c - ot + LOD_MIN : 0),
      ft = 4 * (this._cubeSize - ut);
    _setViewport(o, pt, ft, 3 * ut, 2 * ut),
      b.setRenderTarget(o),
      b.render(_e, _flatCamera);
  }
}
function _createPlanes(s) {
  const e = [],
    o = [],
    a = [];
  let c = s;
  const d = s - LOD_MIN + 1 + EXTRA_LOD_SIGMA.length;
  for (let g = 0; g < d; g++) {
    const _ = Math.pow(2, c);
    o.push(_);
    let b = 1 / _;
    g > s - LOD_MIN
      ? (b = EXTRA_LOD_SIGMA[g - s + LOD_MIN - 1])
      : g === 0 && (b = 0),
      a.push(b);
    const j = 1 / (_ - 2),
      $ = -j,
      _e = 1 + j,
      et = [$, $, _e, $, _e, _e, $, $, _e, _e, $, _e],
      rt = 6,
      st = 6,
      at = 3,
      ct = 2,
      it = 1,
      lt = new Float32Array(at * st * rt),
      ot = new Float32Array(ct * st * rt),
      ut = new Float32Array(it * st * rt);
    for (let ft = 0; ft < rt; ft++) {
      const gt = ((ft % 3) * 2) / 3 - 1,
        xt = ft > 2 ? 0 : -1,
        _t = [
          gt,
          xt,
          0,
          gt + 2 / 3,
          xt,
          0,
          gt + 2 / 3,
          xt + 1,
          0,
          gt,
          xt,
          0,
          gt + 2 / 3,
          xt + 1,
          0,
          gt,
          xt + 1,
          0,
        ];
      lt.set(_t, at * st * ft), ot.set(et, ct * st * ft);
      const St = [ft, ft, ft, ft, ft, ft];
      ut.set(St, it * st * ft);
    }
    const pt = new BufferGeometry();
    pt.setAttribute("position", new BufferAttribute(lt, at)),
      pt.setAttribute("uv", new BufferAttribute(ot, ct)),
      pt.setAttribute("faceIndex", new BufferAttribute(ut, it)),
      e.push(pt),
      c > LOD_MIN && c--;
  }
  return { lodPlanes: e, sizeLods: o, sigmas: a };
}
function _createRenderTarget(s, e, o) {
  const a = new WebGLRenderTarget(s, e, o);
  return (
    (a.texture.mapping = CubeUVReflectionMapping),
    (a.texture.name = "PMREM.cubeUv"),
    (a.scissorTest = !0),
    a
  );
}
function _setViewport(s, e, o, a, c) {
  s.viewport.set(e, o, a, c), s.scissor.set(e, o, a, c);
}
function _getBlurShader(s, e, o) {
  const a = new Float32Array(MAX_SAMPLES),
    c = new Vector3(0, 1, 0);
  return new ShaderMaterial({
    name: "SphericalGaussianBlur",
    defines: {
      n: MAX_SAMPLES,
      CUBEUV_TEXEL_WIDTH: 1 / e,
      CUBEUV_TEXEL_HEIGHT: 1 / o,
      CUBEUV_MAX_MIP: `${s}.0`,
    },
    uniforms: {
      envMap: { value: null },
      samples: { value: 1 },
      weights: { value: a },
      latitudinal: { value: !1 },
      dTheta: { value: 0 },
      mipInt: { value: 0 },
      poleAxis: { value: c },
    },
    vertexShader: _getCommonVertexShader(),
    fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

			}
		`,
    blending: NoBlending,
    depthTest: !1,
    depthWrite: !1,
  });
}
function _getEquirectMaterial() {
  return new ShaderMaterial({
    name: "EquirectangularToCubeUV",
    uniforms: { envMap: { value: null } },
    vertexShader: _getCommonVertexShader(),
    fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;

			#include <common>

			void main() {

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );

			}
		`,
    blending: NoBlending,
    depthTest: !1,
    depthWrite: !1,
  });
}
function _getCubemapMaterial() {
  return new ShaderMaterial({
    name: "CubemapToCubeUV",
    uniforms: { envMap: { value: null }, flipEnvMap: { value: -1 } },
    vertexShader: _getCommonVertexShader(),
    fragmentShader: `

			precision mediump float;
			precision mediump int;

			uniform float flipEnvMap;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			void main() {

				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );

			}
		`,
    blending: NoBlending,
    depthTest: !1,
    depthWrite: !1,
  });
}
function _getCommonVertexShader() {
  return `

		precision mediump float;
		precision mediump int;

		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`;
}
function WebGLCubeUVMaps(s) {
  let e = new WeakMap(),
    o = null;
  function a(_) {
    if (_ && _.isTexture) {
      const b = _.mapping,
        j =
          b === EquirectangularReflectionMapping ||
          b === EquirectangularRefractionMapping,
        $ = b === CubeReflectionMapping || b === CubeRefractionMapping;
      if (j || $) {
        let _e = e.get(_);
        const et = _e !== void 0 ? _e.texture.pmremVersion : 0;
        if (_.isRenderTargetTexture && _.pmremVersion !== et)
          return (
            o === null && (o = new PMREMGenerator(s)),
            (_e = j ? o.fromEquirectangular(_, _e) : o.fromCubemap(_, _e)),
            (_e.texture.pmremVersion = _.pmremVersion),
            e.set(_, _e),
            _e.texture
          );
        if (_e !== void 0) return _e.texture;
        {
          const rt = _.image;
          return (j && rt && rt.height > 0) || ($ && rt && c(rt))
            ? (o === null && (o = new PMREMGenerator(s)),
              (_e = j ? o.fromEquirectangular(_) : o.fromCubemap(_)),
              (_e.texture.pmremVersion = _.pmremVersion),
              e.set(_, _e),
              _.addEventListener("dispose", d),
              _e.texture)
            : null;
        }
      }
    }
    return _;
  }
  function c(_) {
    let b = 0;
    const j = 6;
    for (let $ = 0; $ < j; $++) _[$] !== void 0 && b++;
    return b === j;
  }
  function d(_) {
    const b = _.target;
    b.removeEventListener("dispose", d);
    const j = e.get(b);
    j !== void 0 && (e.delete(b), j.dispose());
  }
  function g() {
    (e = new WeakMap()), o !== null && (o.dispose(), (o = null));
  }
  return { get: a, dispose: g };
}
function WebGLExtensions(s) {
  const e = {};
  function o(a) {
    if (e[a] !== void 0) return e[a];
    let c;
    switch (a) {
      case "WEBGL_depth_texture":
        c =
          s.getExtension("WEBGL_depth_texture") ||
          s.getExtension("MOZ_WEBGL_depth_texture") ||
          s.getExtension("WEBKIT_WEBGL_depth_texture");
        break;
      case "EXT_texture_filter_anisotropic":
        c =
          s.getExtension("EXT_texture_filter_anisotropic") ||
          s.getExtension("MOZ_EXT_texture_filter_anisotropic") ||
          s.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
        break;
      case "WEBGL_compressed_texture_s3tc":
        c =
          s.getExtension("WEBGL_compressed_texture_s3tc") ||
          s.getExtension("MOZ_WEBGL_compressed_texture_s3tc") ||
          s.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
        break;
      case "WEBGL_compressed_texture_pvrtc":
        c =
          s.getExtension("WEBGL_compressed_texture_pvrtc") ||
          s.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
        break;
      default:
        c = s.getExtension(a);
    }
    return (e[a] = c), c;
  }
  return {
    has: function (a) {
      return o(a) !== null;
    },
    init: function () {
      o("EXT_color_buffer_float"),
        o("WEBGL_clip_cull_distance"),
        o("OES_texture_float_linear"),
        o("EXT_color_buffer_half_float"),
        o("WEBGL_multisampled_render_to_texture"),
        o("WEBGL_render_shared_exponent");
    },
    get: function (a) {
      const c = o(a);
      return (
        c === null &&
          warnOnce("THREE.WebGLRenderer: " + a + " extension not supported."),
        c
      );
    },
  };
}
function WebGLGeometries(s, e, o, a) {
  const c = {},
    d = new WeakMap();
  function g(_e) {
    const et = _e.target;
    et.index !== null && e.remove(et.index);
    for (const st in et.attributes) e.remove(et.attributes[st]);
    for (const st in et.morphAttributes) {
      const at = et.morphAttributes[st];
      for (let ct = 0, it = at.length; ct < it; ct++) e.remove(at[ct]);
    }
    et.removeEventListener("dispose", g), delete c[et.id];
    const rt = d.get(et);
    rt && (e.remove(rt), d.delete(et)),
      a.releaseStatesOfGeometry(et),
      et.isInstancedBufferGeometry === !0 && delete et._maxInstanceCount,
      o.memory.geometries--;
  }
  function _(_e, et) {
    return (
      c[et.id] === !0 ||
        (et.addEventListener("dispose", g),
        (c[et.id] = !0),
        o.memory.geometries++),
      et
    );
  }
  function b(_e) {
    const et = _e.attributes;
    for (const st in et) e.update(et[st], s.ARRAY_BUFFER);
    const rt = _e.morphAttributes;
    for (const st in rt) {
      const at = rt[st];
      for (let ct = 0, it = at.length; ct < it; ct++)
        e.update(at[ct], s.ARRAY_BUFFER);
    }
  }
  function j(_e) {
    const et = [],
      rt = _e.index,
      st = _e.attributes.position;
    let at = 0;
    if (rt !== null) {
      const lt = rt.array;
      at = rt.version;
      for (let ot = 0, ut = lt.length; ot < ut; ot += 3) {
        const pt = lt[ot + 0],
          ft = lt[ot + 1],
          gt = lt[ot + 2];
        et.push(pt, ft, ft, gt, gt, pt);
      }
    } else if (st !== void 0) {
      const lt = st.array;
      at = st.version;
      for (let ot = 0, ut = lt.length / 3 - 1; ot < ut; ot += 3) {
        const pt = ot + 0,
          ft = ot + 1,
          gt = ot + 2;
        et.push(pt, ft, ft, gt, gt, pt);
      }
    } else return;
    const ct = new (
      arrayNeedsUint32(et) ? Uint32BufferAttribute : Uint16BufferAttribute
    )(et, 1);
    ct.version = at;
    const it = d.get(_e);
    it && e.remove(it), d.set(_e, ct);
  }
  function $(_e) {
    const et = d.get(_e);
    if (et) {
      const rt = _e.index;
      rt !== null && et.version < rt.version && j(_e);
    } else j(_e);
    return d.get(_e);
  }
  return { get: _, update: b, getWireframeAttribute: $ };
}
function WebGLIndexedBufferRenderer(s, e, o) {
  let a;
  function c(et) {
    a = et;
  }
  let d, g;
  function _(et) {
    (d = et.type), (g = et.bytesPerElement);
  }
  function b(et, rt) {
    s.drawElements(a, rt, d, et * g), o.update(rt, a, 1);
  }
  function j(et, rt, st) {
    st !== 0 &&
      (s.drawElementsInstanced(a, rt, d, et * g, st), o.update(rt, a, st));
  }
  function $(et, rt, st) {
    if (st === 0) return;
    e.get("WEBGL_multi_draw").multiDrawElementsWEBGL(a, rt, 0, d, et, 0, st);
    let ct = 0;
    for (let it = 0; it < st; it++) ct += rt[it];
    o.update(ct, a, 1);
  }
  function _e(et, rt, st, at) {
    if (st === 0) return;
    const ct = e.get("WEBGL_multi_draw");
    if (ct === null)
      for (let it = 0; it < et.length; it++) j(et[it] / g, rt[it], at[it]);
    else {
      ct.multiDrawElementsInstancedWEBGL(a, rt, 0, d, et, 0, at, 0, st);
      let it = 0;
      for (let lt = 0; lt < st; lt++) it += rt[lt];
      for (let lt = 0; lt < at.length; lt++) o.update(it, a, at[lt]);
    }
  }
  (this.setMode = c),
    (this.setIndex = _),
    (this.render = b),
    (this.renderInstances = j),
    (this.renderMultiDraw = $),
    (this.renderMultiDrawInstances = _e);
}
function WebGLInfo(s) {
  const e = { geometries: 0, textures: 0 },
    o = { frame: 0, calls: 0, triangles: 0, points: 0, lines: 0 };
  function a(d, g, _) {
    switch ((o.calls++, g)) {
      case s.TRIANGLES:
        o.triangles += _ * (d / 3);
        break;
      case s.LINES:
        o.lines += _ * (d / 2);
        break;
      case s.LINE_STRIP:
        o.lines += _ * (d - 1);
        break;
      case s.LINE_LOOP:
        o.lines += _ * d;
        break;
      case s.POINTS:
        o.points += _ * d;
        break;
      default:
        console.error("THREE.WebGLInfo: Unknown draw mode:", g);
        break;
    }
  }
  function c() {
    (o.calls = 0), (o.triangles = 0), (o.points = 0), (o.lines = 0);
  }
  return {
    memory: e,
    render: o,
    programs: null,
    autoReset: !0,
    reset: c,
    update: a,
  };
}
function WebGLMorphtargets(s, e, o) {
  const a = new WeakMap(),
    c = new Vector4();
  function d(g, _, b) {
    const j = g.morphTargetInfluences,
      $ =
        _.morphAttributes.position ||
        _.morphAttributes.normal ||
        _.morphAttributes.color,
      _e = $ !== void 0 ? $.length : 0;
    let et = a.get(_);
    if (et === void 0 || et.count !== _e) {
      let St = function () {
        xt.dispose(), a.delete(_), _.removeEventListener("dispose", St);
      };
      var rt = St;
      et !== void 0 && et.texture.dispose();
      const st = _.morphAttributes.position !== void 0,
        at = _.morphAttributes.normal !== void 0,
        ct = _.morphAttributes.color !== void 0,
        it = _.morphAttributes.position || [],
        lt = _.morphAttributes.normal || [],
        ot = _.morphAttributes.color || [];
      let ut = 0;
      st === !0 && (ut = 1), at === !0 && (ut = 2), ct === !0 && (ut = 3);
      let pt = _.attributes.position.count * ut,
        ft = 1;
      pt > e.maxTextureSize &&
        ((ft = Math.ceil(pt / e.maxTextureSize)), (pt = e.maxTextureSize));
      const gt = new Float32Array(pt * ft * 4 * _e),
        xt = new DataArrayTexture(gt, pt, ft, _e);
      (xt.type = FloatType), (xt.needsUpdate = !0);
      const _t = ut * 4;
      for (let Mt = 0; Mt < _e; Mt++) {
        const Rt = it[Mt],
          Ft = lt[Mt],
          Ot = ot[Mt],
          Lt = pt * ft * 4 * Mt;
        for (let Et = 0; Et < Rt.count; Et++) {
          const bt = Et * _t;
          st === !0 &&
            (c.fromBufferAttribute(Rt, Et),
            (gt[Lt + bt + 0] = c.x),
            (gt[Lt + bt + 1] = c.y),
            (gt[Lt + bt + 2] = c.z),
            (gt[Lt + bt + 3] = 0)),
            at === !0 &&
              (c.fromBufferAttribute(Ft, Et),
              (gt[Lt + bt + 4] = c.x),
              (gt[Lt + bt + 5] = c.y),
              (gt[Lt + bt + 6] = c.z),
              (gt[Lt + bt + 7] = 0)),
            ct === !0 &&
              (c.fromBufferAttribute(Ot, Et),
              (gt[Lt + bt + 8] = c.x),
              (gt[Lt + bt + 9] = c.y),
              (gt[Lt + bt + 10] = c.z),
              (gt[Lt + bt + 11] = Ot.itemSize === 4 ? c.w : 1));
        }
      }
      (et = { count: _e, texture: xt, size: new Vector2(pt, ft) }),
        a.set(_, et),
        _.addEventListener("dispose", St);
    }
    if (g.isInstancedMesh === !0 && g.morphTexture !== null)
      b.getUniforms().setValue(s, "morphTexture", g.morphTexture, o);
    else {
      let st = 0;
      for (let ct = 0; ct < j.length; ct++) st += j[ct];
      const at = _.morphTargetsRelative ? 1 : 1 - st;
      b.getUniforms().setValue(s, "morphTargetBaseInfluence", at),
        b.getUniforms().setValue(s, "morphTargetInfluences", j);
    }
    b.getUniforms().setValue(s, "morphTargetsTexture", et.texture, o),
      b.getUniforms().setValue(s, "morphTargetsTextureSize", et.size);
  }
  return { update: d };
}
function WebGLObjects(s, e, o, a) {
  let c = new WeakMap();
  function d(b) {
    const j = a.render.frame,
      $ = b.geometry,
      _e = e.get(b, $);
    if (
      (c.get(_e) !== j && (e.update(_e), c.set(_e, j)),
      b.isInstancedMesh &&
        (b.hasEventListener("dispose", _) === !1 &&
          b.addEventListener("dispose", _),
        c.get(b) !== j &&
          (o.update(b.instanceMatrix, s.ARRAY_BUFFER),
          b.instanceColor !== null && o.update(b.instanceColor, s.ARRAY_BUFFER),
          c.set(b, j))),
      b.isSkinnedMesh)
    ) {
      const et = b.skeleton;
      c.get(et) !== j && (et.update(), c.set(et, j));
    }
    return _e;
  }
  function g() {
    c = new WeakMap();
  }
  function _(b) {
    const j = b.target;
    j.removeEventListener("dispose", _),
      o.remove(j.instanceMatrix),
      j.instanceColor !== null && o.remove(j.instanceColor);
  }
  return { update: d, dispose: g };
}
class DepthTexture extends Texture {
  constructor(e, o, a, c, d, g, _, b, j, $ = DepthFormat) {
    if ($ !== DepthFormat && $ !== DepthStencilFormat)
      throw new Error(
        "DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat"
      );
    a === void 0 && $ === DepthFormat && (a = UnsignedIntType),
      a === void 0 && $ === DepthStencilFormat && (a = UnsignedInt248Type),
      super(null, c, d, g, _, b, $, a, j),
      (this.isDepthTexture = !0),
      (this.image = { width: e, height: o }),
      (this.magFilter = _ !== void 0 ? _ : NearestFilter),
      (this.minFilter = b !== void 0 ? b : NearestFilter),
      (this.flipY = !1),
      (this.generateMipmaps = !1),
      (this.compareFunction = null);
  }
  copy(e) {
    return super.copy(e), (this.compareFunction = e.compareFunction), this;
  }
  toJSON(e) {
    const o = super.toJSON(e);
    return (
      this.compareFunction !== null &&
        (o.compareFunction = this.compareFunction),
      o
    );
  }
}
const emptyTexture = new Texture(),
  emptyShadowTexture = new DepthTexture(1, 1),
  emptyArrayTexture = new DataArrayTexture(),
  empty3dTexture = new Data3DTexture(),
  emptyCubeTexture = new CubeTexture(),
  arrayCacheF32 = [],
  arrayCacheI32 = [],
  mat4array = new Float32Array(16),
  mat3array = new Float32Array(9),
  mat2array = new Float32Array(4);
function flatten(s, e, o) {
  const a = s[0];
  if (a <= 0 || a > 0) return s;
  const c = e * o;
  let d = arrayCacheF32[c];
  if (
    (d === void 0 && ((d = new Float32Array(c)), (arrayCacheF32[c] = d)),
    e !== 0)
  ) {
    a.toArray(d, 0);
    for (let g = 1, _ = 0; g !== e; ++g) (_ += o), s[g].toArray(d, _);
  }
  return d;
}
function arraysEqual(s, e) {
  if (s.length !== e.length) return !1;
  for (let o = 0, a = s.length; o < a; o++) if (s[o] !== e[o]) return !1;
  return !0;
}
function copyArray(s, e) {
  for (let o = 0, a = e.length; o < a; o++) s[o] = e[o];
}
function allocTexUnits(s, e) {
  let o = arrayCacheI32[e];
  o === void 0 && ((o = new Int32Array(e)), (arrayCacheI32[e] = o));
  for (let a = 0; a !== e; ++a) o[a] = s.allocateTextureUnit();
  return o;
}
function setValueV1f(s, e) {
  const o = this.cache;
  o[0] !== e && (s.uniform1f(this.addr, e), (o[0] = e));
}
function setValueV2f(s, e) {
  const o = this.cache;
  if (e.x !== void 0)
    (o[0] !== e.x || o[1] !== e.y) &&
      (s.uniform2f(this.addr, e.x, e.y), (o[0] = e.x), (o[1] = e.y));
  else {
    if (arraysEqual(o, e)) return;
    s.uniform2fv(this.addr, e), copyArray(o, e);
  }
}
function setValueV3f(s, e) {
  const o = this.cache;
  if (e.x !== void 0)
    (o[0] !== e.x || o[1] !== e.y || o[2] !== e.z) &&
      (s.uniform3f(this.addr, e.x, e.y, e.z),
      (o[0] = e.x),
      (o[1] = e.y),
      (o[2] = e.z));
  else if (e.r !== void 0)
    (o[0] !== e.r || o[1] !== e.g || o[2] !== e.b) &&
      (s.uniform3f(this.addr, e.r, e.g, e.b),
      (o[0] = e.r),
      (o[1] = e.g),
      (o[2] = e.b));
  else {
    if (arraysEqual(o, e)) return;
    s.uniform3fv(this.addr, e), copyArray(o, e);
  }
}
function setValueV4f(s, e) {
  const o = this.cache;
  if (e.x !== void 0)
    (o[0] !== e.x || o[1] !== e.y || o[2] !== e.z || o[3] !== e.w) &&
      (s.uniform4f(this.addr, e.x, e.y, e.z, e.w),
      (o[0] = e.x),
      (o[1] = e.y),
      (o[2] = e.z),
      (o[3] = e.w));
  else {
    if (arraysEqual(o, e)) return;
    s.uniform4fv(this.addr, e), copyArray(o, e);
  }
}
function setValueM2(s, e) {
  const o = this.cache,
    a = e.elements;
  if (a === void 0) {
    if (arraysEqual(o, e)) return;
    s.uniformMatrix2fv(this.addr, !1, e), copyArray(o, e);
  } else {
    if (arraysEqual(o, a)) return;
    mat2array.set(a),
      s.uniformMatrix2fv(this.addr, !1, mat2array),
      copyArray(o, a);
  }
}
function setValueM3(s, e) {
  const o = this.cache,
    a = e.elements;
  if (a === void 0) {
    if (arraysEqual(o, e)) return;
    s.uniformMatrix3fv(this.addr, !1, e), copyArray(o, e);
  } else {
    if (arraysEqual(o, a)) return;
    mat3array.set(a),
      s.uniformMatrix3fv(this.addr, !1, mat3array),
      copyArray(o, a);
  }
}
function setValueM4(s, e) {
  const o = this.cache,
    a = e.elements;
  if (a === void 0) {
    if (arraysEqual(o, e)) return;
    s.uniformMatrix4fv(this.addr, !1, e), copyArray(o, e);
  } else {
    if (arraysEqual(o, a)) return;
    mat4array.set(a),
      s.uniformMatrix4fv(this.addr, !1, mat4array),
      copyArray(o, a);
  }
}
function setValueV1i(s, e) {
  const o = this.cache;
  o[0] !== e && (s.uniform1i(this.addr, e), (o[0] = e));
}
function setValueV2i(s, e) {
  const o = this.cache;
  if (e.x !== void 0)
    (o[0] !== e.x || o[1] !== e.y) &&
      (s.uniform2i(this.addr, e.x, e.y), (o[0] = e.x), (o[1] = e.y));
  else {
    if (arraysEqual(o, e)) return;
    s.uniform2iv(this.addr, e), copyArray(o, e);
  }
}
function setValueV3i(s, e) {
  const o = this.cache;
  if (e.x !== void 0)
    (o[0] !== e.x || o[1] !== e.y || o[2] !== e.z) &&
      (s.uniform3i(this.addr, e.x, e.y, e.z),
      (o[0] = e.x),
      (o[1] = e.y),
      (o[2] = e.z));
  else {
    if (arraysEqual(o, e)) return;
    s.uniform3iv(this.addr, e), copyArray(o, e);
  }
}
function setValueV4i(s, e) {
  const o = this.cache;
  if (e.x !== void 0)
    (o[0] !== e.x || o[1] !== e.y || o[2] !== e.z || o[3] !== e.w) &&
      (s.uniform4i(this.addr, e.x, e.y, e.z, e.w),
      (o[0] = e.x),
      (o[1] = e.y),
      (o[2] = e.z),
      (o[3] = e.w));
  else {
    if (arraysEqual(o, e)) return;
    s.uniform4iv(this.addr, e), copyArray(o, e);
  }
}
function setValueV1ui(s, e) {
  const o = this.cache;
  o[0] !== e && (s.uniform1ui(this.addr, e), (o[0] = e));
}
function setValueV2ui(s, e) {
  const o = this.cache;
  if (e.x !== void 0)
    (o[0] !== e.x || o[1] !== e.y) &&
      (s.uniform2ui(this.addr, e.x, e.y), (o[0] = e.x), (o[1] = e.y));
  else {
    if (arraysEqual(o, e)) return;
    s.uniform2uiv(this.addr, e), copyArray(o, e);
  }
}
function setValueV3ui(s, e) {
  const o = this.cache;
  if (e.x !== void 0)
    (o[0] !== e.x || o[1] !== e.y || o[2] !== e.z) &&
      (s.uniform3ui(this.addr, e.x, e.y, e.z),
      (o[0] = e.x),
      (o[1] = e.y),
      (o[2] = e.z));
  else {
    if (arraysEqual(o, e)) return;
    s.uniform3uiv(this.addr, e), copyArray(o, e);
  }
}
function setValueV4ui(s, e) {
  const o = this.cache;
  if (e.x !== void 0)
    (o[0] !== e.x || o[1] !== e.y || o[2] !== e.z || o[3] !== e.w) &&
      (s.uniform4ui(this.addr, e.x, e.y, e.z, e.w),
      (o[0] = e.x),
      (o[1] = e.y),
      (o[2] = e.z),
      (o[3] = e.w));
  else {
    if (arraysEqual(o, e)) return;
    s.uniform4uiv(this.addr, e), copyArray(o, e);
  }
}
function setValueT1(s, e, o) {
  const a = this.cache,
    c = o.allocateTextureUnit();
  a[0] !== c && (s.uniform1i(this.addr, c), (a[0] = c));
  let d;
  this.type === s.SAMPLER_2D_SHADOW
    ? ((emptyShadowTexture.compareFunction = LessEqualCompare),
      (d = emptyShadowTexture))
    : (d = emptyTexture),
    o.setTexture2D(e || d, c);
}
function setValueT3D1(s, e, o) {
  const a = this.cache,
    c = o.allocateTextureUnit();
  a[0] !== c && (s.uniform1i(this.addr, c), (a[0] = c)),
    o.setTexture3D(e || empty3dTexture, c);
}
function setValueT6(s, e, o) {
  const a = this.cache,
    c = o.allocateTextureUnit();
  a[0] !== c && (s.uniform1i(this.addr, c), (a[0] = c)),
    o.setTextureCube(e || emptyCubeTexture, c);
}
function setValueT2DArray1(s, e, o) {
  const a = this.cache,
    c = o.allocateTextureUnit();
  a[0] !== c && (s.uniform1i(this.addr, c), (a[0] = c)),
    o.setTexture2DArray(e || emptyArrayTexture, c);
}
function getSingularSetter(s) {
  switch (s) {
    case 5126:
      return setValueV1f;
    case 35664:
      return setValueV2f;
    case 35665:
      return setValueV3f;
    case 35666:
      return setValueV4f;
    case 35674:
      return setValueM2;
    case 35675:
      return setValueM3;
    case 35676:
      return setValueM4;
    case 5124:
    case 35670:
      return setValueV1i;
    case 35667:
    case 35671:
      return setValueV2i;
    case 35668:
    case 35672:
      return setValueV3i;
    case 35669:
    case 35673:
      return setValueV4i;
    case 5125:
      return setValueV1ui;
    case 36294:
      return setValueV2ui;
    case 36295:
      return setValueV3ui;
    case 36296:
      return setValueV4ui;
    case 35678:
    case 36198:
    case 36298:
    case 36306:
    case 35682:
      return setValueT1;
    case 35679:
    case 36299:
    case 36307:
      return setValueT3D1;
    case 35680:
    case 36300:
    case 36308:
    case 36293:
      return setValueT6;
    case 36289:
    case 36303:
    case 36311:
    case 36292:
      return setValueT2DArray1;
  }
}
function setValueV1fArray(s, e) {
  s.uniform1fv(this.addr, e);
}
function setValueV2fArray(s, e) {
  const o = flatten(e, this.size, 2);
  s.uniform2fv(this.addr, o);
}
function setValueV3fArray(s, e) {
  const o = flatten(e, this.size, 3);
  s.uniform3fv(this.addr, o);
}
function setValueV4fArray(s, e) {
  const o = flatten(e, this.size, 4);
  s.uniform4fv(this.addr, o);
}
function setValueM2Array(s, e) {
  const o = flatten(e, this.size, 4);
  s.uniformMatrix2fv(this.addr, !1, o);
}
function setValueM3Array(s, e) {
  const o = flatten(e, this.size, 9);
  s.uniformMatrix3fv(this.addr, !1, o);
}
function setValueM4Array(s, e) {
  const o = flatten(e, this.size, 16);
  s.uniformMatrix4fv(this.addr, !1, o);
}
function setValueV1iArray(s, e) {
  s.uniform1iv(this.addr, e);
}
function setValueV2iArray(s, e) {
  s.uniform2iv(this.addr, e);
}
function setValueV3iArray(s, e) {
  s.uniform3iv(this.addr, e);
}
function setValueV4iArray(s, e) {
  s.uniform4iv(this.addr, e);
}
function setValueV1uiArray(s, e) {
  s.uniform1uiv(this.addr, e);
}
function setValueV2uiArray(s, e) {
  s.uniform2uiv(this.addr, e);
}
function setValueV3uiArray(s, e) {
  s.uniform3uiv(this.addr, e);
}
function setValueV4uiArray(s, e) {
  s.uniform4uiv(this.addr, e);
}
function setValueT1Array(s, e, o) {
  const a = this.cache,
    c = e.length,
    d = allocTexUnits(o, c);
  arraysEqual(a, d) || (s.uniform1iv(this.addr, d), copyArray(a, d));
  for (let g = 0; g !== c; ++g) o.setTexture2D(e[g] || emptyTexture, d[g]);
}
function setValueT3DArray(s, e, o) {
  const a = this.cache,
    c = e.length,
    d = allocTexUnits(o, c);
  arraysEqual(a, d) || (s.uniform1iv(this.addr, d), copyArray(a, d));
  for (let g = 0; g !== c; ++g) o.setTexture3D(e[g] || empty3dTexture, d[g]);
}
function setValueT6Array(s, e, o) {
  const a = this.cache,
    c = e.length,
    d = allocTexUnits(o, c);
  arraysEqual(a, d) || (s.uniform1iv(this.addr, d), copyArray(a, d));
  for (let g = 0; g !== c; ++g)
    o.setTextureCube(e[g] || emptyCubeTexture, d[g]);
}
function setValueT2DArrayArray(s, e, o) {
  const a = this.cache,
    c = e.length,
    d = allocTexUnits(o, c);
  arraysEqual(a, d) || (s.uniform1iv(this.addr, d), copyArray(a, d));
  for (let g = 0; g !== c; ++g)
    o.setTexture2DArray(e[g] || emptyArrayTexture, d[g]);
}
function getPureArraySetter(s) {
  switch (s) {
    case 5126:
      return setValueV1fArray;
    case 35664:
      return setValueV2fArray;
    case 35665:
      return setValueV3fArray;
    case 35666:
      return setValueV4fArray;
    case 35674:
      return setValueM2Array;
    case 35675:
      return setValueM3Array;
    case 35676:
      return setValueM4Array;
    case 5124:
    case 35670:
      return setValueV1iArray;
    case 35667:
    case 35671:
      return setValueV2iArray;
    case 35668:
    case 35672:
      return setValueV3iArray;
    case 35669:
    case 35673:
      return setValueV4iArray;
    case 5125:
      return setValueV1uiArray;
    case 36294:
      return setValueV2uiArray;
    case 36295:
      return setValueV3uiArray;
    case 36296:
      return setValueV4uiArray;
    case 35678:
    case 36198:
    case 36298:
    case 36306:
    case 35682:
      return setValueT1Array;
    case 35679:
    case 36299:
    case 36307:
      return setValueT3DArray;
    case 35680:
    case 36300:
    case 36308:
    case 36293:
      return setValueT6Array;
    case 36289:
    case 36303:
    case 36311:
    case 36292:
      return setValueT2DArrayArray;
  }
}
class SingleUniform {
  constructor(e, o, a) {
    (this.id = e),
      (this.addr = a),
      (this.cache = []),
      (this.type = o.type),
      (this.setValue = getSingularSetter(o.type));
  }
}
class PureArrayUniform {
  constructor(e, o, a) {
    (this.id = e),
      (this.addr = a),
      (this.cache = []),
      (this.type = o.type),
      (this.size = o.size),
      (this.setValue = getPureArraySetter(o.type));
  }
}
class StructuredUniform {
  constructor(e) {
    (this.id = e), (this.seq = []), (this.map = {});
  }
  setValue(e, o, a) {
    const c = this.seq;
    for (let d = 0, g = c.length; d !== g; ++d) {
      const _ = c[d];
      _.setValue(e, o[_.id], a);
    }
  }
}
const RePathPart = /(\w+)(\])?(\[|\.)?/g;
function addUniform(s, e) {
  s.seq.push(e), (s.map[e.id] = e);
}
function parseUniform(s, e, o) {
  const a = s.name,
    c = a.length;
  for (RePathPart.lastIndex = 0; ; ) {
    const d = RePathPart.exec(a),
      g = RePathPart.lastIndex;
    let _ = d[1];
    const b = d[2] === "]",
      j = d[3];
    if ((b && (_ = _ | 0), j === void 0 || (j === "[" && g + 2 === c))) {
      addUniform(
        o,
        j === void 0
          ? new SingleUniform(_, s, e)
          : new PureArrayUniform(_, s, e)
      );
      break;
    } else {
      let _e = o.map[_];
      _e === void 0 && ((_e = new StructuredUniform(_)), addUniform(o, _e)),
        (o = _e);
    }
  }
}
class WebGLUniforms {
  constructor(e, o) {
    (this.seq = []), (this.map = {});
    const a = e.getProgramParameter(o, e.ACTIVE_UNIFORMS);
    for (let c = 0; c < a; ++c) {
      const d = e.getActiveUniform(o, c),
        g = e.getUniformLocation(o, d.name);
      parseUniform(d, g, this);
    }
  }
  setValue(e, o, a, c) {
    const d = this.map[o];
    d !== void 0 && d.setValue(e, a, c);
  }
  setOptional(e, o, a) {
    const c = o[a];
    c !== void 0 && this.setValue(e, a, c);
  }
  static upload(e, o, a, c) {
    for (let d = 0, g = o.length; d !== g; ++d) {
      const _ = o[d],
        b = a[_.id];
      b.needsUpdate !== !1 && _.setValue(e, b.value, c);
    }
  }
  static seqWithValue(e, o) {
    const a = [];
    for (let c = 0, d = e.length; c !== d; ++c) {
      const g = e[c];
      g.id in o && a.push(g);
    }
    return a;
  }
}
function WebGLShader(s, e, o) {
  const a = s.createShader(e);
  return s.shaderSource(a, o), s.compileShader(a), a;
}
const COMPLETION_STATUS_KHR = 37297;
let programIdCount = 0;
function handleSource(s, e) {
  const o = s.split(`
`),
    a = [],
    c = Math.max(e - 6, 0),
    d = Math.min(e + 6, o.length);
  for (let g = c; g < d; g++) {
    const _ = g + 1;
    a.push(`${_ === e ? ">" : " "} ${_}: ${o[g]}`);
  }
  return a.join(`
`);
}
function getEncodingComponents(s) {
  const e = ColorManagement.getPrimaries(ColorManagement.workingColorSpace),
    o = ColorManagement.getPrimaries(s);
  let a;
  switch (
    (e === o
      ? (a = "")
      : e === P3Primaries && o === Rec709Primaries
      ? (a = "LinearDisplayP3ToLinearSRGB")
      : e === Rec709Primaries &&
        o === P3Primaries &&
        (a = "LinearSRGBToLinearDisplayP3"),
    s)
  ) {
    case LinearSRGBColorSpace$1:
    case LinearDisplayP3ColorSpace:
      return [a, "LinearTransferOETF"];
    case SRGBColorSpace$1:
    case DisplayP3ColorSpace:
      return [a, "sRGBTransferOETF"];
    default:
      return (
        console.warn("THREE.WebGLProgram: Unsupported color space:", s),
        [a, "LinearTransferOETF"]
      );
  }
}
function getShaderErrors(s, e, o) {
  const a = s.getShaderParameter(e, s.COMPILE_STATUS),
    c = s.getShaderInfoLog(e).trim();
  if (a && c === "") return "";
  const d = /ERROR: 0:(\d+)/.exec(c);
  if (d) {
    const g = parseInt(d[1]);
    return (
      o.toUpperCase() +
      `

` +
      c +
      `

` +
      handleSource(s.getShaderSource(e), g)
    );
  } else return c;
}
function getTexelEncodingFunction(s, e) {
  const o = getEncodingComponents(e);
  return `vec4 ${s}( vec4 value ) { return ${o[0]}( ${o[1]}( value ) ); }`;
}
function getToneMappingFunction(s, e) {
  let o;
  switch (e) {
    case LinearToneMapping:
      o = "Linear";
      break;
    case ReinhardToneMapping:
      o = "Reinhard";
      break;
    case CineonToneMapping:
      o = "OptimizedCineon";
      break;
    case ACESFilmicToneMapping:
      o = "ACESFilmic";
      break;
    case AgXToneMapping:
      o = "AgX";
      break;
    case NeutralToneMapping:
      o = "Neutral";
      break;
    case CustomToneMapping:
      o = "Custom";
      break;
    default:
      console.warn("THREE.WebGLProgram: Unsupported toneMapping:", e),
        (o = "Linear");
  }
  return (
    "vec3 " + s + "( vec3 color ) { return " + o + "ToneMapping( color ); }"
  );
}
const _v0$1 = new Vector3();
function getLuminanceFunction() {
  ColorManagement.getLuminanceCoefficients(_v0$1);
  const s = _v0$1.x.toFixed(4),
    e = _v0$1.y.toFixed(4),
    o = _v0$1.z.toFixed(4);
  return [
    "float luminance( const in vec3 rgb ) {",
    `	const vec3 weights = vec3( ${s}, ${e}, ${o} );`,
    "	return dot( weights, rgb );",
    "}",
  ].join(`
`);
}
function generateVertexExtensions(s) {
  return [
    s.extensionClipCullDistance
      ? "#extension GL_ANGLE_clip_cull_distance : require"
      : "",
    s.extensionMultiDraw ? "#extension GL_ANGLE_multi_draw : require" : "",
  ].filter(filterEmptyLine).join(`
`);
}
function generateDefines(s) {
  const e = [];
  for (const o in s) {
    const a = s[o];
    a !== !1 && e.push("#define " + o + " " + a);
  }
  return e.join(`
`);
}
function fetchAttributeLocations(s, e) {
  const o = {},
    a = s.getProgramParameter(e, s.ACTIVE_ATTRIBUTES);
  for (let c = 0; c < a; c++) {
    const d = s.getActiveAttrib(e, c),
      g = d.name;
    let _ = 1;
    d.type === s.FLOAT_MAT2 && (_ = 2),
      d.type === s.FLOAT_MAT3 && (_ = 3),
      d.type === s.FLOAT_MAT4 && (_ = 4),
      (o[g] = {
        type: d.type,
        location: s.getAttribLocation(e, g),
        locationSize: _,
      });
  }
  return o;
}
function filterEmptyLine(s) {
  return s !== "";
}
function replaceLightNums(s, e) {
  const o =
    e.numSpotLightShadows + e.numSpotLightMaps - e.numSpotLightShadowsWithMaps;
  return s
    .replace(/NUM_DIR_LIGHTS/g, e.numDirLights)
    .replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights)
    .replace(/NUM_SPOT_LIGHT_MAPS/g, e.numSpotLightMaps)
    .replace(/NUM_SPOT_LIGHT_COORDS/g, o)
    .replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights)
    .replace(/NUM_POINT_LIGHTS/g, e.numPointLights)
    .replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights)
    .replace(/NUM_DIR_LIGHT_SHADOWS/g, e.numDirLightShadows)
    .replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g, e.numSpotLightShadowsWithMaps)
    .replace(/NUM_SPOT_LIGHT_SHADOWS/g, e.numSpotLightShadows)
    .replace(/NUM_POINT_LIGHT_SHADOWS/g, e.numPointLightShadows);
}
function replaceClippingPlaneNums(s, e) {
  return s
    .replace(/NUM_CLIPPING_PLANES/g, e.numClippingPlanes)
    .replace(
      /UNION_CLIPPING_PLANES/g,
      e.numClippingPlanes - e.numClipIntersection
    );
}
const includePattern = /^[ \t]*#include +<([\w\d./]+)>/gm;
function resolveIncludes(s) {
  return s.replace(includePattern, includeReplacer);
}
const shaderChunkMap = new Map();
function includeReplacer(s, e) {
  let o = ShaderChunk[e];
  if (o === void 0) {
    const a = shaderChunkMap.get(e);
    if (a !== void 0)
      (o = ShaderChunk[a]),
        console.warn(
          'THREE.WebGLRenderer: Shader chunk "%s" has been deprecated. Use "%s" instead.',
          e,
          a
        );
    else throw new Error("Can not resolve #include <" + e + ">");
  }
  return resolveIncludes(o);
}
const unrollLoopPattern =
  /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
function unrollLoops(s) {
  return s.replace(unrollLoopPattern, loopReplacer);
}
function loopReplacer(s, e, o, a) {
  let c = "";
  for (let d = parseInt(e); d < parseInt(o); d++)
    c += a
      .replace(/\[\s*i\s*\]/g, "[ " + d + " ]")
      .replace(/UNROLLED_LOOP_INDEX/g, d);
  return c;
}
function generatePrecision(s) {
  let e = `precision ${s.precision} float;
	precision ${s.precision} int;
	precision ${s.precision} sampler2D;
	precision ${s.precision} samplerCube;
	precision ${s.precision} sampler3D;
	precision ${s.precision} sampler2DArray;
	precision ${s.precision} sampler2DShadow;
	precision ${s.precision} samplerCubeShadow;
	precision ${s.precision} sampler2DArrayShadow;
	precision ${s.precision} isampler2D;
	precision ${s.precision} isampler3D;
	precision ${s.precision} isamplerCube;
	precision ${s.precision} isampler2DArray;
	precision ${s.precision} usampler2D;
	precision ${s.precision} usampler3D;
	precision ${s.precision} usamplerCube;
	precision ${s.precision} usampler2DArray;
	`;
  return (
    s.precision === "highp"
      ? (e += `
#define HIGH_PRECISION`)
      : s.precision === "mediump"
      ? (e += `
#define MEDIUM_PRECISION`)
      : s.precision === "lowp" &&
        (e += `
#define LOW_PRECISION`),
    e
  );
}
function generateShadowMapTypeDefine(s) {
  let e = "SHADOWMAP_TYPE_BASIC";
  return (
    s.shadowMapType === PCFShadowMap
      ? (e = "SHADOWMAP_TYPE_PCF")
      : s.shadowMapType === PCFSoftShadowMap
      ? (e = "SHADOWMAP_TYPE_PCF_SOFT")
      : s.shadowMapType === VSMShadowMap && (e = "SHADOWMAP_TYPE_VSM"),
    e
  );
}
function generateEnvMapTypeDefine(s) {
  let e = "ENVMAP_TYPE_CUBE";
  if (s.envMap)
    switch (s.envMapMode) {
      case CubeReflectionMapping:
      case CubeRefractionMapping:
        e = "ENVMAP_TYPE_CUBE";
        break;
      case CubeUVReflectionMapping:
        e = "ENVMAP_TYPE_CUBE_UV";
        break;
    }
  return e;
}
function generateEnvMapModeDefine(s) {
  let e = "ENVMAP_MODE_REFLECTION";
  if (s.envMap)
    switch (s.envMapMode) {
      case CubeRefractionMapping:
        e = "ENVMAP_MODE_REFRACTION";
        break;
    }
  return e;
}
function generateEnvMapBlendingDefine(s) {
  let e = "ENVMAP_BLENDING_NONE";
  if (s.envMap)
    switch (s.combine) {
      case MultiplyOperation:
        e = "ENVMAP_BLENDING_MULTIPLY";
        break;
      case MixOperation:
        e = "ENVMAP_BLENDING_MIX";
        break;
      case AddOperation:
        e = "ENVMAP_BLENDING_ADD";
        break;
    }
  return e;
}
function generateCubeUVSize(s) {
  const e = s.envMapCubeUVHeight;
  if (e === null) return null;
  const o = Math.log2(e) - 2,
    a = 1 / e;
  return {
    texelWidth: 1 / (3 * Math.max(Math.pow(2, o), 7 * 16)),
    texelHeight: a,
    maxMip: o,
  };
}
function WebGLProgram(s, e, o, a) {
  const c = s.getContext(),
    d = o.defines;
  let g = o.vertexShader,
    _ = o.fragmentShader;
  const b = generateShadowMapTypeDefine(o),
    j = generateEnvMapTypeDefine(o),
    $ = generateEnvMapModeDefine(o),
    _e = generateEnvMapBlendingDefine(o),
    et = generateCubeUVSize(o),
    rt = generateVertexExtensions(o),
    st = generateDefines(d),
    at = c.createProgram();
  let ct,
    it,
    lt = o.glslVersion
      ? "#version " +
        o.glslVersion +
        `
`
      : "";
  o.isRawShaderMaterial
    ? ((ct = [
        "#define SHADER_TYPE " + o.shaderType,
        "#define SHADER_NAME " + o.shaderName,
        st,
      ].filter(filterEmptyLine).join(`
`)),
      ct.length > 0 &&
        (ct += `
`),
      (it = [
        "#define SHADER_TYPE " + o.shaderType,
        "#define SHADER_NAME " + o.shaderName,
        st,
      ].filter(filterEmptyLine).join(`
`)),
      it.length > 0 &&
        (it += `
`))
    : ((ct = [
        generatePrecision(o),
        "#define SHADER_TYPE " + o.shaderType,
        "#define SHADER_NAME " + o.shaderName,
        st,
        o.extensionClipCullDistance ? "#define USE_CLIP_DISTANCE" : "",
        o.batching ? "#define USE_BATCHING" : "",
        o.batchingColor ? "#define USE_BATCHING_COLOR" : "",
        o.instancing ? "#define USE_INSTANCING" : "",
        o.instancingColor ? "#define USE_INSTANCING_COLOR" : "",
        o.instancingMorph ? "#define USE_INSTANCING_MORPH" : "",
        o.useFog && o.fog ? "#define USE_FOG" : "",
        o.useFog && o.fogExp2 ? "#define FOG_EXP2" : "",
        o.map ? "#define USE_MAP" : "",
        o.envMap ? "#define USE_ENVMAP" : "",
        o.envMap ? "#define " + $ : "",
        o.lightMap ? "#define USE_LIGHTMAP" : "",
        o.aoMap ? "#define USE_AOMAP" : "",
        o.bumpMap ? "#define USE_BUMPMAP" : "",
        o.normalMap ? "#define USE_NORMALMAP" : "",
        o.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "",
        o.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "",
        o.displacementMap ? "#define USE_DISPLACEMENTMAP" : "",
        o.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
        o.anisotropy ? "#define USE_ANISOTROPY" : "",
        o.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "",
        o.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
        o.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
        o.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
        o.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "",
        o.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "",
        o.specularMap ? "#define USE_SPECULARMAP" : "",
        o.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "",
        o.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "",
        o.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
        o.metalnessMap ? "#define USE_METALNESSMAP" : "",
        o.alphaMap ? "#define USE_ALPHAMAP" : "",
        o.alphaHash ? "#define USE_ALPHAHASH" : "",
        o.transmission ? "#define USE_TRANSMISSION" : "",
        o.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
        o.thicknessMap ? "#define USE_THICKNESSMAP" : "",
        o.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "",
        o.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "",
        o.mapUv ? "#define MAP_UV " + o.mapUv : "",
        o.alphaMapUv ? "#define ALPHAMAP_UV " + o.alphaMapUv : "",
        o.lightMapUv ? "#define LIGHTMAP_UV " + o.lightMapUv : "",
        o.aoMapUv ? "#define AOMAP_UV " + o.aoMapUv : "",
        o.emissiveMapUv ? "#define EMISSIVEMAP_UV " + o.emissiveMapUv : "",
        o.bumpMapUv ? "#define BUMPMAP_UV " + o.bumpMapUv : "",
        o.normalMapUv ? "#define NORMALMAP_UV " + o.normalMapUv : "",
        o.displacementMapUv
          ? "#define DISPLACEMENTMAP_UV " + o.displacementMapUv
          : "",
        o.metalnessMapUv ? "#define METALNESSMAP_UV " + o.metalnessMapUv : "",
        o.roughnessMapUv ? "#define ROUGHNESSMAP_UV " + o.roughnessMapUv : "",
        o.anisotropyMapUv
          ? "#define ANISOTROPYMAP_UV " + o.anisotropyMapUv
          : "",
        o.clearcoatMapUv ? "#define CLEARCOATMAP_UV " + o.clearcoatMapUv : "",
        o.clearcoatNormalMapUv
          ? "#define CLEARCOAT_NORMALMAP_UV " + o.clearcoatNormalMapUv
          : "",
        o.clearcoatRoughnessMapUv
          ? "#define CLEARCOAT_ROUGHNESSMAP_UV " + o.clearcoatRoughnessMapUv
          : "",
        o.iridescenceMapUv
          ? "#define IRIDESCENCEMAP_UV " + o.iridescenceMapUv
          : "",
        o.iridescenceThicknessMapUv
          ? "#define IRIDESCENCE_THICKNESSMAP_UV " + o.iridescenceThicknessMapUv
          : "",
        o.sheenColorMapUv
          ? "#define SHEEN_COLORMAP_UV " + o.sheenColorMapUv
          : "",
        o.sheenRoughnessMapUv
          ? "#define SHEEN_ROUGHNESSMAP_UV " + o.sheenRoughnessMapUv
          : "",
        o.specularMapUv ? "#define SPECULARMAP_UV " + o.specularMapUv : "",
        o.specularColorMapUv
          ? "#define SPECULAR_COLORMAP_UV " + o.specularColorMapUv
          : "",
        o.specularIntensityMapUv
          ? "#define SPECULAR_INTENSITYMAP_UV " + o.specularIntensityMapUv
          : "",
        o.transmissionMapUv
          ? "#define TRANSMISSIONMAP_UV " + o.transmissionMapUv
          : "",
        o.thicknessMapUv ? "#define THICKNESSMAP_UV " + o.thicknessMapUv : "",
        o.vertexTangents && o.flatShading === !1 ? "#define USE_TANGENT" : "",
        o.vertexColors ? "#define USE_COLOR" : "",
        o.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
        o.vertexUv1s ? "#define USE_UV1" : "",
        o.vertexUv2s ? "#define USE_UV2" : "",
        o.vertexUv3s ? "#define USE_UV3" : "",
        o.pointsUvs ? "#define USE_POINTS_UV" : "",
        o.flatShading ? "#define FLAT_SHADED" : "",
        o.skinning ? "#define USE_SKINNING" : "",
        o.morphTargets ? "#define USE_MORPHTARGETS" : "",
        o.morphNormals && o.flatShading === !1
          ? "#define USE_MORPHNORMALS"
          : "",
        o.morphColors ? "#define USE_MORPHCOLORS" : "",
        o.morphTargetsCount > 0
          ? "#define MORPHTARGETS_TEXTURE_STRIDE " + o.morphTextureStride
          : "",
        o.morphTargetsCount > 0
          ? "#define MORPHTARGETS_COUNT " + o.morphTargetsCount
          : "",
        o.doubleSided ? "#define DOUBLE_SIDED" : "",
        o.flipSided ? "#define FLIP_SIDED" : "",
        o.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
        o.shadowMapEnabled ? "#define " + b : "",
        o.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "",
        o.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "",
        o.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
        "uniform mat4 modelMatrix;",
        "uniform mat4 modelViewMatrix;",
        "uniform mat4 projectionMatrix;",
        "uniform mat4 viewMatrix;",
        "uniform mat3 normalMatrix;",
        "uniform vec3 cameraPosition;",
        "uniform bool isOrthographic;",
        "#ifdef USE_INSTANCING",
        "	attribute mat4 instanceMatrix;",
        "#endif",
        "#ifdef USE_INSTANCING_COLOR",
        "	attribute vec3 instanceColor;",
        "#endif",
        "#ifdef USE_INSTANCING_MORPH",
        "	uniform sampler2D morphTexture;",
        "#endif",
        "attribute vec3 position;",
        "attribute vec3 normal;",
        "attribute vec2 uv;",
        "#ifdef USE_UV1",
        "	attribute vec2 uv1;",
        "#endif",
        "#ifdef USE_UV2",
        "	attribute vec2 uv2;",
        "#endif",
        "#ifdef USE_UV3",
        "	attribute vec2 uv3;",
        "#endif",
        "#ifdef USE_TANGENT",
        "	attribute vec4 tangent;",
        "#endif",
        "#if defined( USE_COLOR_ALPHA )",
        "	attribute vec4 color;",
        "#elif defined( USE_COLOR )",
        "	attribute vec3 color;",
        "#endif",
        "#ifdef USE_SKINNING",
        "	attribute vec4 skinIndex;",
        "	attribute vec4 skinWeight;",
        "#endif",
        `
`,
      ].filter(filterEmptyLine).join(`
`)),
      (it = [
        generatePrecision(o),
        "#define SHADER_TYPE " + o.shaderType,
        "#define SHADER_NAME " + o.shaderName,
        st,
        o.useFog && o.fog ? "#define USE_FOG" : "",
        o.useFog && o.fogExp2 ? "#define FOG_EXP2" : "",
        o.alphaToCoverage ? "#define ALPHA_TO_COVERAGE" : "",
        o.map ? "#define USE_MAP" : "",
        o.matcap ? "#define USE_MATCAP" : "",
        o.envMap ? "#define USE_ENVMAP" : "",
        o.envMap ? "#define " + j : "",
        o.envMap ? "#define " + $ : "",
        o.envMap ? "#define " + _e : "",
        et ? "#define CUBEUV_TEXEL_WIDTH " + et.texelWidth : "",
        et ? "#define CUBEUV_TEXEL_HEIGHT " + et.texelHeight : "",
        et ? "#define CUBEUV_MAX_MIP " + et.maxMip + ".0" : "",
        o.lightMap ? "#define USE_LIGHTMAP" : "",
        o.aoMap ? "#define USE_AOMAP" : "",
        o.bumpMap ? "#define USE_BUMPMAP" : "",
        o.normalMap ? "#define USE_NORMALMAP" : "",
        o.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "",
        o.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "",
        o.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
        o.anisotropy ? "#define USE_ANISOTROPY" : "",
        o.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "",
        o.clearcoat ? "#define USE_CLEARCOAT" : "",
        o.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
        o.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
        o.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
        o.dispersion ? "#define USE_DISPERSION" : "",
        o.iridescence ? "#define USE_IRIDESCENCE" : "",
        o.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "",
        o.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "",
        o.specularMap ? "#define USE_SPECULARMAP" : "",
        o.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "",
        o.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "",
        o.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
        o.metalnessMap ? "#define USE_METALNESSMAP" : "",
        o.alphaMap ? "#define USE_ALPHAMAP" : "",
        o.alphaTest ? "#define USE_ALPHATEST" : "",
        o.alphaHash ? "#define USE_ALPHAHASH" : "",
        o.sheen ? "#define USE_SHEEN" : "",
        o.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "",
        o.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "",
        o.transmission ? "#define USE_TRANSMISSION" : "",
        o.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
        o.thicknessMap ? "#define USE_THICKNESSMAP" : "",
        o.vertexTangents && o.flatShading === !1 ? "#define USE_TANGENT" : "",
        o.vertexColors || o.instancingColor || o.batchingColor
          ? "#define USE_COLOR"
          : "",
        o.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
        o.vertexUv1s ? "#define USE_UV1" : "",
        o.vertexUv2s ? "#define USE_UV2" : "",
        o.vertexUv3s ? "#define USE_UV3" : "",
        o.pointsUvs ? "#define USE_POINTS_UV" : "",
        o.gradientMap ? "#define USE_GRADIENTMAP" : "",
        o.flatShading ? "#define FLAT_SHADED" : "",
        o.doubleSided ? "#define DOUBLE_SIDED" : "",
        o.flipSided ? "#define FLIP_SIDED" : "",
        o.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
        o.shadowMapEnabled ? "#define " + b : "",
        o.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "",
        o.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "",
        o.decodeVideoTexture ? "#define DECODE_VIDEO_TEXTURE" : "",
        o.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
        "uniform mat4 viewMatrix;",
        "uniform vec3 cameraPosition;",
        "uniform bool isOrthographic;",
        o.toneMapping !== NoToneMapping ? "#define TONE_MAPPING" : "",
        o.toneMapping !== NoToneMapping
          ? ShaderChunk.tonemapping_pars_fragment
          : "",
        o.toneMapping !== NoToneMapping
          ? getToneMappingFunction("toneMapping", o.toneMapping)
          : "",
        o.dithering ? "#define DITHERING" : "",
        o.opaque ? "#define OPAQUE" : "",
        ShaderChunk.colorspace_pars_fragment,
        getTexelEncodingFunction("linearToOutputTexel", o.outputColorSpace),
        getLuminanceFunction(),
        o.useDepthPacking ? "#define DEPTH_PACKING " + o.depthPacking : "",
        `
`,
      ].filter(filterEmptyLine).join(`
`))),
    (g = resolveIncludes(g)),
    (g = replaceLightNums(g, o)),
    (g = replaceClippingPlaneNums(g, o)),
    (_ = resolveIncludes(_)),
    (_ = replaceLightNums(_, o)),
    (_ = replaceClippingPlaneNums(_, o)),
    (g = unrollLoops(g)),
    (_ = unrollLoops(_)),
    o.isRawShaderMaterial !== !0 &&
      ((lt = `#version 300 es
`),
      (ct =
        [
          rt,
          "#define attribute in",
          "#define varying out",
          "#define texture2D texture",
        ].join(`
`) +
        `
` +
        ct),
      (it =
        [
          "#define varying in",
          o.glslVersion === GLSL3
            ? ""
            : "layout(location = 0) out highp vec4 pc_fragColor;",
          o.glslVersion === GLSL3 ? "" : "#define gl_FragColor pc_fragColor",
          "#define gl_FragDepthEXT gl_FragDepth",
          "#define texture2D texture",
          "#define textureCube texture",
          "#define texture2DProj textureProj",
          "#define texture2DLodEXT textureLod",
          "#define texture2DProjLodEXT textureProjLod",
          "#define textureCubeLodEXT textureLod",
          "#define texture2DGradEXT textureGrad",
          "#define texture2DProjGradEXT textureProjGrad",
          "#define textureCubeGradEXT textureGrad",
        ].join(`
`) +
        `
` +
        it));
  const ot = lt + ct + g,
    ut = lt + it + _,
    pt = WebGLShader(c, c.VERTEX_SHADER, ot),
    ft = WebGLShader(c, c.FRAGMENT_SHADER, ut);
  c.attachShader(at, pt),
    c.attachShader(at, ft),
    o.index0AttributeName !== void 0
      ? c.bindAttribLocation(at, 0, o.index0AttributeName)
      : o.morphTargets === !0 && c.bindAttribLocation(at, 0, "position"),
    c.linkProgram(at);
  function gt(Mt) {
    if (s.debug.checkShaderErrors) {
      const Rt = c.getProgramInfoLog(at).trim(),
        Ft = c.getShaderInfoLog(pt).trim(),
        Ot = c.getShaderInfoLog(ft).trim();
      let Lt = !0,
        Et = !0;
      if (c.getProgramParameter(at, c.LINK_STATUS) === !1)
        if (((Lt = !1), typeof s.debug.onShaderError == "function"))
          s.debug.onShaderError(c, at, pt, ft);
        else {
          const bt = getShaderErrors(c, pt, "vertex"),
            mt = getShaderErrors(c, ft, "fragment");
          console.error(
            "THREE.WebGLProgram: Shader Error " +
              c.getError() +
              " - VALIDATE_STATUS " +
              c.getProgramParameter(at, c.VALIDATE_STATUS) +
              `

Material Name: ` +
              Mt.name +
              `
Material Type: ` +
              Mt.type +
              `

Program Info Log: ` +
              Rt +
              `
` +
              bt +
              `
` +
              mt
          );
        }
      else
        Rt !== ""
          ? console.warn("THREE.WebGLProgram: Program Info Log:", Rt)
          : (Ft === "" || Ot === "") && (Et = !1);
      Et &&
        (Mt.diagnostics = {
          runnable: Lt,
          programLog: Rt,
          vertexShader: { log: Ft, prefix: ct },
          fragmentShader: { log: Ot, prefix: it },
        });
    }
    c.deleteShader(pt),
      c.deleteShader(ft),
      (xt = new WebGLUniforms(c, at)),
      (_t = fetchAttributeLocations(c, at));
  }
  let xt;
  this.getUniforms = function () {
    return xt === void 0 && gt(this), xt;
  };
  let _t;
  this.getAttributes = function () {
    return _t === void 0 && gt(this), _t;
  };
  let St = o.rendererExtensionParallelShaderCompile === !1;
  return (
    (this.isReady = function () {
      return (
        St === !1 && (St = c.getProgramParameter(at, COMPLETION_STATUS_KHR)), St
      );
    }),
    (this.destroy = function () {
      a.releaseStatesOfProgram(this),
        c.deleteProgram(at),
        (this.program = void 0);
    }),
    (this.type = o.shaderType),
    (this.name = o.shaderName),
    (this.id = programIdCount++),
    (this.cacheKey = e),
    (this.usedTimes = 1),
    (this.program = at),
    (this.vertexShader = pt),
    (this.fragmentShader = ft),
    this
  );
}
let _id$1 = 0;
class WebGLShaderCache {
  constructor() {
    (this.shaderCache = new Map()), (this.materialCache = new Map());
  }
  update(e) {
    const o = e.vertexShader,
      a = e.fragmentShader,
      c = this._getShaderStage(o),
      d = this._getShaderStage(a),
      g = this._getShaderCacheForMaterial(e);
    return (
      g.has(c) === !1 && (g.add(c), c.usedTimes++),
      g.has(d) === !1 && (g.add(d), d.usedTimes++),
      this
    );
  }
  remove(e) {
    const o = this.materialCache.get(e);
    for (const a of o)
      a.usedTimes--, a.usedTimes === 0 && this.shaderCache.delete(a.code);
    return this.materialCache.delete(e), this;
  }
  getVertexShaderID(e) {
    return this._getShaderStage(e.vertexShader).id;
  }
  getFragmentShaderID(e) {
    return this._getShaderStage(e.fragmentShader).id;
  }
  dispose() {
    this.shaderCache.clear(), this.materialCache.clear();
  }
  _getShaderCacheForMaterial(e) {
    const o = this.materialCache;
    let a = o.get(e);
    return a === void 0 && ((a = new Set()), o.set(e, a)), a;
  }
  _getShaderStage(e) {
    const o = this.shaderCache;
    let a = o.get(e);
    return a === void 0 && ((a = new WebGLShaderStage(e)), o.set(e, a)), a;
  }
}
class WebGLShaderStage {
  constructor(e) {
    (this.id = _id$1++), (this.code = e), (this.usedTimes = 0);
  }
}
function WebGLPrograms(s, e, o, a, c, d, g) {
  const _ = new Layers(),
    b = new WebGLShaderCache(),
    j = new Set(),
    $ = [],
    _e = c.logarithmicDepthBuffer,
    et = c.vertexTextures;
  let rt = c.precision;
  const st = {
    MeshDepthMaterial: "depth",
    MeshDistanceMaterial: "distanceRGBA",
    MeshNormalMaterial: "normal",
    MeshBasicMaterial: "basic",
    MeshLambertMaterial: "lambert",
    MeshPhongMaterial: "phong",
    MeshToonMaterial: "toon",
    MeshStandardMaterial: "physical",
    MeshPhysicalMaterial: "physical",
    MeshMatcapMaterial: "matcap",
    LineBasicMaterial: "basic",
    LineDashedMaterial: "dashed",
    PointsMaterial: "points",
    ShadowMaterial: "shadow",
    SpriteMaterial: "sprite",
  };
  function at(_t) {
    return j.add(_t), _t === 0 ? "uv" : `uv${_t}`;
  }
  function ct(_t, St, Mt, Rt, Ft) {
    const Ot = Rt.fog,
      Lt = Ft.geometry,
      Et = _t.isMeshStandardMaterial ? Rt.environment : null,
      bt = (_t.isMeshStandardMaterial ? o : e).get(_t.envMap || Et),
      mt =
        bt && bt.mapping === CubeUVReflectionMapping ? bt.image.height : null,
      vt = st[_t.type];
    _t.precision !== null &&
      ((rt = c.getMaxPrecision(_t.precision)),
      rt !== _t.precision &&
        console.warn(
          "THREE.WebGLProgram.getParameters:",
          _t.precision,
          "not supported, using",
          rt,
          "instead."
        ));
    const Ct =
        Lt.morphAttributes.position ||
        Lt.morphAttributes.normal ||
        Lt.morphAttributes.color,
      Tt = Ct !== void 0 ? Ct.length : 0;
    let Dt = 0;
    Lt.morphAttributes.position !== void 0 && (Dt = 1),
      Lt.morphAttributes.normal !== void 0 && (Dt = 2),
      Lt.morphAttributes.color !== void 0 && (Dt = 3);
    let Wt, Pt, Jt, Gt;
    if (vt) {
      const tr = ShaderLib[vt];
      (Wt = tr.vertexShader), (Pt = tr.fragmentShader);
    } else
      (Wt = _t.vertexShader),
        (Pt = _t.fragmentShader),
        b.update(_t),
        (Jt = b.getVertexShaderID(_t)),
        (Gt = b.getFragmentShaderID(_t));
    const en = s.getRenderTarget(),
      _n = Ft.isInstancedMesh === !0,
      Tn = Ft.isBatchedMesh === !0,
      fn = !!_t.map,
      pn = !!_t.matcap,
      Bt = !!bt,
      qt = !!_t.aoMap,
      $t = !!_t.lightMap,
      yn = !!_t.bumpMap,
      nn = !!_t.normalMap,
      Pn = !!_t.displacementMap,
      xn = !!_t.emissiveMap,
      An = !!_t.metalnessMap,
      kt = !!_t.roughnessMap,
      wt = _t.anisotropy > 0,
      Kt = _t.clearcoat > 0,
      on = _t.dispersion > 0,
      sn = _t.iridescence > 0,
      cn = _t.sheen > 0,
      bn = _t.transmission > 0,
      vn = wt && !!_t.anisotropyMap,
      wn = Kt && !!_t.clearcoatMap,
      zn = Kt && !!_t.clearcoatNormalMap,
      gn = Kt && !!_t.clearcoatRoughnessMap,
      Rn = sn && !!_t.iridescenceMap,
      qn = sn && !!_t.iridescenceThicknessMap,
      Wn = cn && !!_t.sheenColorMap,
      kn = cn && !!_t.sheenRoughnessMap,
      Vt = !!_t.specularMap,
      un = !!_t.specularColorMap,
      In = !!_t.specularIntensityMap,
      Ut = bn && !!_t.transmissionMap,
      dn = bn && !!_t.thicknessMap,
      an = !!_t.gradientMap,
      hn = !!_t.alphaMap,
      Mn = _t.alphaTest > 0,
      $n = !!_t.alphaHash,
      Yn = !!_t.extensions;
    let rr = NoToneMapping;
    _t.toneMapped &&
      (en === null || en.isXRRenderTarget === !0) &&
      (rr = s.toneMapping);
    const pr = {
      shaderID: vt,
      shaderType: _t.type,
      shaderName: _t.name,
      vertexShader: Wt,
      fragmentShader: Pt,
      defines: _t.defines,
      customVertexShaderID: Jt,
      customFragmentShaderID: Gt,
      isRawShaderMaterial: _t.isRawShaderMaterial === !0,
      glslVersion: _t.glslVersion,
      precision: rt,
      batching: Tn,
      batchingColor: Tn && Ft._colorsTexture !== null,
      instancing: _n,
      instancingColor: _n && Ft.instanceColor !== null,
      instancingMorph: _n && Ft.morphTexture !== null,
      supportsVertexTextures: et,
      outputColorSpace:
        en === null
          ? s.outputColorSpace
          : en.isXRRenderTarget === !0
          ? en.texture.colorSpace
          : LinearSRGBColorSpace$1,
      alphaToCoverage: !!_t.alphaToCoverage,
      map: fn,
      matcap: pn,
      envMap: Bt,
      envMapMode: Bt && bt.mapping,
      envMapCubeUVHeight: mt,
      aoMap: qt,
      lightMap: $t,
      bumpMap: yn,
      normalMap: nn,
      displacementMap: et && Pn,
      emissiveMap: xn,
      normalMapObjectSpace: nn && _t.normalMapType === ObjectSpaceNormalMap,
      normalMapTangentSpace: nn && _t.normalMapType === TangentSpaceNormalMap,
      metalnessMap: An,
      roughnessMap: kt,
      anisotropy: wt,
      anisotropyMap: vn,
      clearcoat: Kt,
      clearcoatMap: wn,
      clearcoatNormalMap: zn,
      clearcoatRoughnessMap: gn,
      dispersion: on,
      iridescence: sn,
      iridescenceMap: Rn,
      iridescenceThicknessMap: qn,
      sheen: cn,
      sheenColorMap: Wn,
      sheenRoughnessMap: kn,
      specularMap: Vt,
      specularColorMap: un,
      specularIntensityMap: In,
      transmission: bn,
      transmissionMap: Ut,
      thicknessMap: dn,
      gradientMap: an,
      opaque:
        _t.transparent === !1 &&
        _t.blending === NormalBlending &&
        _t.alphaToCoverage === !1,
      alphaMap: hn,
      alphaTest: Mn,
      alphaHash: $n,
      combine: _t.combine,
      mapUv: fn && at(_t.map.channel),
      aoMapUv: qt && at(_t.aoMap.channel),
      lightMapUv: $t && at(_t.lightMap.channel),
      bumpMapUv: yn && at(_t.bumpMap.channel),
      normalMapUv: nn && at(_t.normalMap.channel),
      displacementMapUv: Pn && at(_t.displacementMap.channel),
      emissiveMapUv: xn && at(_t.emissiveMap.channel),
      metalnessMapUv: An && at(_t.metalnessMap.channel),
      roughnessMapUv: kt && at(_t.roughnessMap.channel),
      anisotropyMapUv: vn && at(_t.anisotropyMap.channel),
      clearcoatMapUv: wn && at(_t.clearcoatMap.channel),
      clearcoatNormalMapUv: zn && at(_t.clearcoatNormalMap.channel),
      clearcoatRoughnessMapUv: gn && at(_t.clearcoatRoughnessMap.channel),
      iridescenceMapUv: Rn && at(_t.iridescenceMap.channel),
      iridescenceThicknessMapUv: qn && at(_t.iridescenceThicknessMap.channel),
      sheenColorMapUv: Wn && at(_t.sheenColorMap.channel),
      sheenRoughnessMapUv: kn && at(_t.sheenRoughnessMap.channel),
      specularMapUv: Vt && at(_t.specularMap.channel),
      specularColorMapUv: un && at(_t.specularColorMap.channel),
      specularIntensityMapUv: In && at(_t.specularIntensityMap.channel),
      transmissionMapUv: Ut && at(_t.transmissionMap.channel),
      thicknessMapUv: dn && at(_t.thicknessMap.channel),
      alphaMapUv: hn && at(_t.alphaMap.channel),
      vertexTangents: !!Lt.attributes.tangent && (nn || wt),
      vertexColors: _t.vertexColors,
      vertexAlphas:
        _t.vertexColors === !0 &&
        !!Lt.attributes.color &&
        Lt.attributes.color.itemSize === 4,
      pointsUvs: Ft.isPoints === !0 && !!Lt.attributes.uv && (fn || hn),
      fog: !!Ot,
      useFog: _t.fog === !0,
      fogExp2: !!Ot && Ot.isFogExp2,
      flatShading: _t.flatShading === !0,
      sizeAttenuation: _t.sizeAttenuation === !0,
      logarithmicDepthBuffer: _e,
      skinning: Ft.isSkinnedMesh === !0,
      morphTargets: Lt.morphAttributes.position !== void 0,
      morphNormals: Lt.morphAttributes.normal !== void 0,
      morphColors: Lt.morphAttributes.color !== void 0,
      morphTargetsCount: Tt,
      morphTextureStride: Dt,
      numDirLights: St.directional.length,
      numPointLights: St.point.length,
      numSpotLights: St.spot.length,
      numSpotLightMaps: St.spotLightMap.length,
      numRectAreaLights: St.rectArea.length,
      numHemiLights: St.hemi.length,
      numDirLightShadows: St.directionalShadowMap.length,
      numPointLightShadows: St.pointShadowMap.length,
      numSpotLightShadows: St.spotShadowMap.length,
      numSpotLightShadowsWithMaps: St.numSpotLightShadowsWithMaps,
      numLightProbes: St.numLightProbes,
      numClippingPlanes: g.numPlanes,
      numClipIntersection: g.numIntersection,
      dithering: _t.dithering,
      shadowMapEnabled: s.shadowMap.enabled && Mt.length > 0,
      shadowMapType: s.shadowMap.type,
      toneMapping: rr,
      decodeVideoTexture:
        fn &&
        _t.map.isVideoTexture === !0 &&
        ColorManagement.getTransfer(_t.map.colorSpace) === SRGBTransfer,
      premultipliedAlpha: _t.premultipliedAlpha,
      doubleSided: _t.side === DoubleSide,
      flipSided: _t.side === BackSide,
      useDepthPacking: _t.depthPacking >= 0,
      depthPacking: _t.depthPacking || 0,
      index0AttributeName: _t.index0AttributeName,
      extensionClipCullDistance:
        Yn &&
        _t.extensions.clipCullDistance === !0 &&
        a.has("WEBGL_clip_cull_distance"),
      extensionMultiDraw:
        ((Yn && _t.extensions.multiDraw === !0) || Tn) &&
        a.has("WEBGL_multi_draw"),
      rendererExtensionParallelShaderCompile: a.has(
        "KHR_parallel_shader_compile"
      ),
      customProgramCacheKey: _t.customProgramCacheKey(),
    };
    return (
      (pr.vertexUv1s = j.has(1)),
      (pr.vertexUv2s = j.has(2)),
      (pr.vertexUv3s = j.has(3)),
      j.clear(),
      pr
    );
  }
  function it(_t) {
    const St = [];
    if (
      (_t.shaderID
        ? St.push(_t.shaderID)
        : (St.push(_t.customVertexShaderID),
          St.push(_t.customFragmentShaderID)),
      _t.defines !== void 0)
    )
      for (const Mt in _t.defines) St.push(Mt), St.push(_t.defines[Mt]);
    return (
      _t.isRawShaderMaterial === !1 &&
        (lt(St, _t), ot(St, _t), St.push(s.outputColorSpace)),
      St.push(_t.customProgramCacheKey),
      St.join()
    );
  }
  function lt(_t, St) {
    _t.push(St.precision),
      _t.push(St.outputColorSpace),
      _t.push(St.envMapMode),
      _t.push(St.envMapCubeUVHeight),
      _t.push(St.mapUv),
      _t.push(St.alphaMapUv),
      _t.push(St.lightMapUv),
      _t.push(St.aoMapUv),
      _t.push(St.bumpMapUv),
      _t.push(St.normalMapUv),
      _t.push(St.displacementMapUv),
      _t.push(St.emissiveMapUv),
      _t.push(St.metalnessMapUv),
      _t.push(St.roughnessMapUv),
      _t.push(St.anisotropyMapUv),
      _t.push(St.clearcoatMapUv),
      _t.push(St.clearcoatNormalMapUv),
      _t.push(St.clearcoatRoughnessMapUv),
      _t.push(St.iridescenceMapUv),
      _t.push(St.iridescenceThicknessMapUv),
      _t.push(St.sheenColorMapUv),
      _t.push(St.sheenRoughnessMapUv),
      _t.push(St.specularMapUv),
      _t.push(St.specularColorMapUv),
      _t.push(St.specularIntensityMapUv),
      _t.push(St.transmissionMapUv),
      _t.push(St.thicknessMapUv),
      _t.push(St.combine),
      _t.push(St.fogExp2),
      _t.push(St.sizeAttenuation),
      _t.push(St.morphTargetsCount),
      _t.push(St.morphAttributeCount),
      _t.push(St.numDirLights),
      _t.push(St.numPointLights),
      _t.push(St.numSpotLights),
      _t.push(St.numSpotLightMaps),
      _t.push(St.numHemiLights),
      _t.push(St.numRectAreaLights),
      _t.push(St.numDirLightShadows),
      _t.push(St.numPointLightShadows),
      _t.push(St.numSpotLightShadows),
      _t.push(St.numSpotLightShadowsWithMaps),
      _t.push(St.numLightProbes),
      _t.push(St.shadowMapType),
      _t.push(St.toneMapping),
      _t.push(St.numClippingPlanes),
      _t.push(St.numClipIntersection),
      _t.push(St.depthPacking);
  }
  function ot(_t, St) {
    _.disableAll(),
      St.supportsVertexTextures && _.enable(0),
      St.instancing && _.enable(1),
      St.instancingColor && _.enable(2),
      St.instancingMorph && _.enable(3),
      St.matcap && _.enable(4),
      St.envMap && _.enable(5),
      St.normalMapObjectSpace && _.enable(6),
      St.normalMapTangentSpace && _.enable(7),
      St.clearcoat && _.enable(8),
      St.iridescence && _.enable(9),
      St.alphaTest && _.enable(10),
      St.vertexColors && _.enable(11),
      St.vertexAlphas && _.enable(12),
      St.vertexUv1s && _.enable(13),
      St.vertexUv2s && _.enable(14),
      St.vertexUv3s && _.enable(15),
      St.vertexTangents && _.enable(16),
      St.anisotropy && _.enable(17),
      St.alphaHash && _.enable(18),
      St.batching && _.enable(19),
      St.dispersion && _.enable(20),
      St.batchingColor && _.enable(21),
      _t.push(_.mask),
      _.disableAll(),
      St.fog && _.enable(0),
      St.useFog && _.enable(1),
      St.flatShading && _.enable(2),
      St.logarithmicDepthBuffer && _.enable(3),
      St.skinning && _.enable(4),
      St.morphTargets && _.enable(5),
      St.morphNormals && _.enable(6),
      St.morphColors && _.enable(7),
      St.premultipliedAlpha && _.enable(8),
      St.shadowMapEnabled && _.enable(9),
      St.doubleSided && _.enable(10),
      St.flipSided && _.enable(11),
      St.useDepthPacking && _.enable(12),
      St.dithering && _.enable(13),
      St.transmission && _.enable(14),
      St.sheen && _.enable(15),
      St.opaque && _.enable(16),
      St.pointsUvs && _.enable(17),
      St.decodeVideoTexture && _.enable(18),
      St.alphaToCoverage && _.enable(19),
      _t.push(_.mask);
  }
  function ut(_t) {
    const St = st[_t.type];
    let Mt;
    if (St) {
      const Rt = ShaderLib[St];
      Mt = UniformsUtils.clone(Rt.uniforms);
    } else Mt = _t.uniforms;
    return Mt;
  }
  function pt(_t, St) {
    let Mt;
    for (let Rt = 0, Ft = $.length; Rt < Ft; Rt++) {
      const Ot = $[Rt];
      if (Ot.cacheKey === St) {
        (Mt = Ot), ++Mt.usedTimes;
        break;
      }
    }
    return (
      Mt === void 0 && ((Mt = new WebGLProgram(s, St, _t, d)), $.push(Mt)), Mt
    );
  }
  function ft(_t) {
    if (--_t.usedTimes === 0) {
      const St = $.indexOf(_t);
      ($[St] = $[$.length - 1]), $.pop(), _t.destroy();
    }
  }
  function gt(_t) {
    b.remove(_t);
  }
  function xt() {
    b.dispose();
  }
  return {
    getParameters: ct,
    getProgramCacheKey: it,
    getUniforms: ut,
    acquireProgram: pt,
    releaseProgram: ft,
    releaseShaderCache: gt,
    programs: $,
    dispose: xt,
  };
}
function WebGLProperties() {
  let s = new WeakMap();
  function e(d) {
    let g = s.get(d);
    return g === void 0 && ((g = {}), s.set(d, g)), g;
  }
  function o(d) {
    s.delete(d);
  }
  function a(d, g, _) {
    s.get(d)[g] = _;
  }
  function c() {
    s = new WeakMap();
  }
  return { get: e, remove: o, update: a, dispose: c };
}
function painterSortStable(s, e) {
  return s.groupOrder !== e.groupOrder
    ? s.groupOrder - e.groupOrder
    : s.renderOrder !== e.renderOrder
    ? s.renderOrder - e.renderOrder
    : s.material.id !== e.material.id
    ? s.material.id - e.material.id
    : s.z !== e.z
    ? s.z - e.z
    : s.id - e.id;
}
function reversePainterSortStable(s, e) {
  return s.groupOrder !== e.groupOrder
    ? s.groupOrder - e.groupOrder
    : s.renderOrder !== e.renderOrder
    ? s.renderOrder - e.renderOrder
    : s.z !== e.z
    ? e.z - s.z
    : s.id - e.id;
}
function WebGLRenderList() {
  const s = [];
  let e = 0;
  const o = [],
    a = [],
    c = [];
  function d() {
    (e = 0), (o.length = 0), (a.length = 0), (c.length = 0);
  }
  function g(_e, et, rt, st, at, ct) {
    let it = s[e];
    return (
      it === void 0
        ? ((it = {
            id: _e.id,
            object: _e,
            geometry: et,
            material: rt,
            groupOrder: st,
            renderOrder: _e.renderOrder,
            z: at,
            group: ct,
          }),
          (s[e] = it))
        : ((it.id = _e.id),
          (it.object = _e),
          (it.geometry = et),
          (it.material = rt),
          (it.groupOrder = st),
          (it.renderOrder = _e.renderOrder),
          (it.z = at),
          (it.group = ct)),
      e++,
      it
    );
  }
  function _(_e, et, rt, st, at, ct) {
    const it = g(_e, et, rt, st, at, ct);
    rt.transmission > 0
      ? a.push(it)
      : rt.transparent === !0
      ? c.push(it)
      : o.push(it);
  }
  function b(_e, et, rt, st, at, ct) {
    const it = g(_e, et, rt, st, at, ct);
    rt.transmission > 0
      ? a.unshift(it)
      : rt.transparent === !0
      ? c.unshift(it)
      : o.unshift(it);
  }
  function j(_e, et) {
    o.length > 1 && o.sort(_e || painterSortStable),
      a.length > 1 && a.sort(et || reversePainterSortStable),
      c.length > 1 && c.sort(et || reversePainterSortStable);
  }
  function $() {
    for (let _e = e, et = s.length; _e < et; _e++) {
      const rt = s[_e];
      if (rt.id === null) break;
      (rt.id = null),
        (rt.object = null),
        (rt.geometry = null),
        (rt.material = null),
        (rt.group = null);
    }
  }
  return {
    opaque: o,
    transmissive: a,
    transparent: c,
    init: d,
    push: _,
    unshift: b,
    finish: $,
    sort: j,
  };
}
function WebGLRenderLists() {
  let s = new WeakMap();
  function e(a, c) {
    const d = s.get(a);
    let g;
    return (
      d === void 0
        ? ((g = new WebGLRenderList()), s.set(a, [g]))
        : c >= d.length
        ? ((g = new WebGLRenderList()), d.push(g))
        : (g = d[c]),
      g
    );
  }
  function o() {
    s = new WeakMap();
  }
  return { get: e, dispose: o };
}
function UniformsCache() {
  const s = {};
  return {
    get: function (e) {
      if (s[e.id] !== void 0) return s[e.id];
      let o;
      switch (e.type) {
        case "DirectionalLight":
          o = { direction: new Vector3(), color: new Color() };
          break;
        case "SpotLight":
          o = {
            position: new Vector3(),
            direction: new Vector3(),
            color: new Color(),
            distance: 0,
            coneCos: 0,
            penumbraCos: 0,
            decay: 0,
          };
          break;
        case "PointLight":
          o = {
            position: new Vector3(),
            color: new Color(),
            distance: 0,
            decay: 0,
          };
          break;
        case "HemisphereLight":
          o = {
            direction: new Vector3(),
            skyColor: new Color(),
            groundColor: new Color(),
          };
          break;
        case "RectAreaLight":
          o = {
            color: new Color(),
            position: new Vector3(),
            halfWidth: new Vector3(),
            halfHeight: new Vector3(),
          };
          break;
      }
      return (s[e.id] = o), o;
    },
  };
}
function ShadowUniformsCache() {
  const s = {};
  return {
    get: function (e) {
      if (s[e.id] !== void 0) return s[e.id];
      let o;
      switch (e.type) {
        case "DirectionalLight":
          o = {
            shadowIntensity: 1,
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new Vector2(),
          };
          break;
        case "SpotLight":
          o = {
            shadowIntensity: 1,
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new Vector2(),
          };
          break;
        case "PointLight":
          o = {
            shadowIntensity: 1,
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new Vector2(),
            shadowCameraNear: 1,
            shadowCameraFar: 1e3,
          };
          break;
      }
      return (s[e.id] = o), o;
    },
  };
}
let nextVersion = 0;
function shadowCastingAndTexturingLightsFirst(s, e) {
  return (
    (e.castShadow ? 2 : 0) -
    (s.castShadow ? 2 : 0) +
    (e.map ? 1 : 0) -
    (s.map ? 1 : 0)
  );
}
function WebGLLights(s) {
  const e = new UniformsCache(),
    o = ShadowUniformsCache(),
    a = {
      version: 0,
      hash: {
        directionalLength: -1,
        pointLength: -1,
        spotLength: -1,
        rectAreaLength: -1,
        hemiLength: -1,
        numDirectionalShadows: -1,
        numPointShadows: -1,
        numSpotShadows: -1,
        numSpotMaps: -1,
        numLightProbes: -1,
      },
      ambient: [0, 0, 0],
      probe: [],
      directional: [],
      directionalShadow: [],
      directionalShadowMap: [],
      directionalShadowMatrix: [],
      spot: [],
      spotLightMap: [],
      spotShadow: [],
      spotShadowMap: [],
      spotLightMatrix: [],
      rectArea: [],
      rectAreaLTC1: null,
      rectAreaLTC2: null,
      point: [],
      pointShadow: [],
      pointShadowMap: [],
      pointShadowMatrix: [],
      hemi: [],
      numSpotLightShadowsWithMaps: 0,
      numLightProbes: 0,
    };
  for (let j = 0; j < 9; j++) a.probe.push(new Vector3());
  const c = new Vector3(),
    d = new Matrix4(),
    g = new Matrix4();
  function _(j) {
    let $ = 0,
      _e = 0,
      et = 0;
    for (let _t = 0; _t < 9; _t++) a.probe[_t].set(0, 0, 0);
    let rt = 0,
      st = 0,
      at = 0,
      ct = 0,
      it = 0,
      lt = 0,
      ot = 0,
      ut = 0,
      pt = 0,
      ft = 0,
      gt = 0;
    j.sort(shadowCastingAndTexturingLightsFirst);
    for (let _t = 0, St = j.length; _t < St; _t++) {
      const Mt = j[_t],
        Rt = Mt.color,
        Ft = Mt.intensity,
        Ot = Mt.distance,
        Lt = Mt.shadow && Mt.shadow.map ? Mt.shadow.map.texture : null;
      if (Mt.isAmbientLight)
        ($ += Rt.r * Ft), (_e += Rt.g * Ft), (et += Rt.b * Ft);
      else if (Mt.isLightProbe) {
        for (let Et = 0; Et < 9; Et++)
          a.probe[Et].addScaledVector(Mt.sh.coefficients[Et], Ft);
        gt++;
      } else if (Mt.isDirectionalLight) {
        const Et = e.get(Mt);
        if (
          (Et.color.copy(Mt.color).multiplyScalar(Mt.intensity), Mt.castShadow)
        ) {
          const bt = Mt.shadow,
            mt = o.get(Mt);
          (mt.shadowIntensity = bt.intensity),
            (mt.shadowBias = bt.bias),
            (mt.shadowNormalBias = bt.normalBias),
            (mt.shadowRadius = bt.radius),
            (mt.shadowMapSize = bt.mapSize),
            (a.directionalShadow[rt] = mt),
            (a.directionalShadowMap[rt] = Lt),
            (a.directionalShadowMatrix[rt] = Mt.shadow.matrix),
            lt++;
        }
        (a.directional[rt] = Et), rt++;
      } else if (Mt.isSpotLight) {
        const Et = e.get(Mt);
        Et.position.setFromMatrixPosition(Mt.matrixWorld),
          Et.color.copy(Rt).multiplyScalar(Ft),
          (Et.distance = Ot),
          (Et.coneCos = Math.cos(Mt.angle)),
          (Et.penumbraCos = Math.cos(Mt.angle * (1 - Mt.penumbra))),
          (Et.decay = Mt.decay),
          (a.spot[at] = Et);
        const bt = Mt.shadow;
        if (
          (Mt.map &&
            ((a.spotLightMap[pt] = Mt.map),
            pt++,
            bt.updateMatrices(Mt),
            Mt.castShadow && ft++),
          (a.spotLightMatrix[at] = bt.matrix),
          Mt.castShadow)
        ) {
          const mt = o.get(Mt);
          (mt.shadowIntensity = bt.intensity),
            (mt.shadowBias = bt.bias),
            (mt.shadowNormalBias = bt.normalBias),
            (mt.shadowRadius = bt.radius),
            (mt.shadowMapSize = bt.mapSize),
            (a.spotShadow[at] = mt),
            (a.spotShadowMap[at] = Lt),
            ut++;
        }
        at++;
      } else if (Mt.isRectAreaLight) {
        const Et = e.get(Mt);
        Et.color.copy(Rt).multiplyScalar(Ft),
          Et.halfWidth.set(Mt.width * 0.5, 0, 0),
          Et.halfHeight.set(0, Mt.height * 0.5, 0),
          (a.rectArea[ct] = Et),
          ct++;
      } else if (Mt.isPointLight) {
        const Et = e.get(Mt);
        if (
          (Et.color.copy(Mt.color).multiplyScalar(Mt.intensity),
          (Et.distance = Mt.distance),
          (Et.decay = Mt.decay),
          Mt.castShadow)
        ) {
          const bt = Mt.shadow,
            mt = o.get(Mt);
          (mt.shadowIntensity = bt.intensity),
            (mt.shadowBias = bt.bias),
            (mt.shadowNormalBias = bt.normalBias),
            (mt.shadowRadius = bt.radius),
            (mt.shadowMapSize = bt.mapSize),
            (mt.shadowCameraNear = bt.camera.near),
            (mt.shadowCameraFar = bt.camera.far),
            (a.pointShadow[st] = mt),
            (a.pointShadowMap[st] = Lt),
            (a.pointShadowMatrix[st] = Mt.shadow.matrix),
            ot++;
        }
        (a.point[st] = Et), st++;
      } else if (Mt.isHemisphereLight) {
        const Et = e.get(Mt);
        Et.skyColor.copy(Mt.color).multiplyScalar(Ft),
          Et.groundColor.copy(Mt.groundColor).multiplyScalar(Ft),
          (a.hemi[it] = Et),
          it++;
      }
    }
    ct > 0 &&
      (s.has("OES_texture_float_linear") === !0
        ? ((a.rectAreaLTC1 = UniformsLib.LTC_FLOAT_1),
          (a.rectAreaLTC2 = UniformsLib.LTC_FLOAT_2))
        : ((a.rectAreaLTC1 = UniformsLib.LTC_HALF_1),
          (a.rectAreaLTC2 = UniformsLib.LTC_HALF_2))),
      (a.ambient[0] = $),
      (a.ambient[1] = _e),
      (a.ambient[2] = et);
    const xt = a.hash;
    (xt.directionalLength !== rt ||
      xt.pointLength !== st ||
      xt.spotLength !== at ||
      xt.rectAreaLength !== ct ||
      xt.hemiLength !== it ||
      xt.numDirectionalShadows !== lt ||
      xt.numPointShadows !== ot ||
      xt.numSpotShadows !== ut ||
      xt.numSpotMaps !== pt ||
      xt.numLightProbes !== gt) &&
      ((a.directional.length = rt),
      (a.spot.length = at),
      (a.rectArea.length = ct),
      (a.point.length = st),
      (a.hemi.length = it),
      (a.directionalShadow.length = lt),
      (a.directionalShadowMap.length = lt),
      (a.pointShadow.length = ot),
      (a.pointShadowMap.length = ot),
      (a.spotShadow.length = ut),
      (a.spotShadowMap.length = ut),
      (a.directionalShadowMatrix.length = lt),
      (a.pointShadowMatrix.length = ot),
      (a.spotLightMatrix.length = ut + pt - ft),
      (a.spotLightMap.length = pt),
      (a.numSpotLightShadowsWithMaps = ft),
      (a.numLightProbes = gt),
      (xt.directionalLength = rt),
      (xt.pointLength = st),
      (xt.spotLength = at),
      (xt.rectAreaLength = ct),
      (xt.hemiLength = it),
      (xt.numDirectionalShadows = lt),
      (xt.numPointShadows = ot),
      (xt.numSpotShadows = ut),
      (xt.numSpotMaps = pt),
      (xt.numLightProbes = gt),
      (a.version = nextVersion++));
  }
  function b(j, $) {
    let _e = 0,
      et = 0,
      rt = 0,
      st = 0,
      at = 0;
    const ct = $.matrixWorldInverse;
    for (let it = 0, lt = j.length; it < lt; it++) {
      const ot = j[it];
      if (ot.isDirectionalLight) {
        const ut = a.directional[_e];
        ut.direction.setFromMatrixPosition(ot.matrixWorld),
          c.setFromMatrixPosition(ot.target.matrixWorld),
          ut.direction.sub(c),
          ut.direction.transformDirection(ct),
          _e++;
      } else if (ot.isSpotLight) {
        const ut = a.spot[rt];
        ut.position.setFromMatrixPosition(ot.matrixWorld),
          ut.position.applyMatrix4(ct),
          ut.direction.setFromMatrixPosition(ot.matrixWorld),
          c.setFromMatrixPosition(ot.target.matrixWorld),
          ut.direction.sub(c),
          ut.direction.transformDirection(ct),
          rt++;
      } else if (ot.isRectAreaLight) {
        const ut = a.rectArea[st];
        ut.position.setFromMatrixPosition(ot.matrixWorld),
          ut.position.applyMatrix4(ct),
          g.identity(),
          d.copy(ot.matrixWorld),
          d.premultiply(ct),
          g.extractRotation(d),
          ut.halfWidth.set(ot.width * 0.5, 0, 0),
          ut.halfHeight.set(0, ot.height * 0.5, 0),
          ut.halfWidth.applyMatrix4(g),
          ut.halfHeight.applyMatrix4(g),
          st++;
      } else if (ot.isPointLight) {
        const ut = a.point[et];
        ut.position.setFromMatrixPosition(ot.matrixWorld),
          ut.position.applyMatrix4(ct),
          et++;
      } else if (ot.isHemisphereLight) {
        const ut = a.hemi[at];
        ut.direction.setFromMatrixPosition(ot.matrixWorld),
          ut.direction.transformDirection(ct),
          at++;
      }
    }
  }
  return { setup: _, setupView: b, state: a };
}
function WebGLRenderState(s) {
  const e = new WebGLLights(s),
    o = [],
    a = [];
  function c($) {
    (j.camera = $), (o.length = 0), (a.length = 0);
  }
  function d($) {
    o.push($);
  }
  function g($) {
    a.push($);
  }
  function _() {
    e.setup(o);
  }
  function b($) {
    e.setupView(o, $);
  }
  const j = {
    lightsArray: o,
    shadowsArray: a,
    camera: null,
    lights: e,
    transmissionRenderTarget: {},
  };
  return {
    init: c,
    state: j,
    setupLights: _,
    setupLightsView: b,
    pushLight: d,
    pushShadow: g,
  };
}
function WebGLRenderStates(s) {
  let e = new WeakMap();
  function o(c, d = 0) {
    const g = e.get(c);
    let _;
    return (
      g === void 0
        ? ((_ = new WebGLRenderState(s)), e.set(c, [_]))
        : d >= g.length
        ? ((_ = new WebGLRenderState(s)), g.push(_))
        : (_ = g[d]),
      _
    );
  }
  function a() {
    e = new WeakMap();
  }
  return { get: o, dispose: a };
}
class MeshDepthMaterial extends Material {
  constructor(e) {
    super(),
      (this.isMeshDepthMaterial = !0),
      (this.type = "MeshDepthMaterial"),
      (this.depthPacking = BasicDepthPacking),
      (this.map = null),
      (this.alphaMap = null),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      (this.depthPacking = e.depthPacking),
      (this.map = e.map),
      (this.alphaMap = e.alphaMap),
      (this.displacementMap = e.displacementMap),
      (this.displacementScale = e.displacementScale),
      (this.displacementBias = e.displacementBias),
      (this.wireframe = e.wireframe),
      (this.wireframeLinewidth = e.wireframeLinewidth),
      this
    );
  }
}
class MeshDistanceMaterial extends Material {
  constructor(e) {
    super(),
      (this.isMeshDistanceMaterial = !0),
      (this.type = "MeshDistanceMaterial"),
      (this.map = null),
      (this.alphaMap = null),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      (this.map = e.map),
      (this.alphaMap = e.alphaMap),
      (this.displacementMap = e.displacementMap),
      (this.displacementScale = e.displacementScale),
      (this.displacementBias = e.displacementBias),
      this
    );
  }
}
const vertex = `void main() {
	gl_Position = vec4( position, 1.0 );
}`,
  fragment = `uniform sampler2D shadow_pass;
uniform vec2 resolution;
uniform float radius;
#include <packing>
void main() {
	const float samples = float( VSM_SAMPLES );
	float mean = 0.0;
	float squared_mean = 0.0;
	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );
	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;
	for ( float i = 0.0; i < samples; i ++ ) {
		float uvOffset = uvStart + i * uvStride;
		#ifdef HORIZONTAL_PASS
			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );
			mean += distribution.x;
			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;
		#else
			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );
			mean += depth;
			squared_mean += depth * depth;
		#endif
	}
	mean = mean / samples;
	squared_mean = squared_mean / samples;
	float std_dev = sqrt( squared_mean - mean * mean );
	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );
}`;
function WebGLShadowMap(s, e, o) {
  let a = new Frustum();
  const c = new Vector2(),
    d = new Vector2(),
    g = new Vector4(),
    _ = new MeshDepthMaterial({ depthPacking: RGBADepthPacking }),
    b = new MeshDistanceMaterial(),
    j = {},
    $ = o.maxTextureSize,
    _e = {
      [FrontSide]: BackSide,
      [BackSide]: FrontSide,
      [DoubleSide]: DoubleSide,
    },
    et = new ShaderMaterial({
      defines: { VSM_SAMPLES: 8 },
      uniforms: {
        shadow_pass: { value: null },
        resolution: { value: new Vector2() },
        radius: { value: 4 },
      },
      vertexShader: vertex,
      fragmentShader: fragment,
    }),
    rt = et.clone();
  rt.defines.HORIZONTAL_PASS = 1;
  const st = new BufferGeometry();
  st.setAttribute(
    "position",
    new BufferAttribute(
      new Float32Array([-1, -1, 0.5, 3, -1, 0.5, -1, 3, 0.5]),
      3
    )
  );
  const at = new Mesh(st, et),
    ct = this;
  (this.enabled = !1),
    (this.autoUpdate = !0),
    (this.needsUpdate = !1),
    (this.type = PCFShadowMap);
  let it = this.type;
  this.render = function (ft, gt, xt) {
    if (
      ct.enabled === !1 ||
      (ct.autoUpdate === !1 && ct.needsUpdate === !1) ||
      ft.length === 0
    )
      return;
    const _t = s.getRenderTarget(),
      St = s.getActiveCubeFace(),
      Mt = s.getActiveMipmapLevel(),
      Rt = s.state;
    Rt.setBlending(NoBlending),
      Rt.buffers.color.setClear(1, 1, 1, 1),
      Rt.buffers.depth.setTest(!0),
      Rt.setScissorTest(!1);
    const Ft = it !== VSMShadowMap && this.type === VSMShadowMap,
      Ot = it === VSMShadowMap && this.type !== VSMShadowMap;
    for (let Lt = 0, Et = ft.length; Lt < Et; Lt++) {
      const bt = ft[Lt],
        mt = bt.shadow;
      if (mt === void 0) {
        console.warn("THREE.WebGLShadowMap:", bt, "has no shadow.");
        continue;
      }
      if (mt.autoUpdate === !1 && mt.needsUpdate === !1) continue;
      c.copy(mt.mapSize);
      const vt = mt.getFrameExtents();
      if (
        (c.multiply(vt),
        d.copy(mt.mapSize),
        (c.x > $ || c.y > $) &&
          (c.x > $ &&
            ((d.x = Math.floor($ / vt.x)),
            (c.x = d.x * vt.x),
            (mt.mapSize.x = d.x)),
          c.y > $ &&
            ((d.y = Math.floor($ / vt.y)),
            (c.y = d.y * vt.y),
            (mt.mapSize.y = d.y))),
        mt.map === null || Ft === !0 || Ot === !0)
      ) {
        const Tt =
          this.type !== VSMShadowMap
            ? { minFilter: NearestFilter, magFilter: NearestFilter }
            : {};
        mt.map !== null && mt.map.dispose(),
          (mt.map = new WebGLRenderTarget(c.x, c.y, Tt)),
          (mt.map.texture.name = bt.name + ".shadowMap"),
          mt.camera.updateProjectionMatrix();
      }
      s.setRenderTarget(mt.map), s.clear();
      const Ct = mt.getViewportCount();
      for (let Tt = 0; Tt < Ct; Tt++) {
        const Dt = mt.getViewport(Tt);
        g.set(d.x * Dt.x, d.y * Dt.y, d.x * Dt.z, d.y * Dt.w),
          Rt.viewport(g),
          mt.updateMatrices(bt, Tt),
          (a = mt.getFrustum()),
          ut(gt, xt, mt.camera, bt, this.type);
      }
      mt.isPointLightShadow !== !0 && this.type === VSMShadowMap && lt(mt, xt),
        (mt.needsUpdate = !1);
    }
    (it = this.type), (ct.needsUpdate = !1), s.setRenderTarget(_t, St, Mt);
  };
  function lt(ft, gt) {
    const xt = e.update(at);
    et.defines.VSM_SAMPLES !== ft.blurSamples &&
      ((et.defines.VSM_SAMPLES = ft.blurSamples),
      (rt.defines.VSM_SAMPLES = ft.blurSamples),
      (et.needsUpdate = !0),
      (rt.needsUpdate = !0)),
      ft.mapPass === null && (ft.mapPass = new WebGLRenderTarget(c.x, c.y)),
      (et.uniforms.shadow_pass.value = ft.map.texture),
      (et.uniforms.resolution.value = ft.mapSize),
      (et.uniforms.radius.value = ft.radius),
      s.setRenderTarget(ft.mapPass),
      s.clear(),
      s.renderBufferDirect(gt, null, xt, et, at, null),
      (rt.uniforms.shadow_pass.value = ft.mapPass.texture),
      (rt.uniforms.resolution.value = ft.mapSize),
      (rt.uniforms.radius.value = ft.radius),
      s.setRenderTarget(ft.map),
      s.clear(),
      s.renderBufferDirect(gt, null, xt, rt, at, null);
  }
  function ot(ft, gt, xt, _t) {
    let St = null;
    const Mt =
      xt.isPointLight === !0
        ? ft.customDistanceMaterial
        : ft.customDepthMaterial;
    if (Mt !== void 0) St = Mt;
    else if (
      ((St = xt.isPointLight === !0 ? b : _),
      (s.localClippingEnabled &&
        gt.clipShadows === !0 &&
        Array.isArray(gt.clippingPlanes) &&
        gt.clippingPlanes.length !== 0) ||
        (gt.displacementMap && gt.displacementScale !== 0) ||
        (gt.alphaMap && gt.alphaTest > 0) ||
        (gt.map && gt.alphaTest > 0))
    ) {
      const Rt = St.uuid,
        Ft = gt.uuid;
      let Ot = j[Rt];
      Ot === void 0 && ((Ot = {}), (j[Rt] = Ot));
      let Lt = Ot[Ft];
      Lt === void 0 &&
        ((Lt = St.clone()), (Ot[Ft] = Lt), gt.addEventListener("dispose", pt)),
        (St = Lt);
    }
    if (
      ((St.visible = gt.visible),
      (St.wireframe = gt.wireframe),
      _t === VSMShadowMap
        ? (St.side = gt.shadowSide !== null ? gt.shadowSide : gt.side)
        : (St.side = gt.shadowSide !== null ? gt.shadowSide : _e[gt.side]),
      (St.alphaMap = gt.alphaMap),
      (St.alphaTest = gt.alphaTest),
      (St.map = gt.map),
      (St.clipShadows = gt.clipShadows),
      (St.clippingPlanes = gt.clippingPlanes),
      (St.clipIntersection = gt.clipIntersection),
      (St.displacementMap = gt.displacementMap),
      (St.displacementScale = gt.displacementScale),
      (St.displacementBias = gt.displacementBias),
      (St.wireframeLinewidth = gt.wireframeLinewidth),
      (St.linewidth = gt.linewidth),
      xt.isPointLight === !0 && St.isMeshDistanceMaterial === !0)
    ) {
      const Rt = s.properties.get(St);
      Rt.light = xt;
    }
    return St;
  }
  function ut(ft, gt, xt, _t, St) {
    if (ft.visible === !1) return;
    if (
      ft.layers.test(gt.layers) &&
      (ft.isMesh || ft.isLine || ft.isPoints) &&
      (ft.castShadow || (ft.receiveShadow && St === VSMShadowMap)) &&
      (!ft.frustumCulled || a.intersectsObject(ft))
    ) {
      ft.modelViewMatrix.multiplyMatrices(
        xt.matrixWorldInverse,
        ft.matrixWorld
      );
      const Ft = e.update(ft),
        Ot = ft.material;
      if (Array.isArray(Ot)) {
        const Lt = Ft.groups;
        for (let Et = 0, bt = Lt.length; Et < bt; Et++) {
          const mt = Lt[Et],
            vt = Ot[mt.materialIndex];
          if (vt && vt.visible) {
            const Ct = ot(ft, vt, _t, St);
            ft.onBeforeShadow(s, ft, gt, xt, Ft, Ct, mt),
              s.renderBufferDirect(xt, null, Ft, Ct, ft, mt),
              ft.onAfterShadow(s, ft, gt, xt, Ft, Ct, mt);
          }
        }
      } else if (Ot.visible) {
        const Lt = ot(ft, Ot, _t, St);
        ft.onBeforeShadow(s, ft, gt, xt, Ft, Lt, null),
          s.renderBufferDirect(xt, null, Ft, Lt, ft, null),
          ft.onAfterShadow(s, ft, gt, xt, Ft, Lt, null);
      }
    }
    const Rt = ft.children;
    for (let Ft = 0, Ot = Rt.length; Ft < Ot; Ft++) ut(Rt[Ft], gt, xt, _t, St);
  }
  function pt(ft) {
    ft.target.removeEventListener("dispose", pt);
    for (const xt in j) {
      const _t = j[xt],
        St = ft.target.uuid;
      St in _t && (_t[St].dispose(), delete _t[St]);
    }
  }
}
function WebGLState(s) {
  function e() {
    let Ut = !1;
    const dn = new Vector4();
    let an = null;
    const hn = new Vector4(0, 0, 0, 0);
    return {
      setMask: function (Mn) {
        an !== Mn && !Ut && (s.colorMask(Mn, Mn, Mn, Mn), (an = Mn));
      },
      setLocked: function (Mn) {
        Ut = Mn;
      },
      setClear: function (Mn, $n, Yn, rr, pr) {
        pr === !0 && ((Mn *= rr), ($n *= rr), (Yn *= rr)),
          dn.set(Mn, $n, Yn, rr),
          hn.equals(dn) === !1 && (s.clearColor(Mn, $n, Yn, rr), hn.copy(dn));
      },
      reset: function () {
        (Ut = !1), (an = null), hn.set(-1, 0, 0, 0);
      },
    };
  }
  function o() {
    let Ut = !1,
      dn = null,
      an = null,
      hn = null;
    return {
      setTest: function (Mn) {
        Mn ? Gt(s.DEPTH_TEST) : en(s.DEPTH_TEST);
      },
      setMask: function (Mn) {
        dn !== Mn && !Ut && (s.depthMask(Mn), (dn = Mn));
      },
      setFunc: function (Mn) {
        if (an !== Mn) {
          switch (Mn) {
            case NeverDepth:
              s.depthFunc(s.NEVER);
              break;
            case AlwaysDepth:
              s.depthFunc(s.ALWAYS);
              break;
            case LessDepth:
              s.depthFunc(s.LESS);
              break;
            case LessEqualDepth:
              s.depthFunc(s.LEQUAL);
              break;
            case EqualDepth:
              s.depthFunc(s.EQUAL);
              break;
            case GreaterEqualDepth:
              s.depthFunc(s.GEQUAL);
              break;
            case GreaterDepth:
              s.depthFunc(s.GREATER);
              break;
            case NotEqualDepth:
              s.depthFunc(s.NOTEQUAL);
              break;
            default:
              s.depthFunc(s.LEQUAL);
          }
          an = Mn;
        }
      },
      setLocked: function (Mn) {
        Ut = Mn;
      },
      setClear: function (Mn) {
        hn !== Mn && (s.clearDepth(Mn), (hn = Mn));
      },
      reset: function () {
        (Ut = !1), (dn = null), (an = null), (hn = null);
      },
    };
  }
  function a() {
    let Ut = !1,
      dn = null,
      an = null,
      hn = null,
      Mn = null,
      $n = null,
      Yn = null,
      rr = null,
      pr = null;
    return {
      setTest: function (tr) {
        Ut || (tr ? Gt(s.STENCIL_TEST) : en(s.STENCIL_TEST));
      },
      setMask: function (tr) {
        dn !== tr && !Ut && (s.stencilMask(tr), (dn = tr));
      },
      setFunc: function (tr, Cr, Tr) {
        (an !== tr || hn !== Cr || Mn !== Tr) &&
          (s.stencilFunc(tr, Cr, Tr), (an = tr), (hn = Cr), (Mn = Tr));
      },
      setOp: function (tr, Cr, Tr) {
        ($n !== tr || Yn !== Cr || rr !== Tr) &&
          (s.stencilOp(tr, Cr, Tr), ($n = tr), (Yn = Cr), (rr = Tr));
      },
      setLocked: function (tr) {
        Ut = tr;
      },
      setClear: function (tr) {
        pr !== tr && (s.clearStencil(tr), (pr = tr));
      },
      reset: function () {
        (Ut = !1),
          (dn = null),
          (an = null),
          (hn = null),
          (Mn = null),
          ($n = null),
          (Yn = null),
          (rr = null),
          (pr = null);
      },
    };
  }
  const c = new e(),
    d = new o(),
    g = new a(),
    _ = new WeakMap(),
    b = new WeakMap();
  let j = {},
    $ = {},
    _e = new WeakMap(),
    et = [],
    rt = null,
    st = !1,
    at = null,
    ct = null,
    it = null,
    lt = null,
    ot = null,
    ut = null,
    pt = null,
    ft = new Color(0, 0, 0),
    gt = 0,
    xt = !1,
    _t = null,
    St = null,
    Mt = null,
    Rt = null,
    Ft = null;
  const Ot = s.getParameter(s.MAX_COMBINED_TEXTURE_IMAGE_UNITS);
  let Lt = !1,
    Et = 0;
  const bt = s.getParameter(s.VERSION);
  bt.indexOf("WebGL") !== -1
    ? ((Et = parseFloat(/^WebGL (\d)/.exec(bt)[1])), (Lt = Et >= 1))
    : bt.indexOf("OpenGL ES") !== -1 &&
      ((Et = parseFloat(/^OpenGL ES (\d)/.exec(bt)[1])), (Lt = Et >= 2));
  let mt = null,
    vt = {};
  const Ct = s.getParameter(s.SCISSOR_BOX),
    Tt = s.getParameter(s.VIEWPORT),
    Dt = new Vector4().fromArray(Ct),
    Wt = new Vector4().fromArray(Tt);
  function Pt(Ut, dn, an, hn) {
    const Mn = new Uint8Array(4),
      $n = s.createTexture();
    s.bindTexture(Ut, $n),
      s.texParameteri(Ut, s.TEXTURE_MIN_FILTER, s.NEAREST),
      s.texParameteri(Ut, s.TEXTURE_MAG_FILTER, s.NEAREST);
    for (let Yn = 0; Yn < an; Yn++)
      Ut === s.TEXTURE_3D || Ut === s.TEXTURE_2D_ARRAY
        ? s.texImage3D(dn, 0, s.RGBA, 1, 1, hn, 0, s.RGBA, s.UNSIGNED_BYTE, Mn)
        : s.texImage2D(
            dn + Yn,
            0,
            s.RGBA,
            1,
            1,
            0,
            s.RGBA,
            s.UNSIGNED_BYTE,
            Mn
          );
    return $n;
  }
  const Jt = {};
  (Jt[s.TEXTURE_2D] = Pt(s.TEXTURE_2D, s.TEXTURE_2D, 1)),
    (Jt[s.TEXTURE_CUBE_MAP] = Pt(
      s.TEXTURE_CUBE_MAP,
      s.TEXTURE_CUBE_MAP_POSITIVE_X,
      6
    )),
    (Jt[s.TEXTURE_2D_ARRAY] = Pt(s.TEXTURE_2D_ARRAY, s.TEXTURE_2D_ARRAY, 1, 1)),
    (Jt[s.TEXTURE_3D] = Pt(s.TEXTURE_3D, s.TEXTURE_3D, 1, 1)),
    c.setClear(0, 0, 0, 1),
    d.setClear(1),
    g.setClear(0),
    Gt(s.DEPTH_TEST),
    d.setFunc(LessEqualDepth),
    yn(!1),
    nn(CullFaceBack),
    Gt(s.CULL_FACE),
    qt(NoBlending);
  function Gt(Ut) {
    j[Ut] !== !0 && (s.enable(Ut), (j[Ut] = !0));
  }
  function en(Ut) {
    j[Ut] !== !1 && (s.disable(Ut), (j[Ut] = !1));
  }
  function _n(Ut, dn) {
    return $[Ut] !== dn
      ? (s.bindFramebuffer(Ut, dn),
        ($[Ut] = dn),
        Ut === s.DRAW_FRAMEBUFFER && ($[s.FRAMEBUFFER] = dn),
        Ut === s.FRAMEBUFFER && ($[s.DRAW_FRAMEBUFFER] = dn),
        !0)
      : !1;
  }
  function Tn(Ut, dn) {
    let an = et,
      hn = !1;
    if (Ut) {
      (an = _e.get(dn)), an === void 0 && ((an = []), _e.set(dn, an));
      const Mn = Ut.textures;
      if (an.length !== Mn.length || an[0] !== s.COLOR_ATTACHMENT0) {
        for (let $n = 0, Yn = Mn.length; $n < Yn; $n++)
          an[$n] = s.COLOR_ATTACHMENT0 + $n;
        (an.length = Mn.length), (hn = !0);
      }
    } else an[0] !== s.BACK && ((an[0] = s.BACK), (hn = !0));
    hn && s.drawBuffers(an);
  }
  function fn(Ut) {
    return rt !== Ut ? (s.useProgram(Ut), (rt = Ut), !0) : !1;
  }
  const pn = {
    [AddEquation]: s.FUNC_ADD,
    [SubtractEquation]: s.FUNC_SUBTRACT,
    [ReverseSubtractEquation]: s.FUNC_REVERSE_SUBTRACT,
  };
  (pn[MinEquation] = s.MIN), (pn[MaxEquation] = s.MAX);
  const Bt = {
    [ZeroFactor]: s.ZERO,
    [OneFactor]: s.ONE,
    [SrcColorFactor]: s.SRC_COLOR,
    [SrcAlphaFactor]: s.SRC_ALPHA,
    [SrcAlphaSaturateFactor]: s.SRC_ALPHA_SATURATE,
    [DstColorFactor]: s.DST_COLOR,
    [DstAlphaFactor]: s.DST_ALPHA,
    [OneMinusSrcColorFactor]: s.ONE_MINUS_SRC_COLOR,
    [OneMinusSrcAlphaFactor]: s.ONE_MINUS_SRC_ALPHA,
    [OneMinusDstColorFactor]: s.ONE_MINUS_DST_COLOR,
    [OneMinusDstAlphaFactor]: s.ONE_MINUS_DST_ALPHA,
    [ConstantColorFactor]: s.CONSTANT_COLOR,
    [OneMinusConstantColorFactor]: s.ONE_MINUS_CONSTANT_COLOR,
    [ConstantAlphaFactor]: s.CONSTANT_ALPHA,
    [OneMinusConstantAlphaFactor]: s.ONE_MINUS_CONSTANT_ALPHA,
  };
  function qt(Ut, dn, an, hn, Mn, $n, Yn, rr, pr, tr) {
    if (Ut === NoBlending) {
      st === !0 && (en(s.BLEND), (st = !1));
      return;
    }
    if ((st === !1 && (Gt(s.BLEND), (st = !0)), Ut !== CustomBlending)) {
      if (Ut !== at || tr !== xt) {
        if (
          ((ct !== AddEquation || ot !== AddEquation) &&
            (s.blendEquation(s.FUNC_ADD),
            (ct = AddEquation),
            (ot = AddEquation)),
          tr)
        )
          switch (Ut) {
            case NormalBlending:
              s.blendFuncSeparate(
                s.ONE,
                s.ONE_MINUS_SRC_ALPHA,
                s.ONE,
                s.ONE_MINUS_SRC_ALPHA
              );
              break;
            case AdditiveBlending:
              s.blendFunc(s.ONE, s.ONE);
              break;
            case SubtractiveBlending:
              s.blendFuncSeparate(s.ZERO, s.ONE_MINUS_SRC_COLOR, s.ZERO, s.ONE);
              break;
            case MultiplyBlending:
              s.blendFuncSeparate(s.ZERO, s.SRC_COLOR, s.ZERO, s.SRC_ALPHA);
              break;
            default:
              console.error("THREE.WebGLState: Invalid blending: ", Ut);
              break;
          }
        else
          switch (Ut) {
            case NormalBlending:
              s.blendFuncSeparate(
                s.SRC_ALPHA,
                s.ONE_MINUS_SRC_ALPHA,
                s.ONE,
                s.ONE_MINUS_SRC_ALPHA
              );
              break;
            case AdditiveBlending:
              s.blendFunc(s.SRC_ALPHA, s.ONE);
              break;
            case SubtractiveBlending:
              s.blendFuncSeparate(s.ZERO, s.ONE_MINUS_SRC_COLOR, s.ZERO, s.ONE);
              break;
            case MultiplyBlending:
              s.blendFunc(s.ZERO, s.SRC_COLOR);
              break;
            default:
              console.error("THREE.WebGLState: Invalid blending: ", Ut);
              break;
          }
        (it = null),
          (lt = null),
          (ut = null),
          (pt = null),
          ft.set(0, 0, 0),
          (gt = 0),
          (at = Ut),
          (xt = tr);
      }
      return;
    }
    (Mn = Mn || dn),
      ($n = $n || an),
      (Yn = Yn || hn),
      (dn !== ct || Mn !== ot) &&
        (s.blendEquationSeparate(pn[dn], pn[Mn]), (ct = dn), (ot = Mn)),
      (an !== it || hn !== lt || $n !== ut || Yn !== pt) &&
        (s.blendFuncSeparate(Bt[an], Bt[hn], Bt[$n], Bt[Yn]),
        (it = an),
        (lt = hn),
        (ut = $n),
        (pt = Yn)),
      (rr.equals(ft) === !1 || pr !== gt) &&
        (s.blendColor(rr.r, rr.g, rr.b, pr), ft.copy(rr), (gt = pr)),
      (at = Ut),
      (xt = !1);
  }
  function $t(Ut, dn) {
    Ut.side === DoubleSide ? en(s.CULL_FACE) : Gt(s.CULL_FACE);
    let an = Ut.side === BackSide;
    dn && (an = !an),
      yn(an),
      Ut.blending === NormalBlending && Ut.transparent === !1
        ? qt(NoBlending)
        : qt(
            Ut.blending,
            Ut.blendEquation,
            Ut.blendSrc,
            Ut.blendDst,
            Ut.blendEquationAlpha,
            Ut.blendSrcAlpha,
            Ut.blendDstAlpha,
            Ut.blendColor,
            Ut.blendAlpha,
            Ut.premultipliedAlpha
          ),
      d.setFunc(Ut.depthFunc),
      d.setTest(Ut.depthTest),
      d.setMask(Ut.depthWrite),
      c.setMask(Ut.colorWrite);
    const hn = Ut.stencilWrite;
    g.setTest(hn),
      hn &&
        (g.setMask(Ut.stencilWriteMask),
        g.setFunc(Ut.stencilFunc, Ut.stencilRef, Ut.stencilFuncMask),
        g.setOp(Ut.stencilFail, Ut.stencilZFail, Ut.stencilZPass)),
      xn(Ut.polygonOffset, Ut.polygonOffsetFactor, Ut.polygonOffsetUnits),
      Ut.alphaToCoverage === !0
        ? Gt(s.SAMPLE_ALPHA_TO_COVERAGE)
        : en(s.SAMPLE_ALPHA_TO_COVERAGE);
  }
  function yn(Ut) {
    _t !== Ut && (Ut ? s.frontFace(s.CW) : s.frontFace(s.CCW), (_t = Ut));
  }
  function nn(Ut) {
    Ut !== CullFaceNone
      ? (Gt(s.CULL_FACE),
        Ut !== St &&
          (Ut === CullFaceBack
            ? s.cullFace(s.BACK)
            : Ut === CullFaceFront
            ? s.cullFace(s.FRONT)
            : s.cullFace(s.FRONT_AND_BACK)))
      : en(s.CULL_FACE),
      (St = Ut);
  }
  function Pn(Ut) {
    Ut !== Mt && (Lt && s.lineWidth(Ut), (Mt = Ut));
  }
  function xn(Ut, dn, an) {
    Ut
      ? (Gt(s.POLYGON_OFFSET_FILL),
        (Rt !== dn || Ft !== an) &&
          (s.polygonOffset(dn, an), (Rt = dn), (Ft = an)))
      : en(s.POLYGON_OFFSET_FILL);
  }
  function An(Ut) {
    Ut ? Gt(s.SCISSOR_TEST) : en(s.SCISSOR_TEST);
  }
  function kt(Ut) {
    Ut === void 0 && (Ut = s.TEXTURE0 + Ot - 1),
      mt !== Ut && (s.activeTexture(Ut), (mt = Ut));
  }
  function wt(Ut, dn, an) {
    an === void 0 && (mt === null ? (an = s.TEXTURE0 + Ot - 1) : (an = mt));
    let hn = vt[an];
    hn === void 0 && ((hn = { type: void 0, texture: void 0 }), (vt[an] = hn)),
      (hn.type !== Ut || hn.texture !== dn) &&
        (mt !== an && (s.activeTexture(an), (mt = an)),
        s.bindTexture(Ut, dn || Jt[Ut]),
        (hn.type = Ut),
        (hn.texture = dn));
  }
  function Kt() {
    const Ut = vt[mt];
    Ut !== void 0 &&
      Ut.type !== void 0 &&
      (s.bindTexture(Ut.type, null), (Ut.type = void 0), (Ut.texture = void 0));
  }
  function on() {
    try {
      s.compressedTexImage2D.apply(s, arguments);
    } catch (Ut) {
      console.error("THREE.WebGLState:", Ut);
    }
  }
  function sn() {
    try {
      s.compressedTexImage3D.apply(s, arguments);
    } catch (Ut) {
      console.error("THREE.WebGLState:", Ut);
    }
  }
  function cn() {
    try {
      s.texSubImage2D.apply(s, arguments);
    } catch (Ut) {
      console.error("THREE.WebGLState:", Ut);
    }
  }
  function bn() {
    try {
      s.texSubImage3D.apply(s, arguments);
    } catch (Ut) {
      console.error("THREE.WebGLState:", Ut);
    }
  }
  function vn() {
    try {
      s.compressedTexSubImage2D.apply(s, arguments);
    } catch (Ut) {
      console.error("THREE.WebGLState:", Ut);
    }
  }
  function wn() {
    try {
      s.compressedTexSubImage3D.apply(s, arguments);
    } catch (Ut) {
      console.error("THREE.WebGLState:", Ut);
    }
  }
  function zn() {
    try {
      s.texStorage2D.apply(s, arguments);
    } catch (Ut) {
      console.error("THREE.WebGLState:", Ut);
    }
  }
  function gn() {
    try {
      s.texStorage3D.apply(s, arguments);
    } catch (Ut) {
      console.error("THREE.WebGLState:", Ut);
    }
  }
  function Rn() {
    try {
      s.texImage2D.apply(s, arguments);
    } catch (Ut) {
      console.error("THREE.WebGLState:", Ut);
    }
  }
  function qn() {
    try {
      s.texImage3D.apply(s, arguments);
    } catch (Ut) {
      console.error("THREE.WebGLState:", Ut);
    }
  }
  function Wn(Ut) {
    Dt.equals(Ut) === !1 && (s.scissor(Ut.x, Ut.y, Ut.z, Ut.w), Dt.copy(Ut));
  }
  function kn(Ut) {
    Wt.equals(Ut) === !1 && (s.viewport(Ut.x, Ut.y, Ut.z, Ut.w), Wt.copy(Ut));
  }
  function Vt(Ut, dn) {
    let an = b.get(dn);
    an === void 0 && ((an = new WeakMap()), b.set(dn, an));
    let hn = an.get(Ut);
    hn === void 0 &&
      ((hn = s.getUniformBlockIndex(dn, Ut.name)), an.set(Ut, hn));
  }
  function un(Ut, dn) {
    const hn = b.get(dn).get(Ut);
    _.get(dn) !== hn &&
      (s.uniformBlockBinding(dn, hn, Ut.__bindingPointIndex), _.set(dn, hn));
  }
  function In() {
    s.disable(s.BLEND),
      s.disable(s.CULL_FACE),
      s.disable(s.DEPTH_TEST),
      s.disable(s.POLYGON_OFFSET_FILL),
      s.disable(s.SCISSOR_TEST),
      s.disable(s.STENCIL_TEST),
      s.disable(s.SAMPLE_ALPHA_TO_COVERAGE),
      s.blendEquation(s.FUNC_ADD),
      s.blendFunc(s.ONE, s.ZERO),
      s.blendFuncSeparate(s.ONE, s.ZERO, s.ONE, s.ZERO),
      s.blendColor(0, 0, 0, 0),
      s.colorMask(!0, !0, !0, !0),
      s.clearColor(0, 0, 0, 0),
      s.depthMask(!0),
      s.depthFunc(s.LESS),
      s.clearDepth(1),
      s.stencilMask(4294967295),
      s.stencilFunc(s.ALWAYS, 0, 4294967295),
      s.stencilOp(s.KEEP, s.KEEP, s.KEEP),
      s.clearStencil(0),
      s.cullFace(s.BACK),
      s.frontFace(s.CCW),
      s.polygonOffset(0, 0),
      s.activeTexture(s.TEXTURE0),
      s.bindFramebuffer(s.FRAMEBUFFER, null),
      s.bindFramebuffer(s.DRAW_FRAMEBUFFER, null),
      s.bindFramebuffer(s.READ_FRAMEBUFFER, null),
      s.useProgram(null),
      s.lineWidth(1),
      s.scissor(0, 0, s.canvas.width, s.canvas.height),
      s.viewport(0, 0, s.canvas.width, s.canvas.height),
      (j = {}),
      (mt = null),
      (vt = {}),
      ($ = {}),
      (_e = new WeakMap()),
      (et = []),
      (rt = null),
      (st = !1),
      (at = null),
      (ct = null),
      (it = null),
      (lt = null),
      (ot = null),
      (ut = null),
      (pt = null),
      (ft = new Color(0, 0, 0)),
      (gt = 0),
      (xt = !1),
      (_t = null),
      (St = null),
      (Mt = null),
      (Rt = null),
      (Ft = null),
      Dt.set(0, 0, s.canvas.width, s.canvas.height),
      Wt.set(0, 0, s.canvas.width, s.canvas.height),
      c.reset(),
      d.reset(),
      g.reset();
  }
  return {
    buffers: { color: c, depth: d, stencil: g },
    enable: Gt,
    disable: en,
    bindFramebuffer: _n,
    drawBuffers: Tn,
    useProgram: fn,
    setBlending: qt,
    setMaterial: $t,
    setFlipSided: yn,
    setCullFace: nn,
    setLineWidth: Pn,
    setPolygonOffset: xn,
    setScissorTest: An,
    activeTexture: kt,
    bindTexture: wt,
    unbindTexture: Kt,
    compressedTexImage2D: on,
    compressedTexImage3D: sn,
    texImage2D: Rn,
    texImage3D: qn,
    updateUBOMapping: Vt,
    uniformBlockBinding: un,
    texStorage2D: zn,
    texStorage3D: gn,
    texSubImage2D: cn,
    texSubImage3D: bn,
    compressedTexSubImage2D: vn,
    compressedTexSubImage3D: wn,
    scissor: Wn,
    viewport: kn,
    reset: In,
  };
}
function contain(s, e) {
  const o = s.image && s.image.width ? s.image.width / s.image.height : 1;
  return (
    o > e
      ? ((s.repeat.x = 1),
        (s.repeat.y = o / e),
        (s.offset.x = 0),
        (s.offset.y = (1 - s.repeat.y) / 2))
      : ((s.repeat.x = e / o),
        (s.repeat.y = 1),
        (s.offset.x = (1 - s.repeat.x) / 2),
        (s.offset.y = 0)),
    s
  );
}
function cover(s, e) {
  const o = s.image && s.image.width ? s.image.width / s.image.height : 1;
  return (
    o > e
      ? ((s.repeat.x = e / o),
        (s.repeat.y = 1),
        (s.offset.x = (1 - s.repeat.x) / 2),
        (s.offset.y = 0))
      : ((s.repeat.x = 1),
        (s.repeat.y = o / e),
        (s.offset.x = 0),
        (s.offset.y = (1 - s.repeat.y) / 2)),
    s
  );
}
function fill(s) {
  return (
    (s.repeat.x = 1), (s.repeat.y = 1), (s.offset.x = 0), (s.offset.y = 0), s
  );
}
function getByteLength(s, e, o, a) {
  const c = getTextureTypeByteLength(a);
  switch (o) {
    case AlphaFormat:
      return s * e;
    case LuminanceFormat:
      return s * e;
    case LuminanceAlphaFormat:
      return s * e * 2;
    case RedFormat:
      return ((s * e) / c.components) * c.byteLength;
    case RedIntegerFormat:
      return ((s * e) / c.components) * c.byteLength;
    case RGFormat:
      return ((s * e * 2) / c.components) * c.byteLength;
    case RGIntegerFormat:
      return ((s * e * 2) / c.components) * c.byteLength;
    case RGBFormat:
      return ((s * e * 3) / c.components) * c.byteLength;
    case RGBAFormat:
      return ((s * e * 4) / c.components) * c.byteLength;
    case RGBAIntegerFormat:
      return ((s * e * 4) / c.components) * c.byteLength;
    case RGB_S3TC_DXT1_Format:
    case RGBA_S3TC_DXT1_Format:
      return Math.floor((s + 3) / 4) * Math.floor((e + 3) / 4) * 8;
    case RGBA_S3TC_DXT3_Format:
    case RGBA_S3TC_DXT5_Format:
      return Math.floor((s + 3) / 4) * Math.floor((e + 3) / 4) * 16;
    case RGB_PVRTC_2BPPV1_Format:
    case RGBA_PVRTC_2BPPV1_Format:
      return (Math.max(s, 16) * Math.max(e, 8)) / 4;
    case RGB_PVRTC_4BPPV1_Format:
    case RGBA_PVRTC_4BPPV1_Format:
      return (Math.max(s, 8) * Math.max(e, 8)) / 2;
    case RGB_ETC1_Format:
    case RGB_ETC2_Format:
      return Math.floor((s + 3) / 4) * Math.floor((e + 3) / 4) * 8;
    case RGBA_ETC2_EAC_Format:
      return Math.floor((s + 3) / 4) * Math.floor((e + 3) / 4) * 16;
    case RGBA_ASTC_4x4_Format:
      return Math.floor((s + 3) / 4) * Math.floor((e + 3) / 4) * 16;
    case RGBA_ASTC_5x4_Format:
      return Math.floor((s + 4) / 5) * Math.floor((e + 3) / 4) * 16;
    case RGBA_ASTC_5x5_Format:
      return Math.floor((s + 4) / 5) * Math.floor((e + 4) / 5) * 16;
    case RGBA_ASTC_6x5_Format:
      return Math.floor((s + 5) / 6) * Math.floor((e + 4) / 5) * 16;
    case RGBA_ASTC_6x6_Format:
      return Math.floor((s + 5) / 6) * Math.floor((e + 5) / 6) * 16;
    case RGBA_ASTC_8x5_Format:
      return Math.floor((s + 7) / 8) * Math.floor((e + 4) / 5) * 16;
    case RGBA_ASTC_8x6_Format:
      return Math.floor((s + 7) / 8) * Math.floor((e + 5) / 6) * 16;
    case RGBA_ASTC_8x8_Format:
      return Math.floor((s + 7) / 8) * Math.floor((e + 7) / 8) * 16;
    case RGBA_ASTC_10x5_Format:
      return Math.floor((s + 9) / 10) * Math.floor((e + 4) / 5) * 16;
    case RGBA_ASTC_10x6_Format:
      return Math.floor((s + 9) / 10) * Math.floor((e + 5) / 6) * 16;
    case RGBA_ASTC_10x8_Format:
      return Math.floor((s + 9) / 10) * Math.floor((e + 7) / 8) * 16;
    case RGBA_ASTC_10x10_Format:
      return Math.floor((s + 9) / 10) * Math.floor((e + 9) / 10) * 16;
    case RGBA_ASTC_12x10_Format:
      return Math.floor((s + 11) / 12) * Math.floor((e + 9) / 10) * 16;
    case RGBA_ASTC_12x12_Format:
      return Math.floor((s + 11) / 12) * Math.floor((e + 11) / 12) * 16;
    case RGBA_BPTC_Format:
    case RGB_BPTC_SIGNED_Format:
    case RGB_BPTC_UNSIGNED_Format:
      return Math.ceil(s / 4) * Math.ceil(e / 4) * 16;
    case RED_RGTC1_Format:
    case SIGNED_RED_RGTC1_Format:
      return Math.ceil(s / 4) * Math.ceil(e / 4) * 8;
    case RED_GREEN_RGTC2_Format:
    case SIGNED_RED_GREEN_RGTC2_Format:
      return Math.ceil(s / 4) * Math.ceil(e / 4) * 16;
  }
  throw new Error(`Unable to determine texture byte length for ${o} format.`);
}
function getTextureTypeByteLength(s) {
  switch (s) {
    case UnsignedByteType:
    case ByteType:
      return { byteLength: 1, components: 1 };
    case UnsignedShortType:
    case ShortType:
    case HalfFloatType:
      return { byteLength: 2, components: 1 };
    case UnsignedShort4444Type:
    case UnsignedShort5551Type:
      return { byteLength: 2, components: 4 };
    case UnsignedIntType:
    case IntType:
    case FloatType:
      return { byteLength: 4, components: 1 };
    case UnsignedInt5999Type:
      return { byteLength: 4, components: 3 };
  }
  throw new Error(`Unknown texture type ${s}.`);
}
const TextureUtils = { contain, cover, fill, getByteLength };
function WebGLTextures(s, e, o, a, c, d, g) {
  const _ = e.has("WEBGL_multisampled_render_to_texture")
      ? e.get("WEBGL_multisampled_render_to_texture")
      : null,
    b =
      typeof navigator > "u" ? !1 : /OculusBrowser/g.test(navigator.userAgent),
    j = new Vector2(),
    $ = new WeakMap();
  let _e;
  const et = new WeakMap();
  let rt = !1;
  try {
    rt =
      typeof OffscreenCanvas < "u" &&
      new OffscreenCanvas(1, 1).getContext("2d") !== null;
  } catch {}
  function st(kt, wt) {
    return rt ? new OffscreenCanvas(kt, wt) : createElementNS("canvas");
  }
  function at(kt, wt, Kt) {
    let on = 1;
    const sn = An(kt);
    if (
      ((sn.width > Kt || sn.height > Kt) &&
        (on = Kt / Math.max(sn.width, sn.height)),
      on < 1)
    )
      if (
        (typeof HTMLImageElement < "u" && kt instanceof HTMLImageElement) ||
        (typeof HTMLCanvasElement < "u" && kt instanceof HTMLCanvasElement) ||
        (typeof ImageBitmap < "u" && kt instanceof ImageBitmap) ||
        (typeof VideoFrame < "u" && kt instanceof VideoFrame)
      ) {
        const cn = Math.floor(on * sn.width),
          bn = Math.floor(on * sn.height);
        _e === void 0 && (_e = st(cn, bn));
        const vn = wt ? st(cn, bn) : _e;
        return (
          (vn.width = cn),
          (vn.height = bn),
          vn.getContext("2d").drawImage(kt, 0, 0, cn, bn),
          console.warn(
            "THREE.WebGLRenderer: Texture has been resized from (" +
              sn.width +
              "x" +
              sn.height +
              ") to (" +
              cn +
              "x" +
              bn +
              ")."
          ),
          vn
        );
      } else
        return (
          "data" in kt &&
            console.warn(
              "THREE.WebGLRenderer: Image in DataTexture is too big (" +
                sn.width +
                "x" +
                sn.height +
                ")."
            ),
          kt
        );
    return kt;
  }
  function ct(kt) {
    return (
      kt.generateMipmaps &&
      kt.minFilter !== NearestFilter &&
      kt.minFilter !== LinearFilter
    );
  }
  function it(kt) {
    s.generateMipmap(kt);
  }
  function lt(kt, wt, Kt, on, sn = !1) {
    if (kt !== null) {
      if (s[kt] !== void 0) return s[kt];
      console.warn(
        "THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" +
          kt +
          "'"
      );
    }
    let cn = wt;
    if (
      (wt === s.RED &&
        (Kt === s.FLOAT && (cn = s.R32F),
        Kt === s.HALF_FLOAT && (cn = s.R16F),
        Kt === s.UNSIGNED_BYTE && (cn = s.R8)),
      wt === s.RED_INTEGER &&
        (Kt === s.UNSIGNED_BYTE && (cn = s.R8UI),
        Kt === s.UNSIGNED_SHORT && (cn = s.R16UI),
        Kt === s.UNSIGNED_INT && (cn = s.R32UI),
        Kt === s.BYTE && (cn = s.R8I),
        Kt === s.SHORT && (cn = s.R16I),
        Kt === s.INT && (cn = s.R32I)),
      wt === s.RG &&
        (Kt === s.FLOAT && (cn = s.RG32F),
        Kt === s.HALF_FLOAT && (cn = s.RG16F),
        Kt === s.UNSIGNED_BYTE && (cn = s.RG8)),
      wt === s.RG_INTEGER &&
        (Kt === s.UNSIGNED_BYTE && (cn = s.RG8UI),
        Kt === s.UNSIGNED_SHORT && (cn = s.RG16UI),
        Kt === s.UNSIGNED_INT && (cn = s.RG32UI),
        Kt === s.BYTE && (cn = s.RG8I),
        Kt === s.SHORT && (cn = s.RG16I),
        Kt === s.INT && (cn = s.RG32I)),
      wt === s.RGB && Kt === s.UNSIGNED_INT_5_9_9_9_REV && (cn = s.RGB9_E5),
      wt === s.RGBA)
    ) {
      const bn = sn ? LinearTransfer : ColorManagement.getTransfer(on);
      Kt === s.FLOAT && (cn = s.RGBA32F),
        Kt === s.HALF_FLOAT && (cn = s.RGBA16F),
        Kt === s.UNSIGNED_BYTE &&
          (cn = bn === SRGBTransfer ? s.SRGB8_ALPHA8 : s.RGBA8),
        Kt === s.UNSIGNED_SHORT_4_4_4_4 && (cn = s.RGBA4),
        Kt === s.UNSIGNED_SHORT_5_5_5_1 && (cn = s.RGB5_A1);
    }
    return (
      (cn === s.R16F ||
        cn === s.R32F ||
        cn === s.RG16F ||
        cn === s.RG32F ||
        cn === s.RGBA16F ||
        cn === s.RGBA32F) &&
        e.get("EXT_color_buffer_float"),
      cn
    );
  }
  function ot(kt, wt) {
    let Kt;
    return (
      kt
        ? wt === null || wt === UnsignedIntType || wt === UnsignedInt248Type
          ? (Kt = s.DEPTH24_STENCIL8)
          : wt === FloatType
          ? (Kt = s.DEPTH32F_STENCIL8)
          : wt === UnsignedShortType &&
            ((Kt = s.DEPTH24_STENCIL8),
            console.warn(
              "DepthTexture: 16 bit depth attachment is not supported with stencil. Using 24-bit attachment."
            ))
        : wt === null || wt === UnsignedIntType || wt === UnsignedInt248Type
        ? (Kt = s.DEPTH_COMPONENT24)
        : wt === FloatType
        ? (Kt = s.DEPTH_COMPONENT32F)
        : wt === UnsignedShortType && (Kt = s.DEPTH_COMPONENT16),
      Kt
    );
  }
  function ut(kt, wt) {
    return ct(kt) === !0 ||
      (kt.isFramebufferTexture &&
        kt.minFilter !== NearestFilter &&
        kt.minFilter !== LinearFilter)
      ? Math.log2(Math.max(wt.width, wt.height)) + 1
      : kt.mipmaps !== void 0 && kt.mipmaps.length > 0
      ? kt.mipmaps.length
      : kt.isCompressedTexture && Array.isArray(kt.image)
      ? wt.mipmaps.length
      : 1;
  }
  function pt(kt) {
    const wt = kt.target;
    wt.removeEventListener("dispose", pt),
      gt(wt),
      wt.isVideoTexture && $.delete(wt);
  }
  function ft(kt) {
    const wt = kt.target;
    wt.removeEventListener("dispose", ft), _t(wt);
  }
  function gt(kt) {
    const wt = a.get(kt);
    if (wt.__webglInit === void 0) return;
    const Kt = kt.source,
      on = et.get(Kt);
    if (on) {
      const sn = on[wt.__cacheKey];
      sn.usedTimes--,
        sn.usedTimes === 0 && xt(kt),
        Object.keys(on).length === 0 && et.delete(Kt);
    }
    a.remove(kt);
  }
  function xt(kt) {
    const wt = a.get(kt);
    s.deleteTexture(wt.__webglTexture);
    const Kt = kt.source,
      on = et.get(Kt);
    delete on[wt.__cacheKey], g.memory.textures--;
  }
  function _t(kt) {
    const wt = a.get(kt);
    if (
      (kt.depthTexture && kt.depthTexture.dispose(), kt.isWebGLCubeRenderTarget)
    )
      for (let on = 0; on < 6; on++) {
        if (Array.isArray(wt.__webglFramebuffer[on]))
          for (let sn = 0; sn < wt.__webglFramebuffer[on].length; sn++)
            s.deleteFramebuffer(wt.__webglFramebuffer[on][sn]);
        else s.deleteFramebuffer(wt.__webglFramebuffer[on]);
        wt.__webglDepthbuffer &&
          s.deleteRenderbuffer(wt.__webglDepthbuffer[on]);
      }
    else {
      if (Array.isArray(wt.__webglFramebuffer))
        for (let on = 0; on < wt.__webglFramebuffer.length; on++)
          s.deleteFramebuffer(wt.__webglFramebuffer[on]);
      else s.deleteFramebuffer(wt.__webglFramebuffer);
      if (
        (wt.__webglDepthbuffer && s.deleteRenderbuffer(wt.__webglDepthbuffer),
        wt.__webglMultisampledFramebuffer &&
          s.deleteFramebuffer(wt.__webglMultisampledFramebuffer),
        wt.__webglColorRenderbuffer)
      )
        for (let on = 0; on < wt.__webglColorRenderbuffer.length; on++)
          wt.__webglColorRenderbuffer[on] &&
            s.deleteRenderbuffer(wt.__webglColorRenderbuffer[on]);
      wt.__webglDepthRenderbuffer &&
        s.deleteRenderbuffer(wt.__webglDepthRenderbuffer);
    }
    const Kt = kt.textures;
    for (let on = 0, sn = Kt.length; on < sn; on++) {
      const cn = a.get(Kt[on]);
      cn.__webglTexture &&
        (s.deleteTexture(cn.__webglTexture), g.memory.textures--),
        a.remove(Kt[on]);
    }
    a.remove(kt);
  }
  let St = 0;
  function Mt() {
    St = 0;
  }
  function Rt() {
    const kt = St;
    return (
      kt >= c.maxTextures &&
        console.warn(
          "THREE.WebGLTextures: Trying to use " +
            kt +
            " texture units while this GPU supports only " +
            c.maxTextures
        ),
      (St += 1),
      kt
    );
  }
  function Ft(kt) {
    const wt = [];
    return (
      wt.push(kt.wrapS),
      wt.push(kt.wrapT),
      wt.push(kt.wrapR || 0),
      wt.push(kt.magFilter),
      wt.push(kt.minFilter),
      wt.push(kt.anisotropy),
      wt.push(kt.internalFormat),
      wt.push(kt.format),
      wt.push(kt.type),
      wt.push(kt.generateMipmaps),
      wt.push(kt.premultiplyAlpha),
      wt.push(kt.flipY),
      wt.push(kt.unpackAlignment),
      wt.push(kt.colorSpace),
      wt.join()
    );
  }
  function Ot(kt, wt) {
    const Kt = a.get(kt);
    if (
      (kt.isVideoTexture && Pn(kt),
      kt.isRenderTargetTexture === !1 &&
        kt.version > 0 &&
        Kt.__version !== kt.version)
    ) {
      const on = kt.image;
      if (on === null)
        console.warn(
          "THREE.WebGLRenderer: Texture marked for update but no image data found."
        );
      else if (on.complete === !1)
        console.warn(
          "THREE.WebGLRenderer: Texture marked for update but image is incomplete"
        );
      else {
        Wt(Kt, kt, wt);
        return;
      }
    }
    o.bindTexture(s.TEXTURE_2D, Kt.__webglTexture, s.TEXTURE0 + wt);
  }
  function Lt(kt, wt) {
    const Kt = a.get(kt);
    if (kt.version > 0 && Kt.__version !== kt.version) {
      Wt(Kt, kt, wt);
      return;
    }
    o.bindTexture(s.TEXTURE_2D_ARRAY, Kt.__webglTexture, s.TEXTURE0 + wt);
  }
  function Et(kt, wt) {
    const Kt = a.get(kt);
    if (kt.version > 0 && Kt.__version !== kt.version) {
      Wt(Kt, kt, wt);
      return;
    }
    o.bindTexture(s.TEXTURE_3D, Kt.__webglTexture, s.TEXTURE0 + wt);
  }
  function bt(kt, wt) {
    const Kt = a.get(kt);
    if (kt.version > 0 && Kt.__version !== kt.version) {
      Pt(Kt, kt, wt);
      return;
    }
    o.bindTexture(s.TEXTURE_CUBE_MAP, Kt.__webglTexture, s.TEXTURE0 + wt);
  }
  const mt = {
      [RepeatWrapping]: s.REPEAT,
      [ClampToEdgeWrapping]: s.CLAMP_TO_EDGE,
      [MirroredRepeatWrapping]: s.MIRRORED_REPEAT,
    },
    vt = {
      [NearestFilter]: s.NEAREST,
      [NearestMipmapNearestFilter]: s.NEAREST_MIPMAP_NEAREST,
      [NearestMipmapLinearFilter]: s.NEAREST_MIPMAP_LINEAR,
      [LinearFilter]: s.LINEAR,
      [LinearMipmapNearestFilter]: s.LINEAR_MIPMAP_NEAREST,
      [LinearMipmapLinearFilter]: s.LINEAR_MIPMAP_LINEAR,
    },
    Ct = {
      [NeverCompare]: s.NEVER,
      [AlwaysCompare]: s.ALWAYS,
      [LessCompare]: s.LESS,
      [LessEqualCompare]: s.LEQUAL,
      [EqualCompare]: s.EQUAL,
      [GreaterEqualCompare]: s.GEQUAL,
      [GreaterCompare]: s.GREATER,
      [NotEqualCompare]: s.NOTEQUAL,
    };
  function Tt(kt, wt) {
    if (
      (wt.type === FloatType &&
        e.has("OES_texture_float_linear") === !1 &&
        (wt.magFilter === LinearFilter ||
          wt.magFilter === LinearMipmapNearestFilter ||
          wt.magFilter === NearestMipmapLinearFilter ||
          wt.magFilter === LinearMipmapLinearFilter ||
          wt.minFilter === LinearFilter ||
          wt.minFilter === LinearMipmapNearestFilter ||
          wt.minFilter === NearestMipmapLinearFilter ||
          wt.minFilter === LinearMipmapLinearFilter) &&
        console.warn(
          "THREE.WebGLRenderer: Unable to use linear filtering with floating point textures. OES_texture_float_linear not supported on this device."
        ),
      s.texParameteri(kt, s.TEXTURE_WRAP_S, mt[wt.wrapS]),
      s.texParameteri(kt, s.TEXTURE_WRAP_T, mt[wt.wrapT]),
      (kt === s.TEXTURE_3D || kt === s.TEXTURE_2D_ARRAY) &&
        s.texParameteri(kt, s.TEXTURE_WRAP_R, mt[wt.wrapR]),
      s.texParameteri(kt, s.TEXTURE_MAG_FILTER, vt[wt.magFilter]),
      s.texParameteri(kt, s.TEXTURE_MIN_FILTER, vt[wt.minFilter]),
      wt.compareFunction &&
        (s.texParameteri(kt, s.TEXTURE_COMPARE_MODE, s.COMPARE_REF_TO_TEXTURE),
        s.texParameteri(kt, s.TEXTURE_COMPARE_FUNC, Ct[wt.compareFunction])),
      e.has("EXT_texture_filter_anisotropic") === !0)
    ) {
      if (
        wt.magFilter === NearestFilter ||
        (wt.minFilter !== NearestMipmapLinearFilter &&
          wt.minFilter !== LinearMipmapLinearFilter) ||
        (wt.type === FloatType && e.has("OES_texture_float_linear") === !1)
      )
        return;
      if (wt.anisotropy > 1 || a.get(wt).__currentAnisotropy) {
        const Kt = e.get("EXT_texture_filter_anisotropic");
        s.texParameterf(
          kt,
          Kt.TEXTURE_MAX_ANISOTROPY_EXT,
          Math.min(wt.anisotropy, c.getMaxAnisotropy())
        ),
          (a.get(wt).__currentAnisotropy = wt.anisotropy);
      }
    }
  }
  function Dt(kt, wt) {
    let Kt = !1;
    kt.__webglInit === void 0 &&
      ((kt.__webglInit = !0), wt.addEventListener("dispose", pt));
    const on = wt.source;
    let sn = et.get(on);
    sn === void 0 && ((sn = {}), et.set(on, sn));
    const cn = Ft(wt);
    if (cn !== kt.__cacheKey) {
      sn[cn] === void 0 &&
        ((sn[cn] = { texture: s.createTexture(), usedTimes: 0 }),
        g.memory.textures++,
        (Kt = !0)),
        sn[cn].usedTimes++;
      const bn = sn[kt.__cacheKey];
      bn !== void 0 &&
        (sn[kt.__cacheKey].usedTimes--, bn.usedTimes === 0 && xt(wt)),
        (kt.__cacheKey = cn),
        (kt.__webglTexture = sn[cn].texture);
    }
    return Kt;
  }
  function Wt(kt, wt, Kt) {
    let on = s.TEXTURE_2D;
    (wt.isDataArrayTexture || wt.isCompressedArrayTexture) &&
      (on = s.TEXTURE_2D_ARRAY),
      wt.isData3DTexture && (on = s.TEXTURE_3D);
    const sn = Dt(kt, wt),
      cn = wt.source;
    o.bindTexture(on, kt.__webglTexture, s.TEXTURE0 + Kt);
    const bn = a.get(cn);
    if (cn.version !== bn.__version || sn === !0) {
      o.activeTexture(s.TEXTURE0 + Kt);
      const vn = ColorManagement.getPrimaries(
          ColorManagement.workingColorSpace
        ),
        wn =
          wt.colorSpace === NoColorSpace
            ? null
            : ColorManagement.getPrimaries(wt.colorSpace),
        zn =
          wt.colorSpace === NoColorSpace || vn === wn
            ? s.NONE
            : s.BROWSER_DEFAULT_WEBGL;
      s.pixelStorei(s.UNPACK_FLIP_Y_WEBGL, wt.flipY),
        s.pixelStorei(s.UNPACK_PREMULTIPLY_ALPHA_WEBGL, wt.premultiplyAlpha),
        s.pixelStorei(s.UNPACK_ALIGNMENT, wt.unpackAlignment),
        s.pixelStorei(s.UNPACK_COLORSPACE_CONVERSION_WEBGL, zn);
      let gn = at(wt.image, !1, c.maxTextureSize);
      gn = xn(wt, gn);
      const Rn = d.convert(wt.format, wt.colorSpace),
        qn = d.convert(wt.type);
      let Wn = lt(wt.internalFormat, Rn, qn, wt.colorSpace, wt.isVideoTexture);
      Tt(on, wt);
      let kn;
      const Vt = wt.mipmaps,
        un = wt.isVideoTexture !== !0,
        In = bn.__version === void 0 || sn === !0,
        Ut = cn.dataReady,
        dn = ut(wt, gn);
      if (wt.isDepthTexture)
        (Wn = ot(wt.format === DepthStencilFormat, wt.type)),
          In &&
            (un
              ? o.texStorage2D(s.TEXTURE_2D, 1, Wn, gn.width, gn.height)
              : o.texImage2D(
                  s.TEXTURE_2D,
                  0,
                  Wn,
                  gn.width,
                  gn.height,
                  0,
                  Rn,
                  qn,
                  null
                ));
      else if (wt.isDataTexture)
        if (Vt.length > 0) {
          un &&
            In &&
            o.texStorage2D(s.TEXTURE_2D, dn, Wn, Vt[0].width, Vt[0].height);
          for (let an = 0, hn = Vt.length; an < hn; an++)
            (kn = Vt[an]),
              un
                ? Ut &&
                  o.texSubImage2D(
                    s.TEXTURE_2D,
                    an,
                    0,
                    0,
                    kn.width,
                    kn.height,
                    Rn,
                    qn,
                    kn.data
                  )
                : o.texImage2D(
                    s.TEXTURE_2D,
                    an,
                    Wn,
                    kn.width,
                    kn.height,
                    0,
                    Rn,
                    qn,
                    kn.data
                  );
          wt.generateMipmaps = !1;
        } else
          un
            ? (In && o.texStorage2D(s.TEXTURE_2D, dn, Wn, gn.width, gn.height),
              Ut &&
                o.texSubImage2D(
                  s.TEXTURE_2D,
                  0,
                  0,
                  0,
                  gn.width,
                  gn.height,
                  Rn,
                  qn,
                  gn.data
                ))
            : o.texImage2D(
                s.TEXTURE_2D,
                0,
                Wn,
                gn.width,
                gn.height,
                0,
                Rn,
                qn,
                gn.data
              );
      else if (wt.isCompressedTexture)
        if (wt.isCompressedArrayTexture) {
          un &&
            In &&
            o.texStorage3D(
              s.TEXTURE_2D_ARRAY,
              dn,
              Wn,
              Vt[0].width,
              Vt[0].height,
              gn.depth
            );
          for (let an = 0, hn = Vt.length; an < hn; an++)
            if (((kn = Vt[an]), wt.format !== RGBAFormat))
              if (Rn !== null)
                if (un) {
                  if (Ut)
                    if (wt.layerUpdates.size > 0) {
                      const Mn = getByteLength(
                        kn.width,
                        kn.height,
                        wt.format,
                        wt.type
                      );
                      for (const $n of wt.layerUpdates) {
                        const Yn = kn.data.subarray(
                          ($n * Mn) / kn.data.BYTES_PER_ELEMENT,
                          (($n + 1) * Mn) / kn.data.BYTES_PER_ELEMENT
                        );
                        o.compressedTexSubImage3D(
                          s.TEXTURE_2D_ARRAY,
                          an,
                          0,
                          0,
                          $n,
                          kn.width,
                          kn.height,
                          1,
                          Rn,
                          Yn,
                          0,
                          0
                        );
                      }
                      wt.clearLayerUpdates();
                    } else
                      o.compressedTexSubImage3D(
                        s.TEXTURE_2D_ARRAY,
                        an,
                        0,
                        0,
                        0,
                        kn.width,
                        kn.height,
                        gn.depth,
                        Rn,
                        kn.data,
                        0,
                        0
                      );
                } else
                  o.compressedTexImage3D(
                    s.TEXTURE_2D_ARRAY,
                    an,
                    Wn,
                    kn.width,
                    kn.height,
                    gn.depth,
                    0,
                    kn.data,
                    0,
                    0
                  );
              else
                console.warn(
                  "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"
                );
            else
              un
                ? Ut &&
                  o.texSubImage3D(
                    s.TEXTURE_2D_ARRAY,
                    an,
                    0,
                    0,
                    0,
                    kn.width,
                    kn.height,
                    gn.depth,
                    Rn,
                    qn,
                    kn.data
                  )
                : o.texImage3D(
                    s.TEXTURE_2D_ARRAY,
                    an,
                    Wn,
                    kn.width,
                    kn.height,
                    gn.depth,
                    0,
                    Rn,
                    qn,
                    kn.data
                  );
        } else {
          un &&
            In &&
            o.texStorage2D(s.TEXTURE_2D, dn, Wn, Vt[0].width, Vt[0].height);
          for (let an = 0, hn = Vt.length; an < hn; an++)
            (kn = Vt[an]),
              wt.format !== RGBAFormat
                ? Rn !== null
                  ? un
                    ? Ut &&
                      o.compressedTexSubImage2D(
                        s.TEXTURE_2D,
                        an,
                        0,
                        0,
                        kn.width,
                        kn.height,
                        Rn,
                        kn.data
                      )
                    : o.compressedTexImage2D(
                        s.TEXTURE_2D,
                        an,
                        Wn,
                        kn.width,
                        kn.height,
                        0,
                        kn.data
                      )
                  : console.warn(
                      "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"
                    )
                : un
                ? Ut &&
                  o.texSubImage2D(
                    s.TEXTURE_2D,
                    an,
                    0,
                    0,
                    kn.width,
                    kn.height,
                    Rn,
                    qn,
                    kn.data
                  )
                : o.texImage2D(
                    s.TEXTURE_2D,
                    an,
                    Wn,
                    kn.width,
                    kn.height,
                    0,
                    Rn,
                    qn,
                    kn.data
                  );
        }
      else if (wt.isDataArrayTexture)
        if (un) {
          if (
            (In &&
              o.texStorage3D(
                s.TEXTURE_2D_ARRAY,
                dn,
                Wn,
                gn.width,
                gn.height,
                gn.depth
              ),
            Ut)
          )
            if (wt.layerUpdates.size > 0) {
              const an = getByteLength(gn.width, gn.height, wt.format, wt.type);
              for (const hn of wt.layerUpdates) {
                const Mn = gn.data.subarray(
                  (hn * an) / gn.data.BYTES_PER_ELEMENT,
                  ((hn + 1) * an) / gn.data.BYTES_PER_ELEMENT
                );
                o.texSubImage3D(
                  s.TEXTURE_2D_ARRAY,
                  0,
                  0,
                  0,
                  hn,
                  gn.width,
                  gn.height,
                  1,
                  Rn,
                  qn,
                  Mn
                );
              }
              wt.clearLayerUpdates();
            } else
              o.texSubImage3D(
                s.TEXTURE_2D_ARRAY,
                0,
                0,
                0,
                0,
                gn.width,
                gn.height,
                gn.depth,
                Rn,
                qn,
                gn.data
              );
        } else
          o.texImage3D(
            s.TEXTURE_2D_ARRAY,
            0,
            Wn,
            gn.width,
            gn.height,
            gn.depth,
            0,
            Rn,
            qn,
            gn.data
          );
      else if (wt.isData3DTexture)
        un
          ? (In &&
              o.texStorage3D(
                s.TEXTURE_3D,
                dn,
                Wn,
                gn.width,
                gn.height,
                gn.depth
              ),
            Ut &&
              o.texSubImage3D(
                s.TEXTURE_3D,
                0,
                0,
                0,
                0,
                gn.width,
                gn.height,
                gn.depth,
                Rn,
                qn,
                gn.data
              ))
          : o.texImage3D(
              s.TEXTURE_3D,
              0,
              Wn,
              gn.width,
              gn.height,
              gn.depth,
              0,
              Rn,
              qn,
              gn.data
            );
      else if (wt.isFramebufferTexture) {
        if (In)
          if (un) o.texStorage2D(s.TEXTURE_2D, dn, Wn, gn.width, gn.height);
          else {
            let an = gn.width,
              hn = gn.height;
            for (let Mn = 0; Mn < dn; Mn++)
              o.texImage2D(s.TEXTURE_2D, Mn, Wn, an, hn, 0, Rn, qn, null),
                (an >>= 1),
                (hn >>= 1);
          }
      } else if (Vt.length > 0) {
        if (un && In) {
          const an = An(Vt[0]);
          o.texStorage2D(s.TEXTURE_2D, dn, Wn, an.width, an.height);
        }
        for (let an = 0, hn = Vt.length; an < hn; an++)
          (kn = Vt[an]),
            un
              ? Ut && o.texSubImage2D(s.TEXTURE_2D, an, 0, 0, Rn, qn, kn)
              : o.texImage2D(s.TEXTURE_2D, an, Wn, Rn, qn, kn);
        wt.generateMipmaps = !1;
      } else if (un) {
        if (In) {
          const an = An(gn);
          o.texStorage2D(s.TEXTURE_2D, dn, Wn, an.width, an.height);
        }
        Ut && o.texSubImage2D(s.TEXTURE_2D, 0, 0, 0, Rn, qn, gn);
      } else o.texImage2D(s.TEXTURE_2D, 0, Wn, Rn, qn, gn);
      ct(wt) && it(on),
        (bn.__version = cn.version),
        wt.onUpdate && wt.onUpdate(wt);
    }
    kt.__version = wt.version;
  }
  function Pt(kt, wt, Kt) {
    if (wt.image.length !== 6) return;
    const on = Dt(kt, wt),
      sn = wt.source;
    o.bindTexture(s.TEXTURE_CUBE_MAP, kt.__webglTexture, s.TEXTURE0 + Kt);
    const cn = a.get(sn);
    if (sn.version !== cn.__version || on === !0) {
      o.activeTexture(s.TEXTURE0 + Kt);
      const bn = ColorManagement.getPrimaries(
          ColorManagement.workingColorSpace
        ),
        vn =
          wt.colorSpace === NoColorSpace
            ? null
            : ColorManagement.getPrimaries(wt.colorSpace),
        wn =
          wt.colorSpace === NoColorSpace || bn === vn
            ? s.NONE
            : s.BROWSER_DEFAULT_WEBGL;
      s.pixelStorei(s.UNPACK_FLIP_Y_WEBGL, wt.flipY),
        s.pixelStorei(s.UNPACK_PREMULTIPLY_ALPHA_WEBGL, wt.premultiplyAlpha),
        s.pixelStorei(s.UNPACK_ALIGNMENT, wt.unpackAlignment),
        s.pixelStorei(s.UNPACK_COLORSPACE_CONVERSION_WEBGL, wn);
      const zn = wt.isCompressedTexture || wt.image[0].isCompressedTexture,
        gn = wt.image[0] && wt.image[0].isDataTexture,
        Rn = [];
      for (let hn = 0; hn < 6; hn++)
        !zn && !gn
          ? (Rn[hn] = at(wt.image[hn], !0, c.maxCubemapSize))
          : (Rn[hn] = gn ? wt.image[hn].image : wt.image[hn]),
          (Rn[hn] = xn(wt, Rn[hn]));
      const qn = Rn[0],
        Wn = d.convert(wt.format, wt.colorSpace),
        kn = d.convert(wt.type),
        Vt = lt(wt.internalFormat, Wn, kn, wt.colorSpace),
        un = wt.isVideoTexture !== !0,
        In = cn.__version === void 0 || on === !0,
        Ut = sn.dataReady;
      let dn = ut(wt, qn);
      Tt(s.TEXTURE_CUBE_MAP, wt);
      let an;
      if (zn) {
        un &&
          In &&
          o.texStorage2D(s.TEXTURE_CUBE_MAP, dn, Vt, qn.width, qn.height);
        for (let hn = 0; hn < 6; hn++) {
          an = Rn[hn].mipmaps;
          for (let Mn = 0; Mn < an.length; Mn++) {
            const $n = an[Mn];
            wt.format !== RGBAFormat
              ? Wn !== null
                ? un
                  ? Ut &&
                    o.compressedTexSubImage2D(
                      s.TEXTURE_CUBE_MAP_POSITIVE_X + hn,
                      Mn,
                      0,
                      0,
                      $n.width,
                      $n.height,
                      Wn,
                      $n.data
                    )
                  : o.compressedTexImage2D(
                      s.TEXTURE_CUBE_MAP_POSITIVE_X + hn,
                      Mn,
                      Vt,
                      $n.width,
                      $n.height,
                      0,
                      $n.data
                    )
                : console.warn(
                    "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()"
                  )
              : un
              ? Ut &&
                o.texSubImage2D(
                  s.TEXTURE_CUBE_MAP_POSITIVE_X + hn,
                  Mn,
                  0,
                  0,
                  $n.width,
                  $n.height,
                  Wn,
                  kn,
                  $n.data
                )
              : o.texImage2D(
                  s.TEXTURE_CUBE_MAP_POSITIVE_X + hn,
                  Mn,
                  Vt,
                  $n.width,
                  $n.height,
                  0,
                  Wn,
                  kn,
                  $n.data
                );
          }
        }
      } else {
        if (((an = wt.mipmaps), un && In)) {
          an.length > 0 && dn++;
          const hn = An(Rn[0]);
          o.texStorage2D(s.TEXTURE_CUBE_MAP, dn, Vt, hn.width, hn.height);
        }
        for (let hn = 0; hn < 6; hn++)
          if (gn) {
            un
              ? Ut &&
                o.texSubImage2D(
                  s.TEXTURE_CUBE_MAP_POSITIVE_X + hn,
                  0,
                  0,
                  0,
                  Rn[hn].width,
                  Rn[hn].height,
                  Wn,
                  kn,
                  Rn[hn].data
                )
              : o.texImage2D(
                  s.TEXTURE_CUBE_MAP_POSITIVE_X + hn,
                  0,
                  Vt,
                  Rn[hn].width,
                  Rn[hn].height,
                  0,
                  Wn,
                  kn,
                  Rn[hn].data
                );
            for (let Mn = 0; Mn < an.length; Mn++) {
              const Yn = an[Mn].image[hn].image;
              un
                ? Ut &&
                  o.texSubImage2D(
                    s.TEXTURE_CUBE_MAP_POSITIVE_X + hn,
                    Mn + 1,
                    0,
                    0,
                    Yn.width,
                    Yn.height,
                    Wn,
                    kn,
                    Yn.data
                  )
                : o.texImage2D(
                    s.TEXTURE_CUBE_MAP_POSITIVE_X + hn,
                    Mn + 1,
                    Vt,
                    Yn.width,
                    Yn.height,
                    0,
                    Wn,
                    kn,
                    Yn.data
                  );
            }
          } else {
            un
              ? Ut &&
                o.texSubImage2D(
                  s.TEXTURE_CUBE_MAP_POSITIVE_X + hn,
                  0,
                  0,
                  0,
                  Wn,
                  kn,
                  Rn[hn]
                )
              : o.texImage2D(
                  s.TEXTURE_CUBE_MAP_POSITIVE_X + hn,
                  0,
                  Vt,
                  Wn,
                  kn,
                  Rn[hn]
                );
            for (let Mn = 0; Mn < an.length; Mn++) {
              const $n = an[Mn];
              un
                ? Ut &&
                  o.texSubImage2D(
                    s.TEXTURE_CUBE_MAP_POSITIVE_X + hn,
                    Mn + 1,
                    0,
                    0,
                    Wn,
                    kn,
                    $n.image[hn]
                  )
                : o.texImage2D(
                    s.TEXTURE_CUBE_MAP_POSITIVE_X + hn,
                    Mn + 1,
                    Vt,
                    Wn,
                    kn,
                    $n.image[hn]
                  );
            }
          }
      }
      ct(wt) && it(s.TEXTURE_CUBE_MAP),
        (cn.__version = sn.version),
        wt.onUpdate && wt.onUpdate(wt);
    }
    kt.__version = wt.version;
  }
  function Jt(kt, wt, Kt, on, sn, cn) {
    const bn = d.convert(Kt.format, Kt.colorSpace),
      vn = d.convert(Kt.type),
      wn = lt(Kt.internalFormat, bn, vn, Kt.colorSpace);
    if (!a.get(wt).__hasExternalTextures) {
      const gn = Math.max(1, wt.width >> cn),
        Rn = Math.max(1, wt.height >> cn);
      sn === s.TEXTURE_3D || sn === s.TEXTURE_2D_ARRAY
        ? o.texImage3D(sn, cn, wn, gn, Rn, wt.depth, 0, bn, vn, null)
        : o.texImage2D(sn, cn, wn, gn, Rn, 0, bn, vn, null);
    }
    o.bindFramebuffer(s.FRAMEBUFFER, kt),
      nn(wt)
        ? _.framebufferTexture2DMultisampleEXT(
            s.FRAMEBUFFER,
            on,
            sn,
            a.get(Kt).__webglTexture,
            0,
            yn(wt)
          )
        : (sn === s.TEXTURE_2D ||
            (sn >= s.TEXTURE_CUBE_MAP_POSITIVE_X &&
              sn <= s.TEXTURE_CUBE_MAP_NEGATIVE_Z)) &&
          s.framebufferTexture2D(
            s.FRAMEBUFFER,
            on,
            sn,
            a.get(Kt).__webglTexture,
            cn
          ),
      o.bindFramebuffer(s.FRAMEBUFFER, null);
  }
  function Gt(kt, wt, Kt) {
    if ((s.bindRenderbuffer(s.RENDERBUFFER, kt), wt.depthBuffer)) {
      const on = wt.depthTexture,
        sn = on && on.isDepthTexture ? on.type : null,
        cn = ot(wt.stencilBuffer, sn),
        bn = wt.stencilBuffer ? s.DEPTH_STENCIL_ATTACHMENT : s.DEPTH_ATTACHMENT,
        vn = yn(wt);
      nn(wt)
        ? _.renderbufferStorageMultisampleEXT(
            s.RENDERBUFFER,
            vn,
            cn,
            wt.width,
            wt.height
          )
        : Kt
        ? s.renderbufferStorageMultisample(
            s.RENDERBUFFER,
            vn,
            cn,
            wt.width,
            wt.height
          )
        : s.renderbufferStorage(s.RENDERBUFFER, cn, wt.width, wt.height),
        s.framebufferRenderbuffer(s.FRAMEBUFFER, bn, s.RENDERBUFFER, kt);
    } else {
      const on = wt.textures;
      for (let sn = 0; sn < on.length; sn++) {
        const cn = on[sn],
          bn = d.convert(cn.format, cn.colorSpace),
          vn = d.convert(cn.type),
          wn = lt(cn.internalFormat, bn, vn, cn.colorSpace),
          zn = yn(wt);
        Kt && nn(wt) === !1
          ? s.renderbufferStorageMultisample(
              s.RENDERBUFFER,
              zn,
              wn,
              wt.width,
              wt.height
            )
          : nn(wt)
          ? _.renderbufferStorageMultisampleEXT(
              s.RENDERBUFFER,
              zn,
              wn,
              wt.width,
              wt.height
            )
          : s.renderbufferStorage(s.RENDERBUFFER, wn, wt.width, wt.height);
      }
    }
    s.bindRenderbuffer(s.RENDERBUFFER, null);
  }
  function en(kt, wt) {
    if (wt && wt.isWebGLCubeRenderTarget)
      throw new Error(
        "Depth Texture with cube render targets is not supported"
      );
    if (
      (o.bindFramebuffer(s.FRAMEBUFFER, kt),
      !(wt.depthTexture && wt.depthTexture.isDepthTexture))
    )
      throw new Error(
        "renderTarget.depthTexture must be an instance of THREE.DepthTexture"
      );
    (!a.get(wt.depthTexture).__webglTexture ||
      wt.depthTexture.image.width !== wt.width ||
      wt.depthTexture.image.height !== wt.height) &&
      ((wt.depthTexture.image.width = wt.width),
      (wt.depthTexture.image.height = wt.height),
      (wt.depthTexture.needsUpdate = !0)),
      Ot(wt.depthTexture, 0);
    const on = a.get(wt.depthTexture).__webglTexture,
      sn = yn(wt);
    if (wt.depthTexture.format === DepthFormat)
      nn(wt)
        ? _.framebufferTexture2DMultisampleEXT(
            s.FRAMEBUFFER,
            s.DEPTH_ATTACHMENT,
            s.TEXTURE_2D,
            on,
            0,
            sn
          )
        : s.framebufferTexture2D(
            s.FRAMEBUFFER,
            s.DEPTH_ATTACHMENT,
            s.TEXTURE_2D,
            on,
            0
          );
    else if (wt.depthTexture.format === DepthStencilFormat)
      nn(wt)
        ? _.framebufferTexture2DMultisampleEXT(
            s.FRAMEBUFFER,
            s.DEPTH_STENCIL_ATTACHMENT,
            s.TEXTURE_2D,
            on,
            0,
            sn
          )
        : s.framebufferTexture2D(
            s.FRAMEBUFFER,
            s.DEPTH_STENCIL_ATTACHMENT,
            s.TEXTURE_2D,
            on,
            0
          );
    else throw new Error("Unknown depthTexture format");
  }
  function _n(kt) {
    const wt = a.get(kt),
      Kt = kt.isWebGLCubeRenderTarget === !0;
    if (kt.depthTexture && !wt.__autoAllocateDepthBuffer) {
      if (Kt)
        throw new Error(
          "target.depthTexture not supported in Cube render targets"
        );
      en(wt.__webglFramebuffer, kt);
    } else if (Kt) {
      wt.__webglDepthbuffer = [];
      for (let on = 0; on < 6; on++)
        o.bindFramebuffer(s.FRAMEBUFFER, wt.__webglFramebuffer[on]),
          (wt.__webglDepthbuffer[on] = s.createRenderbuffer()),
          Gt(wt.__webglDepthbuffer[on], kt, !1);
    } else
      o.bindFramebuffer(s.FRAMEBUFFER, wt.__webglFramebuffer),
        (wt.__webglDepthbuffer = s.createRenderbuffer()),
        Gt(wt.__webglDepthbuffer, kt, !1);
    o.bindFramebuffer(s.FRAMEBUFFER, null);
  }
  function Tn(kt, wt, Kt) {
    const on = a.get(kt);
    wt !== void 0 &&
      Jt(
        on.__webglFramebuffer,
        kt,
        kt.texture,
        s.COLOR_ATTACHMENT0,
        s.TEXTURE_2D,
        0
      ),
      Kt !== void 0 && _n(kt);
  }
  function fn(kt) {
    const wt = kt.texture,
      Kt = a.get(kt),
      on = a.get(wt);
    kt.addEventListener("dispose", ft);
    const sn = kt.textures,
      cn = kt.isWebGLCubeRenderTarget === !0,
      bn = sn.length > 1;
    if (
      (bn ||
        (on.__webglTexture === void 0 &&
          (on.__webglTexture = s.createTexture()),
        (on.__version = wt.version),
        g.memory.textures++),
      cn)
    ) {
      Kt.__webglFramebuffer = [];
      for (let vn = 0; vn < 6; vn++)
        if (wt.mipmaps && wt.mipmaps.length > 0) {
          Kt.__webglFramebuffer[vn] = [];
          for (let wn = 0; wn < wt.mipmaps.length; wn++)
            Kt.__webglFramebuffer[vn][wn] = s.createFramebuffer();
        } else Kt.__webglFramebuffer[vn] = s.createFramebuffer();
    } else {
      if (wt.mipmaps && wt.mipmaps.length > 0) {
        Kt.__webglFramebuffer = [];
        for (let vn = 0; vn < wt.mipmaps.length; vn++)
          Kt.__webglFramebuffer[vn] = s.createFramebuffer();
      } else Kt.__webglFramebuffer = s.createFramebuffer();
      if (bn)
        for (let vn = 0, wn = sn.length; vn < wn; vn++) {
          const zn = a.get(sn[vn]);
          zn.__webglTexture === void 0 &&
            ((zn.__webglTexture = s.createTexture()), g.memory.textures++);
        }
      if (kt.samples > 0 && nn(kt) === !1) {
        (Kt.__webglMultisampledFramebuffer = s.createFramebuffer()),
          (Kt.__webglColorRenderbuffer = []),
          o.bindFramebuffer(s.FRAMEBUFFER, Kt.__webglMultisampledFramebuffer);
        for (let vn = 0; vn < sn.length; vn++) {
          const wn = sn[vn];
          (Kt.__webglColorRenderbuffer[vn] = s.createRenderbuffer()),
            s.bindRenderbuffer(s.RENDERBUFFER, Kt.__webglColorRenderbuffer[vn]);
          const zn = d.convert(wn.format, wn.colorSpace),
            gn = d.convert(wn.type),
            Rn = lt(
              wn.internalFormat,
              zn,
              gn,
              wn.colorSpace,
              kt.isXRRenderTarget === !0
            ),
            qn = yn(kt);
          s.renderbufferStorageMultisample(
            s.RENDERBUFFER,
            qn,
            Rn,
            kt.width,
            kt.height
          ),
            s.framebufferRenderbuffer(
              s.FRAMEBUFFER,
              s.COLOR_ATTACHMENT0 + vn,
              s.RENDERBUFFER,
              Kt.__webglColorRenderbuffer[vn]
            );
        }
        s.bindRenderbuffer(s.RENDERBUFFER, null),
          kt.depthBuffer &&
            ((Kt.__webglDepthRenderbuffer = s.createRenderbuffer()),
            Gt(Kt.__webglDepthRenderbuffer, kt, !0)),
          o.bindFramebuffer(s.FRAMEBUFFER, null);
      }
    }
    if (cn) {
      o.bindTexture(s.TEXTURE_CUBE_MAP, on.__webglTexture),
        Tt(s.TEXTURE_CUBE_MAP, wt);
      for (let vn = 0; vn < 6; vn++)
        if (wt.mipmaps && wt.mipmaps.length > 0)
          for (let wn = 0; wn < wt.mipmaps.length; wn++)
            Jt(
              Kt.__webglFramebuffer[vn][wn],
              kt,
              wt,
              s.COLOR_ATTACHMENT0,
              s.TEXTURE_CUBE_MAP_POSITIVE_X + vn,
              wn
            );
        else
          Jt(
            Kt.__webglFramebuffer[vn],
            kt,
            wt,
            s.COLOR_ATTACHMENT0,
            s.TEXTURE_CUBE_MAP_POSITIVE_X + vn,
            0
          );
      ct(wt) && it(s.TEXTURE_CUBE_MAP), o.unbindTexture();
    } else if (bn) {
      for (let vn = 0, wn = sn.length; vn < wn; vn++) {
        const zn = sn[vn],
          gn = a.get(zn);
        o.bindTexture(s.TEXTURE_2D, gn.__webglTexture),
          Tt(s.TEXTURE_2D, zn),
          Jt(
            Kt.__webglFramebuffer,
            kt,
            zn,
            s.COLOR_ATTACHMENT0 + vn,
            s.TEXTURE_2D,
            0
          ),
          ct(zn) && it(s.TEXTURE_2D);
      }
      o.unbindTexture();
    } else {
      let vn = s.TEXTURE_2D;
      if (
        ((kt.isWebGL3DRenderTarget || kt.isWebGLArrayRenderTarget) &&
          (vn = kt.isWebGL3DRenderTarget ? s.TEXTURE_3D : s.TEXTURE_2D_ARRAY),
        o.bindTexture(vn, on.__webglTexture),
        Tt(vn, wt),
        wt.mipmaps && wt.mipmaps.length > 0)
      )
        for (let wn = 0; wn < wt.mipmaps.length; wn++)
          Jt(Kt.__webglFramebuffer[wn], kt, wt, s.COLOR_ATTACHMENT0, vn, wn);
      else Jt(Kt.__webglFramebuffer, kt, wt, s.COLOR_ATTACHMENT0, vn, 0);
      ct(wt) && it(vn), o.unbindTexture();
    }
    kt.depthBuffer && _n(kt);
  }
  function pn(kt) {
    const wt = kt.textures;
    for (let Kt = 0, on = wt.length; Kt < on; Kt++) {
      const sn = wt[Kt];
      if (ct(sn)) {
        const cn = kt.isWebGLCubeRenderTarget
            ? s.TEXTURE_CUBE_MAP
            : s.TEXTURE_2D,
          bn = a.get(sn).__webglTexture;
        o.bindTexture(cn, bn), it(cn), o.unbindTexture();
      }
    }
  }
  const Bt = [],
    qt = [];
  function $t(kt) {
    if (kt.samples > 0) {
      if (nn(kt) === !1) {
        const wt = kt.textures,
          Kt = kt.width,
          on = kt.height;
        let sn = s.COLOR_BUFFER_BIT;
        const cn = kt.stencilBuffer
            ? s.DEPTH_STENCIL_ATTACHMENT
            : s.DEPTH_ATTACHMENT,
          bn = a.get(kt),
          vn = wt.length > 1;
        if (vn)
          for (let wn = 0; wn < wt.length; wn++)
            o.bindFramebuffer(s.FRAMEBUFFER, bn.__webglMultisampledFramebuffer),
              s.framebufferRenderbuffer(
                s.FRAMEBUFFER,
                s.COLOR_ATTACHMENT0 + wn,
                s.RENDERBUFFER,
                null
              ),
              o.bindFramebuffer(s.FRAMEBUFFER, bn.__webglFramebuffer),
              s.framebufferTexture2D(
                s.DRAW_FRAMEBUFFER,
                s.COLOR_ATTACHMENT0 + wn,
                s.TEXTURE_2D,
                null,
                0
              );
        o.bindFramebuffer(
          s.READ_FRAMEBUFFER,
          bn.__webglMultisampledFramebuffer
        ),
          o.bindFramebuffer(s.DRAW_FRAMEBUFFER, bn.__webglFramebuffer);
        for (let wn = 0; wn < wt.length; wn++) {
          if (
            (kt.resolveDepthBuffer &&
              (kt.depthBuffer && (sn |= s.DEPTH_BUFFER_BIT),
              kt.stencilBuffer &&
                kt.resolveStencilBuffer &&
                (sn |= s.STENCIL_BUFFER_BIT)),
            vn)
          ) {
            s.framebufferRenderbuffer(
              s.READ_FRAMEBUFFER,
              s.COLOR_ATTACHMENT0,
              s.RENDERBUFFER,
              bn.__webglColorRenderbuffer[wn]
            );
            const zn = a.get(wt[wn]).__webglTexture;
            s.framebufferTexture2D(
              s.DRAW_FRAMEBUFFER,
              s.COLOR_ATTACHMENT0,
              s.TEXTURE_2D,
              zn,
              0
            );
          }
          s.blitFramebuffer(0, 0, Kt, on, 0, 0, Kt, on, sn, s.NEAREST),
            b === !0 &&
              ((Bt.length = 0),
              (qt.length = 0),
              Bt.push(s.COLOR_ATTACHMENT0 + wn),
              kt.depthBuffer &&
                kt.resolveDepthBuffer === !1 &&
                (Bt.push(cn),
                qt.push(cn),
                s.invalidateFramebuffer(s.DRAW_FRAMEBUFFER, qt)),
              s.invalidateFramebuffer(s.READ_FRAMEBUFFER, Bt));
        }
        if (
          (o.bindFramebuffer(s.READ_FRAMEBUFFER, null),
          o.bindFramebuffer(s.DRAW_FRAMEBUFFER, null),
          vn)
        )
          for (let wn = 0; wn < wt.length; wn++) {
            o.bindFramebuffer(s.FRAMEBUFFER, bn.__webglMultisampledFramebuffer),
              s.framebufferRenderbuffer(
                s.FRAMEBUFFER,
                s.COLOR_ATTACHMENT0 + wn,
                s.RENDERBUFFER,
                bn.__webglColorRenderbuffer[wn]
              );
            const zn = a.get(wt[wn]).__webglTexture;
            o.bindFramebuffer(s.FRAMEBUFFER, bn.__webglFramebuffer),
              s.framebufferTexture2D(
                s.DRAW_FRAMEBUFFER,
                s.COLOR_ATTACHMENT0 + wn,
                s.TEXTURE_2D,
                zn,
                0
              );
          }
        o.bindFramebuffer(
          s.DRAW_FRAMEBUFFER,
          bn.__webglMultisampledFramebuffer
        );
      } else if (kt.depthBuffer && kt.resolveDepthBuffer === !1 && b) {
        const wt = kt.stencilBuffer
          ? s.DEPTH_STENCIL_ATTACHMENT
          : s.DEPTH_ATTACHMENT;
        s.invalidateFramebuffer(s.DRAW_FRAMEBUFFER, [wt]);
      }
    }
  }
  function yn(kt) {
    return Math.min(c.maxSamples, kt.samples);
  }
  function nn(kt) {
    const wt = a.get(kt);
    return (
      kt.samples > 0 &&
      e.has("WEBGL_multisampled_render_to_texture") === !0 &&
      wt.__useRenderToTexture !== !1
    );
  }
  function Pn(kt) {
    const wt = g.render.frame;
    $.get(kt) !== wt && ($.set(kt, wt), kt.update());
  }
  function xn(kt, wt) {
    const Kt = kt.colorSpace,
      on = kt.format,
      sn = kt.type;
    return (
      kt.isCompressedTexture === !0 ||
        kt.isVideoTexture === !0 ||
        (Kt !== LinearSRGBColorSpace$1 &&
          Kt !== NoColorSpace &&
          (ColorManagement.getTransfer(Kt) === SRGBTransfer
            ? (on !== RGBAFormat || sn !== UnsignedByteType) &&
              console.warn(
                "THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType."
              )
            : console.error(
                "THREE.WebGLTextures: Unsupported texture color space:",
                Kt
              ))),
      wt
    );
  }
  function An(kt) {
    return (
      typeof HTMLImageElement < "u" && kt instanceof HTMLImageElement
        ? ((j.width = kt.naturalWidth || kt.width),
          (j.height = kt.naturalHeight || kt.height))
        : typeof VideoFrame < "u" && kt instanceof VideoFrame
        ? ((j.width = kt.displayWidth), (j.height = kt.displayHeight))
        : ((j.width = kt.width), (j.height = kt.height)),
      j
    );
  }
  (this.allocateTextureUnit = Rt),
    (this.resetTextureUnits = Mt),
    (this.setTexture2D = Ot),
    (this.setTexture2DArray = Lt),
    (this.setTexture3D = Et),
    (this.setTextureCube = bt),
    (this.rebindTextures = Tn),
    (this.setupRenderTarget = fn),
    (this.updateRenderTargetMipmap = pn),
    (this.updateMultisampleRenderTarget = $t),
    (this.setupDepthRenderbuffer = _n),
    (this.setupFrameBufferTexture = Jt),
    (this.useMultisampledRTT = nn);
}
function WebGLUtils(s, e) {
  function o(a, c = NoColorSpace) {
    let d;
    const g = ColorManagement.getTransfer(c);
    if (a === UnsignedByteType) return s.UNSIGNED_BYTE;
    if (a === UnsignedShort4444Type) return s.UNSIGNED_SHORT_4_4_4_4;
    if (a === UnsignedShort5551Type) return s.UNSIGNED_SHORT_5_5_5_1;
    if (a === UnsignedInt5999Type) return s.UNSIGNED_INT_5_9_9_9_REV;
    if (a === ByteType) return s.BYTE;
    if (a === ShortType) return s.SHORT;
    if (a === UnsignedShortType) return s.UNSIGNED_SHORT;
    if (a === IntType) return s.INT;
    if (a === UnsignedIntType) return s.UNSIGNED_INT;
    if (a === FloatType) return s.FLOAT;
    if (a === HalfFloatType) return s.HALF_FLOAT;
    if (a === AlphaFormat) return s.ALPHA;
    if (a === RGBFormat) return s.RGB;
    if (a === RGBAFormat) return s.RGBA;
    if (a === LuminanceFormat) return s.LUMINANCE;
    if (a === LuminanceAlphaFormat) return s.LUMINANCE_ALPHA;
    if (a === DepthFormat) return s.DEPTH_COMPONENT;
    if (a === DepthStencilFormat) return s.DEPTH_STENCIL;
    if (a === RedFormat) return s.RED;
    if (a === RedIntegerFormat) return s.RED_INTEGER;
    if (a === RGFormat) return s.RG;
    if (a === RGIntegerFormat) return s.RG_INTEGER;
    if (a === RGBAIntegerFormat) return s.RGBA_INTEGER;
    if (
      a === RGB_S3TC_DXT1_Format ||
      a === RGBA_S3TC_DXT1_Format ||
      a === RGBA_S3TC_DXT3_Format ||
      a === RGBA_S3TC_DXT5_Format
    )
      if (g === SRGBTransfer)
        if (((d = e.get("WEBGL_compressed_texture_s3tc_srgb")), d !== null)) {
          if (a === RGB_S3TC_DXT1_Format)
            return d.COMPRESSED_SRGB_S3TC_DXT1_EXT;
          if (a === RGBA_S3TC_DXT1_Format)
            return d.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
          if (a === RGBA_S3TC_DXT3_Format)
            return d.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
          if (a === RGBA_S3TC_DXT5_Format)
            return d.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;
        } else return null;
      else if (((d = e.get("WEBGL_compressed_texture_s3tc")), d !== null)) {
        if (a === RGB_S3TC_DXT1_Format) return d.COMPRESSED_RGB_S3TC_DXT1_EXT;
        if (a === RGBA_S3TC_DXT1_Format) return d.COMPRESSED_RGBA_S3TC_DXT1_EXT;
        if (a === RGBA_S3TC_DXT3_Format) return d.COMPRESSED_RGBA_S3TC_DXT3_EXT;
        if (a === RGBA_S3TC_DXT5_Format) return d.COMPRESSED_RGBA_S3TC_DXT5_EXT;
      } else return null;
    if (
      a === RGB_PVRTC_4BPPV1_Format ||
      a === RGB_PVRTC_2BPPV1_Format ||
      a === RGBA_PVRTC_4BPPV1_Format ||
      a === RGBA_PVRTC_2BPPV1_Format
    )
      if (((d = e.get("WEBGL_compressed_texture_pvrtc")), d !== null)) {
        if (a === RGB_PVRTC_4BPPV1_Format)
          return d.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
        if (a === RGB_PVRTC_2BPPV1_Format)
          return d.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
        if (a === RGBA_PVRTC_4BPPV1_Format)
          return d.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
        if (a === RGBA_PVRTC_2BPPV1_Format)
          return d.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
      } else return null;
    if (
      a === RGB_ETC1_Format ||
      a === RGB_ETC2_Format ||
      a === RGBA_ETC2_EAC_Format
    )
      if (((d = e.get("WEBGL_compressed_texture_etc")), d !== null)) {
        if (a === RGB_ETC1_Format || a === RGB_ETC2_Format)
          return g === SRGBTransfer
            ? d.COMPRESSED_SRGB8_ETC2
            : d.COMPRESSED_RGB8_ETC2;
        if (a === RGBA_ETC2_EAC_Format)
          return g === SRGBTransfer
            ? d.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC
            : d.COMPRESSED_RGBA8_ETC2_EAC;
      } else return null;
    if (
      a === RGBA_ASTC_4x4_Format ||
      a === RGBA_ASTC_5x4_Format ||
      a === RGBA_ASTC_5x5_Format ||
      a === RGBA_ASTC_6x5_Format ||
      a === RGBA_ASTC_6x6_Format ||
      a === RGBA_ASTC_8x5_Format ||
      a === RGBA_ASTC_8x6_Format ||
      a === RGBA_ASTC_8x8_Format ||
      a === RGBA_ASTC_10x5_Format ||
      a === RGBA_ASTC_10x6_Format ||
      a === RGBA_ASTC_10x8_Format ||
      a === RGBA_ASTC_10x10_Format ||
      a === RGBA_ASTC_12x10_Format ||
      a === RGBA_ASTC_12x12_Format
    )
      if (((d = e.get("WEBGL_compressed_texture_astc")), d !== null)) {
        if (a === RGBA_ASTC_4x4_Format)
          return g === SRGBTransfer
            ? d.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR
            : d.COMPRESSED_RGBA_ASTC_4x4_KHR;
        if (a === RGBA_ASTC_5x4_Format)
          return g === SRGBTransfer
            ? d.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR
            : d.COMPRESSED_RGBA_ASTC_5x4_KHR;
        if (a === RGBA_ASTC_5x5_Format)
          return g === SRGBTransfer
            ? d.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR
            : d.COMPRESSED_RGBA_ASTC_5x5_KHR;
        if (a === RGBA_ASTC_6x5_Format)
          return g === SRGBTransfer
            ? d.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR
            : d.COMPRESSED_RGBA_ASTC_6x5_KHR;
        if (a === RGBA_ASTC_6x6_Format)
          return g === SRGBTransfer
            ? d.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR
            : d.COMPRESSED_RGBA_ASTC_6x6_KHR;
        if (a === RGBA_ASTC_8x5_Format)
          return g === SRGBTransfer
            ? d.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR
            : d.COMPRESSED_RGBA_ASTC_8x5_KHR;
        if (a === RGBA_ASTC_8x6_Format)
          return g === SRGBTransfer
            ? d.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR
            : d.COMPRESSED_RGBA_ASTC_8x6_KHR;
        if (a === RGBA_ASTC_8x8_Format)
          return g === SRGBTransfer
            ? d.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR
            : d.COMPRESSED_RGBA_ASTC_8x8_KHR;
        if (a === RGBA_ASTC_10x5_Format)
          return g === SRGBTransfer
            ? d.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR
            : d.COMPRESSED_RGBA_ASTC_10x5_KHR;
        if (a === RGBA_ASTC_10x6_Format)
          return g === SRGBTransfer
            ? d.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR
            : d.COMPRESSED_RGBA_ASTC_10x6_KHR;
        if (a === RGBA_ASTC_10x8_Format)
          return g === SRGBTransfer
            ? d.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR
            : d.COMPRESSED_RGBA_ASTC_10x8_KHR;
        if (a === RGBA_ASTC_10x10_Format)
          return g === SRGBTransfer
            ? d.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR
            : d.COMPRESSED_RGBA_ASTC_10x10_KHR;
        if (a === RGBA_ASTC_12x10_Format)
          return g === SRGBTransfer
            ? d.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR
            : d.COMPRESSED_RGBA_ASTC_12x10_KHR;
        if (a === RGBA_ASTC_12x12_Format)
          return g === SRGBTransfer
            ? d.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR
            : d.COMPRESSED_RGBA_ASTC_12x12_KHR;
      } else return null;
    if (
      a === RGBA_BPTC_Format ||
      a === RGB_BPTC_SIGNED_Format ||
      a === RGB_BPTC_UNSIGNED_Format
    )
      if (((d = e.get("EXT_texture_compression_bptc")), d !== null)) {
        if (a === RGBA_BPTC_Format)
          return g === SRGBTransfer
            ? d.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT
            : d.COMPRESSED_RGBA_BPTC_UNORM_EXT;
        if (a === RGB_BPTC_SIGNED_Format)
          return d.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT;
        if (a === RGB_BPTC_UNSIGNED_Format)
          return d.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT;
      } else return null;
    if (
      a === RED_RGTC1_Format ||
      a === SIGNED_RED_RGTC1_Format ||
      a === RED_GREEN_RGTC2_Format ||
      a === SIGNED_RED_GREEN_RGTC2_Format
    )
      if (((d = e.get("EXT_texture_compression_rgtc")), d !== null)) {
        if (a === RGBA_BPTC_Format) return d.COMPRESSED_RED_RGTC1_EXT;
        if (a === SIGNED_RED_RGTC1_Format)
          return d.COMPRESSED_SIGNED_RED_RGTC1_EXT;
        if (a === RED_GREEN_RGTC2_Format)
          return d.COMPRESSED_RED_GREEN_RGTC2_EXT;
        if (a === SIGNED_RED_GREEN_RGTC2_Format)
          return d.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT;
      } else return null;
    return a === UnsignedInt248Type
      ? s.UNSIGNED_INT_24_8
      : s[a] !== void 0
      ? s[a]
      : null;
  }
  return { convert: o };
}
class ArrayCamera extends PerspectiveCamera {
  constructor(e = []) {
    super(), (this.isArrayCamera = !0), (this.cameras = e);
  }
}
class Group extends Object3D {
  constructor() {
    super(), (this.isGroup = !0), (this.type = "Group");
  }
}
const _moveEvent = { type: "move" };
class WebXRController {
  constructor() {
    (this._targetRay = null), (this._grip = null), (this._hand = null);
  }
  getHandSpace() {
    return (
      this._hand === null &&
        ((this._hand = new Group()),
        (this._hand.matrixAutoUpdate = !1),
        (this._hand.visible = !1),
        (this._hand.joints = {}),
        (this._hand.inputState = { pinching: !1 })),
      this._hand
    );
  }
  getTargetRaySpace() {
    return (
      this._targetRay === null &&
        ((this._targetRay = new Group()),
        (this._targetRay.matrixAutoUpdate = !1),
        (this._targetRay.visible = !1),
        (this._targetRay.hasLinearVelocity = !1),
        (this._targetRay.linearVelocity = new Vector3()),
        (this._targetRay.hasAngularVelocity = !1),
        (this._targetRay.angularVelocity = new Vector3())),
      this._targetRay
    );
  }
  getGripSpace() {
    return (
      this._grip === null &&
        ((this._grip = new Group()),
        (this._grip.matrixAutoUpdate = !1),
        (this._grip.visible = !1),
        (this._grip.hasLinearVelocity = !1),
        (this._grip.linearVelocity = new Vector3()),
        (this._grip.hasAngularVelocity = !1),
        (this._grip.angularVelocity = new Vector3())),
      this._grip
    );
  }
  dispatchEvent(e) {
    return (
      this._targetRay !== null && this._targetRay.dispatchEvent(e),
      this._grip !== null && this._grip.dispatchEvent(e),
      this._hand !== null && this._hand.dispatchEvent(e),
      this
    );
  }
  connect(e) {
    if (e && e.hand) {
      const o = this._hand;
      if (o) for (const a of e.hand.values()) this._getHandJoint(o, a);
    }
    return this.dispatchEvent({ type: "connected", data: e }), this;
  }
  disconnect(e) {
    return (
      this.dispatchEvent({ type: "disconnected", data: e }),
      this._targetRay !== null && (this._targetRay.visible = !1),
      this._grip !== null && (this._grip.visible = !1),
      this._hand !== null && (this._hand.visible = !1),
      this
    );
  }
  update(e, o, a) {
    let c = null,
      d = null,
      g = null;
    const _ = this._targetRay,
      b = this._grip,
      j = this._hand;
    if (e && o.session.visibilityState !== "visible-blurred") {
      if (j && e.hand) {
        g = !0;
        for (const at of e.hand.values()) {
          const ct = o.getJointPose(at, a),
            it = this._getHandJoint(j, at);
          ct !== null &&
            (it.matrix.fromArray(ct.transform.matrix),
            it.matrix.decompose(it.position, it.rotation, it.scale),
            (it.matrixWorldNeedsUpdate = !0),
            (it.jointRadius = ct.radius)),
            (it.visible = ct !== null);
        }
        const $ = j.joints["index-finger-tip"],
          _e = j.joints["thumb-tip"],
          et = $.position.distanceTo(_e.position),
          rt = 0.02,
          st = 0.005;
        j.inputState.pinching && et > rt + st
          ? ((j.inputState.pinching = !1),
            this.dispatchEvent({
              type: "pinchend",
              handedness: e.handedness,
              target: this,
            }))
          : !j.inputState.pinching &&
            et <= rt - st &&
            ((j.inputState.pinching = !0),
            this.dispatchEvent({
              type: "pinchstart",
              handedness: e.handedness,
              target: this,
            }));
      } else
        b !== null &&
          e.gripSpace &&
          ((d = o.getPose(e.gripSpace, a)),
          d !== null &&
            (b.matrix.fromArray(d.transform.matrix),
            b.matrix.decompose(b.position, b.rotation, b.scale),
            (b.matrixWorldNeedsUpdate = !0),
            d.linearVelocity
              ? ((b.hasLinearVelocity = !0),
                b.linearVelocity.copy(d.linearVelocity))
              : (b.hasLinearVelocity = !1),
            d.angularVelocity
              ? ((b.hasAngularVelocity = !0),
                b.angularVelocity.copy(d.angularVelocity))
              : (b.hasAngularVelocity = !1)));
      _ !== null &&
        ((c = o.getPose(e.targetRaySpace, a)),
        c === null && d !== null && (c = d),
        c !== null &&
          (_.matrix.fromArray(c.transform.matrix),
          _.matrix.decompose(_.position, _.rotation, _.scale),
          (_.matrixWorldNeedsUpdate = !0),
          c.linearVelocity
            ? ((_.hasLinearVelocity = !0),
              _.linearVelocity.copy(c.linearVelocity))
            : (_.hasLinearVelocity = !1),
          c.angularVelocity
            ? ((_.hasAngularVelocity = !0),
              _.angularVelocity.copy(c.angularVelocity))
            : (_.hasAngularVelocity = !1),
          this.dispatchEvent(_moveEvent)));
    }
    return (
      _ !== null && (_.visible = c !== null),
      b !== null && (b.visible = d !== null),
      j !== null && (j.visible = g !== null),
      this
    );
  }
  _getHandJoint(e, o) {
    if (e.joints[o.jointName] === void 0) {
      const a = new Group();
      (a.matrixAutoUpdate = !1),
        (a.visible = !1),
        (e.joints[o.jointName] = a),
        e.add(a);
    }
    return e.joints[o.jointName];
  }
}
const _occlusion_vertex = `
void main() {

	gl_Position = vec4( position, 1.0 );

}`,
  _occlusion_fragment = `
uniform sampler2DArray depthColor;
uniform float depthWidth;
uniform float depthHeight;

void main() {

	vec2 coord = vec2( gl_FragCoord.x / depthWidth, gl_FragCoord.y / depthHeight );

	if ( coord.x >= 1.0 ) {

		gl_FragDepth = texture( depthColor, vec3( coord.x - 1.0, coord.y, 1 ) ).r;

	} else {

		gl_FragDepth = texture( depthColor, vec3( coord.x, coord.y, 0 ) ).r;

	}

}`;
class WebXRDepthSensing {
  constructor() {
    (this.texture = null),
      (this.mesh = null),
      (this.depthNear = 0),
      (this.depthFar = 0);
  }
  init(e, o, a) {
    if (this.texture === null) {
      const c = new Texture(),
        d = e.properties.get(c);
      (d.__webglTexture = o.texture),
        (o.depthNear != a.depthNear || o.depthFar != a.depthFar) &&
          ((this.depthNear = o.depthNear), (this.depthFar = o.depthFar)),
        (this.texture = c);
    }
  }
  getMesh(e) {
    if (this.texture !== null && this.mesh === null) {
      const o = e.cameras[0].viewport,
        a = new ShaderMaterial({
          vertexShader: _occlusion_vertex,
          fragmentShader: _occlusion_fragment,
          uniforms: {
            depthColor: { value: this.texture },
            depthWidth: { value: o.z },
            depthHeight: { value: o.w },
          },
        });
      this.mesh = new Mesh(new PlaneGeometry(20, 20), a);
    }
    return this.mesh;
  }
  reset() {
    (this.texture = null), (this.mesh = null);
  }
  getDepthTexture() {
    return this.texture;
  }
}
class WebXRManager extends EventDispatcher {
  constructor(e, o) {
    super();
    const a = this;
    let c = null,
      d = 1,
      g = null,
      _ = "local-floor",
      b = 1,
      j = null,
      $ = null,
      _e = null,
      et = null,
      rt = null,
      st = null;
    const at = new WebXRDepthSensing(),
      ct = o.getContextAttributes();
    let it = null,
      lt = null;
    const ot = [],
      ut = [],
      pt = new Vector2();
    let ft = null;
    const gt = new PerspectiveCamera();
    gt.layers.enable(1), (gt.viewport = new Vector4());
    const xt = new PerspectiveCamera();
    xt.layers.enable(2), (xt.viewport = new Vector4());
    const _t = [gt, xt],
      St = new ArrayCamera();
    St.layers.enable(1), St.layers.enable(2);
    let Mt = null,
      Rt = null;
    (this.cameraAutoUpdate = !0),
      (this.enabled = !1),
      (this.isPresenting = !1),
      (this.getController = function (Pt) {
        let Jt = ot[Pt];
        return (
          Jt === void 0 && ((Jt = new WebXRController()), (ot[Pt] = Jt)),
          Jt.getTargetRaySpace()
        );
      }),
      (this.getControllerGrip = function (Pt) {
        let Jt = ot[Pt];
        return (
          Jt === void 0 && ((Jt = new WebXRController()), (ot[Pt] = Jt)),
          Jt.getGripSpace()
        );
      }),
      (this.getHand = function (Pt) {
        let Jt = ot[Pt];
        return (
          Jt === void 0 && ((Jt = new WebXRController()), (ot[Pt] = Jt)),
          Jt.getHandSpace()
        );
      });
    function Ft(Pt) {
      const Jt = ut.indexOf(Pt.inputSource);
      if (Jt === -1) return;
      const Gt = ot[Jt];
      Gt !== void 0 &&
        (Gt.update(Pt.inputSource, Pt.frame, j || g),
        Gt.dispatchEvent({ type: Pt.type, data: Pt.inputSource }));
    }
    function Ot() {
      c.removeEventListener("select", Ft),
        c.removeEventListener("selectstart", Ft),
        c.removeEventListener("selectend", Ft),
        c.removeEventListener("squeeze", Ft),
        c.removeEventListener("squeezestart", Ft),
        c.removeEventListener("squeezeend", Ft),
        c.removeEventListener("end", Ot),
        c.removeEventListener("inputsourceschange", Lt);
      for (let Pt = 0; Pt < ot.length; Pt++) {
        const Jt = ut[Pt];
        Jt !== null && ((ut[Pt] = null), ot[Pt].disconnect(Jt));
      }
      (Mt = null),
        (Rt = null),
        at.reset(),
        e.setRenderTarget(it),
        (rt = null),
        (et = null),
        (_e = null),
        (c = null),
        (lt = null),
        Wt.stop(),
        (a.isPresenting = !1),
        e.setPixelRatio(ft),
        e.setSize(pt.width, pt.height, !1),
        a.dispatchEvent({ type: "sessionend" });
    }
    (this.setFramebufferScaleFactor = function (Pt) {
      (d = Pt),
        a.isPresenting === !0 &&
          console.warn(
            "THREE.WebXRManager: Cannot change framebuffer scale while presenting."
          );
    }),
      (this.setReferenceSpaceType = function (Pt) {
        (_ = Pt),
          a.isPresenting === !0 &&
            console.warn(
              "THREE.WebXRManager: Cannot change reference space type while presenting."
            );
      }),
      (this.getReferenceSpace = function () {
        return j || g;
      }),
      (this.setReferenceSpace = function (Pt) {
        j = Pt;
      }),
      (this.getBaseLayer = function () {
        return et !== null ? et : rt;
      }),
      (this.getBinding = function () {
        return _e;
      }),
      (this.getFrame = function () {
        return st;
      }),
      (this.getSession = function () {
        return c;
      }),
      (this.setSession = async function (Pt) {
        if (((c = Pt), c !== null)) {
          if (
            ((it = e.getRenderTarget()),
            c.addEventListener("select", Ft),
            c.addEventListener("selectstart", Ft),
            c.addEventListener("selectend", Ft),
            c.addEventListener("squeeze", Ft),
            c.addEventListener("squeezestart", Ft),
            c.addEventListener("squeezeend", Ft),
            c.addEventListener("end", Ot),
            c.addEventListener("inputsourceschange", Lt),
            ct.xrCompatible !== !0 && (await o.makeXRCompatible()),
            (ft = e.getPixelRatio()),
            e.getSize(pt),
            c.renderState.layers === void 0)
          ) {
            const Jt = {
              antialias: ct.antialias,
              alpha: !0,
              depth: ct.depth,
              stencil: ct.stencil,
              framebufferScaleFactor: d,
            };
            (rt = new XRWebGLLayer(c, o, Jt)),
              c.updateRenderState({ baseLayer: rt }),
              e.setPixelRatio(1),
              e.setSize(rt.framebufferWidth, rt.framebufferHeight, !1),
              (lt = new WebGLRenderTarget(
                rt.framebufferWidth,
                rt.framebufferHeight,
                {
                  format: RGBAFormat,
                  type: UnsignedByteType,
                  colorSpace: e.outputColorSpace,
                  stencilBuffer: ct.stencil,
                }
              ));
          } else {
            let Jt = null,
              Gt = null,
              en = null;
            ct.depth &&
              ((en = ct.stencil ? o.DEPTH24_STENCIL8 : o.DEPTH_COMPONENT24),
              (Jt = ct.stencil ? DepthStencilFormat : DepthFormat),
              (Gt = ct.stencil ? UnsignedInt248Type : UnsignedIntType));
            const _n = {
              colorFormat: o.RGBA8,
              depthFormat: en,
              scaleFactor: d,
            };
            (_e = new XRWebGLBinding(c, o)),
              (et = _e.createProjectionLayer(_n)),
              c.updateRenderState({ layers: [et] }),
              e.setPixelRatio(1),
              e.setSize(et.textureWidth, et.textureHeight, !1),
              (lt = new WebGLRenderTarget(et.textureWidth, et.textureHeight, {
                format: RGBAFormat,
                type: UnsignedByteType,
                depthTexture: new DepthTexture(
                  et.textureWidth,
                  et.textureHeight,
                  Gt,
                  void 0,
                  void 0,
                  void 0,
                  void 0,
                  void 0,
                  void 0,
                  Jt
                ),
                stencilBuffer: ct.stencil,
                colorSpace: e.outputColorSpace,
                samples: ct.antialias ? 4 : 0,
                resolveDepthBuffer: et.ignoreDepthValues === !1,
              }));
          }
          (lt.isXRRenderTarget = !0),
            this.setFoveation(b),
            (j = null),
            (g = await c.requestReferenceSpace(_)),
            Wt.setContext(c),
            Wt.start(),
            (a.isPresenting = !0),
            a.dispatchEvent({ type: "sessionstart" });
        }
      }),
      (this.getEnvironmentBlendMode = function () {
        if (c !== null) return c.environmentBlendMode;
      }),
      (this.getDepthTexture = function () {
        return at.getDepthTexture();
      });
    function Lt(Pt) {
      for (let Jt = 0; Jt < Pt.removed.length; Jt++) {
        const Gt = Pt.removed[Jt],
          en = ut.indexOf(Gt);
        en >= 0 && ((ut[en] = null), ot[en].disconnect(Gt));
      }
      for (let Jt = 0; Jt < Pt.added.length; Jt++) {
        const Gt = Pt.added[Jt];
        let en = ut.indexOf(Gt);
        if (en === -1) {
          for (let Tn = 0; Tn < ot.length; Tn++)
            if (Tn >= ut.length) {
              ut.push(Gt), (en = Tn);
              break;
            } else if (ut[Tn] === null) {
              (ut[Tn] = Gt), (en = Tn);
              break;
            }
          if (en === -1) break;
        }
        const _n = ot[en];
        _n && _n.connect(Gt);
      }
    }
    const Et = new Vector3(),
      bt = new Vector3();
    function mt(Pt, Jt, Gt) {
      Et.setFromMatrixPosition(Jt.matrixWorld),
        bt.setFromMatrixPosition(Gt.matrixWorld);
      const en = Et.distanceTo(bt),
        _n = Jt.projectionMatrix.elements,
        Tn = Gt.projectionMatrix.elements,
        fn = _n[14] / (_n[10] - 1),
        pn = _n[14] / (_n[10] + 1),
        Bt = (_n[9] + 1) / _n[5],
        qt = (_n[9] - 1) / _n[5],
        $t = (_n[8] - 1) / _n[0],
        yn = (Tn[8] + 1) / Tn[0],
        nn = fn * $t,
        Pn = fn * yn,
        xn = en / (-$t + yn),
        An = xn * -$t;
      Jt.matrixWorld.decompose(Pt.position, Pt.quaternion, Pt.scale),
        Pt.translateX(An),
        Pt.translateZ(xn),
        Pt.matrixWorld.compose(Pt.position, Pt.quaternion, Pt.scale),
        Pt.matrixWorldInverse.copy(Pt.matrixWorld).invert();
      const kt = fn + xn,
        wt = pn + xn,
        Kt = nn - An,
        on = Pn + (en - An),
        sn = ((Bt * pn) / wt) * kt,
        cn = ((qt * pn) / wt) * kt;
      Pt.projectionMatrix.makePerspective(Kt, on, sn, cn, kt, wt),
        Pt.projectionMatrixInverse.copy(Pt.projectionMatrix).invert();
    }
    function vt(Pt, Jt) {
      Jt === null
        ? Pt.matrixWorld.copy(Pt.matrix)
        : Pt.matrixWorld.multiplyMatrices(Jt.matrixWorld, Pt.matrix),
        Pt.matrixWorldInverse.copy(Pt.matrixWorld).invert();
    }
    this.updateCamera = function (Pt) {
      if (c === null) return;
      at.texture !== null && ((Pt.near = at.depthNear), (Pt.far = at.depthFar)),
        (St.near = xt.near = gt.near = Pt.near),
        (St.far = xt.far = gt.far = Pt.far),
        (Mt !== St.near || Rt !== St.far) &&
          (c.updateRenderState({ depthNear: St.near, depthFar: St.far }),
          (Mt = St.near),
          (Rt = St.far),
          (gt.near = Mt),
          (gt.far = Rt),
          (xt.near = Mt),
          (xt.far = Rt),
          gt.updateProjectionMatrix(),
          xt.updateProjectionMatrix(),
          Pt.updateProjectionMatrix());
      const Jt = Pt.parent,
        Gt = St.cameras;
      vt(St, Jt);
      for (let en = 0; en < Gt.length; en++) vt(Gt[en], Jt);
      Gt.length === 2
        ? mt(St, gt, xt)
        : St.projectionMatrix.copy(gt.projectionMatrix),
        Ct(Pt, St, Jt);
    };
    function Ct(Pt, Jt, Gt) {
      Gt === null
        ? Pt.matrix.copy(Jt.matrixWorld)
        : (Pt.matrix.copy(Gt.matrixWorld),
          Pt.matrix.invert(),
          Pt.matrix.multiply(Jt.matrixWorld)),
        Pt.matrix.decompose(Pt.position, Pt.quaternion, Pt.scale),
        Pt.updateMatrixWorld(!0),
        Pt.projectionMatrix.copy(Jt.projectionMatrix),
        Pt.projectionMatrixInverse.copy(Jt.projectionMatrixInverse),
        Pt.isPerspectiveCamera &&
          ((Pt.fov =
            RAD2DEG * 2 * Math.atan(1 / Pt.projectionMatrix.elements[5])),
          (Pt.zoom = 1));
    }
    (this.getCamera = function () {
      return St;
    }),
      (this.getFoveation = function () {
        if (!(et === null && rt === null)) return b;
      }),
      (this.setFoveation = function (Pt) {
        (b = Pt),
          et !== null && (et.fixedFoveation = Pt),
          rt !== null &&
            rt.fixedFoveation !== void 0 &&
            (rt.fixedFoveation = Pt);
      }),
      (this.hasDepthSensing = function () {
        return at.texture !== null;
      }),
      (this.getDepthSensingMesh = function () {
        return at.getMesh(St);
      });
    let Tt = null;
    function Dt(Pt, Jt) {
      if ((($ = Jt.getViewerPose(j || g)), (st = Jt), $ !== null)) {
        const Gt = $.views;
        rt !== null &&
          (e.setRenderTargetFramebuffer(lt, rt.framebuffer),
          e.setRenderTarget(lt));
        let en = !1;
        Gt.length !== St.cameras.length && ((St.cameras.length = 0), (en = !0));
        for (let Tn = 0; Tn < Gt.length; Tn++) {
          const fn = Gt[Tn];
          let pn = null;
          if (rt !== null) pn = rt.getViewport(fn);
          else {
            const qt = _e.getViewSubImage(et, fn);
            (pn = qt.viewport),
              Tn === 0 &&
                (e.setRenderTargetTextures(
                  lt,
                  qt.colorTexture,
                  et.ignoreDepthValues ? void 0 : qt.depthStencilTexture
                ),
                e.setRenderTarget(lt));
          }
          let Bt = _t[Tn];
          Bt === void 0 &&
            ((Bt = new PerspectiveCamera()),
            Bt.layers.enable(Tn),
            (Bt.viewport = new Vector4()),
            (_t[Tn] = Bt)),
            Bt.matrix.fromArray(fn.transform.matrix),
            Bt.matrix.decompose(Bt.position, Bt.quaternion, Bt.scale),
            Bt.projectionMatrix.fromArray(fn.projectionMatrix),
            Bt.projectionMatrixInverse.copy(Bt.projectionMatrix).invert(),
            Bt.viewport.set(pn.x, pn.y, pn.width, pn.height),
            Tn === 0 &&
              (St.matrix.copy(Bt.matrix),
              St.matrix.decompose(St.position, St.quaternion, St.scale)),
            en === !0 && St.cameras.push(Bt);
        }
        const _n = c.enabledFeatures;
        if (_n && _n.includes("depth-sensing")) {
          const Tn = _e.getDepthInformation(Gt[0]);
          Tn && Tn.isValid && Tn.texture && at.init(e, Tn, c.renderState);
        }
      }
      for (let Gt = 0; Gt < ot.length; Gt++) {
        const en = ut[Gt],
          _n = ot[Gt];
        en !== null && _n !== void 0 && _n.update(en, Jt, j || g);
      }
      Tt && Tt(Pt, Jt),
        Jt.detectedPlanes &&
          a.dispatchEvent({ type: "planesdetected", data: Jt }),
        (st = null);
    }
    const Wt = new WebGLAnimation();
    Wt.setAnimationLoop(Dt),
      (this.setAnimationLoop = function (Pt) {
        Tt = Pt;
      }),
      (this.dispose = function () {});
  }
}
const _e1 = new Euler(),
  _m1 = new Matrix4();
function WebGLMaterials(s, e) {
  function o(ct, it) {
    ct.matrixAutoUpdate === !0 && ct.updateMatrix(), it.value.copy(ct.matrix);
  }
  function a(ct, it) {
    it.color.getRGB(ct.fogColor.value, getUnlitUniformColorSpace(s)),
      it.isFog
        ? ((ct.fogNear.value = it.near), (ct.fogFar.value = it.far))
        : it.isFogExp2 && (ct.fogDensity.value = it.density);
  }
  function c(ct, it, lt, ot, ut) {
    it.isMeshBasicMaterial || it.isMeshLambertMaterial
      ? d(ct, it)
      : it.isMeshToonMaterial
      ? (d(ct, it), _e(ct, it))
      : it.isMeshPhongMaterial
      ? (d(ct, it), $(ct, it))
      : it.isMeshStandardMaterial
      ? (d(ct, it), et(ct, it), it.isMeshPhysicalMaterial && rt(ct, it, ut))
      : it.isMeshMatcapMaterial
      ? (d(ct, it), st(ct, it))
      : it.isMeshDepthMaterial
      ? d(ct, it)
      : it.isMeshDistanceMaterial
      ? (d(ct, it), at(ct, it))
      : it.isMeshNormalMaterial
      ? d(ct, it)
      : it.isLineBasicMaterial
      ? (g(ct, it), it.isLineDashedMaterial && _(ct, it))
      : it.isPointsMaterial
      ? b(ct, it, lt, ot)
      : it.isSpriteMaterial
      ? j(ct, it)
      : it.isShadowMaterial
      ? (ct.color.value.copy(it.color), (ct.opacity.value = it.opacity))
      : it.isShaderMaterial && (it.uniformsNeedUpdate = !1);
  }
  function d(ct, it) {
    (ct.opacity.value = it.opacity),
      it.color && ct.diffuse.value.copy(it.color),
      it.emissive &&
        ct.emissive.value
          .copy(it.emissive)
          .multiplyScalar(it.emissiveIntensity),
      it.map && ((ct.map.value = it.map), o(it.map, ct.mapTransform)),
      it.alphaMap &&
        ((ct.alphaMap.value = it.alphaMap),
        o(it.alphaMap, ct.alphaMapTransform)),
      it.bumpMap &&
        ((ct.bumpMap.value = it.bumpMap),
        o(it.bumpMap, ct.bumpMapTransform),
        (ct.bumpScale.value = it.bumpScale),
        it.side === BackSide && (ct.bumpScale.value *= -1)),
      it.normalMap &&
        ((ct.normalMap.value = it.normalMap),
        o(it.normalMap, ct.normalMapTransform),
        ct.normalScale.value.copy(it.normalScale),
        it.side === BackSide && ct.normalScale.value.negate()),
      it.displacementMap &&
        ((ct.displacementMap.value = it.displacementMap),
        o(it.displacementMap, ct.displacementMapTransform),
        (ct.displacementScale.value = it.displacementScale),
        (ct.displacementBias.value = it.displacementBias)),
      it.emissiveMap &&
        ((ct.emissiveMap.value = it.emissiveMap),
        o(it.emissiveMap, ct.emissiveMapTransform)),
      it.specularMap &&
        ((ct.specularMap.value = it.specularMap),
        o(it.specularMap, ct.specularMapTransform)),
      it.alphaTest > 0 && (ct.alphaTest.value = it.alphaTest);
    const lt = e.get(it),
      ot = lt.envMap,
      ut = lt.envMapRotation;
    ot &&
      ((ct.envMap.value = ot),
      _e1.copy(ut),
      (_e1.x *= -1),
      (_e1.y *= -1),
      (_e1.z *= -1),
      ot.isCubeTexture &&
        ot.isRenderTargetTexture === !1 &&
        ((_e1.y *= -1), (_e1.z *= -1)),
      ct.envMapRotation.value.setFromMatrix4(_m1.makeRotationFromEuler(_e1)),
      (ct.flipEnvMap.value =
        ot.isCubeTexture && ot.isRenderTargetTexture === !1 ? -1 : 1),
      (ct.reflectivity.value = it.reflectivity),
      (ct.ior.value = it.ior),
      (ct.refractionRatio.value = it.refractionRatio)),
      it.lightMap &&
        ((ct.lightMap.value = it.lightMap),
        (ct.lightMapIntensity.value = it.lightMapIntensity),
        o(it.lightMap, ct.lightMapTransform)),
      it.aoMap &&
        ((ct.aoMap.value = it.aoMap),
        (ct.aoMapIntensity.value = it.aoMapIntensity),
        o(it.aoMap, ct.aoMapTransform));
  }
  function g(ct, it) {
    ct.diffuse.value.copy(it.color),
      (ct.opacity.value = it.opacity),
      it.map && ((ct.map.value = it.map), o(it.map, ct.mapTransform));
  }
  function _(ct, it) {
    (ct.dashSize.value = it.dashSize),
      (ct.totalSize.value = it.dashSize + it.gapSize),
      (ct.scale.value = it.scale);
  }
  function b(ct, it, lt, ot) {
    ct.diffuse.value.copy(it.color),
      (ct.opacity.value = it.opacity),
      (ct.size.value = it.size * lt),
      (ct.scale.value = ot * 0.5),
      it.map && ((ct.map.value = it.map), o(it.map, ct.uvTransform)),
      it.alphaMap &&
        ((ct.alphaMap.value = it.alphaMap),
        o(it.alphaMap, ct.alphaMapTransform)),
      it.alphaTest > 0 && (ct.alphaTest.value = it.alphaTest);
  }
  function j(ct, it) {
    ct.diffuse.value.copy(it.color),
      (ct.opacity.value = it.opacity),
      (ct.rotation.value = it.rotation),
      it.map && ((ct.map.value = it.map), o(it.map, ct.mapTransform)),
      it.alphaMap &&
        ((ct.alphaMap.value = it.alphaMap),
        o(it.alphaMap, ct.alphaMapTransform)),
      it.alphaTest > 0 && (ct.alphaTest.value = it.alphaTest);
  }
  function $(ct, it) {
    ct.specular.value.copy(it.specular),
      (ct.shininess.value = Math.max(it.shininess, 1e-4));
  }
  function _e(ct, it) {
    it.gradientMap && (ct.gradientMap.value = it.gradientMap);
  }
  function et(ct, it) {
    (ct.metalness.value = it.metalness),
      it.metalnessMap &&
        ((ct.metalnessMap.value = it.metalnessMap),
        o(it.metalnessMap, ct.metalnessMapTransform)),
      (ct.roughness.value = it.roughness),
      it.roughnessMap &&
        ((ct.roughnessMap.value = it.roughnessMap),
        o(it.roughnessMap, ct.roughnessMapTransform)),
      it.envMap && (ct.envMapIntensity.value = it.envMapIntensity);
  }
  function rt(ct, it, lt) {
    (ct.ior.value = it.ior),
      it.sheen > 0 &&
        (ct.sheenColor.value.copy(it.sheenColor).multiplyScalar(it.sheen),
        (ct.sheenRoughness.value = it.sheenRoughness),
        it.sheenColorMap &&
          ((ct.sheenColorMap.value = it.sheenColorMap),
          o(it.sheenColorMap, ct.sheenColorMapTransform)),
        it.sheenRoughnessMap &&
          ((ct.sheenRoughnessMap.value = it.sheenRoughnessMap),
          o(it.sheenRoughnessMap, ct.sheenRoughnessMapTransform))),
      it.clearcoat > 0 &&
        ((ct.clearcoat.value = it.clearcoat),
        (ct.clearcoatRoughness.value = it.clearcoatRoughness),
        it.clearcoatMap &&
          ((ct.clearcoatMap.value = it.clearcoatMap),
          o(it.clearcoatMap, ct.clearcoatMapTransform)),
        it.clearcoatRoughnessMap &&
          ((ct.clearcoatRoughnessMap.value = it.clearcoatRoughnessMap),
          o(it.clearcoatRoughnessMap, ct.clearcoatRoughnessMapTransform)),
        it.clearcoatNormalMap &&
          ((ct.clearcoatNormalMap.value = it.clearcoatNormalMap),
          o(it.clearcoatNormalMap, ct.clearcoatNormalMapTransform),
          ct.clearcoatNormalScale.value.copy(it.clearcoatNormalScale),
          it.side === BackSide && ct.clearcoatNormalScale.value.negate())),
      it.dispersion > 0 && (ct.dispersion.value = it.dispersion),
      it.iridescence > 0 &&
        ((ct.iridescence.value = it.iridescence),
        (ct.iridescenceIOR.value = it.iridescenceIOR),
        (ct.iridescenceThicknessMinimum.value =
          it.iridescenceThicknessRange[0]),
        (ct.iridescenceThicknessMaximum.value =
          it.iridescenceThicknessRange[1]),
        it.iridescenceMap &&
          ((ct.iridescenceMap.value = it.iridescenceMap),
          o(it.iridescenceMap, ct.iridescenceMapTransform)),
        it.iridescenceThicknessMap &&
          ((ct.iridescenceThicknessMap.value = it.iridescenceThicknessMap),
          o(it.iridescenceThicknessMap, ct.iridescenceThicknessMapTransform))),
      it.transmission > 0 &&
        ((ct.transmission.value = it.transmission),
        (ct.transmissionSamplerMap.value = lt.texture),
        ct.transmissionSamplerSize.value.set(lt.width, lt.height),
        it.transmissionMap &&
          ((ct.transmissionMap.value = it.transmissionMap),
          o(it.transmissionMap, ct.transmissionMapTransform)),
        (ct.thickness.value = it.thickness),
        it.thicknessMap &&
          ((ct.thicknessMap.value = it.thicknessMap),
          o(it.thicknessMap, ct.thicknessMapTransform)),
        (ct.attenuationDistance.value = it.attenuationDistance),
        ct.attenuationColor.value.copy(it.attenuationColor)),
      it.anisotropy > 0 &&
        (ct.anisotropyVector.value.set(
          it.anisotropy * Math.cos(it.anisotropyRotation),
          it.anisotropy * Math.sin(it.anisotropyRotation)
        ),
        it.anisotropyMap &&
          ((ct.anisotropyMap.value = it.anisotropyMap),
          o(it.anisotropyMap, ct.anisotropyMapTransform))),
      (ct.specularIntensity.value = it.specularIntensity),
      ct.specularColor.value.copy(it.specularColor),
      it.specularColorMap &&
        ((ct.specularColorMap.value = it.specularColorMap),
        o(it.specularColorMap, ct.specularColorMapTransform)),
      it.specularIntensityMap &&
        ((ct.specularIntensityMap.value = it.specularIntensityMap),
        o(it.specularIntensityMap, ct.specularIntensityMapTransform));
  }
  function st(ct, it) {
    it.matcap && (ct.matcap.value = it.matcap);
  }
  function at(ct, it) {
    const lt = e.get(it).light;
    ct.referencePosition.value.setFromMatrixPosition(lt.matrixWorld),
      (ct.nearDistance.value = lt.shadow.camera.near),
      (ct.farDistance.value = lt.shadow.camera.far);
  }
  return { refreshFogUniforms: a, refreshMaterialUniforms: c };
}
function WebGLUniformsGroups(s, e, o, a) {
  let c = {},
    d = {},
    g = [];
  const _ = s.getParameter(s.MAX_UNIFORM_BUFFER_BINDINGS);
  function b(lt, ot) {
    const ut = ot.program;
    a.uniformBlockBinding(lt, ut);
  }
  function j(lt, ot) {
    let ut = c[lt.id];
    ut === void 0 &&
      (st(lt),
      (ut = $(lt)),
      (c[lt.id] = ut),
      lt.addEventListener("dispose", ct));
    const pt = ot.program;
    a.updateUBOMapping(lt, pt);
    const ft = e.render.frame;
    d[lt.id] !== ft && (et(lt), (d[lt.id] = ft));
  }
  function $(lt) {
    const ot = _e();
    lt.__bindingPointIndex = ot;
    const ut = s.createBuffer(),
      pt = lt.__size,
      ft = lt.usage;
    return (
      s.bindBuffer(s.UNIFORM_BUFFER, ut),
      s.bufferData(s.UNIFORM_BUFFER, pt, ft),
      s.bindBuffer(s.UNIFORM_BUFFER, null),
      s.bindBufferBase(s.UNIFORM_BUFFER, ot, ut),
      ut
    );
  }
  function _e() {
    for (let lt = 0; lt < _; lt++)
      if (g.indexOf(lt) === -1) return g.push(lt), lt;
    return (
      console.error(
        "THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached."
      ),
      0
    );
  }
  function et(lt) {
    const ot = c[lt.id],
      ut = lt.uniforms,
      pt = lt.__cache;
    s.bindBuffer(s.UNIFORM_BUFFER, ot);
    for (let ft = 0, gt = ut.length; ft < gt; ft++) {
      const xt = Array.isArray(ut[ft]) ? ut[ft] : [ut[ft]];
      for (let _t = 0, St = xt.length; _t < St; _t++) {
        const Mt = xt[_t];
        if (rt(Mt, ft, _t, pt) === !0) {
          const Rt = Mt.__offset,
            Ft = Array.isArray(Mt.value) ? Mt.value : [Mt.value];
          let Ot = 0;
          for (let Lt = 0; Lt < Ft.length; Lt++) {
            const Et = Ft[Lt],
              bt = at(Et);
            typeof Et == "number" || typeof Et == "boolean"
              ? ((Mt.__data[0] = Et),
                s.bufferSubData(s.UNIFORM_BUFFER, Rt + Ot, Mt.__data))
              : Et.isMatrix3
              ? ((Mt.__data[0] = Et.elements[0]),
                (Mt.__data[1] = Et.elements[1]),
                (Mt.__data[2] = Et.elements[2]),
                (Mt.__data[3] = 0),
                (Mt.__data[4] = Et.elements[3]),
                (Mt.__data[5] = Et.elements[4]),
                (Mt.__data[6] = Et.elements[5]),
                (Mt.__data[7] = 0),
                (Mt.__data[8] = Et.elements[6]),
                (Mt.__data[9] = Et.elements[7]),
                (Mt.__data[10] = Et.elements[8]),
                (Mt.__data[11] = 0))
              : (Et.toArray(Mt.__data, Ot),
                (Ot += bt.storage / Float32Array.BYTES_PER_ELEMENT));
          }
          s.bufferSubData(s.UNIFORM_BUFFER, Rt, Mt.__data);
        }
      }
    }
    s.bindBuffer(s.UNIFORM_BUFFER, null);
  }
  function rt(lt, ot, ut, pt) {
    const ft = lt.value,
      gt = ot + "_" + ut;
    if (pt[gt] === void 0)
      return (
        typeof ft == "number" || typeof ft == "boolean"
          ? (pt[gt] = ft)
          : (pt[gt] = ft.clone()),
        !0
      );
    {
      const xt = pt[gt];
      if (typeof ft == "number" || typeof ft == "boolean") {
        if (xt !== ft) return (pt[gt] = ft), !0;
      } else if (xt.equals(ft) === !1) return xt.copy(ft), !0;
    }
    return !1;
  }
  function st(lt) {
    const ot = lt.uniforms;
    let ut = 0;
    const pt = 16;
    for (let gt = 0, xt = ot.length; gt < xt; gt++) {
      const _t = Array.isArray(ot[gt]) ? ot[gt] : [ot[gt]];
      for (let St = 0, Mt = _t.length; St < Mt; St++) {
        const Rt = _t[St],
          Ft = Array.isArray(Rt.value) ? Rt.value : [Rt.value];
        for (let Ot = 0, Lt = Ft.length; Ot < Lt; Ot++) {
          const Et = Ft[Ot],
            bt = at(Et),
            mt = ut % pt,
            vt = mt % bt.boundary,
            Ct = mt + vt;
          (ut += vt),
            Ct !== 0 && pt - Ct < bt.storage && (ut += pt - Ct),
            (Rt.__data = new Float32Array(
              bt.storage / Float32Array.BYTES_PER_ELEMENT
            )),
            (Rt.__offset = ut),
            (ut += bt.storage);
        }
      }
    }
    const ft = ut % pt;
    return ft > 0 && (ut += pt - ft), (lt.__size = ut), (lt.__cache = {}), this;
  }
  function at(lt) {
    const ot = { boundary: 0, storage: 0 };
    return (
      typeof lt == "number" || typeof lt == "boolean"
        ? ((ot.boundary = 4), (ot.storage = 4))
        : lt.isVector2
        ? ((ot.boundary = 8), (ot.storage = 8))
        : lt.isVector3 || lt.isColor
        ? ((ot.boundary = 16), (ot.storage = 12))
        : lt.isVector4
        ? ((ot.boundary = 16), (ot.storage = 16))
        : lt.isMatrix3
        ? ((ot.boundary = 48), (ot.storage = 48))
        : lt.isMatrix4
        ? ((ot.boundary = 64), (ot.storage = 64))
        : lt.isTexture
        ? console.warn(
            "THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group."
          )
        : console.warn(
            "THREE.WebGLRenderer: Unsupported uniform value type.",
            lt
          ),
      ot
    );
  }
  function ct(lt) {
    const ot = lt.target;
    ot.removeEventListener("dispose", ct);
    const ut = g.indexOf(ot.__bindingPointIndex);
    g.splice(ut, 1), s.deleteBuffer(c[ot.id]), delete c[ot.id], delete d[ot.id];
  }
  function it() {
    for (const lt in c) s.deleteBuffer(c[lt]);
    (g = []), (c = {}), (d = {});
  }
  return { bind: b, update: j, dispose: it };
}
class WebGLRenderer {
  constructor(e = {}) {
    const {
      canvas: o = createCanvasElement(),
      context: a = null,
      depth: c = !0,
      stencil: d = !1,
      alpha: g = !1,
      antialias: _ = !1,
      premultipliedAlpha: b = !0,
      preserveDrawingBuffer: j = !1,
      powerPreference: $ = "default",
      failIfMajorPerformanceCaveat: _e = !1,
    } = e;
    this.isWebGLRenderer = !0;
    let et;
    if (a !== null) {
      if (
        typeof WebGLRenderingContext < "u" &&
        a instanceof WebGLRenderingContext
      )
        throw new Error(
          "THREE.WebGLRenderer: WebGL 1 is not supported since r163."
        );
      et = a.getContextAttributes().alpha;
    } else et = g;
    const rt = new Uint32Array(4),
      st = new Int32Array(4);
    let at = null,
      ct = null;
    const it = [],
      lt = [];
    (this.domElement = o),
      (this.debug = { checkShaderErrors: !0, onShaderError: null }),
      (this.autoClear = !0),
      (this.autoClearColor = !0),
      (this.autoClearDepth = !0),
      (this.autoClearStencil = !0),
      (this.sortObjects = !0),
      (this.clippingPlanes = []),
      (this.localClippingEnabled = !1),
      (this._outputColorSpace = SRGBColorSpace$1),
      (this.toneMapping = NoToneMapping),
      (this.toneMappingExposure = 1);
    const ot = this;
    let ut = !1,
      pt = 0,
      ft = 0,
      gt = null,
      xt = -1,
      _t = null;
    const St = new Vector4(),
      Mt = new Vector4();
    let Rt = null;
    const Ft = new Color(0);
    let Ot = 0,
      Lt = o.width,
      Et = o.height,
      bt = 1,
      mt = null,
      vt = null;
    const Ct = new Vector4(0, 0, Lt, Et),
      Tt = new Vector4(0, 0, Lt, Et);
    let Dt = !1;
    const Wt = new Frustum();
    let Pt = !1,
      Jt = !1;
    const Gt = new Matrix4(),
      en = new Vector3(),
      _n = new Vector4(),
      Tn = {
        background: null,
        fog: null,
        environment: null,
        overrideMaterial: null,
        isScene: !0,
      };
    let fn = !1;
    function pn() {
      return gt === null ? bt : 1;
    }
    let Bt = a;
    function qt(It, zt) {
      return o.getContext(It, zt);
    }
    try {
      const It = {
        alpha: !0,
        depth: c,
        stencil: d,
        antialias: _,
        premultipliedAlpha: b,
        preserveDrawingBuffer: j,
        powerPreference: $,
        failIfMajorPerformanceCaveat: _e,
      };
      if (
        ("setAttribute" in o &&
          o.setAttribute("data-engine", `three.js r${REVISION}`),
        o.addEventListener("webglcontextlost", an, !1),
        o.addEventListener("webglcontextrestored", hn, !1),
        o.addEventListener("webglcontextcreationerror", Mn, !1),
        Bt === null)
      ) {
        const zt = "webgl2";
        if (((Bt = qt(zt, It)), Bt === null))
          throw qt(zt)
            ? new Error(
                "Error creating WebGL context with your selected attributes."
              )
            : new Error("Error creating WebGL context.");
      }
    } catch (It) {
      throw (console.error("THREE.WebGLRenderer: " + It.message), It);
    }
    let $t,
      yn,
      nn,
      Pn,
      xn,
      An,
      kt,
      wt,
      Kt,
      on,
      sn,
      cn,
      bn,
      vn,
      wn,
      zn,
      gn,
      Rn,
      qn,
      Wn,
      kn,
      Vt,
      un,
      In;
    function Ut() {
      ($t = new WebGLExtensions(Bt)),
        $t.init(),
        (Vt = new WebGLUtils(Bt, $t)),
        (yn = new WebGLCapabilities(Bt, $t, e, Vt)),
        (nn = new WebGLState(Bt)),
        (Pn = new WebGLInfo(Bt)),
        (xn = new WebGLProperties()),
        (An = new WebGLTextures(Bt, $t, nn, xn, yn, Vt, Pn)),
        (kt = new WebGLCubeMaps(ot)),
        (wt = new WebGLCubeUVMaps(ot)),
        (Kt = new WebGLAttributes(Bt)),
        (un = new WebGLBindingStates(Bt, Kt)),
        (on = new WebGLGeometries(Bt, Kt, Pn, un)),
        (sn = new WebGLObjects(Bt, on, Kt, Pn)),
        (qn = new WebGLMorphtargets(Bt, yn, An)),
        (zn = new WebGLClipping(xn)),
        (cn = new WebGLPrograms(ot, kt, wt, $t, yn, un, zn)),
        (bn = new WebGLMaterials(ot, xn)),
        (vn = new WebGLRenderLists()),
        (wn = new WebGLRenderStates($t)),
        (Rn = new WebGLBackground(ot, kt, wt, nn, sn, et, b)),
        (gn = new WebGLShadowMap(ot, sn, yn)),
        (In = new WebGLUniformsGroups(Bt, Pn, yn, nn)),
        (Wn = new WebGLBufferRenderer(Bt, $t, Pn)),
        (kn = new WebGLIndexedBufferRenderer(Bt, $t, Pn)),
        (Pn.programs = cn.programs),
        (ot.capabilities = yn),
        (ot.extensions = $t),
        (ot.properties = xn),
        (ot.renderLists = vn),
        (ot.shadowMap = gn),
        (ot.state = nn),
        (ot.info = Pn);
    }
    Ut();
    const dn = new WebXRManager(ot, Bt);
    (this.xr = dn),
      (this.getContext = function () {
        return Bt;
      }),
      (this.getContextAttributes = function () {
        return Bt.getContextAttributes();
      }),
      (this.forceContextLoss = function () {
        const It = $t.get("WEBGL_lose_context");
        It && It.loseContext();
      }),
      (this.forceContextRestore = function () {
        const It = $t.get("WEBGL_lose_context");
        It && It.restoreContext();
      }),
      (this.getPixelRatio = function () {
        return bt;
      }),
      (this.setPixelRatio = function (It) {
        It !== void 0 && ((bt = It), this.setSize(Lt, Et, !1));
      }),
      (this.getSize = function (It) {
        return It.set(Lt, Et);
      }),
      (this.setSize = function (It, zt, Qt = !0) {
        if (dn.isPresenting) {
          console.warn(
            "THREE.WebGLRenderer: Can't change size while VR device is presenting."
          );
          return;
        }
        (Lt = It),
          (Et = zt),
          (o.width = Math.floor(It * bt)),
          (o.height = Math.floor(zt * bt)),
          Qt === !0 &&
            ((o.style.width = It + "px"), (o.style.height = zt + "px")),
          this.setViewport(0, 0, It, zt);
      }),
      (this.getDrawingBufferSize = function (It) {
        return It.set(Lt * bt, Et * bt).floor();
      }),
      (this.setDrawingBufferSize = function (It, zt, Qt) {
        (Lt = It),
          (Et = zt),
          (bt = Qt),
          (o.width = Math.floor(It * Qt)),
          (o.height = Math.floor(zt * Qt)),
          this.setViewport(0, 0, It, zt);
      }),
      (this.getCurrentViewport = function (It) {
        return It.copy(St);
      }),
      (this.getViewport = function (It) {
        return It.copy(Ct);
      }),
      (this.setViewport = function (It, zt, Qt, Zt) {
        It.isVector4 ? Ct.set(It.x, It.y, It.z, It.w) : Ct.set(It, zt, Qt, Zt),
          nn.viewport(St.copy(Ct).multiplyScalar(bt).round());
      }),
      (this.getScissor = function (It) {
        return It.copy(Tt);
      }),
      (this.setScissor = function (It, zt, Qt, Zt) {
        It.isVector4 ? Tt.set(It.x, It.y, It.z, It.w) : Tt.set(It, zt, Qt, Zt),
          nn.scissor(Mt.copy(Tt).multiplyScalar(bt).round());
      }),
      (this.getScissorTest = function () {
        return Dt;
      }),
      (this.setScissorTest = function (It) {
        nn.setScissorTest((Dt = It));
      }),
      (this.setOpaqueSort = function (It) {
        mt = It;
      }),
      (this.setTransparentSort = function (It) {
        vt = It;
      }),
      (this.getClearColor = function (It) {
        return It.copy(Rn.getClearColor());
      }),
      (this.setClearColor = function () {
        Rn.setClearColor.apply(Rn, arguments);
      }),
      (this.getClearAlpha = function () {
        return Rn.getClearAlpha();
      }),
      (this.setClearAlpha = function () {
        Rn.setClearAlpha.apply(Rn, arguments);
      }),
      (this.clear = function (It = !0, zt = !0, Qt = !0) {
        let Zt = 0;
        if (It) {
          let Xt = !1;
          if (gt !== null) {
            const En = gt.texture.format;
            Xt =
              En === RGBAIntegerFormat ||
              En === RGIntegerFormat ||
              En === RedIntegerFormat;
          }
          if (Xt) {
            const En = gt.texture.type,
              Fn =
                En === UnsignedByteType ||
                En === UnsignedIntType ||
                En === UnsignedShortType ||
                En === UnsignedInt248Type ||
                En === UnsignedShort4444Type ||
                En === UnsignedShort5551Type,
              On = Rn.getClearColor(),
              Nn = Rn.getClearAlpha(),
              Hn = On.r,
              Kn = On.g,
              jn = On.b;
            Fn
              ? ((rt[0] = Hn),
                (rt[1] = Kn),
                (rt[2] = jn),
                (rt[3] = Nn),
                Bt.clearBufferuiv(Bt.COLOR, 0, rt))
              : ((st[0] = Hn),
                (st[1] = Kn),
                (st[2] = jn),
                (st[3] = Nn),
                Bt.clearBufferiv(Bt.COLOR, 0, st));
          } else Zt |= Bt.COLOR_BUFFER_BIT;
        }
        zt && (Zt |= Bt.DEPTH_BUFFER_BIT),
          Qt &&
            ((Zt |= Bt.STENCIL_BUFFER_BIT),
            this.state.buffers.stencil.setMask(4294967295)),
          Bt.clear(Zt);
      }),
      (this.clearColor = function () {
        this.clear(!0, !1, !1);
      }),
      (this.clearDepth = function () {
        this.clear(!1, !0, !1);
      }),
      (this.clearStencil = function () {
        this.clear(!1, !1, !0);
      }),
      (this.dispose = function () {
        o.removeEventListener("webglcontextlost", an, !1),
          o.removeEventListener("webglcontextrestored", hn, !1),
          o.removeEventListener("webglcontextcreationerror", Mn, !1),
          vn.dispose(),
          wn.dispose(),
          xn.dispose(),
          kt.dispose(),
          wt.dispose(),
          sn.dispose(),
          un.dispose(),
          In.dispose(),
          cn.dispose(),
          dn.dispose(),
          dn.removeEventListener("sessionstart", Tr),
          dn.removeEventListener("sessionend", Ao),
          ds.stop();
      });
    function an(It) {
      It.preventDefault(),
        console.log("THREE.WebGLRenderer: Context Lost."),
        (ut = !0);
    }
    function hn() {
      console.log("THREE.WebGLRenderer: Context Restored."), (ut = !1);
      const It = Pn.autoReset,
        zt = gn.enabled,
        Qt = gn.autoUpdate,
        Zt = gn.needsUpdate,
        Xt = gn.type;
      Ut(),
        (Pn.autoReset = It),
        (gn.enabled = zt),
        (gn.autoUpdate = Qt),
        (gn.needsUpdate = Zt),
        (gn.type = Xt);
    }
    function Mn(It) {
      console.error(
        "THREE.WebGLRenderer: A WebGL context could not be created. Reason: ",
        It.statusMessage
      );
    }
    function $n(It) {
      const zt = It.target;
      zt.removeEventListener("dispose", $n), Yn(zt);
    }
    function Yn(It) {
      rr(It), xn.remove(It);
    }
    function rr(It) {
      const zt = xn.get(It).programs;
      zt !== void 0 &&
        (zt.forEach(function (Qt) {
          cn.releaseProgram(Qt);
        }),
        It.isShaderMaterial && cn.releaseShaderCache(It));
    }
    this.renderBufferDirect = function (It, zt, Qt, Zt, Xt, En) {
      zt === null && (zt = Tn);
      const Fn = Xt.isMesh && Xt.matrixWorld.determinant() < 0,
        On = Fl(It, zt, Qt, Zt, Xt);
      nn.setMaterial(Zt, Fn);
      let Nn = Qt.index,
        Hn = 1;
      if (Zt.wireframe === !0) {
        if (((Nn = on.getWireframeAttribute(Qt)), Nn === void 0)) return;
        Hn = 2;
      }
      const Kn = Qt.drawRange,
        jn = Qt.attributes.position;
      let ir = Kn.start * Hn,
        ur = (Kn.start + Kn.count) * Hn;
      En !== null &&
        ((ir = Math.max(ir, En.start * Hn)),
        (ur = Math.min(ur, (En.start + En.count) * Hn))),
        Nn !== null
          ? ((ir = Math.max(ir, 0)), (ur = Math.min(ur, Nn.count)))
          : jn != null &&
            ((ir = Math.max(ir, 0)), (ur = Math.min(ur, jn.count)));
      const lr = ur - ir;
      if (lr < 0 || lr === 1 / 0) return;
      un.setup(Xt, Zt, On, Qt, Nn);
      let yr,
        Gn = Wn;
      if (
        (Nn !== null && ((yr = Kt.get(Nn)), (Gn = kn), Gn.setIndex(yr)),
        Xt.isMesh)
      )
        Zt.wireframe === !0
          ? (nn.setLineWidth(Zt.wireframeLinewidth * pn()),
            Gn.setMode(Bt.LINES))
          : Gn.setMode(Bt.TRIANGLES);
      else if (Xt.isLine) {
        let Cn = Zt.linewidth;
        Cn === void 0 && (Cn = 1),
          nn.setLineWidth(Cn * pn()),
          Xt.isLineSegments
            ? Gn.setMode(Bt.LINES)
            : Xt.isLineLoop
            ? Gn.setMode(Bt.LINE_LOOP)
            : Gn.setMode(Bt.LINE_STRIP);
      } else
        Xt.isPoints
          ? Gn.setMode(Bt.POINTS)
          : Xt.isSprite && Gn.setMode(Bt.TRIANGLES);
      if (Xt.isBatchedMesh)
        if (Xt._multiDrawInstances !== null)
          Gn.renderMultiDrawInstances(
            Xt._multiDrawStarts,
            Xt._multiDrawCounts,
            Xt._multiDrawCount,
            Xt._multiDrawInstances
          );
        else if ($t.get("WEBGL_multi_draw"))
          Gn.renderMultiDraw(
            Xt._multiDrawStarts,
            Xt._multiDrawCounts,
            Xt._multiDrawCount
          );
        else {
          const Cn = Xt._multiDrawStarts,
            hr = Xt._multiDrawCounts,
            Jn = Xt._multiDrawCount,
            dr = Nn ? Kt.get(Nn).bytesPerElement : 1,
            Vr = xn.get(Zt).currentProgram.getUniforms();
          for (let Sr = 0; Sr < Jn; Sr++)
            Vr.setValue(Bt, "_gl_DrawID", Sr), Gn.render(Cn[Sr] / dr, hr[Sr]);
        }
      else if (Xt.isInstancedMesh) Gn.renderInstances(ir, lr, Xt.count);
      else if (Qt.isInstancedBufferGeometry) {
        const Cn =
            Qt._maxInstanceCount !== void 0 ? Qt._maxInstanceCount : 1 / 0,
          hr = Math.min(Qt.instanceCount, Cn);
        Gn.renderInstances(ir, lr, hr);
      } else Gn.render(ir, lr);
    };
    function pr(It, zt, Qt) {
      It.transparent === !0 &&
      It.side === DoubleSide &&
      It.forceSinglePass === !1
        ? ((It.side = BackSide),
          (It.needsUpdate = !0),
          Vs(It, zt, Qt),
          (It.side = FrontSide),
          (It.needsUpdate = !0),
          Vs(It, zt, Qt),
          (It.side = DoubleSide))
        : Vs(It, zt, Qt);
    }
    (this.compile = function (It, zt, Qt = null) {
      Qt === null && (Qt = It),
        (ct = wn.get(Qt)),
        ct.init(zt),
        lt.push(ct),
        Qt.traverseVisible(function (Xt) {
          Xt.isLight &&
            Xt.layers.test(zt.layers) &&
            (ct.pushLight(Xt), Xt.castShadow && ct.pushShadow(Xt));
        }),
        It !== Qt &&
          It.traverseVisible(function (Xt) {
            Xt.isLight &&
              Xt.layers.test(zt.layers) &&
              (ct.pushLight(Xt), Xt.castShadow && ct.pushShadow(Xt));
          }),
        ct.setupLights();
      const Zt = new Set();
      return (
        It.traverse(function (Xt) {
          const En = Xt.material;
          if (En)
            if (Array.isArray(En))
              for (let Fn = 0; Fn < En.length; Fn++) {
                const On = En[Fn];
                pr(On, Qt, Xt), Zt.add(On);
              }
            else pr(En, Qt, Xt), Zt.add(En);
        }),
        lt.pop(),
        (ct = null),
        Zt
      );
    }),
      (this.compileAsync = function (It, zt, Qt = null) {
        const Zt = this.compile(It, zt, Qt);
        return new Promise((Xt) => {
          function En() {
            if (
              (Zt.forEach(function (Fn) {
                xn.get(Fn).currentProgram.isReady() && Zt.delete(Fn);
              }),
              Zt.size === 0)
            ) {
              Xt(It);
              return;
            }
            setTimeout(En, 10);
          }
          $t.get("KHR_parallel_shader_compile") !== null
            ? En()
            : setTimeout(En, 10);
        });
      });
    let tr = null;
    function Cr(It) {
      tr && tr(It);
    }
    function Tr() {
      ds.stop();
    }
    function Ao() {
      ds.start();
    }
    const ds = new WebGLAnimation();
    ds.setAnimationLoop(Cr),
      typeof self < "u" && ds.setContext(self),
      (this.setAnimationLoop = function (It) {
        (tr = It),
          dn.setAnimationLoop(It),
          It === null ? ds.stop() : ds.start();
      }),
      dn.addEventListener("sessionstart", Tr),
      dn.addEventListener("sessionend", Ao),
      (this.render = function (It, zt) {
        if (zt !== void 0 && zt.isCamera !== !0) {
          console.error(
            "THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera."
          );
          return;
        }
        if (ut === !0) return;
        if (
          (It.matrixWorldAutoUpdate === !0 && It.updateMatrixWorld(),
          zt.parent === null &&
            zt.matrixWorldAutoUpdate === !0 &&
            zt.updateMatrixWorld(),
          dn.enabled === !0 &&
            dn.isPresenting === !0 &&
            (dn.cameraAutoUpdate === !0 && dn.updateCamera(zt),
            (zt = dn.getCamera())),
          It.isScene === !0 && It.onBeforeRender(ot, It, zt, gt),
          (ct = wn.get(It, lt.length)),
          ct.init(zt),
          lt.push(ct),
          Gt.multiplyMatrices(zt.projectionMatrix, zt.matrixWorldInverse),
          Wt.setFromProjectionMatrix(Gt),
          (Jt = this.localClippingEnabled),
          (Pt = zn.init(this.clippingPlanes, Jt)),
          (at = vn.get(It, it.length)),
          at.init(),
          it.push(at),
          dn.enabled === !0 && dn.isPresenting === !0)
        ) {
          const En = ot.xr.getDepthSensingMesh();
          En !== null && to(En, zt, -1 / 0, ot.sortObjects);
        }
        to(It, zt, 0, ot.sortObjects),
          at.finish(),
          ot.sortObjects === !0 && at.sort(mt, vt),
          (fn =
            dn.enabled === !1 ||
            dn.isPresenting === !1 ||
            dn.hasDepthSensing() === !1),
          fn && Rn.addToRenderList(at, It),
          this.info.render.frame++,
          Pt === !0 && zn.beginShadows();
        const Qt = ct.state.shadowsArray;
        gn.render(Qt, It, zt),
          Pt === !0 && zn.endShadows(),
          this.info.autoReset === !0 && this.info.reset();
        const Zt = at.opaque,
          Xt = at.transmissive;
        if ((ct.setupLights(), zt.isArrayCamera)) {
          const En = zt.cameras;
          if (Xt.length > 0)
            for (let Fn = 0, On = En.length; Fn < On; Fn++) {
              const Nn = En[Fn];
              Os(Zt, Xt, It, Nn);
            }
          fn && Rn.render(It);
          for (let Fn = 0, On = En.length; Fn < On; Fn++) {
            const Nn = En[Fn];
            no(at, It, Nn, Nn.viewport);
          }
        } else
          Xt.length > 0 && Os(Zt, Xt, It, zt),
            fn && Rn.render(It),
            no(at, It, zt);
        gt !== null &&
          (An.updateMultisampleRenderTarget(gt),
          An.updateRenderTargetMipmap(gt)),
          It.isScene === !0 && It.onAfterRender(ot, It, zt),
          un.resetDefaultState(),
          (xt = -1),
          (_t = null),
          lt.pop(),
          lt.length > 0
            ? ((ct = lt[lt.length - 1]),
              Pt === !0 &&
                zn.setGlobalState(ot.clippingPlanes, ct.state.camera))
            : (ct = null),
          it.pop(),
          it.length > 0 ? (at = it[it.length - 1]) : (at = null);
      });
    function to(It, zt, Qt, Zt) {
      if (It.visible === !1) return;
      if (It.layers.test(zt.layers)) {
        if (It.isGroup) Qt = It.renderOrder;
        else if (It.isLOD) It.autoUpdate === !0 && It.update(zt);
        else if (It.isLight)
          ct.pushLight(It), It.castShadow && ct.pushShadow(It);
        else if (It.isSprite) {
          if (!It.frustumCulled || Wt.intersectsSprite(It)) {
            Zt && _n.setFromMatrixPosition(It.matrixWorld).applyMatrix4(Gt);
            const Fn = sn.update(It),
              On = It.material;
            On.visible && at.push(It, Fn, On, Qt, _n.z, null);
          }
        } else if (
          (It.isMesh || It.isLine || It.isPoints) &&
          (!It.frustumCulled || Wt.intersectsObject(It))
        ) {
          const Fn = sn.update(It),
            On = It.material;
          if (
            (Zt &&
              (It.boundingSphere !== void 0
                ? (It.boundingSphere === null && It.computeBoundingSphere(),
                  _n.copy(It.boundingSphere.center))
                : (Fn.boundingSphere === null && Fn.computeBoundingSphere(),
                  _n.copy(Fn.boundingSphere.center)),
              _n.applyMatrix4(It.matrixWorld).applyMatrix4(Gt)),
            Array.isArray(On))
          ) {
            const Nn = Fn.groups;
            for (let Hn = 0, Kn = Nn.length; Hn < Kn; Hn++) {
              const jn = Nn[Hn],
                ir = On[jn.materialIndex];
              ir && ir.visible && at.push(It, Fn, ir, Qt, _n.z, jn);
            }
          } else On.visible && at.push(It, Fn, On, Qt, _n.z, null);
        }
      }
      const En = It.children;
      for (let Fn = 0, On = En.length; Fn < On; Fn++) to(En[Fn], zt, Qt, Zt);
    }
    function no(It, zt, Qt, Zt) {
      const Xt = It.opaque,
        En = It.transmissive,
        Fn = It.transparent;
      ct.setupLightsView(Qt),
        Pt === !0 && zn.setGlobalState(ot.clippingPlanes, Qt),
        Zt && nn.viewport(St.copy(Zt)),
        Xt.length > 0 && Us(Xt, zt, Qt),
        En.length > 0 && Us(En, zt, Qt),
        Fn.length > 0 && Us(Fn, zt, Qt),
        nn.buffers.depth.setTest(!0),
        nn.buffers.depth.setMask(!0),
        nn.buffers.color.setMask(!0),
        nn.setPolygonOffset(!1);
    }
    function Os(It, zt, Qt, Zt) {
      if ((Qt.isScene === !0 ? Qt.overrideMaterial : null) !== null) return;
      ct.state.transmissionRenderTarget[Zt.id] === void 0 &&
        (ct.state.transmissionRenderTarget[Zt.id] = new WebGLRenderTarget(
          1,
          1,
          {
            generateMipmaps: !0,
            type:
              $t.has("EXT_color_buffer_half_float") ||
              $t.has("EXT_color_buffer_float")
                ? HalfFloatType
                : UnsignedByteType,
            minFilter: LinearMipmapLinearFilter,
            samples: 4,
            stencilBuffer: d,
            resolveDepthBuffer: !1,
            resolveStencilBuffer: !1,
            colorSpace: ColorManagement.workingColorSpace,
          }
        ));
      const En = ct.state.transmissionRenderTarget[Zt.id],
        Fn = Zt.viewport || St;
      En.setSize(Fn.z, Fn.w);
      const On = ot.getRenderTarget();
      ot.setRenderTarget(En),
        ot.getClearColor(Ft),
        (Ot = ot.getClearAlpha()),
        Ot < 1 && ot.setClearColor(16777215, 0.5),
        ot.clear(),
        fn && Rn.render(Qt);
      const Nn = ot.toneMapping;
      ot.toneMapping = NoToneMapping;
      const Hn = Zt.viewport;
      if (
        (Zt.viewport !== void 0 && (Zt.viewport = void 0),
        ct.setupLightsView(Zt),
        Pt === !0 && zn.setGlobalState(ot.clippingPlanes, Zt),
        Us(It, Qt, Zt),
        An.updateMultisampleRenderTarget(En),
        An.updateRenderTargetMipmap(En),
        $t.has("WEBGL_multisampled_render_to_texture") === !1)
      ) {
        let Kn = !1;
        for (let jn = 0, ir = zt.length; jn < ir; jn++) {
          const ur = zt[jn],
            lr = ur.object,
            yr = ur.geometry,
            Gn = ur.material,
            Cn = ur.group;
          if (Gn.side === DoubleSide && lr.layers.test(Zt.layers)) {
            const hr = Gn.side;
            (Gn.side = BackSide),
              (Gn.needsUpdate = !0),
              _s(lr, Qt, Zt, yr, Gn, Cn),
              (Gn.side = hr),
              (Gn.needsUpdate = !0),
              (Kn = !0);
          }
        }
        Kn === !0 &&
          (An.updateMultisampleRenderTarget(En),
          An.updateRenderTargetMipmap(En));
      }
      ot.setRenderTarget(On),
        ot.setClearColor(Ft, Ot),
        Hn !== void 0 && (Zt.viewport = Hn),
        (ot.toneMapping = Nn);
    }
    function Us(It, zt, Qt) {
      const Zt = zt.isScene === !0 ? zt.overrideMaterial : null;
      for (let Xt = 0, En = It.length; Xt < En; Xt++) {
        const Fn = It[Xt],
          On = Fn.object,
          Nn = Fn.geometry,
          Hn = Zt === null ? Fn.material : Zt,
          Kn = Fn.group;
        On.layers.test(Qt.layers) && _s(On, zt, Qt, Nn, Hn, Kn);
      }
    }
    function _s(It, zt, Qt, Zt, Xt, En) {
      It.onBeforeRender(ot, zt, Qt, Zt, Xt, En),
        It.modelViewMatrix.multiplyMatrices(
          Qt.matrixWorldInverse,
          It.matrixWorld
        ),
        It.normalMatrix.getNormalMatrix(It.modelViewMatrix),
        Xt.transparent === !0 &&
        Xt.side === DoubleSide &&
        Xt.forceSinglePass === !1
          ? ((Xt.side = BackSide),
            (Xt.needsUpdate = !0),
            ot.renderBufferDirect(Qt, zt, Zt, Xt, It, En),
            (Xt.side = FrontSide),
            (Xt.needsUpdate = !0),
            ot.renderBufferDirect(Qt, zt, Zt, Xt, It, En),
            (Xt.side = DoubleSide))
          : ot.renderBufferDirect(Qt, zt, Zt, Xt, It, En),
        It.onAfterRender(ot, zt, Qt, Zt, Xt, En);
    }
    function Vs(It, zt, Qt) {
      zt.isScene !== !0 && (zt = Tn);
      const Zt = xn.get(It),
        Xt = ct.state.lights,
        En = ct.state.shadowsArray,
        Fn = Xt.state.version,
        On = cn.getParameters(It, Xt.state, En, zt, Qt),
        Nn = cn.getProgramCacheKey(On);
      let Hn = Zt.programs;
      (Zt.environment = It.isMeshStandardMaterial ? zt.environment : null),
        (Zt.fog = zt.fog),
        (Zt.envMap = (It.isMeshStandardMaterial ? wt : kt).get(
          It.envMap || Zt.environment
        )),
        (Zt.envMapRotation =
          Zt.environment !== null && It.envMap === null
            ? zt.environmentRotation
            : It.envMapRotation),
        Hn === void 0 &&
          (It.addEventListener("dispose", $n),
          (Hn = new Map()),
          (Zt.programs = Hn));
      let Kn = Hn.get(Nn);
      if (Kn !== void 0) {
        if (Zt.currentProgram === Kn && Zt.lightsStateVersion === Fn)
          return Co(It, On), Kn;
      } else
        (On.uniforms = cn.getUniforms(It)),
          It.onBeforeCompile(On, ot),
          (Kn = cn.acquireProgram(On, Nn)),
          Hn.set(Nn, Kn),
          (Zt.uniforms = On.uniforms);
      const jn = Zt.uniforms;
      return (
        ((!It.isShaderMaterial && !It.isRawShaderMaterial) ||
          It.clipping === !0) &&
          (jn.clippingPlanes = zn.uniform),
        Co(It, On),
        (Zt.needsLights = Nl(It)),
        (Zt.lightsStateVersion = Fn),
        Zt.needsLights &&
          ((jn.ambientLightColor.value = Xt.state.ambient),
          (jn.lightProbe.value = Xt.state.probe),
          (jn.directionalLights.value = Xt.state.directional),
          (jn.directionalLightShadows.value = Xt.state.directionalShadow),
          (jn.spotLights.value = Xt.state.spot),
          (jn.spotLightShadows.value = Xt.state.spotShadow),
          (jn.rectAreaLights.value = Xt.state.rectArea),
          (jn.ltc_1.value = Xt.state.rectAreaLTC1),
          (jn.ltc_2.value = Xt.state.rectAreaLTC2),
          (jn.pointLights.value = Xt.state.point),
          (jn.pointLightShadows.value = Xt.state.pointShadow),
          (jn.hemisphereLights.value = Xt.state.hemi),
          (jn.directionalShadowMap.value = Xt.state.directionalShadowMap),
          (jn.directionalShadowMatrix.value = Xt.state.directionalShadowMatrix),
          (jn.spotShadowMap.value = Xt.state.spotShadowMap),
          (jn.spotLightMatrix.value = Xt.state.spotLightMatrix),
          (jn.spotLightMap.value = Xt.state.spotLightMap),
          (jn.pointShadowMap.value = Xt.state.pointShadowMap),
          (jn.pointShadowMatrix.value = Xt.state.pointShadowMatrix)),
        (Zt.currentProgram = Kn),
        (Zt.uniformsList = null),
        Kn
      );
    }
    function Mo(It) {
      if (It.uniformsList === null) {
        const zt = It.currentProgram.getUniforms();
        It.uniformsList = WebGLUniforms.seqWithValue(zt.seq, It.uniforms);
      }
      return It.uniformsList;
    }
    function Co(It, zt) {
      const Qt = xn.get(It);
      (Qt.outputColorSpace = zt.outputColorSpace),
        (Qt.batching = zt.batching),
        (Qt.batchingColor = zt.batchingColor),
        (Qt.instancing = zt.instancing),
        (Qt.instancingColor = zt.instancingColor),
        (Qt.instancingMorph = zt.instancingMorph),
        (Qt.skinning = zt.skinning),
        (Qt.morphTargets = zt.morphTargets),
        (Qt.morphNormals = zt.morphNormals),
        (Qt.morphColors = zt.morphColors),
        (Qt.morphTargetsCount = zt.morphTargetsCount),
        (Qt.numClippingPlanes = zt.numClippingPlanes),
        (Qt.numIntersection = zt.numClipIntersection),
        (Qt.vertexAlphas = zt.vertexAlphas),
        (Qt.vertexTangents = zt.vertexTangents),
        (Qt.toneMapping = zt.toneMapping);
    }
    function Fl(It, zt, Qt, Zt, Xt) {
      zt.isScene !== !0 && (zt = Tn), An.resetTextureUnits();
      const En = zt.fog,
        Fn = Zt.isMeshStandardMaterial ? zt.environment : null,
        On =
          gt === null
            ? ot.outputColorSpace
            : gt.isXRRenderTarget === !0
            ? gt.texture.colorSpace
            : LinearSRGBColorSpace$1,
        Nn = (Zt.isMeshStandardMaterial ? wt : kt).get(Zt.envMap || Fn),
        Hn =
          Zt.vertexColors === !0 &&
          !!Qt.attributes.color &&
          Qt.attributes.color.itemSize === 4,
        Kn = !!Qt.attributes.tangent && (!!Zt.normalMap || Zt.anisotropy > 0),
        jn = !!Qt.morphAttributes.position,
        ir = !!Qt.morphAttributes.normal,
        ur = !!Qt.morphAttributes.color;
      let lr = NoToneMapping;
      Zt.toneMapped &&
        (gt === null || gt.isXRRenderTarget === !0) &&
        (lr = ot.toneMapping);
      const yr =
          Qt.morphAttributes.position ||
          Qt.morphAttributes.normal ||
          Qt.morphAttributes.color,
        Gn = yr !== void 0 ? yr.length : 0,
        Cn = xn.get(Zt),
        hr = ct.state.lights;
      if (Pt === !0 && (Jt === !0 || It !== _t)) {
        const Br = It === _t && Zt.id === xt;
        zn.setState(Zt, It, Br);
      }
      let Jn = !1;
      Zt.version === Cn.__version
        ? ((Cn.needsLights && Cn.lightsStateVersion !== hr.state.version) ||
            Cn.outputColorSpace !== On ||
            (Xt.isBatchedMesh && Cn.batching === !1) ||
            (!Xt.isBatchedMesh && Cn.batching === !0) ||
            (Xt.isBatchedMesh &&
              Cn.batchingColor === !0 &&
              Xt.colorTexture === null) ||
            (Xt.isBatchedMesh &&
              Cn.batchingColor === !1 &&
              Xt.colorTexture !== null) ||
            (Xt.isInstancedMesh && Cn.instancing === !1) ||
            (!Xt.isInstancedMesh && Cn.instancing === !0) ||
            (Xt.isSkinnedMesh && Cn.skinning === !1) ||
            (!Xt.isSkinnedMesh && Cn.skinning === !0) ||
            (Xt.isInstancedMesh &&
              Cn.instancingColor === !0 &&
              Xt.instanceColor === null) ||
            (Xt.isInstancedMesh &&
              Cn.instancingColor === !1 &&
              Xt.instanceColor !== null) ||
            (Xt.isInstancedMesh &&
              Cn.instancingMorph === !0 &&
              Xt.morphTexture === null) ||
            (Xt.isInstancedMesh &&
              Cn.instancingMorph === !1 &&
              Xt.morphTexture !== null) ||
            Cn.envMap !== Nn ||
            (Zt.fog === !0 && Cn.fog !== En) ||
            (Cn.numClippingPlanes !== void 0 &&
              (Cn.numClippingPlanes !== zn.numPlanes ||
                Cn.numIntersection !== zn.numIntersection)) ||
            Cn.vertexAlphas !== Hn ||
            Cn.vertexTangents !== Kn ||
            Cn.morphTargets !== jn ||
            Cn.morphNormals !== ir ||
            Cn.morphColors !== ur ||
            Cn.toneMapping !== lr ||
            Cn.morphTargetsCount !== Gn) &&
          (Jn = !0)
        : ((Jn = !0), (Cn.__version = Zt.version));
      let dr = Cn.currentProgram;
      Jn === !0 && (dr = Vs(Zt, zt, Xt));
      let Vr = !1,
        Sr = !1,
        br = !1;
      const mr = dr.getUniforms(),
        ns = Cn.uniforms;
      if (
        (nn.useProgram(dr.program) && ((Vr = !0), (Sr = !0), (br = !0)),
        Zt.id !== xt && ((xt = Zt.id), (Sr = !0)),
        Vr || _t !== It)
      ) {
        mr.setValue(Bt, "projectionMatrix", It.projectionMatrix),
          mr.setValue(Bt, "viewMatrix", It.matrixWorldInverse);
        const Br = mr.map.cameraPosition;
        Br !== void 0 &&
          Br.setValue(Bt, en.setFromMatrixPosition(It.matrixWorld)),
          yn.logarithmicDepthBuffer &&
            mr.setValue(
              Bt,
              "logDepthBufFC",
              2 / (Math.log(It.far + 1) / Math.LN2)
            ),
          (Zt.isMeshPhongMaterial ||
            Zt.isMeshToonMaterial ||
            Zt.isMeshLambertMaterial ||
            Zt.isMeshBasicMaterial ||
            Zt.isMeshStandardMaterial ||
            Zt.isShaderMaterial) &&
            mr.setValue(Bt, "isOrthographic", It.isOrthographicCamera === !0),
          _t !== It && ((_t = It), (Sr = !0), (br = !0));
      }
      if (Xt.isSkinnedMesh) {
        mr.setOptional(Bt, Xt, "bindMatrix"),
          mr.setOptional(Bt, Xt, "bindMatrixInverse");
        const Br = Xt.skeleton;
        Br &&
          (Br.boneTexture === null && Br.computeBoneTexture(),
          mr.setValue(Bt, "boneTexture", Br.boneTexture, An));
      }
      Xt.isBatchedMesh &&
        (mr.setOptional(Bt, Xt, "batchingTexture"),
        mr.setValue(Bt, "batchingTexture", Xt._matricesTexture, An),
        mr.setOptional(Bt, Xt, "batchingIdTexture"),
        mr.setValue(Bt, "batchingIdTexture", Xt._indirectTexture, An),
        mr.setOptional(Bt, Xt, "batchingColorTexture"),
        Xt._colorsTexture !== null &&
          mr.setValue(Bt, "batchingColorTexture", Xt._colorsTexture, An));
      const Gs = Qt.morphAttributes;
      if (
        ((Gs.position !== void 0 ||
          Gs.normal !== void 0 ||
          Gs.color !== void 0) &&
          qn.update(Xt, Qt, dr),
        (Sr || Cn.receiveShadow !== Xt.receiveShadow) &&
          ((Cn.receiveShadow = Xt.receiveShadow),
          mr.setValue(Bt, "receiveShadow", Xt.receiveShadow)),
        Zt.isMeshGouraudMaterial &&
          Zt.envMap !== null &&
          ((ns.envMap.value = Nn),
          (ns.flipEnvMap.value =
            Nn.isCubeTexture && Nn.isRenderTargetTexture === !1 ? -1 : 1)),
        Zt.isMeshStandardMaterial &&
          Zt.envMap === null &&
          zt.environment !== null &&
          (ns.envMapIntensity.value = zt.environmentIntensity),
        Sr &&
          (mr.setValue(Bt, "toneMappingExposure", ot.toneMappingExposure),
          Cn.needsLights && Dl(ns, br),
          En && Zt.fog === !0 && bn.refreshFogUniforms(ns, En),
          bn.refreshMaterialUniforms(
            ns,
            Zt,
            bt,
            Et,
            ct.state.transmissionRenderTarget[It.id]
          ),
          WebGLUniforms.upload(Bt, Mo(Cn), ns, An)),
        Zt.isShaderMaterial &&
          Zt.uniformsNeedUpdate === !0 &&
          (WebGLUniforms.upload(Bt, Mo(Cn), ns, An),
          (Zt.uniformsNeedUpdate = !1)),
        Zt.isSpriteMaterial && mr.setValue(Bt, "center", Xt.center),
        mr.setValue(Bt, "modelViewMatrix", Xt.modelViewMatrix),
        mr.setValue(Bt, "normalMatrix", Xt.normalMatrix),
        mr.setValue(Bt, "modelMatrix", Xt.matrixWorld),
        Zt.isShaderMaterial || Zt.isRawShaderMaterial)
      ) {
        const Br = Zt.uniformsGroups;
        for (let js = 0, Hr = Br.length; js < Hr; js++) {
          const To = Br[js];
          In.update(To, dr), In.bind(To, dr);
        }
      }
      return dr;
    }
    function Dl(It, zt) {
      (It.ambientLightColor.needsUpdate = zt),
        (It.lightProbe.needsUpdate = zt),
        (It.directionalLights.needsUpdate = zt),
        (It.directionalLightShadows.needsUpdate = zt),
        (It.pointLights.needsUpdate = zt),
        (It.pointLightShadows.needsUpdate = zt),
        (It.spotLights.needsUpdate = zt),
        (It.spotLightShadows.needsUpdate = zt),
        (It.rectAreaLights.needsUpdate = zt),
        (It.hemisphereLights.needsUpdate = zt);
    }
    function Nl(It) {
      return (
        It.isMeshLambertMaterial ||
        It.isMeshToonMaterial ||
        It.isMeshPhongMaterial ||
        It.isMeshStandardMaterial ||
        It.isShadowMaterial ||
        (It.isShaderMaterial && It.lights === !0)
      );
    }
    (this.getActiveCubeFace = function () {
      return pt;
    }),
      (this.getActiveMipmapLevel = function () {
        return ft;
      }),
      (this.getRenderTarget = function () {
        return gt;
      }),
      (this.setRenderTargetTextures = function (It, zt, Qt) {
        (xn.get(It.texture).__webglTexture = zt),
          (xn.get(It.depthTexture).__webglTexture = Qt);
        const Zt = xn.get(It);
        (Zt.__hasExternalTextures = !0),
          (Zt.__autoAllocateDepthBuffer = Qt === void 0),
          Zt.__autoAllocateDepthBuffer ||
            ($t.has("WEBGL_multisampled_render_to_texture") === !0 &&
              (console.warn(
                "THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided"
              ),
              (Zt.__useRenderToTexture = !1)));
      }),
      (this.setRenderTargetFramebuffer = function (It, zt) {
        const Qt = xn.get(It);
        (Qt.__webglFramebuffer = zt),
          (Qt.__useDefaultFramebuffer = zt === void 0);
      }),
      (this.setRenderTarget = function (It, zt = 0, Qt = 0) {
        (gt = It), (pt = zt), (ft = Qt);
        let Zt = !0,
          Xt = null,
          En = !1,
          Fn = !1;
        if (It) {
          const Nn = xn.get(It);
          Nn.__useDefaultFramebuffer !== void 0
            ? (nn.bindFramebuffer(Bt.FRAMEBUFFER, null), (Zt = !1))
            : Nn.__webglFramebuffer === void 0
            ? An.setupRenderTarget(It)
            : Nn.__hasExternalTextures &&
              An.rebindTextures(
                It,
                xn.get(It.texture).__webglTexture,
                xn.get(It.depthTexture).__webglTexture
              );
          const Hn = It.texture;
          (Hn.isData3DTexture ||
            Hn.isDataArrayTexture ||
            Hn.isCompressedArrayTexture) &&
            (Fn = !0);
          const Kn = xn.get(It).__webglFramebuffer;
          It.isWebGLCubeRenderTarget
            ? (Array.isArray(Kn[zt]) ? (Xt = Kn[zt][Qt]) : (Xt = Kn[zt]),
              (En = !0))
            : It.samples > 0 && An.useMultisampledRTT(It) === !1
            ? (Xt = xn.get(It).__webglMultisampledFramebuffer)
            : Array.isArray(Kn)
            ? (Xt = Kn[Qt])
            : (Xt = Kn),
            St.copy(It.viewport),
            Mt.copy(It.scissor),
            (Rt = It.scissorTest);
        } else
          St.copy(Ct).multiplyScalar(bt).floor(),
            Mt.copy(Tt).multiplyScalar(bt).floor(),
            (Rt = Dt);
        if (
          (nn.bindFramebuffer(Bt.FRAMEBUFFER, Xt) &&
            Zt &&
            nn.drawBuffers(It, Xt),
          nn.viewport(St),
          nn.scissor(Mt),
          nn.setScissorTest(Rt),
          En)
        ) {
          const Nn = xn.get(It.texture);
          Bt.framebufferTexture2D(
            Bt.FRAMEBUFFER,
            Bt.COLOR_ATTACHMENT0,
            Bt.TEXTURE_CUBE_MAP_POSITIVE_X + zt,
            Nn.__webglTexture,
            Qt
          );
        } else if (Fn) {
          const Nn = xn.get(It.texture),
            Hn = zt || 0;
          Bt.framebufferTextureLayer(
            Bt.FRAMEBUFFER,
            Bt.COLOR_ATTACHMENT0,
            Nn.__webglTexture,
            Qt || 0,
            Hn
          );
        }
        xt = -1;
      }),
      (this.readRenderTargetPixels = function (It, zt, Qt, Zt, Xt, En, Fn) {
        if (!(It && It.isWebGLRenderTarget)) {
          console.error(
            "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget."
          );
          return;
        }
        let On = xn.get(It).__webglFramebuffer;
        if (
          (It.isWebGLCubeRenderTarget && Fn !== void 0 && (On = On[Fn]), On)
        ) {
          nn.bindFramebuffer(Bt.FRAMEBUFFER, On);
          try {
            const Nn = It.texture,
              Hn = Nn.format,
              Kn = Nn.type;
            if (!yn.textureFormatReadable(Hn)) {
              console.error(
                "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format."
              );
              return;
            }
            if (!yn.textureTypeReadable(Kn)) {
              console.error(
                "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type."
              );
              return;
            }
            zt >= 0 &&
              zt <= It.width - Zt &&
              Qt >= 0 &&
              Qt <= It.height - Xt &&
              Bt.readPixels(zt, Qt, Zt, Xt, Vt.convert(Hn), Vt.convert(Kn), En);
          } finally {
            const Nn = gt !== null ? xn.get(gt).__webglFramebuffer : null;
            nn.bindFramebuffer(Bt.FRAMEBUFFER, Nn);
          }
        }
      }),
      (this.readRenderTargetPixelsAsync = async function (
        It,
        zt,
        Qt,
        Zt,
        Xt,
        En,
        Fn
      ) {
        if (!(It && It.isWebGLRenderTarget))
          throw new Error(
            "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget."
          );
        let On = xn.get(It).__webglFramebuffer;
        if (
          (It.isWebGLCubeRenderTarget && Fn !== void 0 && (On = On[Fn]), On)
        ) {
          nn.bindFramebuffer(Bt.FRAMEBUFFER, On);
          try {
            const Nn = It.texture,
              Hn = Nn.format,
              Kn = Nn.type;
            if (!yn.textureFormatReadable(Hn))
              throw new Error(
                "THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in RGBA or implementation defined format."
              );
            if (!yn.textureTypeReadable(Kn))
              throw new Error(
                "THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in UnsignedByteType or implementation defined type."
              );
            if (
              zt >= 0 &&
              zt <= It.width - Zt &&
              Qt >= 0 &&
              Qt <= It.height - Xt
            ) {
              const jn = Bt.createBuffer();
              Bt.bindBuffer(Bt.PIXEL_PACK_BUFFER, jn),
                Bt.bufferData(
                  Bt.PIXEL_PACK_BUFFER,
                  En.byteLength,
                  Bt.STREAM_READ
                ),
                Bt.readPixels(
                  zt,
                  Qt,
                  Zt,
                  Xt,
                  Vt.convert(Hn),
                  Vt.convert(Kn),
                  0
                ),
                Bt.flush();
              const ir = Bt.fenceSync(Bt.SYNC_GPU_COMMANDS_COMPLETE, 0);
              await probeAsync(Bt, ir, 4);
              try {
                Bt.bindBuffer(Bt.PIXEL_PACK_BUFFER, jn),
                  Bt.getBufferSubData(Bt.PIXEL_PACK_BUFFER, 0, En);
              } finally {
                Bt.deleteBuffer(jn), Bt.deleteSync(ir);
              }
              return En;
            }
          } finally {
            const Nn = gt !== null ? xn.get(gt).__webglFramebuffer : null;
            nn.bindFramebuffer(Bt.FRAMEBUFFER, Nn);
          }
        }
      }),
      (this.copyFramebufferToTexture = function (It, zt = null, Qt = 0) {
        It.isTexture !== !0 &&
          (warnOnce(
            "WebGLRenderer: copyFramebufferToTexture function signature has changed."
          ),
          (zt = arguments[0] || null),
          (It = arguments[1]));
        const Zt = Math.pow(2, -Qt),
          Xt = Math.floor(It.image.width * Zt),
          En = Math.floor(It.image.height * Zt),
          Fn = zt !== null ? zt.x : 0,
          On = zt !== null ? zt.y : 0;
        An.setTexture2D(It, 0),
          Bt.copyTexSubImage2D(Bt.TEXTURE_2D, Qt, 0, 0, Fn, On, Xt, En),
          nn.unbindTexture();
      }),
      (this.copyTextureToTexture = function (
        It,
        zt,
        Qt = null,
        Zt = null,
        Xt = 0
      ) {
        It.isTexture !== !0 &&
          (warnOnce(
            "WebGLRenderer: copyTextureToTexture function signature has changed."
          ),
          (Zt = arguments[0] || null),
          (It = arguments[1]),
          (zt = arguments[2]),
          (Xt = arguments[3] || 0),
          (Qt = null));
        let En, Fn, On, Nn, Hn, Kn;
        Qt !== null
          ? ((En = Qt.max.x - Qt.min.x),
            (Fn = Qt.max.y - Qt.min.y),
            (On = Qt.min.x),
            (Nn = Qt.min.y))
          : ((En = It.image.width), (Fn = It.image.height), (On = 0), (Nn = 0)),
          Zt !== null ? ((Hn = Zt.x), (Kn = Zt.y)) : ((Hn = 0), (Kn = 0));
        const jn = Vt.convert(zt.format),
          ir = Vt.convert(zt.type);
        An.setTexture2D(zt, 0),
          Bt.pixelStorei(Bt.UNPACK_FLIP_Y_WEBGL, zt.flipY),
          Bt.pixelStorei(
            Bt.UNPACK_PREMULTIPLY_ALPHA_WEBGL,
            zt.premultiplyAlpha
          ),
          Bt.pixelStorei(Bt.UNPACK_ALIGNMENT, zt.unpackAlignment);
        const ur = Bt.getParameter(Bt.UNPACK_ROW_LENGTH),
          lr = Bt.getParameter(Bt.UNPACK_IMAGE_HEIGHT),
          yr = Bt.getParameter(Bt.UNPACK_SKIP_PIXELS),
          Gn = Bt.getParameter(Bt.UNPACK_SKIP_ROWS),
          Cn = Bt.getParameter(Bt.UNPACK_SKIP_IMAGES),
          hr = It.isCompressedTexture ? It.mipmaps[Xt] : It.image;
        Bt.pixelStorei(Bt.UNPACK_ROW_LENGTH, hr.width),
          Bt.pixelStorei(Bt.UNPACK_IMAGE_HEIGHT, hr.height),
          Bt.pixelStorei(Bt.UNPACK_SKIP_PIXELS, On),
          Bt.pixelStorei(Bt.UNPACK_SKIP_ROWS, Nn),
          It.isDataTexture
            ? Bt.texSubImage2D(
                Bt.TEXTURE_2D,
                Xt,
                Hn,
                Kn,
                En,
                Fn,
                jn,
                ir,
                hr.data
              )
            : It.isCompressedTexture
            ? Bt.compressedTexSubImage2D(
                Bt.TEXTURE_2D,
                Xt,
                Hn,
                Kn,
                hr.width,
                hr.height,
                jn,
                hr.data
              )
            : Bt.texSubImage2D(Bt.TEXTURE_2D, Xt, Hn, Kn, En, Fn, jn, ir, hr),
          Bt.pixelStorei(Bt.UNPACK_ROW_LENGTH, ur),
          Bt.pixelStorei(Bt.UNPACK_IMAGE_HEIGHT, lr),
          Bt.pixelStorei(Bt.UNPACK_SKIP_PIXELS, yr),
          Bt.pixelStorei(Bt.UNPACK_SKIP_ROWS, Gn),
          Bt.pixelStorei(Bt.UNPACK_SKIP_IMAGES, Cn),
          Xt === 0 && zt.generateMipmaps && Bt.generateMipmap(Bt.TEXTURE_2D),
          nn.unbindTexture();
      }),
      (this.copyTextureToTexture3D = function (
        It,
        zt,
        Qt = null,
        Zt = null,
        Xt = 0
      ) {
        It.isTexture !== !0 &&
          (warnOnce(
            "WebGLRenderer: copyTextureToTexture3D function signature has changed."
          ),
          (Qt = arguments[0] || null),
          (Zt = arguments[1] || null),
          (It = arguments[2]),
          (zt = arguments[3]),
          (Xt = arguments[4] || 0));
        let En, Fn, On, Nn, Hn, Kn, jn, ir, ur;
        const lr = It.isCompressedTexture ? It.mipmaps[Xt] : It.image;
        Qt !== null
          ? ((En = Qt.max.x - Qt.min.x),
            (Fn = Qt.max.y - Qt.min.y),
            (On = Qt.max.z - Qt.min.z),
            (Nn = Qt.min.x),
            (Hn = Qt.min.y),
            (Kn = Qt.min.z))
          : ((En = lr.width),
            (Fn = lr.height),
            (On = lr.depth),
            (Nn = 0),
            (Hn = 0),
            (Kn = 0)),
          Zt !== null
            ? ((jn = Zt.x), (ir = Zt.y), (ur = Zt.z))
            : ((jn = 0), (ir = 0), (ur = 0));
        const yr = Vt.convert(zt.format),
          Gn = Vt.convert(zt.type);
        let Cn;
        if (zt.isData3DTexture) An.setTexture3D(zt, 0), (Cn = Bt.TEXTURE_3D);
        else if (zt.isDataArrayTexture || zt.isCompressedArrayTexture)
          An.setTexture2DArray(zt, 0), (Cn = Bt.TEXTURE_2D_ARRAY);
        else {
          console.warn(
            "THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray."
          );
          return;
        }
        Bt.pixelStorei(Bt.UNPACK_FLIP_Y_WEBGL, zt.flipY),
          Bt.pixelStorei(
            Bt.UNPACK_PREMULTIPLY_ALPHA_WEBGL,
            zt.premultiplyAlpha
          ),
          Bt.pixelStorei(Bt.UNPACK_ALIGNMENT, zt.unpackAlignment);
        const hr = Bt.getParameter(Bt.UNPACK_ROW_LENGTH),
          Jn = Bt.getParameter(Bt.UNPACK_IMAGE_HEIGHT),
          dr = Bt.getParameter(Bt.UNPACK_SKIP_PIXELS),
          Vr = Bt.getParameter(Bt.UNPACK_SKIP_ROWS),
          Sr = Bt.getParameter(Bt.UNPACK_SKIP_IMAGES);
        Bt.pixelStorei(Bt.UNPACK_ROW_LENGTH, lr.width),
          Bt.pixelStorei(Bt.UNPACK_IMAGE_HEIGHT, lr.height),
          Bt.pixelStorei(Bt.UNPACK_SKIP_PIXELS, Nn),
          Bt.pixelStorei(Bt.UNPACK_SKIP_ROWS, Hn),
          Bt.pixelStorei(Bt.UNPACK_SKIP_IMAGES, Kn),
          It.isDataTexture || It.isData3DTexture
            ? Bt.texSubImage3D(Cn, Xt, jn, ir, ur, En, Fn, On, yr, Gn, lr.data)
            : zt.isCompressedArrayTexture
            ? Bt.compressedTexSubImage3D(
                Cn,
                Xt,
                jn,
                ir,
                ur,
                En,
                Fn,
                On,
                yr,
                lr.data
              )
            : Bt.texSubImage3D(Cn, Xt, jn, ir, ur, En, Fn, On, yr, Gn, lr),
          Bt.pixelStorei(Bt.UNPACK_ROW_LENGTH, hr),
          Bt.pixelStorei(Bt.UNPACK_IMAGE_HEIGHT, Jn),
          Bt.pixelStorei(Bt.UNPACK_SKIP_PIXELS, dr),
          Bt.pixelStorei(Bt.UNPACK_SKIP_ROWS, Vr),
          Bt.pixelStorei(Bt.UNPACK_SKIP_IMAGES, Sr),
          Xt === 0 && zt.generateMipmaps && Bt.generateMipmap(Cn),
          nn.unbindTexture();
      }),
      (this.initRenderTarget = function (It) {
        xn.get(It).__webglFramebuffer === void 0 && An.setupRenderTarget(It);
      }),
      (this.initTexture = function (It) {
        It.isCubeTexture
          ? An.setTextureCube(It, 0)
          : It.isData3DTexture
          ? An.setTexture3D(It, 0)
          : It.isDataArrayTexture || It.isCompressedArrayTexture
          ? An.setTexture2DArray(It, 0)
          : An.setTexture2D(It, 0),
          nn.unbindTexture();
      }),
      (this.resetState = function () {
        (pt = 0), (ft = 0), (gt = null), nn.reset(), un.reset();
      }),
      typeof __THREE_DEVTOOLS__ < "u" &&
        __THREE_DEVTOOLS__.dispatchEvent(
          new CustomEvent("observe", { detail: this })
        );
  }
  get coordinateSystem() {
    return WebGLCoordinateSystem;
  }
  get outputColorSpace() {
    return this._outputColorSpace;
  }
  set outputColorSpace(e) {
    this._outputColorSpace = e;
    const o = this.getContext();
    (o.drawingBufferColorSpace =
      e === DisplayP3ColorSpace ? "display-p3" : "srgb"),
      (o.unpackColorSpace =
        ColorManagement.workingColorSpace === LinearDisplayP3ColorSpace
          ? "display-p3"
          : "srgb");
  }
}
class FogExp2 {
  constructor(e, o = 25e-5) {
    (this.isFogExp2 = !0),
      (this.name = ""),
      (this.color = new Color(e)),
      (this.density = o);
  }
  clone() {
    return new FogExp2(this.color, this.density);
  }
  toJSON() {
    return {
      type: "FogExp2",
      name: this.name,
      color: this.color.getHex(),
      density: this.density,
    };
  }
}
class Fog {
  constructor(e, o = 1, a = 1e3) {
    (this.isFog = !0),
      (this.name = ""),
      (this.color = new Color(e)),
      (this.near = o),
      (this.far = a);
  }
  clone() {
    return new Fog(this.color, this.near, this.far);
  }
  toJSON() {
    return {
      type: "Fog",
      name: this.name,
      color: this.color.getHex(),
      near: this.near,
      far: this.far,
    };
  }
}
class Scene extends Object3D {
  constructor() {
    super(),
      (this.isScene = !0),
      (this.type = "Scene"),
      (this.background = null),
      (this.environment = null),
      (this.fog = null),
      (this.backgroundBlurriness = 0),
      (this.backgroundIntensity = 1),
      (this.backgroundRotation = new Euler()),
      (this.environmentIntensity = 1),
      (this.environmentRotation = new Euler()),
      (this.overrideMaterial = null),
      typeof __THREE_DEVTOOLS__ < "u" &&
        __THREE_DEVTOOLS__.dispatchEvent(
          new CustomEvent("observe", { detail: this })
        );
  }
  copy(e, o) {
    return (
      super.copy(e, o),
      e.background !== null && (this.background = e.background.clone()),
      e.environment !== null && (this.environment = e.environment.clone()),
      e.fog !== null && (this.fog = e.fog.clone()),
      (this.backgroundBlurriness = e.backgroundBlurriness),
      (this.backgroundIntensity = e.backgroundIntensity),
      this.backgroundRotation.copy(e.backgroundRotation),
      (this.environmentIntensity = e.environmentIntensity),
      this.environmentRotation.copy(e.environmentRotation),
      e.overrideMaterial !== null &&
        (this.overrideMaterial = e.overrideMaterial.clone()),
      (this.matrixAutoUpdate = e.matrixAutoUpdate),
      this
    );
  }
  toJSON(e) {
    const o = super.toJSON(e);
    return (
      this.fog !== null && (o.object.fog = this.fog.toJSON()),
      this.backgroundBlurriness > 0 &&
        (o.object.backgroundBlurriness = this.backgroundBlurriness),
      this.backgroundIntensity !== 1 &&
        (o.object.backgroundIntensity = this.backgroundIntensity),
      (o.object.backgroundRotation = this.backgroundRotation.toArray()),
      this.environmentIntensity !== 1 &&
        (o.object.environmentIntensity = this.environmentIntensity),
      (o.object.environmentRotation = this.environmentRotation.toArray()),
      o
    );
  }
}
class InterleavedBuffer {
  constructor(e, o) {
    (this.isInterleavedBuffer = !0),
      (this.array = e),
      (this.stride = o),
      (this.count = e !== void 0 ? e.length / o : 0),
      (this.usage = StaticDrawUsage),
      (this._updateRange = { offset: 0, count: -1 }),
      (this.updateRanges = []),
      (this.version = 0),
      (this.uuid = generateUUID());
  }
  onUploadCallback() {}
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  get updateRange() {
    return (
      warnOnce(
        "THREE.InterleavedBuffer: updateRange() is deprecated and will be removed in r169. Use addUpdateRange() instead."
      ),
      this._updateRange
    );
  }
  setUsage(e) {
    return (this.usage = e), this;
  }
  addUpdateRange(e, o) {
    this.updateRanges.push({ start: e, count: o });
  }
  clearUpdateRanges() {
    this.updateRanges.length = 0;
  }
  copy(e) {
    return (
      (this.array = new e.array.constructor(e.array)),
      (this.count = e.count),
      (this.stride = e.stride),
      (this.usage = e.usage),
      this
    );
  }
  copyAt(e, o, a) {
    (e *= this.stride), (a *= o.stride);
    for (let c = 0, d = this.stride; c < d; c++)
      this.array[e + c] = o.array[a + c];
    return this;
  }
  set(e, o = 0) {
    return this.array.set(e, o), this;
  }
  clone(e) {
    e.arrayBuffers === void 0 && (e.arrayBuffers = {}),
      this.array.buffer._uuid === void 0 &&
        (this.array.buffer._uuid = generateUUID()),
      e.arrayBuffers[this.array.buffer._uuid] === void 0 &&
        (e.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer);
    const o = new this.array.constructor(
        e.arrayBuffers[this.array.buffer._uuid]
      ),
      a = new this.constructor(o, this.stride);
    return a.setUsage(this.usage), a;
  }
  onUpload(e) {
    return (this.onUploadCallback = e), this;
  }
  toJSON(e) {
    return (
      e.arrayBuffers === void 0 && (e.arrayBuffers = {}),
      this.array.buffer._uuid === void 0 &&
        (this.array.buffer._uuid = generateUUID()),
      e.arrayBuffers[this.array.buffer._uuid] === void 0 &&
        (e.arrayBuffers[this.array.buffer._uuid] = Array.from(
          new Uint32Array(this.array.buffer)
        )),
      {
        uuid: this.uuid,
        buffer: this.array.buffer._uuid,
        type: this.array.constructor.name,
        stride: this.stride,
      }
    );
  }
}
const _vector$6 = new Vector3();
class InterleavedBufferAttribute {
  constructor(e, o, a, c = !1) {
    (this.isInterleavedBufferAttribute = !0),
      (this.name = ""),
      (this.data = e),
      (this.itemSize = o),
      (this.offset = a),
      (this.normalized = c);
  }
  get count() {
    return this.data.count;
  }
  get array() {
    return this.data.array;
  }
  set needsUpdate(e) {
    this.data.needsUpdate = e;
  }
  applyMatrix4(e) {
    for (let o = 0, a = this.data.count; o < a; o++)
      _vector$6.fromBufferAttribute(this, o),
        _vector$6.applyMatrix4(e),
        this.setXYZ(o, _vector$6.x, _vector$6.y, _vector$6.z);
    return this;
  }
  applyNormalMatrix(e) {
    for (let o = 0, a = this.count; o < a; o++)
      _vector$6.fromBufferAttribute(this, o),
        _vector$6.applyNormalMatrix(e),
        this.setXYZ(o, _vector$6.x, _vector$6.y, _vector$6.z);
    return this;
  }
  transformDirection(e) {
    for (let o = 0, a = this.count; o < a; o++)
      _vector$6.fromBufferAttribute(this, o),
        _vector$6.transformDirection(e),
        this.setXYZ(o, _vector$6.x, _vector$6.y, _vector$6.z);
    return this;
  }
  getComponent(e, o) {
    let a = this.array[e * this.data.stride + this.offset + o];
    return this.normalized && (a = denormalize(a, this.array)), a;
  }
  setComponent(e, o, a) {
    return (
      this.normalized && (a = normalize(a, this.array)),
      (this.data.array[e * this.data.stride + this.offset + o] = a),
      this
    );
  }
  setX(e, o) {
    return (
      this.normalized && (o = normalize(o, this.array)),
      (this.data.array[e * this.data.stride + this.offset] = o),
      this
    );
  }
  setY(e, o) {
    return (
      this.normalized && (o = normalize(o, this.array)),
      (this.data.array[e * this.data.stride + this.offset + 1] = o),
      this
    );
  }
  setZ(e, o) {
    return (
      this.normalized && (o = normalize(o, this.array)),
      (this.data.array[e * this.data.stride + this.offset + 2] = o),
      this
    );
  }
  setW(e, o) {
    return (
      this.normalized && (o = normalize(o, this.array)),
      (this.data.array[e * this.data.stride + this.offset + 3] = o),
      this
    );
  }
  getX(e) {
    let o = this.data.array[e * this.data.stride + this.offset];
    return this.normalized && (o = denormalize(o, this.array)), o;
  }
  getY(e) {
    let o = this.data.array[e * this.data.stride + this.offset + 1];
    return this.normalized && (o = denormalize(o, this.array)), o;
  }
  getZ(e) {
    let o = this.data.array[e * this.data.stride + this.offset + 2];
    return this.normalized && (o = denormalize(o, this.array)), o;
  }
  getW(e) {
    let o = this.data.array[e * this.data.stride + this.offset + 3];
    return this.normalized && (o = denormalize(o, this.array)), o;
  }
  setXY(e, o, a) {
    return (
      (e = e * this.data.stride + this.offset),
      this.normalized &&
        ((o = normalize(o, this.array)), (a = normalize(a, this.array))),
      (this.data.array[e + 0] = o),
      (this.data.array[e + 1] = a),
      this
    );
  }
  setXYZ(e, o, a, c) {
    return (
      (e = e * this.data.stride + this.offset),
      this.normalized &&
        ((o = normalize(o, this.array)),
        (a = normalize(a, this.array)),
        (c = normalize(c, this.array))),
      (this.data.array[e + 0] = o),
      (this.data.array[e + 1] = a),
      (this.data.array[e + 2] = c),
      this
    );
  }
  setXYZW(e, o, a, c, d) {
    return (
      (e = e * this.data.stride + this.offset),
      this.normalized &&
        ((o = normalize(o, this.array)),
        (a = normalize(a, this.array)),
        (c = normalize(c, this.array)),
        (d = normalize(d, this.array))),
      (this.data.array[e + 0] = o),
      (this.data.array[e + 1] = a),
      (this.data.array[e + 2] = c),
      (this.data.array[e + 3] = d),
      this
    );
  }
  clone(e) {
    if (e === void 0) {
      console.log(
        "THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will de-interleave buffer data."
      );
      const o = [];
      for (let a = 0; a < this.count; a++) {
        const c = a * this.data.stride + this.offset;
        for (let d = 0; d < this.itemSize; d++) o.push(this.data.array[c + d]);
      }
      return new BufferAttribute(
        new this.array.constructor(o),
        this.itemSize,
        this.normalized
      );
    } else
      return (
        e.interleavedBuffers === void 0 && (e.interleavedBuffers = {}),
        e.interleavedBuffers[this.data.uuid] === void 0 &&
          (e.interleavedBuffers[this.data.uuid] = this.data.clone(e)),
        new InterleavedBufferAttribute(
          e.interleavedBuffers[this.data.uuid],
          this.itemSize,
          this.offset,
          this.normalized
        )
      );
  }
  toJSON(e) {
    if (e === void 0) {
      console.log(
        "THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will de-interleave buffer data."
      );
      const o = [];
      for (let a = 0; a < this.count; a++) {
        const c = a * this.data.stride + this.offset;
        for (let d = 0; d < this.itemSize; d++) o.push(this.data.array[c + d]);
      }
      return {
        itemSize: this.itemSize,
        type: this.array.constructor.name,
        array: o,
        normalized: this.normalized,
      };
    } else
      return (
        e.interleavedBuffers === void 0 && (e.interleavedBuffers = {}),
        e.interleavedBuffers[this.data.uuid] === void 0 &&
          (e.interleavedBuffers[this.data.uuid] = this.data.toJSON(e)),
        {
          isInterleavedBufferAttribute: !0,
          itemSize: this.itemSize,
          data: this.data.uuid,
          offset: this.offset,
          normalized: this.normalized,
        }
      );
  }
}
class SpriteMaterial extends Material {
  constructor(e) {
    super(),
      (this.isSpriteMaterial = !0),
      (this.type = "SpriteMaterial"),
      (this.color = new Color(16777215)),
      (this.map = null),
      (this.alphaMap = null),
      (this.rotation = 0),
      (this.sizeAttenuation = !0),
      (this.transparent = !0),
      (this.fog = !0),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      this.color.copy(e.color),
      (this.map = e.map),
      (this.alphaMap = e.alphaMap),
      (this.rotation = e.rotation),
      (this.sizeAttenuation = e.sizeAttenuation),
      (this.fog = e.fog),
      this
    );
  }
}
let _geometry;
const _intersectPoint = new Vector3(),
  _worldScale = new Vector3(),
  _mvPosition = new Vector3(),
  _alignedPosition = new Vector2(),
  _rotatedPosition = new Vector2(),
  _viewWorldMatrix = new Matrix4(),
  _vA = new Vector3(),
  _vB = new Vector3(),
  _vC = new Vector3(),
  _uvA = new Vector2(),
  _uvB = new Vector2(),
  _uvC = new Vector2();
class Sprite extends Object3D {
  constructor(e = new SpriteMaterial()) {
    if (
      (super(),
      (this.isSprite = !0),
      (this.type = "Sprite"),
      _geometry === void 0)
    ) {
      _geometry = new BufferGeometry();
      const o = new Float32Array([
          -0.5, -0.5, 0, 0, 0, 0.5, -0.5, 0, 1, 0, 0.5, 0.5, 0, 1, 1, -0.5, 0.5,
          0, 0, 1,
        ]),
        a = new InterleavedBuffer(o, 5);
      _geometry.setIndex([0, 1, 2, 0, 2, 3]),
        _geometry.setAttribute(
          "position",
          new InterleavedBufferAttribute(a, 3, 0, !1)
        ),
        _geometry.setAttribute(
          "uv",
          new InterleavedBufferAttribute(a, 2, 3, !1)
        );
    }
    (this.geometry = _geometry),
      (this.material = e),
      (this.center = new Vector2(0.5, 0.5));
  }
  raycast(e, o) {
    e.camera === null &&
      console.error(
        'THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'
      ),
      _worldScale.setFromMatrixScale(this.matrixWorld),
      _viewWorldMatrix.copy(e.camera.matrixWorld),
      this.modelViewMatrix.multiplyMatrices(
        e.camera.matrixWorldInverse,
        this.matrixWorld
      ),
      _mvPosition.setFromMatrixPosition(this.modelViewMatrix),
      e.camera.isPerspectiveCamera &&
        this.material.sizeAttenuation === !1 &&
        _worldScale.multiplyScalar(-_mvPosition.z);
    const a = this.material.rotation;
    let c, d;
    a !== 0 && ((d = Math.cos(a)), (c = Math.sin(a)));
    const g = this.center;
    transformVertex(_vA.set(-0.5, -0.5, 0), _mvPosition, g, _worldScale, c, d),
      transformVertex(_vB.set(0.5, -0.5, 0), _mvPosition, g, _worldScale, c, d),
      transformVertex(_vC.set(0.5, 0.5, 0), _mvPosition, g, _worldScale, c, d),
      _uvA.set(0, 0),
      _uvB.set(1, 0),
      _uvC.set(1, 1);
    let _ = e.ray.intersectTriangle(_vA, _vB, _vC, !1, _intersectPoint);
    if (
      _ === null &&
      (transformVertex(
        _vB.set(-0.5, 0.5, 0),
        _mvPosition,
        g,
        _worldScale,
        c,
        d
      ),
      _uvB.set(0, 1),
      (_ = e.ray.intersectTriangle(_vA, _vC, _vB, !1, _intersectPoint)),
      _ === null)
    )
      return;
    const b = e.ray.origin.distanceTo(_intersectPoint);
    b < e.near ||
      b > e.far ||
      o.push({
        distance: b,
        point: _intersectPoint.clone(),
        uv: Triangle.getInterpolation(
          _intersectPoint,
          _vA,
          _vB,
          _vC,
          _uvA,
          _uvB,
          _uvC,
          new Vector2()
        ),
        face: null,
        object: this,
      });
  }
  copy(e, o) {
    return (
      super.copy(e, o),
      e.center !== void 0 && this.center.copy(e.center),
      (this.material = e.material),
      this
    );
  }
}
function transformVertex(s, e, o, a, c, d) {
  _alignedPosition.subVectors(s, o).addScalar(0.5).multiply(a),
    c !== void 0
      ? ((_rotatedPosition.x = d * _alignedPosition.x - c * _alignedPosition.y),
        (_rotatedPosition.y = c * _alignedPosition.x + d * _alignedPosition.y))
      : _rotatedPosition.copy(_alignedPosition),
    s.copy(e),
    (s.x += _rotatedPosition.x),
    (s.y += _rotatedPosition.y),
    s.applyMatrix4(_viewWorldMatrix);
}
const _v1$2 = new Vector3(),
  _v2$1 = new Vector3();
class LOD extends Object3D {
  constructor() {
    super(),
      (this._currentLevel = 0),
      (this.type = "LOD"),
      Object.defineProperties(this, {
        levels: { enumerable: !0, value: [] },
        isLOD: { value: !0 },
      }),
      (this.autoUpdate = !0);
  }
  copy(e) {
    super.copy(e, !1);
    const o = e.levels;
    for (let a = 0, c = o.length; a < c; a++) {
      const d = o[a];
      this.addLevel(d.object.clone(), d.distance, d.hysteresis);
    }
    return (this.autoUpdate = e.autoUpdate), this;
  }
  addLevel(e, o = 0, a = 0) {
    o = Math.abs(o);
    const c = this.levels;
    let d;
    for (d = 0; d < c.length && !(o < c[d].distance); d++);
    return (
      c.splice(d, 0, { distance: o, hysteresis: a, object: e }),
      this.add(e),
      this
    );
  }
  getCurrentLevel() {
    return this._currentLevel;
  }
  getObjectForDistance(e) {
    const o = this.levels;
    if (o.length > 0) {
      let a, c;
      for (a = 1, c = o.length; a < c; a++) {
        let d = o[a].distance;
        if ((o[a].object.visible && (d -= d * o[a].hysteresis), e < d)) break;
      }
      return o[a - 1].object;
    }
    return null;
  }
  raycast(e, o) {
    if (this.levels.length > 0) {
      _v1$2.setFromMatrixPosition(this.matrixWorld);
      const c = e.ray.origin.distanceTo(_v1$2);
      this.getObjectForDistance(c).raycast(e, o);
    }
  }
  update(e) {
    const o = this.levels;
    if (o.length > 1) {
      _v1$2.setFromMatrixPosition(e.matrixWorld),
        _v2$1.setFromMatrixPosition(this.matrixWorld);
      const a = _v1$2.distanceTo(_v2$1) / e.zoom;
      o[0].object.visible = !0;
      let c, d;
      for (c = 1, d = o.length; c < d; c++) {
        let g = o[c].distance;
        if ((o[c].object.visible && (g -= g * o[c].hysteresis), a >= g))
          (o[c - 1].object.visible = !1), (o[c].object.visible = !0);
        else break;
      }
      for (this._currentLevel = c - 1; c < d; c++) o[c].object.visible = !1;
    }
  }
  toJSON(e) {
    const o = super.toJSON(e);
    this.autoUpdate === !1 && (o.object.autoUpdate = !1),
      (o.object.levels = []);
    const a = this.levels;
    for (let c = 0, d = a.length; c < d; c++) {
      const g = a[c];
      o.object.levels.push({
        object: g.object.uuid,
        distance: g.distance,
        hysteresis: g.hysteresis,
      });
    }
    return o;
  }
}
const _basePosition = new Vector3(),
  _skinIndex = new Vector4(),
  _skinWeight = new Vector4(),
  _vector3 = new Vector3(),
  _matrix4 = new Matrix4(),
  _vertex = new Vector3(),
  _sphere$4 = new Sphere(),
  _inverseMatrix$2 = new Matrix4(),
  _ray$2 = new Ray();
class SkinnedMesh extends Mesh {
  constructor(e, o) {
    super(e, o),
      (this.isSkinnedMesh = !0),
      (this.type = "SkinnedMesh"),
      (this.bindMode = AttachedBindMode),
      (this.bindMatrix = new Matrix4()),
      (this.bindMatrixInverse = new Matrix4()),
      (this.boundingBox = null),
      (this.boundingSphere = null);
  }
  computeBoundingBox() {
    const e = this.geometry;
    this.boundingBox === null && (this.boundingBox = new Box3()),
      this.boundingBox.makeEmpty();
    const o = e.getAttribute("position");
    for (let a = 0; a < o.count; a++)
      this.getVertexPosition(a, _vertex),
        this.boundingBox.expandByPoint(_vertex);
  }
  computeBoundingSphere() {
    const e = this.geometry;
    this.boundingSphere === null && (this.boundingSphere = new Sphere()),
      this.boundingSphere.makeEmpty();
    const o = e.getAttribute("position");
    for (let a = 0; a < o.count; a++)
      this.getVertexPosition(a, _vertex),
        this.boundingSphere.expandByPoint(_vertex);
  }
  copy(e, o) {
    return (
      super.copy(e, o),
      (this.bindMode = e.bindMode),
      this.bindMatrix.copy(e.bindMatrix),
      this.bindMatrixInverse.copy(e.bindMatrixInverse),
      (this.skeleton = e.skeleton),
      e.boundingBox !== null && (this.boundingBox = e.boundingBox.clone()),
      e.boundingSphere !== null &&
        (this.boundingSphere = e.boundingSphere.clone()),
      this
    );
  }
  raycast(e, o) {
    const a = this.material,
      c = this.matrixWorld;
    a !== void 0 &&
      (this.boundingSphere === null && this.computeBoundingSphere(),
      _sphere$4.copy(this.boundingSphere),
      _sphere$4.applyMatrix4(c),
      e.ray.intersectsSphere(_sphere$4) !== !1 &&
        (_inverseMatrix$2.copy(c).invert(),
        _ray$2.copy(e.ray).applyMatrix4(_inverseMatrix$2),
        !(
          this.boundingBox !== null &&
          _ray$2.intersectsBox(this.boundingBox) === !1
        ) && this._computeIntersections(e, o, _ray$2)));
  }
  getVertexPosition(e, o) {
    return super.getVertexPosition(e, o), this.applyBoneTransform(e, o), o;
  }
  bind(e, o) {
    (this.skeleton = e),
      o === void 0 &&
        (this.updateMatrixWorld(!0),
        this.skeleton.calculateInverses(),
        (o = this.matrixWorld)),
      this.bindMatrix.copy(o),
      this.bindMatrixInverse.copy(o).invert();
  }
  pose() {
    this.skeleton.pose();
  }
  normalizeSkinWeights() {
    const e = new Vector4(),
      o = this.geometry.attributes.skinWeight;
    for (let a = 0, c = o.count; a < c; a++) {
      e.fromBufferAttribute(o, a);
      const d = 1 / e.manhattanLength();
      d !== 1 / 0 ? e.multiplyScalar(d) : e.set(1, 0, 0, 0),
        o.setXYZW(a, e.x, e.y, e.z, e.w);
    }
  }
  updateMatrixWorld(e) {
    super.updateMatrixWorld(e),
      this.bindMode === AttachedBindMode
        ? this.bindMatrixInverse.copy(this.matrixWorld).invert()
        : this.bindMode === DetachedBindMode
        ? this.bindMatrixInverse.copy(this.bindMatrix).invert()
        : console.warn(
            "THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode
          );
  }
  applyBoneTransform(e, o) {
    const a = this.skeleton,
      c = this.geometry;
    _skinIndex.fromBufferAttribute(c.attributes.skinIndex, e),
      _skinWeight.fromBufferAttribute(c.attributes.skinWeight, e),
      _basePosition.copy(o).applyMatrix4(this.bindMatrix),
      o.set(0, 0, 0);
    for (let d = 0; d < 4; d++) {
      const g = _skinWeight.getComponent(d);
      if (g !== 0) {
        const _ = _skinIndex.getComponent(d);
        _matrix4.multiplyMatrices(a.bones[_].matrixWorld, a.boneInverses[_]),
          o.addScaledVector(
            _vector3.copy(_basePosition).applyMatrix4(_matrix4),
            g
          );
      }
    }
    return o.applyMatrix4(this.bindMatrixInverse);
  }
}
class Bone extends Object3D {
  constructor() {
    super(), (this.isBone = !0), (this.type = "Bone");
  }
}
class DataTexture extends Texture {
  constructor(
    e = null,
    o = 1,
    a = 1,
    c,
    d,
    g,
    _,
    b,
    j = NearestFilter,
    $ = NearestFilter,
    _e,
    et
  ) {
    super(null, g, _, b, j, $, c, d, _e, et),
      (this.isDataTexture = !0),
      (this.image = { data: e, width: o, height: a }),
      (this.generateMipmaps = !1),
      (this.flipY = !1),
      (this.unpackAlignment = 1);
  }
}
const _offsetMatrix = new Matrix4(),
  _identityMatrix$1 = new Matrix4();
class Skeleton {
  constructor(e = [], o = []) {
    (this.uuid = generateUUID()),
      (this.bones = e.slice(0)),
      (this.boneInverses = o),
      (this.boneMatrices = null),
      (this.boneTexture = null),
      this.init();
  }
  init() {
    const e = this.bones,
      o = this.boneInverses;
    if (((this.boneMatrices = new Float32Array(e.length * 16)), o.length === 0))
      this.calculateInverses();
    else if (e.length !== o.length) {
      console.warn(
        "THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."
      ),
        (this.boneInverses = []);
      for (let a = 0, c = this.bones.length; a < c; a++)
        this.boneInverses.push(new Matrix4());
    }
  }
  calculateInverses() {
    this.boneInverses.length = 0;
    for (let e = 0, o = this.bones.length; e < o; e++) {
      const a = new Matrix4();
      this.bones[e] && a.copy(this.bones[e].matrixWorld).invert(),
        this.boneInverses.push(a);
    }
  }
  pose() {
    for (let e = 0, o = this.bones.length; e < o; e++) {
      const a = this.bones[e];
      a && a.matrixWorld.copy(this.boneInverses[e]).invert();
    }
    for (let e = 0, o = this.bones.length; e < o; e++) {
      const a = this.bones[e];
      a &&
        (a.parent && a.parent.isBone
          ? (a.matrix.copy(a.parent.matrixWorld).invert(),
            a.matrix.multiply(a.matrixWorld))
          : a.matrix.copy(a.matrixWorld),
        a.matrix.decompose(a.position, a.quaternion, a.scale));
    }
  }
  update() {
    const e = this.bones,
      o = this.boneInverses,
      a = this.boneMatrices,
      c = this.boneTexture;
    for (let d = 0, g = e.length; d < g; d++) {
      const _ = e[d] ? e[d].matrixWorld : _identityMatrix$1;
      _offsetMatrix.multiplyMatrices(_, o[d]), _offsetMatrix.toArray(a, d * 16);
    }
    c !== null && (c.needsUpdate = !0);
  }
  clone() {
    return new Skeleton(this.bones, this.boneInverses);
  }
  computeBoneTexture() {
    let e = Math.sqrt(this.bones.length * 4);
    (e = Math.ceil(e / 4) * 4), (e = Math.max(e, 4));
    const o = new Float32Array(e * e * 4);
    o.set(this.boneMatrices);
    const a = new DataTexture(o, e, e, RGBAFormat, FloatType);
    return (
      (a.needsUpdate = !0),
      (this.boneMatrices = o),
      (this.boneTexture = a),
      this
    );
  }
  getBoneByName(e) {
    for (let o = 0, a = this.bones.length; o < a; o++) {
      const c = this.bones[o];
      if (c.name === e) return c;
    }
  }
  dispose() {
    this.boneTexture !== null &&
      (this.boneTexture.dispose(), (this.boneTexture = null));
  }
  fromJSON(e, o) {
    this.uuid = e.uuid;
    for (let a = 0, c = e.bones.length; a < c; a++) {
      const d = e.bones[a];
      let g = o[d];
      g === void 0 &&
        (console.warn("THREE.Skeleton: No bone found with UUID:", d),
        (g = new Bone())),
        this.bones.push(g),
        this.boneInverses.push(new Matrix4().fromArray(e.boneInverses[a]));
    }
    return this.init(), this;
  }
  toJSON() {
    const e = {
      metadata: {
        version: 4.6,
        type: "Skeleton",
        generator: "Skeleton.toJSON",
      },
      bones: [],
      boneInverses: [],
    };
    e.uuid = this.uuid;
    const o = this.bones,
      a = this.boneInverses;
    for (let c = 0, d = o.length; c < d; c++) {
      const g = o[c];
      e.bones.push(g.uuid);
      const _ = a[c];
      e.boneInverses.push(_.toArray());
    }
    return e;
  }
}
class InstancedBufferAttribute extends BufferAttribute {
  constructor(e, o, a, c = 1) {
    super(e, o, a),
      (this.isInstancedBufferAttribute = !0),
      (this.meshPerAttribute = c);
  }
  copy(e) {
    return super.copy(e), (this.meshPerAttribute = e.meshPerAttribute), this;
  }
  toJSON() {
    const e = super.toJSON();
    return (
      (e.meshPerAttribute = this.meshPerAttribute),
      (e.isInstancedBufferAttribute = !0),
      e
    );
  }
}
const _instanceLocalMatrix = new Matrix4(),
  _instanceWorldMatrix = new Matrix4(),
  _instanceIntersects = [],
  _box3 = new Box3(),
  _identity = new Matrix4(),
  _mesh$1 = new Mesh(),
  _sphere$3 = new Sphere();
class InstancedMesh extends Mesh {
  constructor(e, o, a) {
    super(e, o),
      (this.isInstancedMesh = !0),
      (this.instanceMatrix = new InstancedBufferAttribute(
        new Float32Array(a * 16),
        16
      )),
      (this.instanceColor = null),
      (this.morphTexture = null),
      (this.count = a),
      (this.boundingBox = null),
      (this.boundingSphere = null);
    for (let c = 0; c < a; c++) this.setMatrixAt(c, _identity);
  }
  computeBoundingBox() {
    const e = this.geometry,
      o = this.count;
    this.boundingBox === null && (this.boundingBox = new Box3()),
      e.boundingBox === null && e.computeBoundingBox(),
      this.boundingBox.makeEmpty();
    for (let a = 0; a < o; a++)
      this.getMatrixAt(a, _instanceLocalMatrix),
        _box3.copy(e.boundingBox).applyMatrix4(_instanceLocalMatrix),
        this.boundingBox.union(_box3);
  }
  computeBoundingSphere() {
    const e = this.geometry,
      o = this.count;
    this.boundingSphere === null && (this.boundingSphere = new Sphere()),
      e.boundingSphere === null && e.computeBoundingSphere(),
      this.boundingSphere.makeEmpty();
    for (let a = 0; a < o; a++)
      this.getMatrixAt(a, _instanceLocalMatrix),
        _sphere$3.copy(e.boundingSphere).applyMatrix4(_instanceLocalMatrix),
        this.boundingSphere.union(_sphere$3);
  }
  copy(e, o) {
    return (
      super.copy(e, o),
      this.instanceMatrix.copy(e.instanceMatrix),
      e.morphTexture !== null && (this.morphTexture = e.morphTexture.clone()),
      e.instanceColor !== null &&
        (this.instanceColor = e.instanceColor.clone()),
      (this.count = e.count),
      e.boundingBox !== null && (this.boundingBox = e.boundingBox.clone()),
      e.boundingSphere !== null &&
        (this.boundingSphere = e.boundingSphere.clone()),
      this
    );
  }
  getColorAt(e, o) {
    o.fromArray(this.instanceColor.array, e * 3);
  }
  getMatrixAt(e, o) {
    o.fromArray(this.instanceMatrix.array, e * 16);
  }
  getMorphAt(e, o) {
    const a = o.morphTargetInfluences,
      c = this.morphTexture.source.data.data,
      d = a.length + 1,
      g = e * d + 1;
    for (let _ = 0; _ < a.length; _++) a[_] = c[g + _];
  }
  raycast(e, o) {
    const a = this.matrixWorld,
      c = this.count;
    if (
      ((_mesh$1.geometry = this.geometry),
      (_mesh$1.material = this.material),
      _mesh$1.material !== void 0 &&
        (this.boundingSphere === null && this.computeBoundingSphere(),
        _sphere$3.copy(this.boundingSphere),
        _sphere$3.applyMatrix4(a),
        e.ray.intersectsSphere(_sphere$3) !== !1))
    )
      for (let d = 0; d < c; d++) {
        this.getMatrixAt(d, _instanceLocalMatrix),
          _instanceWorldMatrix.multiplyMatrices(a, _instanceLocalMatrix),
          (_mesh$1.matrixWorld = _instanceWorldMatrix),
          _mesh$1.raycast(e, _instanceIntersects);
        for (let g = 0, _ = _instanceIntersects.length; g < _; g++) {
          const b = _instanceIntersects[g];
          (b.instanceId = d), (b.object = this), o.push(b);
        }
        _instanceIntersects.length = 0;
      }
  }
  setColorAt(e, o) {
    this.instanceColor === null &&
      (this.instanceColor = new InstancedBufferAttribute(
        new Float32Array(this.instanceMatrix.count * 3).fill(1),
        3
      )),
      o.toArray(this.instanceColor.array, e * 3);
  }
  setMatrixAt(e, o) {
    o.toArray(this.instanceMatrix.array, e * 16);
  }
  setMorphAt(e, o) {
    const a = o.morphTargetInfluences,
      c = a.length + 1;
    this.morphTexture === null &&
      (this.morphTexture = new DataTexture(
        new Float32Array(c * this.count),
        c,
        this.count,
        RedFormat,
        FloatType
      ));
    const d = this.morphTexture.source.data.data;
    let g = 0;
    for (let j = 0; j < a.length; j++) g += a[j];
    const _ = this.geometry.morphTargetsRelative ? 1 : 1 - g,
      b = c * e;
    (d[b] = _), d.set(a, b + 1);
  }
  updateMorphTargets() {}
  dispose() {
    return (
      this.dispatchEvent({ type: "dispose" }),
      this.morphTexture !== null &&
        (this.morphTexture.dispose(), (this.morphTexture = null)),
      this
    );
  }
}
function sortOpaque(s, e) {
  return s.z - e.z;
}
function sortTransparent(s, e) {
  return e.z - s.z;
}
class MultiDrawRenderList {
  constructor() {
    (this.index = 0), (this.pool = []), (this.list = []);
  }
  push(e, o, a) {
    const c = this.pool,
      d = this.list;
    this.index >= c.length &&
      c.push({ start: -1, count: -1, z: -1, index: -1 });
    const g = c[this.index];
    d.push(g),
      this.index++,
      (g.start = e.start),
      (g.count = e.count),
      (g.z = o),
      (g.index = a);
  }
  reset() {
    (this.list.length = 0), (this.index = 0);
  }
}
const _matrix$1 = new Matrix4(),
  _invMatrixWorld = new Matrix4(),
  _identityMatrix$2 = new Matrix4(),
  _whiteColor = new Color(1, 1, 1),
  _projScreenMatrix$2 = new Matrix4(),
  _frustum = new Frustum(),
  _box$1 = new Box3(),
  _sphere$2 = new Sphere(),
  _vector$5 = new Vector3(),
  _forward = new Vector3(),
  _temp = new Vector3(),
  _renderList = new MultiDrawRenderList(),
  _mesh = new Mesh(),
  _batchIntersects = [];
function copyAttributeData(s, e, o = 0) {
  const a = e.itemSize;
  if (
    s.isInterleavedBufferAttribute ||
    s.array.constructor !== e.array.constructor
  ) {
    const c = s.count;
    for (let d = 0; d < c; d++)
      for (let g = 0; g < a; g++)
        e.setComponent(d + o, g, s.getComponent(d, g));
  } else e.array.set(s.array, o * a);
  e.needsUpdate = !0;
}
class BatchedMesh extends Mesh {
  get maxInstanceCount() {
    return this._maxInstanceCount;
  }
  constructor(e, o, a = o * 2, c) {
    super(new BufferGeometry(), c),
      (this.isBatchedMesh = !0),
      (this.perObjectFrustumCulled = !0),
      (this.sortObjects = !0),
      (this.boundingBox = null),
      (this.boundingSphere = null),
      (this.customSort = null),
      (this._drawInfo = []),
      (this._drawRanges = []),
      (this._reservedRanges = []),
      (this._bounds = []),
      (this._maxInstanceCount = e),
      (this._maxVertexCount = o),
      (this._maxIndexCount = a),
      (this._geometryInitialized = !1),
      (this._geometryCount = 0),
      (this._multiDrawCounts = new Int32Array(e)),
      (this._multiDrawStarts = new Int32Array(e)),
      (this._multiDrawCount = 0),
      (this._multiDrawInstances = null),
      (this._visibilityChanged = !0),
      (this._matricesTexture = null),
      (this._indirectTexture = null),
      (this._colorsTexture = null),
      this._initMatricesTexture(),
      this._initIndirectTexture();
  }
  _initMatricesTexture() {
    let e = Math.sqrt(this._maxInstanceCount * 4);
    (e = Math.ceil(e / 4) * 4), (e = Math.max(e, 4));
    const o = new Float32Array(e * e * 4),
      a = new DataTexture(o, e, e, RGBAFormat, FloatType);
    this._matricesTexture = a;
  }
  _initIndirectTexture() {
    let e = Math.sqrt(this._maxInstanceCount);
    e = Math.ceil(e);
    const o = new Uint32Array(e * e),
      a = new DataTexture(o, e, e, RedIntegerFormat, UnsignedIntType);
    this._indirectTexture = a;
  }
  _initColorsTexture() {
    let e = Math.sqrt(this._maxIndexCount);
    e = Math.ceil(e);
    const o = new Float32Array(e * e * 4).fill(1),
      a = new DataTexture(o, e, e, RGBAFormat, FloatType);
    (a.colorSpace = ColorManagement.workingColorSpace),
      (this._colorsTexture = a);
  }
  _initializeGeometry(e) {
    const o = this.geometry,
      a = this._maxVertexCount,
      c = this._maxIndexCount;
    if (this._geometryInitialized === !1) {
      for (const d in e.attributes) {
        const g = e.getAttribute(d),
          { array: _, itemSize: b, normalized: j } = g,
          $ = new _.constructor(a * b),
          _e = new BufferAttribute($, b, j);
        o.setAttribute(d, _e);
      }
      if (e.getIndex() !== null) {
        const d = a > 65535 ? new Uint32Array(c) : new Uint16Array(c);
        o.setIndex(new BufferAttribute(d, 1));
      }
      this._geometryInitialized = !0;
    }
  }
  _validateGeometry(e) {
    const o = this.geometry;
    if (!!e.getIndex() != !!o.getIndex())
      throw new Error(
        'BatchedMesh: All geometries must consistently have "index".'
      );
    for (const a in o.attributes) {
      if (!e.hasAttribute(a))
        throw new Error(
          `BatchedMesh: Added geometry missing "${a}". All geometries must have consistent attributes.`
        );
      const c = e.getAttribute(a),
        d = o.getAttribute(a);
      if (c.itemSize !== d.itemSize || c.normalized !== d.normalized)
        throw new Error(
          "BatchedMesh: All attributes must have a consistent itemSize and normalized value."
        );
    }
  }
  setCustomSort(e) {
    return (this.customSort = e), this;
  }
  computeBoundingBox() {
    this.boundingBox === null && (this.boundingBox = new Box3());
    const e = this._geometryCount,
      o = this.boundingBox,
      a = this._drawInfo;
    o.makeEmpty();
    for (let c = 0; c < e; c++) {
      if (a[c].active === !1) continue;
      const d = a[c].geometryIndex;
      this.getMatrixAt(c, _matrix$1),
        this.getBoundingBoxAt(d, _box$1).applyMatrix4(_matrix$1),
        o.union(_box$1);
    }
  }
  computeBoundingSphere() {
    this.boundingSphere === null && (this.boundingSphere = new Sphere());
    const e = this.boundingSphere,
      o = this._drawInfo;
    e.makeEmpty();
    for (let a = 0, c = o.length; a < c; a++) {
      if (o[a].active === !1) continue;
      const d = o[a].geometryIndex;
      this.getMatrixAt(a, _matrix$1),
        this.getBoundingSphereAt(d, _sphere$2).applyMatrix4(_matrix$1),
        e.union(_sphere$2);
    }
  }
  addInstance(e) {
    if (this._drawInfo.length >= this._maxInstanceCount)
      throw new Error("BatchedMesh: Maximum item count reached.");
    this._drawInfo.push({ visible: !0, active: !0, geometryIndex: e });
    const o = this._drawInfo.length - 1,
      a = this._matricesTexture,
      c = a.image.data;
    _identityMatrix$2.toArray(c, o * 16), (a.needsUpdate = !0);
    const d = this._colorsTexture;
    return (
      d && (_whiteColor.toArray(d.image.data, o * 4), (d.needsUpdate = !0)), o
    );
  }
  addGeometry(e, o = -1, a = -1) {
    if (
      (this._initializeGeometry(e),
      this._validateGeometry(e),
      this._drawInfo.length >= this._maxInstanceCount)
    )
      throw new Error("BatchedMesh: Maximum item count reached.");
    const c = {
      vertexStart: -1,
      vertexCount: -1,
      indexStart: -1,
      indexCount: -1,
    };
    let d = null;
    const g = this._reservedRanges,
      _ = this._drawRanges,
      b = this._bounds;
    this._geometryCount !== 0 && (d = g[g.length - 1]),
      o === -1
        ? (c.vertexCount = e.getAttribute("position").count)
        : (c.vertexCount = o),
      d === null
        ? (c.vertexStart = 0)
        : (c.vertexStart = d.vertexStart + d.vertexCount);
    const j = e.getIndex(),
      $ = j !== null;
    if (
      ($ &&
        (a === -1 ? (c.indexCount = j.count) : (c.indexCount = a),
        d === null
          ? (c.indexStart = 0)
          : (c.indexStart = d.indexStart + d.indexCount)),
      (c.indexStart !== -1 &&
        c.indexStart + c.indexCount > this._maxIndexCount) ||
        c.vertexStart + c.vertexCount > this._maxVertexCount)
    )
      throw new Error(
        "BatchedMesh: Reserved space request exceeds the maximum buffer size."
      );
    const _e = this._geometryCount;
    return (
      this._geometryCount++,
      g.push(c),
      _.push({ start: $ ? c.indexStart : c.vertexStart, count: -1 }),
      b.push({
        boxInitialized: !1,
        box: new Box3(),
        sphereInitialized: !1,
        sphere: new Sphere(),
      }),
      this.setGeometryAt(_e, e),
      _e
    );
  }
  setGeometryAt(e, o) {
    if (e >= this._geometryCount)
      throw new Error("BatchedMesh: Maximum geometry count reached.");
    this._validateGeometry(o);
    const a = this.geometry,
      c = a.getIndex() !== null,
      d = a.getIndex(),
      g = o.getIndex(),
      _ = this._reservedRanges[e];
    if (
      (c && g.count > _.indexCount) ||
      o.attributes.position.count > _.vertexCount
    )
      throw new Error(
        "BatchedMesh: Reserved space not large enough for provided geometry."
      );
    const b = _.vertexStart,
      j = _.vertexCount;
    for (const rt in a.attributes) {
      const st = o.getAttribute(rt),
        at = a.getAttribute(rt);
      copyAttributeData(st, at, b);
      const ct = st.itemSize;
      for (let it = st.count, lt = j; it < lt; it++) {
        const ot = b + it;
        for (let ut = 0; ut < ct; ut++) at.setComponent(ot, ut, 0);
      }
      (at.needsUpdate = !0), at.addUpdateRange(b * ct, j * ct);
    }
    if (c) {
      const rt = _.indexStart;
      for (let st = 0; st < g.count; st++) d.setX(rt + st, b + g.getX(st));
      for (let st = g.count, at = _.indexCount; st < at; st++)
        d.setX(rt + st, b);
      (d.needsUpdate = !0), d.addUpdateRange(rt, _.indexCount);
    }
    const $ = this._bounds[e];
    o.boundingBox !== null
      ? ($.box.copy(o.boundingBox), ($.boxInitialized = !0))
      : ($.boxInitialized = !1),
      o.boundingSphere !== null
        ? ($.sphere.copy(o.boundingSphere), ($.sphereInitialized = !0))
        : ($.sphereInitialized = !1);
    const _e = this._drawRanges[e],
      et = o.getAttribute("position");
    return (
      (_e.count = c ? g.count : et.count), (this._visibilityChanged = !0), e
    );
  }
  getBoundingBoxAt(e, o) {
    if (e >= this._geometryCount) return null;
    const a = this._bounds[e],
      c = a.box,
      d = this.geometry;
    if (a.boxInitialized === !1) {
      c.makeEmpty();
      const g = d.index,
        _ = d.attributes.position,
        b = this._drawRanges[e];
      for (let j = b.start, $ = b.start + b.count; j < $; j++) {
        let _e = j;
        g && (_e = g.getX(_e)),
          c.expandByPoint(_vector$5.fromBufferAttribute(_, _e));
      }
      a.boxInitialized = !0;
    }
    return o.copy(c), o;
  }
  getBoundingSphereAt(e, o) {
    if (e >= this._geometryCount) return null;
    const a = this._bounds[e],
      c = a.sphere,
      d = this.geometry;
    if (a.sphereInitialized === !1) {
      c.makeEmpty(),
        this.getBoundingBoxAt(e, _box$1),
        _box$1.getCenter(c.center);
      const g = d.index,
        _ = d.attributes.position,
        b = this._drawRanges[e];
      let j = 0;
      for (let $ = b.start, _e = b.start + b.count; $ < _e; $++) {
        let et = $;
        g && (et = g.getX(et)),
          _vector$5.fromBufferAttribute(_, et),
          (j = Math.max(j, c.center.distanceToSquared(_vector$5)));
      }
      (c.radius = Math.sqrt(j)), (a.sphereInitialized = !0);
    }
    return o.copy(c), o;
  }
  setMatrixAt(e, o) {
    const a = this._drawInfo,
      c = this._matricesTexture,
      d = this._matricesTexture.image.data;
    return e >= a.length || a[e].active === !1
      ? this
      : (o.toArray(d, e * 16), (c.needsUpdate = !0), this);
  }
  getMatrixAt(e, o) {
    const a = this._drawInfo,
      c = this._matricesTexture.image.data;
    return e >= a.length || a[e].active === !1 ? null : o.fromArray(c, e * 16);
  }
  setColorAt(e, o) {
    this._colorsTexture === null && this._initColorsTexture();
    const a = this._colorsTexture,
      c = this._colorsTexture.image.data,
      d = this._drawInfo;
    return e >= d.length || d[e].active === !1
      ? this
      : (o.toArray(c, e * 4), (a.needsUpdate = !0), this);
  }
  getColorAt(e, o) {
    const a = this._colorsTexture.image.data,
      c = this._drawInfo;
    return e >= c.length || c[e].active === !1 ? null : o.fromArray(a, e * 4);
  }
  setVisibleAt(e, o) {
    const a = this._drawInfo;
    return e >= a.length || a[e].active === !1 || a[e].visible === o
      ? this
      : ((a[e].visible = o), (this._visibilityChanged = !0), this);
  }
  getVisibleAt(e) {
    const o = this._drawInfo;
    return e >= o.length || o[e].active === !1 ? !1 : o[e].visible;
  }
  raycast(e, o) {
    const a = this._drawInfo,
      c = this._drawRanges,
      d = this.matrixWorld,
      g = this.geometry;
    (_mesh.material = this.material),
      (_mesh.geometry.index = g.index),
      (_mesh.geometry.attributes = g.attributes),
      _mesh.geometry.boundingBox === null &&
        (_mesh.geometry.boundingBox = new Box3()),
      _mesh.geometry.boundingSphere === null &&
        (_mesh.geometry.boundingSphere = new Sphere());
    for (let _ = 0, b = a.length; _ < b; _++) {
      if (!a[_].visible || !a[_].active) continue;
      const j = a[_].geometryIndex,
        $ = c[j];
      _mesh.geometry.setDrawRange($.start, $.count),
        this.getMatrixAt(_, _mesh.matrixWorld).premultiply(d),
        this.getBoundingBoxAt(j, _mesh.geometry.boundingBox),
        this.getBoundingSphereAt(j, _mesh.geometry.boundingSphere),
        _mesh.raycast(e, _batchIntersects);
      for (let _e = 0, et = _batchIntersects.length; _e < et; _e++) {
        const rt = _batchIntersects[_e];
        (rt.object = this), (rt.batchId = _), o.push(rt);
      }
      _batchIntersects.length = 0;
    }
    (_mesh.material = null),
      (_mesh.geometry.index = null),
      (_mesh.geometry.attributes = {}),
      _mesh.geometry.setDrawRange(0, 1 / 0);
  }
  copy(e) {
    return (
      super.copy(e),
      (this.geometry = e.geometry.clone()),
      (this.perObjectFrustumCulled = e.perObjectFrustumCulled),
      (this.sortObjects = e.sortObjects),
      (this.boundingBox =
        e.boundingBox !== null ? e.boundingBox.clone() : null),
      (this.boundingSphere =
        e.boundingSphere !== null ? e.boundingSphere.clone() : null),
      (this._drawRanges = e._drawRanges.map((o) => ({ ...o }))),
      (this._reservedRanges = e._reservedRanges.map((o) => ({ ...o }))),
      (this._drawInfo = e._drawInfo.map((o) => ({ ...o }))),
      (this._bounds = e._bounds.map((o) => ({
        boxInitialized: o.boxInitialized,
        box: o.box.clone(),
        sphereInitialized: o.sphereInitialized,
        sphere: o.sphere.clone(),
      }))),
      (this._maxInstanceCount = e._maxInstanceCount),
      (this._maxVertexCount = e._maxVertexCount),
      (this._maxIndexCount = e._maxIndexCount),
      (this._geometryInitialized = e._geometryInitialized),
      (this._geometryCount = e._geometryCount),
      (this._multiDrawCounts = e._multiDrawCounts.slice()),
      (this._multiDrawStarts = e._multiDrawStarts.slice()),
      (this._matricesTexture = e._matricesTexture.clone()),
      (this._matricesTexture.image.data =
        this._matricesTexture.image.data.slice()),
      this._colorsTexture !== null &&
        ((this._colorsTexture = e._colorsTexture.clone()),
        (this._colorsTexture.image.data =
          this._colorsTexture.image.data.slice())),
      this
    );
  }
  dispose() {
    return (
      this.geometry.dispose(),
      this._matricesTexture.dispose(),
      (this._matricesTexture = null),
      this._indirectTexture.dispose(),
      (this._indirectTexture = null),
      this._colorsTexture !== null &&
        (this._colorsTexture.dispose(), (this._colorsTexture = null)),
      this
    );
  }
  onBeforeRender(e, o, a, c, d) {
    if (
      !this._visibilityChanged &&
      !this.perObjectFrustumCulled &&
      !this.sortObjects
    )
      return;
    const g = c.getIndex(),
      _ = g === null ? 1 : g.array.BYTES_PER_ELEMENT,
      b = this._drawInfo,
      j = this._multiDrawStarts,
      $ = this._multiDrawCounts,
      _e = this._drawRanges,
      et = this.perObjectFrustumCulled,
      rt = this._indirectTexture,
      st = rt.image.data;
    et &&
      (_projScreenMatrix$2
        .multiplyMatrices(a.projectionMatrix, a.matrixWorldInverse)
        .multiply(this.matrixWorld),
      _frustum.setFromProjectionMatrix(
        _projScreenMatrix$2,
        e.coordinateSystem
      ));
    let at = 0;
    if (this.sortObjects) {
      _invMatrixWorld.copy(this.matrixWorld).invert(),
        _vector$5
          .setFromMatrixPosition(a.matrixWorld)
          .applyMatrix4(_invMatrixWorld),
        _forward
          .set(0, 0, -1)
          .transformDirection(a.matrixWorld)
          .transformDirection(_invMatrixWorld);
      for (let lt = 0, ot = b.length; lt < ot; lt++)
        if (b[lt].visible && b[lt].active) {
          const ut = b[lt].geometryIndex;
          this.getMatrixAt(lt, _matrix$1),
            this.getBoundingSphereAt(ut, _sphere$2).applyMatrix4(_matrix$1);
          let pt = !1;
          if ((et && (pt = !_frustum.intersectsSphere(_sphere$2)), !pt)) {
            const ft = _temp
              .subVectors(_sphere$2.center, _vector$5)
              .dot(_forward);
            _renderList.push(_e[ut], ft, lt);
          }
        }
      const ct = _renderList.list,
        it = this.customSort;
      it === null
        ? ct.sort(d.transparent ? sortTransparent : sortOpaque)
        : it.call(this, ct, a);
      for (let lt = 0, ot = ct.length; lt < ot; lt++) {
        const ut = ct[lt];
        (j[at] = ut.start * _), ($[at] = ut.count), (st[at] = ut.index), at++;
      }
      _renderList.reset();
    } else
      for (let ct = 0, it = b.length; ct < it; ct++)
        if (b[ct].visible && b[ct].active) {
          const lt = b[ct].geometryIndex;
          let ot = !1;
          if (
            (et &&
              (this.getMatrixAt(ct, _matrix$1),
              this.getBoundingSphereAt(lt, _sphere$2).applyMatrix4(_matrix$1),
              (ot = !_frustum.intersectsSphere(_sphere$2))),
            !ot)
          ) {
            const ut = _e[lt];
            (j[at] = ut.start * _), ($[at] = ut.count), (st[at] = ct), at++;
          }
        }
    (rt.needsUpdate = !0),
      (this._multiDrawCount = at),
      (this._visibilityChanged = !1);
  }
  onBeforeShadow(e, o, a, c, d, g) {
    this.onBeforeRender(e, null, c, d, g);
  }
}
class LineBasicMaterial extends Material {
  constructor(e) {
    super(),
      (this.isLineBasicMaterial = !0),
      (this.type = "LineBasicMaterial"),
      (this.color = new Color(16777215)),
      (this.map = null),
      (this.linewidth = 1),
      (this.linecap = "round"),
      (this.linejoin = "round"),
      (this.fog = !0),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      this.color.copy(e.color),
      (this.map = e.map),
      (this.linewidth = e.linewidth),
      (this.linecap = e.linecap),
      (this.linejoin = e.linejoin),
      (this.fog = e.fog),
      this
    );
  }
}
const _vStart = new Vector3(),
  _vEnd = new Vector3(),
  _inverseMatrix$1 = new Matrix4(),
  _ray$1 = new Ray(),
  _sphere$1 = new Sphere(),
  _intersectPointOnRay = new Vector3(),
  _intersectPointOnSegment = new Vector3();
class Line extends Object3D {
  constructor(e = new BufferGeometry(), o = new LineBasicMaterial()) {
    super(),
      (this.isLine = !0),
      (this.type = "Line"),
      (this.geometry = e),
      (this.material = o),
      this.updateMorphTargets();
  }
  copy(e, o) {
    return (
      super.copy(e, o),
      (this.material = Array.isArray(e.material)
        ? e.material.slice()
        : e.material),
      (this.geometry = e.geometry),
      this
    );
  }
  computeLineDistances() {
    const e = this.geometry;
    if (e.index === null) {
      const o = e.attributes.position,
        a = [0];
      for (let c = 1, d = o.count; c < d; c++)
        _vStart.fromBufferAttribute(o, c - 1),
          _vEnd.fromBufferAttribute(o, c),
          (a[c] = a[c - 1]),
          (a[c] += _vStart.distanceTo(_vEnd));
      e.setAttribute("lineDistance", new Float32BufferAttribute(a, 1));
    } else
      console.warn(
        "THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry."
      );
    return this;
  }
  raycast(e, o) {
    const a = this.geometry,
      c = this.matrixWorld,
      d = e.params.Line.threshold,
      g = a.drawRange;
    if (
      (a.boundingSphere === null && a.computeBoundingSphere(),
      _sphere$1.copy(a.boundingSphere),
      _sphere$1.applyMatrix4(c),
      (_sphere$1.radius += d),
      e.ray.intersectsSphere(_sphere$1) === !1)
    )
      return;
    _inverseMatrix$1.copy(c).invert(),
      _ray$1.copy(e.ray).applyMatrix4(_inverseMatrix$1);
    const _ = d / ((this.scale.x + this.scale.y + this.scale.z) / 3),
      b = _ * _,
      j = this.isLineSegments ? 2 : 1,
      $ = a.index,
      et = a.attributes.position;
    if ($ !== null) {
      const rt = Math.max(0, g.start),
        st = Math.min($.count, g.start + g.count);
      for (let at = rt, ct = st - 1; at < ct; at += j) {
        const it = $.getX(at),
          lt = $.getX(at + 1),
          ot = checkIntersection(this, e, _ray$1, b, it, lt);
        ot && o.push(ot);
      }
      if (this.isLineLoop) {
        const at = $.getX(st - 1),
          ct = $.getX(rt),
          it = checkIntersection(this, e, _ray$1, b, at, ct);
        it && o.push(it);
      }
    } else {
      const rt = Math.max(0, g.start),
        st = Math.min(et.count, g.start + g.count);
      for (let at = rt, ct = st - 1; at < ct; at += j) {
        const it = checkIntersection(this, e, _ray$1, b, at, at + 1);
        it && o.push(it);
      }
      if (this.isLineLoop) {
        const at = checkIntersection(this, e, _ray$1, b, st - 1, rt);
        at && o.push(at);
      }
    }
  }
  updateMorphTargets() {
    const o = this.geometry.morphAttributes,
      a = Object.keys(o);
    if (a.length > 0) {
      const c = o[a[0]];
      if (c !== void 0) {
        (this.morphTargetInfluences = []), (this.morphTargetDictionary = {});
        for (let d = 0, g = c.length; d < g; d++) {
          const _ = c[d].name || String(d);
          this.morphTargetInfluences.push(0),
            (this.morphTargetDictionary[_] = d);
        }
      }
    }
  }
}
function checkIntersection(s, e, o, a, c, d) {
  const g = s.geometry.attributes.position;
  if (
    (_vStart.fromBufferAttribute(g, c),
    _vEnd.fromBufferAttribute(g, d),
    o.distanceSqToSegment(
      _vStart,
      _vEnd,
      _intersectPointOnRay,
      _intersectPointOnSegment
    ) > a)
  )
    return;
  _intersectPointOnRay.applyMatrix4(s.matrixWorld);
  const b = e.ray.origin.distanceTo(_intersectPointOnRay);
  if (!(b < e.near || b > e.far))
    return {
      distance: b,
      point: _intersectPointOnSegment.clone().applyMatrix4(s.matrixWorld),
      index: c,
      face: null,
      faceIndex: null,
      object: s,
    };
}
const _start = new Vector3(),
  _end = new Vector3();
class LineSegments extends Line {
  constructor(e, o) {
    super(e, o), (this.isLineSegments = !0), (this.type = "LineSegments");
  }
  computeLineDistances() {
    const e = this.geometry;
    if (e.index === null) {
      const o = e.attributes.position,
        a = [];
      for (let c = 0, d = o.count; c < d; c += 2)
        _start.fromBufferAttribute(o, c),
          _end.fromBufferAttribute(o, c + 1),
          (a[c] = c === 0 ? 0 : a[c - 1]),
          (a[c + 1] = a[c] + _start.distanceTo(_end));
      e.setAttribute("lineDistance", new Float32BufferAttribute(a, 1));
    } else
      console.warn(
        "THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry."
      );
    return this;
  }
}
class LineLoop extends Line {
  constructor(e, o) {
    super(e, o), (this.isLineLoop = !0), (this.type = "LineLoop");
  }
}
class PointsMaterial extends Material {
  constructor(e) {
    super(),
      (this.isPointsMaterial = !0),
      (this.type = "PointsMaterial"),
      (this.color = new Color(16777215)),
      (this.map = null),
      (this.alphaMap = null),
      (this.size = 1),
      (this.sizeAttenuation = !0),
      (this.fog = !0),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      this.color.copy(e.color),
      (this.map = e.map),
      (this.alphaMap = e.alphaMap),
      (this.size = e.size),
      (this.sizeAttenuation = e.sizeAttenuation),
      (this.fog = e.fog),
      this
    );
  }
}
const _inverseMatrix = new Matrix4(),
  _ray$4 = new Ray(),
  _sphere = new Sphere(),
  _position$2 = new Vector3();
class Points extends Object3D {
  constructor(e = new BufferGeometry(), o = new PointsMaterial()) {
    super(),
      (this.isPoints = !0),
      (this.type = "Points"),
      (this.geometry = e),
      (this.material = o),
      this.updateMorphTargets();
  }
  copy(e, o) {
    return (
      super.copy(e, o),
      (this.material = Array.isArray(e.material)
        ? e.material.slice()
        : e.material),
      (this.geometry = e.geometry),
      this
    );
  }
  raycast(e, o) {
    const a = this.geometry,
      c = this.matrixWorld,
      d = e.params.Points.threshold,
      g = a.drawRange;
    if (
      (a.boundingSphere === null && a.computeBoundingSphere(),
      _sphere.copy(a.boundingSphere),
      _sphere.applyMatrix4(c),
      (_sphere.radius += d),
      e.ray.intersectsSphere(_sphere) === !1)
    )
      return;
    _inverseMatrix.copy(c).invert(),
      _ray$4.copy(e.ray).applyMatrix4(_inverseMatrix);
    const _ = d / ((this.scale.x + this.scale.y + this.scale.z) / 3),
      b = _ * _,
      j = a.index,
      _e = a.attributes.position;
    if (j !== null) {
      const et = Math.max(0, g.start),
        rt = Math.min(j.count, g.start + g.count);
      for (let st = et, at = rt; st < at; st++) {
        const ct = j.getX(st);
        _position$2.fromBufferAttribute(_e, ct),
          testPoint(_position$2, ct, b, c, e, o, this);
      }
    } else {
      const et = Math.max(0, g.start),
        rt = Math.min(_e.count, g.start + g.count);
      for (let st = et, at = rt; st < at; st++)
        _position$2.fromBufferAttribute(_e, st),
          testPoint(_position$2, st, b, c, e, o, this);
    }
  }
  updateMorphTargets() {
    const o = this.geometry.morphAttributes,
      a = Object.keys(o);
    if (a.length > 0) {
      const c = o[a[0]];
      if (c !== void 0) {
        (this.morphTargetInfluences = []), (this.morphTargetDictionary = {});
        for (let d = 0, g = c.length; d < g; d++) {
          const _ = c[d].name || String(d);
          this.morphTargetInfluences.push(0),
            (this.morphTargetDictionary[_] = d);
        }
      }
    }
  }
}
function testPoint(s, e, o, a, c, d, g) {
  const _ = _ray$4.distanceSqToPoint(s);
  if (_ < o) {
    const b = new Vector3();
    _ray$4.closestPointToPoint(s, b), b.applyMatrix4(a);
    const j = c.ray.origin.distanceTo(b);
    if (j < c.near || j > c.far) return;
    d.push({
      distance: j,
      distanceToRay: Math.sqrt(_),
      point: b,
      index: e,
      face: null,
      object: g,
    });
  }
}
class VideoTexture extends Texture {
  constructor(e, o, a, c, d, g, _, b, j) {
    super(e, o, a, c, d, g, _, b, j),
      (this.isVideoTexture = !0),
      (this.minFilter = g !== void 0 ? g : LinearFilter),
      (this.magFilter = d !== void 0 ? d : LinearFilter),
      (this.generateMipmaps = !1);
    const $ = this;
    function _e() {
      ($.needsUpdate = !0), e.requestVideoFrameCallback(_e);
    }
    "requestVideoFrameCallback" in e && e.requestVideoFrameCallback(_e);
  }
  clone() {
    return new this.constructor(this.image).copy(this);
  }
  update() {
    const e = this.image;
    "requestVideoFrameCallback" in e === !1 &&
      e.readyState >= e.HAVE_CURRENT_DATA &&
      (this.needsUpdate = !0);
  }
}
class FramebufferTexture extends Texture {
  constructor(e, o) {
    super({ width: e, height: o }),
      (this.isFramebufferTexture = !0),
      (this.magFilter = NearestFilter),
      (this.minFilter = NearestFilter),
      (this.generateMipmaps = !1),
      (this.needsUpdate = !0);
  }
}
class CompressedTexture extends Texture {
  constructor(e, o, a, c, d, g, _, b, j, $, _e, et) {
    super(null, g, _, b, j, $, c, d, _e, et),
      (this.isCompressedTexture = !0),
      (this.image = { width: o, height: a }),
      (this.mipmaps = e),
      (this.flipY = !1),
      (this.generateMipmaps = !1);
  }
}
class CompressedArrayTexture extends CompressedTexture {
  constructor(e, o, a, c, d, g) {
    super(e, o, a, d, g),
      (this.isCompressedArrayTexture = !0),
      (this.image.depth = c),
      (this.wrapR = ClampToEdgeWrapping),
      (this.layerUpdates = new Set());
  }
  addLayerUpdate(e) {
    this.layerUpdates.add(e);
  }
  clearLayerUpdates() {
    this.layerUpdates.clear();
  }
}
class CompressedCubeTexture extends CompressedTexture {
  constructor(e, o, a) {
    super(void 0, e[0].width, e[0].height, o, a, CubeReflectionMapping),
      (this.isCompressedCubeTexture = !0),
      (this.isCubeTexture = !0),
      (this.image = e);
  }
}
class CanvasTexture extends Texture {
  constructor(e, o, a, c, d, g, _, b, j) {
    super(e, o, a, c, d, g, _, b, j),
      (this.isCanvasTexture = !0),
      (this.needsUpdate = !0);
  }
}
class Curve {
  constructor() {
    (this.type = "Curve"), (this.arcLengthDivisions = 200);
  }
  getPoint() {
    return console.warn("THREE.Curve: .getPoint() not implemented."), null;
  }
  getPointAt(e, o) {
    const a = this.getUtoTmapping(e);
    return this.getPoint(a, o);
  }
  getPoints(e = 5) {
    const o = [];
    for (let a = 0; a <= e; a++) o.push(this.getPoint(a / e));
    return o;
  }
  getSpacedPoints(e = 5) {
    const o = [];
    for (let a = 0; a <= e; a++) o.push(this.getPointAt(a / e));
    return o;
  }
  getLength() {
    const e = this.getLengths();
    return e[e.length - 1];
  }
  getLengths(e = this.arcLengthDivisions) {
    if (
      this.cacheArcLengths &&
      this.cacheArcLengths.length === e + 1 &&
      !this.needsUpdate
    )
      return this.cacheArcLengths;
    this.needsUpdate = !1;
    const o = [];
    let a,
      c = this.getPoint(0),
      d = 0;
    o.push(0);
    for (let g = 1; g <= e; g++)
      (a = this.getPoint(g / e)), (d += a.distanceTo(c)), o.push(d), (c = a);
    return (this.cacheArcLengths = o), o;
  }
  updateArcLengths() {
    (this.needsUpdate = !0), this.getLengths();
  }
  getUtoTmapping(e, o) {
    const a = this.getLengths();
    let c = 0;
    const d = a.length;
    let g;
    o ? (g = o) : (g = e * a[d - 1]);
    let _ = 0,
      b = d - 1,
      j;
    for (; _ <= b; )
      if (((c = Math.floor(_ + (b - _) / 2)), (j = a[c] - g), j < 0)) _ = c + 1;
      else if (j > 0) b = c - 1;
      else {
        b = c;
        break;
      }
    if (((c = b), a[c] === g)) return c / (d - 1);
    const $ = a[c],
      et = a[c + 1] - $,
      rt = (g - $) / et;
    return (c + rt) / (d - 1);
  }
  getTangent(e, o) {
    let c = e - 1e-4,
      d = e + 1e-4;
    c < 0 && (c = 0), d > 1 && (d = 1);
    const g = this.getPoint(c),
      _ = this.getPoint(d),
      b = o || (g.isVector2 ? new Vector2() : new Vector3());
    return b.copy(_).sub(g).normalize(), b;
  }
  getTangentAt(e, o) {
    const a = this.getUtoTmapping(e);
    return this.getTangent(a, o);
  }
  computeFrenetFrames(e, o) {
    const a = new Vector3(),
      c = [],
      d = [],
      g = [],
      _ = new Vector3(),
      b = new Matrix4();
    for (let rt = 0; rt <= e; rt++) {
      const st = rt / e;
      c[rt] = this.getTangentAt(st, new Vector3());
    }
    (d[0] = new Vector3()), (g[0] = new Vector3());
    let j = Number.MAX_VALUE;
    const $ = Math.abs(c[0].x),
      _e = Math.abs(c[0].y),
      et = Math.abs(c[0].z);
    $ <= j && ((j = $), a.set(1, 0, 0)),
      _e <= j && ((j = _e), a.set(0, 1, 0)),
      et <= j && a.set(0, 0, 1),
      _.crossVectors(c[0], a).normalize(),
      d[0].crossVectors(c[0], _),
      g[0].crossVectors(c[0], d[0]);
    for (let rt = 1; rt <= e; rt++) {
      if (
        ((d[rt] = d[rt - 1].clone()),
        (g[rt] = g[rt - 1].clone()),
        _.crossVectors(c[rt - 1], c[rt]),
        _.length() > Number.EPSILON)
      ) {
        _.normalize();
        const st = Math.acos(clamp(c[rt - 1].dot(c[rt]), -1, 1));
        d[rt].applyMatrix4(b.makeRotationAxis(_, st));
      }
      g[rt].crossVectors(c[rt], d[rt]);
    }
    if (o === !0) {
      let rt = Math.acos(clamp(d[0].dot(d[e]), -1, 1));
      (rt /= e), c[0].dot(_.crossVectors(d[0], d[e])) > 0 && (rt = -rt);
      for (let st = 1; st <= e; st++)
        d[st].applyMatrix4(b.makeRotationAxis(c[st], rt * st)),
          g[st].crossVectors(c[st], d[st]);
    }
    return { tangents: c, normals: d, binormals: g };
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return (this.arcLengthDivisions = e.arcLengthDivisions), this;
  }
  toJSON() {
    const e = {
      metadata: { version: 4.6, type: "Curve", generator: "Curve.toJSON" },
    };
    return (
      (e.arcLengthDivisions = this.arcLengthDivisions), (e.type = this.type), e
    );
  }
  fromJSON(e) {
    return (this.arcLengthDivisions = e.arcLengthDivisions), this;
  }
}
class EllipseCurve extends Curve {
  constructor(
    e = 0,
    o = 0,
    a = 1,
    c = 1,
    d = 0,
    g = Math.PI * 2,
    _ = !1,
    b = 0
  ) {
    super(),
      (this.isEllipseCurve = !0),
      (this.type = "EllipseCurve"),
      (this.aX = e),
      (this.aY = o),
      (this.xRadius = a),
      (this.yRadius = c),
      (this.aStartAngle = d),
      (this.aEndAngle = g),
      (this.aClockwise = _),
      (this.aRotation = b);
  }
  getPoint(e, o = new Vector2()) {
    const a = o,
      c = Math.PI * 2;
    let d = this.aEndAngle - this.aStartAngle;
    const g = Math.abs(d) < Number.EPSILON;
    for (; d < 0; ) d += c;
    for (; d > c; ) d -= c;
    d < Number.EPSILON && (g ? (d = 0) : (d = c)),
      this.aClockwise === !0 && !g && (d === c ? (d = -c) : (d = d - c));
    const _ = this.aStartAngle + e * d;
    let b = this.aX + this.xRadius * Math.cos(_),
      j = this.aY + this.yRadius * Math.sin(_);
    if (this.aRotation !== 0) {
      const $ = Math.cos(this.aRotation),
        _e = Math.sin(this.aRotation),
        et = b - this.aX,
        rt = j - this.aY;
      (b = et * $ - rt * _e + this.aX), (j = et * _e + rt * $ + this.aY);
    }
    return a.set(b, j);
  }
  copy(e) {
    return (
      super.copy(e),
      (this.aX = e.aX),
      (this.aY = e.aY),
      (this.xRadius = e.xRadius),
      (this.yRadius = e.yRadius),
      (this.aStartAngle = e.aStartAngle),
      (this.aEndAngle = e.aEndAngle),
      (this.aClockwise = e.aClockwise),
      (this.aRotation = e.aRotation),
      this
    );
  }
  toJSON() {
    const e = super.toJSON();
    return (
      (e.aX = this.aX),
      (e.aY = this.aY),
      (e.xRadius = this.xRadius),
      (e.yRadius = this.yRadius),
      (e.aStartAngle = this.aStartAngle),
      (e.aEndAngle = this.aEndAngle),
      (e.aClockwise = this.aClockwise),
      (e.aRotation = this.aRotation),
      e
    );
  }
  fromJSON(e) {
    return (
      super.fromJSON(e),
      (this.aX = e.aX),
      (this.aY = e.aY),
      (this.xRadius = e.xRadius),
      (this.yRadius = e.yRadius),
      (this.aStartAngle = e.aStartAngle),
      (this.aEndAngle = e.aEndAngle),
      (this.aClockwise = e.aClockwise),
      (this.aRotation = e.aRotation),
      this
    );
  }
}
class ArcCurve extends EllipseCurve {
  constructor(e, o, a, c, d, g) {
    super(e, o, a, a, c, d, g),
      (this.isArcCurve = !0),
      (this.type = "ArcCurve");
  }
}
function CubicPoly() {
  let s = 0,
    e = 0,
    o = 0,
    a = 0;
  function c(d, g, _, b) {
    (s = d),
      (e = _),
      (o = -3 * d + 3 * g - 2 * _ - b),
      (a = 2 * d - 2 * g + _ + b);
  }
  return {
    initCatmullRom: function (d, g, _, b, j) {
      c(g, _, j * (_ - d), j * (b - g));
    },
    initNonuniformCatmullRom: function (d, g, _, b, j, $, _e) {
      let et = (g - d) / j - (_ - d) / (j + $) + (_ - g) / $,
        rt = (_ - g) / $ - (b - g) / ($ + _e) + (b - _) / _e;
      (et *= $), (rt *= $), c(g, _, et, rt);
    },
    calc: function (d) {
      const g = d * d,
        _ = g * d;
      return s + e * d + o * g + a * _;
    },
  };
}
const tmp = new Vector3(),
  px = new CubicPoly(),
  py = new CubicPoly(),
  pz = new CubicPoly();
class CatmullRomCurve3 extends Curve {
  constructor(e = [], o = !1, a = "centripetal", c = 0.5) {
    super(),
      (this.isCatmullRomCurve3 = !0),
      (this.type = "CatmullRomCurve3"),
      (this.points = e),
      (this.closed = o),
      (this.curveType = a),
      (this.tension = c);
  }
  getPoint(e, o = new Vector3()) {
    const a = o,
      c = this.points,
      d = c.length,
      g = (d - (this.closed ? 0 : 1)) * e;
    let _ = Math.floor(g),
      b = g - _;
    this.closed
      ? (_ += _ > 0 ? 0 : (Math.floor(Math.abs(_) / d) + 1) * d)
      : b === 0 && _ === d - 1 && ((_ = d - 2), (b = 1));
    let j, $;
    this.closed || _ > 0
      ? (j = c[(_ - 1) % d])
      : (tmp.subVectors(c[0], c[1]).add(c[0]), (j = tmp));
    const _e = c[_ % d],
      et = c[(_ + 1) % d];
    if (
      (this.closed || _ + 2 < d
        ? ($ = c[(_ + 2) % d])
        : (tmp.subVectors(c[d - 1], c[d - 2]).add(c[d - 1]), ($ = tmp)),
      this.curveType === "centripetal" || this.curveType === "chordal")
    ) {
      const rt = this.curveType === "chordal" ? 0.5 : 0.25;
      let st = Math.pow(j.distanceToSquared(_e), rt),
        at = Math.pow(_e.distanceToSquared(et), rt),
        ct = Math.pow(et.distanceToSquared($), rt);
      at < 1e-4 && (at = 1),
        st < 1e-4 && (st = at),
        ct < 1e-4 && (ct = at),
        px.initNonuniformCatmullRom(j.x, _e.x, et.x, $.x, st, at, ct),
        py.initNonuniformCatmullRom(j.y, _e.y, et.y, $.y, st, at, ct),
        pz.initNonuniformCatmullRom(j.z, _e.z, et.z, $.z, st, at, ct);
    } else
      this.curveType === "catmullrom" &&
        (px.initCatmullRom(j.x, _e.x, et.x, $.x, this.tension),
        py.initCatmullRom(j.y, _e.y, et.y, $.y, this.tension),
        pz.initCatmullRom(j.z, _e.z, et.z, $.z, this.tension));
    return a.set(px.calc(b), py.calc(b), pz.calc(b)), a;
  }
  copy(e) {
    super.copy(e), (this.points = []);
    for (let o = 0, a = e.points.length; o < a; o++) {
      const c = e.points[o];
      this.points.push(c.clone());
    }
    return (
      (this.closed = e.closed),
      (this.curveType = e.curveType),
      (this.tension = e.tension),
      this
    );
  }
  toJSON() {
    const e = super.toJSON();
    e.points = [];
    for (let o = 0, a = this.points.length; o < a; o++) {
      const c = this.points[o];
      e.points.push(c.toArray());
    }
    return (
      (e.closed = this.closed),
      (e.curveType = this.curveType),
      (e.tension = this.tension),
      e
    );
  }
  fromJSON(e) {
    super.fromJSON(e), (this.points = []);
    for (let o = 0, a = e.points.length; o < a; o++) {
      const c = e.points[o];
      this.points.push(new Vector3().fromArray(c));
    }
    return (
      (this.closed = e.closed),
      (this.curveType = e.curveType),
      (this.tension = e.tension),
      this
    );
  }
}
function CatmullRom(s, e, o, a, c) {
  const d = (a - e) * 0.5,
    g = (c - o) * 0.5,
    _ = s * s,
    b = s * _;
  return (
    (2 * o - 2 * a + d + g) * b + (-3 * o + 3 * a - 2 * d - g) * _ + d * s + o
  );
}
function QuadraticBezierP0(s, e) {
  const o = 1 - s;
  return o * o * e;
}
function QuadraticBezierP1(s, e) {
  return 2 * (1 - s) * s * e;
}
function QuadraticBezierP2(s, e) {
  return s * s * e;
}
function QuadraticBezier(s, e, o, a) {
  return (
    QuadraticBezierP0(s, e) + QuadraticBezierP1(s, o) + QuadraticBezierP2(s, a)
  );
}
function CubicBezierP0(s, e) {
  const o = 1 - s;
  return o * o * o * e;
}
function CubicBezierP1(s, e) {
  const o = 1 - s;
  return 3 * o * o * s * e;
}
function CubicBezierP2(s, e) {
  return 3 * (1 - s) * s * s * e;
}
function CubicBezierP3(s, e) {
  return s * s * s * e;
}
function CubicBezier(s, e, o, a, c) {
  return (
    CubicBezierP0(s, e) +
    CubicBezierP1(s, o) +
    CubicBezierP2(s, a) +
    CubicBezierP3(s, c)
  );
}
class CubicBezierCurve extends Curve {
  constructor(
    e = new Vector2(),
    o = new Vector2(),
    a = new Vector2(),
    c = new Vector2()
  ) {
    super(),
      (this.isCubicBezierCurve = !0),
      (this.type = "CubicBezierCurve"),
      (this.v0 = e),
      (this.v1 = o),
      (this.v2 = a),
      (this.v3 = c);
  }
  getPoint(e, o = new Vector2()) {
    const a = o,
      c = this.v0,
      d = this.v1,
      g = this.v2,
      _ = this.v3;
    return (
      a.set(
        CubicBezier(e, c.x, d.x, g.x, _.x),
        CubicBezier(e, c.y, d.y, g.y, _.y)
      ),
      a
    );
  }
  copy(e) {
    return (
      super.copy(e),
      this.v0.copy(e.v0),
      this.v1.copy(e.v1),
      this.v2.copy(e.v2),
      this.v3.copy(e.v3),
      this
    );
  }
  toJSON() {
    const e = super.toJSON();
    return (
      (e.v0 = this.v0.toArray()),
      (e.v1 = this.v1.toArray()),
      (e.v2 = this.v2.toArray()),
      (e.v3 = this.v3.toArray()),
      e
    );
  }
  fromJSON(e) {
    return (
      super.fromJSON(e),
      this.v0.fromArray(e.v0),
      this.v1.fromArray(e.v1),
      this.v2.fromArray(e.v2),
      this.v3.fromArray(e.v3),
      this
    );
  }
}
class CubicBezierCurve3 extends Curve {
  constructor(
    e = new Vector3(),
    o = new Vector3(),
    a = new Vector3(),
    c = new Vector3()
  ) {
    super(),
      (this.isCubicBezierCurve3 = !0),
      (this.type = "CubicBezierCurve3"),
      (this.v0 = e),
      (this.v1 = o),
      (this.v2 = a),
      (this.v3 = c);
  }
  getPoint(e, o = new Vector3()) {
    const a = o,
      c = this.v0,
      d = this.v1,
      g = this.v2,
      _ = this.v3;
    return (
      a.set(
        CubicBezier(e, c.x, d.x, g.x, _.x),
        CubicBezier(e, c.y, d.y, g.y, _.y),
        CubicBezier(e, c.z, d.z, g.z, _.z)
      ),
      a
    );
  }
  copy(e) {
    return (
      super.copy(e),
      this.v0.copy(e.v0),
      this.v1.copy(e.v1),
      this.v2.copy(e.v2),
      this.v3.copy(e.v3),
      this
    );
  }
  toJSON() {
    const e = super.toJSON();
    return (
      (e.v0 = this.v0.toArray()),
      (e.v1 = this.v1.toArray()),
      (e.v2 = this.v2.toArray()),
      (e.v3 = this.v3.toArray()),
      e
    );
  }
  fromJSON(e) {
    return (
      super.fromJSON(e),
      this.v0.fromArray(e.v0),
      this.v1.fromArray(e.v1),
      this.v2.fromArray(e.v2),
      this.v3.fromArray(e.v3),
      this
    );
  }
}
class LineCurve extends Curve {
  constructor(e = new Vector2(), o = new Vector2()) {
    super(),
      (this.isLineCurve = !0),
      (this.type = "LineCurve"),
      (this.v1 = e),
      (this.v2 = o);
  }
  getPoint(e, o = new Vector2()) {
    const a = o;
    return (
      e === 1
        ? a.copy(this.v2)
        : (a.copy(this.v2).sub(this.v1), a.multiplyScalar(e).add(this.v1)),
      a
    );
  }
  getPointAt(e, o) {
    return this.getPoint(e, o);
  }
  getTangent(e, o = new Vector2()) {
    return o.subVectors(this.v2, this.v1).normalize();
  }
  getTangentAt(e, o) {
    return this.getTangent(e, o);
  }
  copy(e) {
    return super.copy(e), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
  }
  toJSON() {
    const e = super.toJSON();
    return (e.v1 = this.v1.toArray()), (e.v2 = this.v2.toArray()), e;
  }
  fromJSON(e) {
    return (
      super.fromJSON(e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this
    );
  }
}
class LineCurve3 extends Curve {
  constructor(e = new Vector3(), o = new Vector3()) {
    super(),
      (this.isLineCurve3 = !0),
      (this.type = "LineCurve3"),
      (this.v1 = e),
      (this.v2 = o);
  }
  getPoint(e, o = new Vector3()) {
    const a = o;
    return (
      e === 1
        ? a.copy(this.v2)
        : (a.copy(this.v2).sub(this.v1), a.multiplyScalar(e).add(this.v1)),
      a
    );
  }
  getPointAt(e, o) {
    return this.getPoint(e, o);
  }
  getTangent(e, o = new Vector3()) {
    return o.subVectors(this.v2, this.v1).normalize();
  }
  getTangentAt(e, o) {
    return this.getTangent(e, o);
  }
  copy(e) {
    return super.copy(e), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
  }
  toJSON() {
    const e = super.toJSON();
    return (e.v1 = this.v1.toArray()), (e.v2 = this.v2.toArray()), e;
  }
  fromJSON(e) {
    return (
      super.fromJSON(e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this
    );
  }
}
class QuadraticBezierCurve extends Curve {
  constructor(e = new Vector2(), o = new Vector2(), a = new Vector2()) {
    super(),
      (this.isQuadraticBezierCurve = !0),
      (this.type = "QuadraticBezierCurve"),
      (this.v0 = e),
      (this.v1 = o),
      (this.v2 = a);
  }
  getPoint(e, o = new Vector2()) {
    const a = o,
      c = this.v0,
      d = this.v1,
      g = this.v2;
    return (
      a.set(
        QuadraticBezier(e, c.x, d.x, g.x),
        QuadraticBezier(e, c.y, d.y, g.y)
      ),
      a
    );
  }
  copy(e) {
    return (
      super.copy(e),
      this.v0.copy(e.v0),
      this.v1.copy(e.v1),
      this.v2.copy(e.v2),
      this
    );
  }
  toJSON() {
    const e = super.toJSON();
    return (
      (e.v0 = this.v0.toArray()),
      (e.v1 = this.v1.toArray()),
      (e.v2 = this.v2.toArray()),
      e
    );
  }
  fromJSON(e) {
    return (
      super.fromJSON(e),
      this.v0.fromArray(e.v0),
      this.v1.fromArray(e.v1),
      this.v2.fromArray(e.v2),
      this
    );
  }
}
class QuadraticBezierCurve3 extends Curve {
  constructor(e = new Vector3(), o = new Vector3(), a = new Vector3()) {
    super(),
      (this.isQuadraticBezierCurve3 = !0),
      (this.type = "QuadraticBezierCurve3"),
      (this.v0 = e),
      (this.v1 = o),
      (this.v2 = a);
  }
  getPoint(e, o = new Vector3()) {
    const a = o,
      c = this.v0,
      d = this.v1,
      g = this.v2;
    return (
      a.set(
        QuadraticBezier(e, c.x, d.x, g.x),
        QuadraticBezier(e, c.y, d.y, g.y),
        QuadraticBezier(e, c.z, d.z, g.z)
      ),
      a
    );
  }
  copy(e) {
    return (
      super.copy(e),
      this.v0.copy(e.v0),
      this.v1.copy(e.v1),
      this.v2.copy(e.v2),
      this
    );
  }
  toJSON() {
    const e = super.toJSON();
    return (
      (e.v0 = this.v0.toArray()),
      (e.v1 = this.v1.toArray()),
      (e.v2 = this.v2.toArray()),
      e
    );
  }
  fromJSON(e) {
    return (
      super.fromJSON(e),
      this.v0.fromArray(e.v0),
      this.v1.fromArray(e.v1),
      this.v2.fromArray(e.v2),
      this
    );
  }
}
class SplineCurve extends Curve {
  constructor(e = []) {
    super(),
      (this.isSplineCurve = !0),
      (this.type = "SplineCurve"),
      (this.points = e);
  }
  getPoint(e, o = new Vector2()) {
    const a = o,
      c = this.points,
      d = (c.length - 1) * e,
      g = Math.floor(d),
      _ = d - g,
      b = c[g === 0 ? g : g - 1],
      j = c[g],
      $ = c[g > c.length - 2 ? c.length - 1 : g + 1],
      _e = c[g > c.length - 3 ? c.length - 1 : g + 2];
    return (
      a.set(
        CatmullRom(_, b.x, j.x, $.x, _e.x),
        CatmullRom(_, b.y, j.y, $.y, _e.y)
      ),
      a
    );
  }
  copy(e) {
    super.copy(e), (this.points = []);
    for (let o = 0, a = e.points.length; o < a; o++) {
      const c = e.points[o];
      this.points.push(c.clone());
    }
    return this;
  }
  toJSON() {
    const e = super.toJSON();
    e.points = [];
    for (let o = 0, a = this.points.length; o < a; o++) {
      const c = this.points[o];
      e.points.push(c.toArray());
    }
    return e;
  }
  fromJSON(e) {
    super.fromJSON(e), (this.points = []);
    for (let o = 0, a = e.points.length; o < a; o++) {
      const c = e.points[o];
      this.points.push(new Vector2().fromArray(c));
    }
    return this;
  }
}
var Curves = Object.freeze({
  __proto__: null,
  ArcCurve,
  CatmullRomCurve3,
  CubicBezierCurve,
  CubicBezierCurve3,
  EllipseCurve,
  LineCurve,
  LineCurve3,
  QuadraticBezierCurve,
  QuadraticBezierCurve3,
  SplineCurve,
});
class CurvePath extends Curve {
  constructor() {
    super(),
      (this.type = "CurvePath"),
      (this.curves = []),
      (this.autoClose = !1);
  }
  add(e) {
    this.curves.push(e);
  }
  closePath() {
    const e = this.curves[0].getPoint(0),
      o = this.curves[this.curves.length - 1].getPoint(1);
    if (!e.equals(o)) {
      const a = e.isVector2 === !0 ? "LineCurve" : "LineCurve3";
      this.curves.push(new Curves[a](o, e));
    }
    return this;
  }
  getPoint(e, o) {
    const a = e * this.getLength(),
      c = this.getCurveLengths();
    let d = 0;
    for (; d < c.length; ) {
      if (c[d] >= a) {
        const g = c[d] - a,
          _ = this.curves[d],
          b = _.getLength(),
          j = b === 0 ? 0 : 1 - g / b;
        return _.getPointAt(j, o);
      }
      d++;
    }
    return null;
  }
  getLength() {
    const e = this.getCurveLengths();
    return e[e.length - 1];
  }
  updateArcLengths() {
    (this.needsUpdate = !0), (this.cacheLengths = null), this.getCurveLengths();
  }
  getCurveLengths() {
    if (this.cacheLengths && this.cacheLengths.length === this.curves.length)
      return this.cacheLengths;
    const e = [];
    let o = 0;
    for (let a = 0, c = this.curves.length; a < c; a++)
      (o += this.curves[a].getLength()), e.push(o);
    return (this.cacheLengths = e), e;
  }
  getSpacedPoints(e = 40) {
    const o = [];
    for (let a = 0; a <= e; a++) o.push(this.getPoint(a / e));
    return this.autoClose && o.push(o[0]), o;
  }
  getPoints(e = 12) {
    const o = [];
    let a;
    for (let c = 0, d = this.curves; c < d.length; c++) {
      const g = d[c],
        _ = g.isEllipseCurve
          ? e * 2
          : g.isLineCurve || g.isLineCurve3
          ? 1
          : g.isSplineCurve
          ? e * g.points.length
          : e,
        b = g.getPoints(_);
      for (let j = 0; j < b.length; j++) {
        const $ = b[j];
        (a && a.equals($)) || (o.push($), (a = $));
      }
    }
    return (
      this.autoClose &&
        o.length > 1 &&
        !o[o.length - 1].equals(o[0]) &&
        o.push(o[0]),
      o
    );
  }
  copy(e) {
    super.copy(e), (this.curves = []);
    for (let o = 0, a = e.curves.length; o < a; o++) {
      const c = e.curves[o];
      this.curves.push(c.clone());
    }
    return (this.autoClose = e.autoClose), this;
  }
  toJSON() {
    const e = super.toJSON();
    (e.autoClose = this.autoClose), (e.curves = []);
    for (let o = 0, a = this.curves.length; o < a; o++) {
      const c = this.curves[o];
      e.curves.push(c.toJSON());
    }
    return e;
  }
  fromJSON(e) {
    super.fromJSON(e), (this.autoClose = e.autoClose), (this.curves = []);
    for (let o = 0, a = e.curves.length; o < a; o++) {
      const c = e.curves[o];
      this.curves.push(new Curves[c.type]().fromJSON(c));
    }
    return this;
  }
}
class Path extends CurvePath {
  constructor(e) {
    super(),
      (this.type = "Path"),
      (this.currentPoint = new Vector2()),
      e && this.setFromPoints(e);
  }
  setFromPoints(e) {
    this.moveTo(e[0].x, e[0].y);
    for (let o = 1, a = e.length; o < a; o++) this.lineTo(e[o].x, e[o].y);
    return this;
  }
  moveTo(e, o) {
    return this.currentPoint.set(e, o), this;
  }
  lineTo(e, o) {
    const a = new LineCurve(this.currentPoint.clone(), new Vector2(e, o));
    return this.curves.push(a), this.currentPoint.set(e, o), this;
  }
  quadraticCurveTo(e, o, a, c) {
    const d = new QuadraticBezierCurve(
      this.currentPoint.clone(),
      new Vector2(e, o),
      new Vector2(a, c)
    );
    return this.curves.push(d), this.currentPoint.set(a, c), this;
  }
  bezierCurveTo(e, o, a, c, d, g) {
    const _ = new CubicBezierCurve(
      this.currentPoint.clone(),
      new Vector2(e, o),
      new Vector2(a, c),
      new Vector2(d, g)
    );
    return this.curves.push(_), this.currentPoint.set(d, g), this;
  }
  splineThru(e) {
    const o = [this.currentPoint.clone()].concat(e),
      a = new SplineCurve(o);
    return this.curves.push(a), this.currentPoint.copy(e[e.length - 1]), this;
  }
  arc(e, o, a, c, d, g) {
    const _ = this.currentPoint.x,
      b = this.currentPoint.y;
    return this.absarc(e + _, o + b, a, c, d, g), this;
  }
  absarc(e, o, a, c, d, g) {
    return this.absellipse(e, o, a, a, c, d, g), this;
  }
  ellipse(e, o, a, c, d, g, _, b) {
    const j = this.currentPoint.x,
      $ = this.currentPoint.y;
    return this.absellipse(e + j, o + $, a, c, d, g, _, b), this;
  }
  absellipse(e, o, a, c, d, g, _, b) {
    const j = new EllipseCurve(e, o, a, c, d, g, _, b);
    if (this.curves.length > 0) {
      const _e = j.getPoint(0);
      _e.equals(this.currentPoint) || this.lineTo(_e.x, _e.y);
    }
    this.curves.push(j);
    const $ = j.getPoint(1);
    return this.currentPoint.copy($), this;
  }
  copy(e) {
    return super.copy(e), this.currentPoint.copy(e.currentPoint), this;
  }
  toJSON() {
    const e = super.toJSON();
    return (e.currentPoint = this.currentPoint.toArray()), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.currentPoint.fromArray(e.currentPoint), this;
  }
}
class LatheGeometry extends BufferGeometry {
  constructor(
    e = [new Vector2(0, -0.5), new Vector2(0.5, 0), new Vector2(0, 0.5)],
    o = 12,
    a = 0,
    c = Math.PI * 2
  ) {
    super(),
      (this.type = "LatheGeometry"),
      (this.parameters = { points: e, segments: o, phiStart: a, phiLength: c }),
      (o = Math.floor(o)),
      (c = clamp(c, 0, Math.PI * 2));
    const d = [],
      g = [],
      _ = [],
      b = [],
      j = [],
      $ = 1 / o,
      _e = new Vector3(),
      et = new Vector2(),
      rt = new Vector3(),
      st = new Vector3(),
      at = new Vector3();
    let ct = 0,
      it = 0;
    for (let lt = 0; lt <= e.length - 1; lt++)
      switch (lt) {
        case 0:
          (ct = e[lt + 1].x - e[lt].x),
            (it = e[lt + 1].y - e[lt].y),
            (rt.x = it * 1),
            (rt.y = -ct),
            (rt.z = it * 0),
            at.copy(rt),
            rt.normalize(),
            b.push(rt.x, rt.y, rt.z);
          break;
        case e.length - 1:
          b.push(at.x, at.y, at.z);
          break;
        default:
          (ct = e[lt + 1].x - e[lt].x),
            (it = e[lt + 1].y - e[lt].y),
            (rt.x = it * 1),
            (rt.y = -ct),
            (rt.z = it * 0),
            st.copy(rt),
            (rt.x += at.x),
            (rt.y += at.y),
            (rt.z += at.z),
            rt.normalize(),
            b.push(rt.x, rt.y, rt.z),
            at.copy(st);
      }
    for (let lt = 0; lt <= o; lt++) {
      const ot = a + lt * $ * c,
        ut = Math.sin(ot),
        pt = Math.cos(ot);
      for (let ft = 0; ft <= e.length - 1; ft++) {
        (_e.x = e[ft].x * ut),
          (_e.y = e[ft].y),
          (_e.z = e[ft].x * pt),
          g.push(_e.x, _e.y, _e.z),
          (et.x = lt / o),
          (et.y = ft / (e.length - 1)),
          _.push(et.x, et.y);
        const gt = b[3 * ft + 0] * ut,
          xt = b[3 * ft + 1],
          _t = b[3 * ft + 0] * pt;
        j.push(gt, xt, _t);
      }
    }
    for (let lt = 0; lt < o; lt++)
      for (let ot = 0; ot < e.length - 1; ot++) {
        const ut = ot + lt * e.length,
          pt = ut,
          ft = ut + e.length,
          gt = ut + e.length + 1,
          xt = ut + 1;
        d.push(pt, ft, xt), d.push(gt, xt, ft);
      }
    this.setIndex(d),
      this.setAttribute("position", new Float32BufferAttribute(g, 3)),
      this.setAttribute("uv", new Float32BufferAttribute(_, 2)),
      this.setAttribute("normal", new Float32BufferAttribute(j, 3));
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  static fromJSON(e) {
    return new LatheGeometry(e.points, e.segments, e.phiStart, e.phiLength);
  }
}
class CapsuleGeometry extends LatheGeometry {
  constructor(e = 1, o = 1, a = 4, c = 8) {
    const d = new Path();
    d.absarc(0, -o / 2, e, Math.PI * 1.5, 0),
      d.absarc(0, o / 2, e, 0, Math.PI * 0.5),
      super(d.getPoints(a), c),
      (this.type = "CapsuleGeometry"),
      (this.parameters = {
        radius: e,
        length: o,
        capSegments: a,
        radialSegments: c,
      });
  }
  static fromJSON(e) {
    return new CapsuleGeometry(
      e.radius,
      e.length,
      e.capSegments,
      e.radialSegments
    );
  }
}
class CircleGeometry extends BufferGeometry {
  constructor(e = 1, o = 32, a = 0, c = Math.PI * 2) {
    super(),
      (this.type = "CircleGeometry"),
      (this.parameters = {
        radius: e,
        segments: o,
        thetaStart: a,
        thetaLength: c,
      }),
      (o = Math.max(3, o));
    const d = [],
      g = [],
      _ = [],
      b = [],
      j = new Vector3(),
      $ = new Vector2();
    g.push(0, 0, 0), _.push(0, 0, 1), b.push(0.5, 0.5);
    for (let _e = 0, et = 3; _e <= o; _e++, et += 3) {
      const rt = a + (_e / o) * c;
      (j.x = e * Math.cos(rt)),
        (j.y = e * Math.sin(rt)),
        g.push(j.x, j.y, j.z),
        _.push(0, 0, 1),
        ($.x = (g[et] / e + 1) / 2),
        ($.y = (g[et + 1] / e + 1) / 2),
        b.push($.x, $.y);
    }
    for (let _e = 1; _e <= o; _e++) d.push(_e, _e + 1, 0);
    this.setIndex(d),
      this.setAttribute("position", new Float32BufferAttribute(g, 3)),
      this.setAttribute("normal", new Float32BufferAttribute(_, 3)),
      this.setAttribute("uv", new Float32BufferAttribute(b, 2));
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  static fromJSON(e) {
    return new CircleGeometry(
      e.radius,
      e.segments,
      e.thetaStart,
      e.thetaLength
    );
  }
}
class CylinderGeometry extends BufferGeometry {
  constructor(
    e = 1,
    o = 1,
    a = 1,
    c = 32,
    d = 1,
    g = !1,
    _ = 0,
    b = Math.PI * 2
  ) {
    super(),
      (this.type = "CylinderGeometry"),
      (this.parameters = {
        radiusTop: e,
        radiusBottom: o,
        height: a,
        radialSegments: c,
        heightSegments: d,
        openEnded: g,
        thetaStart: _,
        thetaLength: b,
      });
    const j = this;
    (c = Math.floor(c)), (d = Math.floor(d));
    const $ = [],
      _e = [],
      et = [],
      rt = [];
    let st = 0;
    const at = [],
      ct = a / 2;
    let it = 0;
    lt(),
      g === !1 && (e > 0 && ot(!0), o > 0 && ot(!1)),
      this.setIndex($),
      this.setAttribute("position", new Float32BufferAttribute(_e, 3)),
      this.setAttribute("normal", new Float32BufferAttribute(et, 3)),
      this.setAttribute("uv", new Float32BufferAttribute(rt, 2));
    function lt() {
      const ut = new Vector3(),
        pt = new Vector3();
      let ft = 0;
      const gt = (o - e) / a;
      for (let xt = 0; xt <= d; xt++) {
        const _t = [],
          St = xt / d,
          Mt = St * (o - e) + e;
        for (let Rt = 0; Rt <= c; Rt++) {
          const Ft = Rt / c,
            Ot = Ft * b + _,
            Lt = Math.sin(Ot),
            Et = Math.cos(Ot);
          (pt.x = Mt * Lt),
            (pt.y = -St * a + ct),
            (pt.z = Mt * Et),
            _e.push(pt.x, pt.y, pt.z),
            ut.set(Lt, gt, Et).normalize(),
            et.push(ut.x, ut.y, ut.z),
            rt.push(Ft, 1 - St),
            _t.push(st++);
        }
        at.push(_t);
      }
      for (let xt = 0; xt < c; xt++)
        for (let _t = 0; _t < d; _t++) {
          const St = at[_t][xt],
            Mt = at[_t + 1][xt],
            Rt = at[_t + 1][xt + 1],
            Ft = at[_t][xt + 1];
          $.push(St, Mt, Ft), $.push(Mt, Rt, Ft), (ft += 6);
        }
      j.addGroup(it, ft, 0), (it += ft);
    }
    function ot(ut) {
      const pt = st,
        ft = new Vector2(),
        gt = new Vector3();
      let xt = 0;
      const _t = ut === !0 ? e : o,
        St = ut === !0 ? 1 : -1;
      for (let Rt = 1; Rt <= c; Rt++)
        _e.push(0, ct * St, 0), et.push(0, St, 0), rt.push(0.5, 0.5), st++;
      const Mt = st;
      for (let Rt = 0; Rt <= c; Rt++) {
        const Ot = (Rt / c) * b + _,
          Lt = Math.cos(Ot),
          Et = Math.sin(Ot);
        (gt.x = _t * Et),
          (gt.y = ct * St),
          (gt.z = _t * Lt),
          _e.push(gt.x, gt.y, gt.z),
          et.push(0, St, 0),
          (ft.x = Lt * 0.5 + 0.5),
          (ft.y = Et * 0.5 * St + 0.5),
          rt.push(ft.x, ft.y),
          st++;
      }
      for (let Rt = 0; Rt < c; Rt++) {
        const Ft = pt + Rt,
          Ot = Mt + Rt;
        ut === !0 ? $.push(Ot, Ot + 1, Ft) : $.push(Ot + 1, Ot, Ft), (xt += 3);
      }
      j.addGroup(it, xt, ut === !0 ? 1 : 2), (it += xt);
    }
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  static fromJSON(e) {
    return new CylinderGeometry(
      e.radiusTop,
      e.radiusBottom,
      e.height,
      e.radialSegments,
      e.heightSegments,
      e.openEnded,
      e.thetaStart,
      e.thetaLength
    );
  }
}
class ConeGeometry extends CylinderGeometry {
  constructor(e = 1, o = 1, a = 32, c = 1, d = !1, g = 0, _ = Math.PI * 2) {
    super(0, e, o, a, c, d, g, _),
      (this.type = "ConeGeometry"),
      (this.parameters = {
        radius: e,
        height: o,
        radialSegments: a,
        heightSegments: c,
        openEnded: d,
        thetaStart: g,
        thetaLength: _,
      });
  }
  static fromJSON(e) {
    return new ConeGeometry(
      e.radius,
      e.height,
      e.radialSegments,
      e.heightSegments,
      e.openEnded,
      e.thetaStart,
      e.thetaLength
    );
  }
}
class PolyhedronGeometry extends BufferGeometry {
  constructor(e = [], o = [], a = 1, c = 0) {
    super(),
      (this.type = "PolyhedronGeometry"),
      (this.parameters = { vertices: e, indices: o, radius: a, detail: c });
    const d = [],
      g = [];
    _(c),
      j(a),
      $(),
      this.setAttribute("position", new Float32BufferAttribute(d, 3)),
      this.setAttribute("normal", new Float32BufferAttribute(d.slice(), 3)),
      this.setAttribute("uv", new Float32BufferAttribute(g, 2)),
      c === 0 ? this.computeVertexNormals() : this.normalizeNormals();
    function _(lt) {
      const ot = new Vector3(),
        ut = new Vector3(),
        pt = new Vector3();
      for (let ft = 0; ft < o.length; ft += 3)
        rt(o[ft + 0], ot),
          rt(o[ft + 1], ut),
          rt(o[ft + 2], pt),
          b(ot, ut, pt, lt);
    }
    function b(lt, ot, ut, pt) {
      const ft = pt + 1,
        gt = [];
      for (let xt = 0; xt <= ft; xt++) {
        gt[xt] = [];
        const _t = lt.clone().lerp(ut, xt / ft),
          St = ot.clone().lerp(ut, xt / ft),
          Mt = ft - xt;
        for (let Rt = 0; Rt <= Mt; Rt++)
          Rt === 0 && xt === ft
            ? (gt[xt][Rt] = _t)
            : (gt[xt][Rt] = _t.clone().lerp(St, Rt / Mt));
      }
      for (let xt = 0; xt < ft; xt++)
        for (let _t = 0; _t < 2 * (ft - xt) - 1; _t++) {
          const St = Math.floor(_t / 2);
          _t % 2 === 0
            ? (et(gt[xt][St + 1]), et(gt[xt + 1][St]), et(gt[xt][St]))
            : (et(gt[xt][St + 1]), et(gt[xt + 1][St + 1]), et(gt[xt + 1][St]));
        }
    }
    function j(lt) {
      const ot = new Vector3();
      for (let ut = 0; ut < d.length; ut += 3)
        (ot.x = d[ut + 0]),
          (ot.y = d[ut + 1]),
          (ot.z = d[ut + 2]),
          ot.normalize().multiplyScalar(lt),
          (d[ut + 0] = ot.x),
          (d[ut + 1] = ot.y),
          (d[ut + 2] = ot.z);
    }
    function $() {
      const lt = new Vector3();
      for (let ot = 0; ot < d.length; ot += 3) {
        (lt.x = d[ot + 0]), (lt.y = d[ot + 1]), (lt.z = d[ot + 2]);
        const ut = ct(lt) / 2 / Math.PI + 0.5,
          pt = it(lt) / Math.PI + 0.5;
        g.push(ut, 1 - pt);
      }
      st(), _e();
    }
    function _e() {
      for (let lt = 0; lt < g.length; lt += 6) {
        const ot = g[lt + 0],
          ut = g[lt + 2],
          pt = g[lt + 4],
          ft = Math.max(ot, ut, pt),
          gt = Math.min(ot, ut, pt);
        ft > 0.9 &&
          gt < 0.1 &&
          (ot < 0.2 && (g[lt + 0] += 1),
          ut < 0.2 && (g[lt + 2] += 1),
          pt < 0.2 && (g[lt + 4] += 1));
      }
    }
    function et(lt) {
      d.push(lt.x, lt.y, lt.z);
    }
    function rt(lt, ot) {
      const ut = lt * 3;
      (ot.x = e[ut + 0]), (ot.y = e[ut + 1]), (ot.z = e[ut + 2]);
    }
    function st() {
      const lt = new Vector3(),
        ot = new Vector3(),
        ut = new Vector3(),
        pt = new Vector3(),
        ft = new Vector2(),
        gt = new Vector2(),
        xt = new Vector2();
      for (let _t = 0, St = 0; _t < d.length; _t += 9, St += 6) {
        lt.set(d[_t + 0], d[_t + 1], d[_t + 2]),
          ot.set(d[_t + 3], d[_t + 4], d[_t + 5]),
          ut.set(d[_t + 6], d[_t + 7], d[_t + 8]),
          ft.set(g[St + 0], g[St + 1]),
          gt.set(g[St + 2], g[St + 3]),
          xt.set(g[St + 4], g[St + 5]),
          pt.copy(lt).add(ot).add(ut).divideScalar(3);
        const Mt = ct(pt);
        at(ft, St + 0, lt, Mt), at(gt, St + 2, ot, Mt), at(xt, St + 4, ut, Mt);
      }
    }
    function at(lt, ot, ut, pt) {
      pt < 0 && lt.x === 1 && (g[ot] = lt.x - 1),
        ut.x === 0 && ut.z === 0 && (g[ot] = pt / 2 / Math.PI + 0.5);
    }
    function ct(lt) {
      return Math.atan2(lt.z, -lt.x);
    }
    function it(lt) {
      return Math.atan2(-lt.y, Math.sqrt(lt.x * lt.x + lt.z * lt.z));
    }
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  static fromJSON(e) {
    return new PolyhedronGeometry(e.vertices, e.indices, e.radius, e.details);
  }
}
class DodecahedronGeometry extends PolyhedronGeometry {
  constructor(e = 1, o = 0) {
    const a = (1 + Math.sqrt(5)) / 2,
      c = 1 / a,
      d = [
        -1,
        -1,
        -1,
        -1,
        -1,
        1,
        -1,
        1,
        -1,
        -1,
        1,
        1,
        1,
        -1,
        -1,
        1,
        -1,
        1,
        1,
        1,
        -1,
        1,
        1,
        1,
        0,
        -c,
        -a,
        0,
        -c,
        a,
        0,
        c,
        -a,
        0,
        c,
        a,
        -c,
        -a,
        0,
        -c,
        a,
        0,
        c,
        -a,
        0,
        c,
        a,
        0,
        -a,
        0,
        -c,
        a,
        0,
        -c,
        -a,
        0,
        c,
        a,
        0,
        c,
      ],
      g = [
        3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4, 8,
        17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0, 1, 18,
        0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2, 3, 13,
        18, 1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5,
        11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19, 4, 17, 1, 12, 14, 1, 14,
        5, 1, 5, 9,
      ];
    super(d, g, e, o),
      (this.type = "DodecahedronGeometry"),
      (this.parameters = { radius: e, detail: o });
  }
  static fromJSON(e) {
    return new DodecahedronGeometry(e.radius, e.detail);
  }
}
const _v0 = new Vector3(),
  _v1$1 = new Vector3(),
  _normal = new Vector3(),
  _triangle = new Triangle();
class EdgesGeometry extends BufferGeometry {
  constructor(e = null, o = 1) {
    if (
      (super(),
      (this.type = "EdgesGeometry"),
      (this.parameters = { geometry: e, thresholdAngle: o }),
      e !== null)
    ) {
      const c = Math.pow(10, 4),
        d = Math.cos(DEG2RAD * o),
        g = e.getIndex(),
        _ = e.getAttribute("position"),
        b = g ? g.count : _.count,
        j = [0, 0, 0],
        $ = ["a", "b", "c"],
        _e = new Array(3),
        et = {},
        rt = [];
      for (let st = 0; st < b; st += 3) {
        g
          ? ((j[0] = g.getX(st)),
            (j[1] = g.getX(st + 1)),
            (j[2] = g.getX(st + 2)))
          : ((j[0] = st), (j[1] = st + 1), (j[2] = st + 2));
        const { a: at, b: ct, c: it } = _triangle;
        if (
          (at.fromBufferAttribute(_, j[0]),
          ct.fromBufferAttribute(_, j[1]),
          it.fromBufferAttribute(_, j[2]),
          _triangle.getNormal(_normal),
          (_e[0] = `${Math.round(at.x * c)},${Math.round(
            at.y * c
          )},${Math.round(at.z * c)}`),
          (_e[1] = `${Math.round(ct.x * c)},${Math.round(
            ct.y * c
          )},${Math.round(ct.z * c)}`),
          (_e[2] = `${Math.round(it.x * c)},${Math.round(
            it.y * c
          )},${Math.round(it.z * c)}`),
          !(_e[0] === _e[1] || _e[1] === _e[2] || _e[2] === _e[0]))
        )
          for (let lt = 0; lt < 3; lt++) {
            const ot = (lt + 1) % 3,
              ut = _e[lt],
              pt = _e[ot],
              ft = _triangle[$[lt]],
              gt = _triangle[$[ot]],
              xt = `${ut}_${pt}`,
              _t = `${pt}_${ut}`;
            _t in et && et[_t]
              ? (_normal.dot(et[_t].normal) <= d &&
                  (rt.push(ft.x, ft.y, ft.z), rt.push(gt.x, gt.y, gt.z)),
                (et[_t] = null))
              : xt in et ||
                (et[xt] = {
                  index0: j[lt],
                  index1: j[ot],
                  normal: _normal.clone(),
                });
          }
      }
      for (const st in et)
        if (et[st]) {
          const { index0: at, index1: ct } = et[st];
          _v0.fromBufferAttribute(_, at),
            _v1$1.fromBufferAttribute(_, ct),
            rt.push(_v0.x, _v0.y, _v0.z),
            rt.push(_v1$1.x, _v1$1.y, _v1$1.z);
        }
      this.setAttribute("position", new Float32BufferAttribute(rt, 3));
    }
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
}
class Shape extends Path {
  constructor(e) {
    super(e),
      (this.uuid = generateUUID()),
      (this.type = "Shape"),
      (this.holes = []);
  }
  getPointsHoles(e) {
    const o = [];
    for (let a = 0, c = this.holes.length; a < c; a++)
      o[a] = this.holes[a].getPoints(e);
    return o;
  }
  extractPoints(e) {
    return { shape: this.getPoints(e), holes: this.getPointsHoles(e) };
  }
  copy(e) {
    super.copy(e), (this.holes = []);
    for (let o = 0, a = e.holes.length; o < a; o++) {
      const c = e.holes[o];
      this.holes.push(c.clone());
    }
    return this;
  }
  toJSON() {
    const e = super.toJSON();
    (e.uuid = this.uuid), (e.holes = []);
    for (let o = 0, a = this.holes.length; o < a; o++) {
      const c = this.holes[o];
      e.holes.push(c.toJSON());
    }
    return e;
  }
  fromJSON(e) {
    super.fromJSON(e), (this.uuid = e.uuid), (this.holes = []);
    for (let o = 0, a = e.holes.length; o < a; o++) {
      const c = e.holes[o];
      this.holes.push(new Path().fromJSON(c));
    }
    return this;
  }
}
const Earcut = {
  triangulate: function (s, e, o = 2) {
    const a = e && e.length,
      c = a ? e[0] * o : s.length;
    let d = linkedList(s, 0, c, o, !0);
    const g = [];
    if (!d || d.next === d.prev) return g;
    let _, b, j, $, _e, et, rt;
    if ((a && (d = eliminateHoles(s, e, d, o)), s.length > 80 * o)) {
      (_ = j = s[0]), (b = $ = s[1]);
      for (let st = o; st < c; st += o)
        (_e = s[st]),
          (et = s[st + 1]),
          _e < _ && (_ = _e),
          et < b && (b = et),
          _e > j && (j = _e),
          et > $ && ($ = et);
      (rt = Math.max(j - _, $ - b)), (rt = rt !== 0 ? 32767 / rt : 0);
    }
    return earcutLinked(d, g, o, _, b, rt, 0), g;
  },
};
function linkedList(s, e, o, a, c) {
  let d, g;
  if (c === signedArea(s, e, o, a) > 0)
    for (d = e; d < o; d += a) g = insertNode(d, s[d], s[d + 1], g);
  else for (d = o - a; d >= e; d -= a) g = insertNode(d, s[d], s[d + 1], g);
  return g && equals(g, g.next) && (removeNode(g), (g = g.next)), g;
}
function filterPoints(s, e) {
  if (!s) return s;
  e || (e = s);
  let o = s,
    a;
  do
    if (
      ((a = !1),
      !o.steiner && (equals(o, o.next) || area(o.prev, o, o.next) === 0))
    ) {
      if ((removeNode(o), (o = e = o.prev), o === o.next)) break;
      a = !0;
    } else o = o.next;
  while (a || o !== e);
  return e;
}
function earcutLinked(s, e, o, a, c, d, g) {
  if (!s) return;
  !g && d && indexCurve(s, a, c, d);
  let _ = s,
    b,
    j;
  for (; s.prev !== s.next; ) {
    if (((b = s.prev), (j = s.next), d ? isEarHashed(s, a, c, d) : isEar(s))) {
      e.push((b.i / o) | 0),
        e.push((s.i / o) | 0),
        e.push((j.i / o) | 0),
        removeNode(s),
        (s = j.next),
        (_ = j.next);
      continue;
    }
    if (((s = j), s === _)) {
      g
        ? g === 1
          ? ((s = cureLocalIntersections(filterPoints(s), e, o)),
            earcutLinked(s, e, o, a, c, d, 2))
          : g === 2 && splitEarcut(s, e, o, a, c, d)
        : earcutLinked(filterPoints(s), e, o, a, c, d, 1);
      break;
    }
  }
}
function isEar(s) {
  const e = s.prev,
    o = s,
    a = s.next;
  if (area(e, o, a) >= 0) return !1;
  const c = e.x,
    d = o.x,
    g = a.x,
    _ = e.y,
    b = o.y,
    j = a.y,
    $ = c < d ? (c < g ? c : g) : d < g ? d : g,
    _e = _ < b ? (_ < j ? _ : j) : b < j ? b : j,
    et = c > d ? (c > g ? c : g) : d > g ? d : g,
    rt = _ > b ? (_ > j ? _ : j) : b > j ? b : j;
  let st = a.next;
  for (; st !== e; ) {
    if (
      st.x >= $ &&
      st.x <= et &&
      st.y >= _e &&
      st.y <= rt &&
      pointInTriangle(c, _, d, b, g, j, st.x, st.y) &&
      area(st.prev, st, st.next) >= 0
    )
      return !1;
    st = st.next;
  }
  return !0;
}
function isEarHashed(s, e, o, a) {
  const c = s.prev,
    d = s,
    g = s.next;
  if (area(c, d, g) >= 0) return !1;
  const _ = c.x,
    b = d.x,
    j = g.x,
    $ = c.y,
    _e = d.y,
    et = g.y,
    rt = _ < b ? (_ < j ? _ : j) : b < j ? b : j,
    st = $ < _e ? ($ < et ? $ : et) : _e < et ? _e : et,
    at = _ > b ? (_ > j ? _ : j) : b > j ? b : j,
    ct = $ > _e ? ($ > et ? $ : et) : _e > et ? _e : et,
    it = zOrder(rt, st, e, o, a),
    lt = zOrder(at, ct, e, o, a);
  let ot = s.prevZ,
    ut = s.nextZ;
  for (; ot && ot.z >= it && ut && ut.z <= lt; ) {
    if (
      (ot.x >= rt &&
        ot.x <= at &&
        ot.y >= st &&
        ot.y <= ct &&
        ot !== c &&
        ot !== g &&
        pointInTriangle(_, $, b, _e, j, et, ot.x, ot.y) &&
        area(ot.prev, ot, ot.next) >= 0) ||
      ((ot = ot.prevZ),
      ut.x >= rt &&
        ut.x <= at &&
        ut.y >= st &&
        ut.y <= ct &&
        ut !== c &&
        ut !== g &&
        pointInTriangle(_, $, b, _e, j, et, ut.x, ut.y) &&
        area(ut.prev, ut, ut.next) >= 0)
    )
      return !1;
    ut = ut.nextZ;
  }
  for (; ot && ot.z >= it; ) {
    if (
      ot.x >= rt &&
      ot.x <= at &&
      ot.y >= st &&
      ot.y <= ct &&
      ot !== c &&
      ot !== g &&
      pointInTriangle(_, $, b, _e, j, et, ot.x, ot.y) &&
      area(ot.prev, ot, ot.next) >= 0
    )
      return !1;
    ot = ot.prevZ;
  }
  for (; ut && ut.z <= lt; ) {
    if (
      ut.x >= rt &&
      ut.x <= at &&
      ut.y >= st &&
      ut.y <= ct &&
      ut !== c &&
      ut !== g &&
      pointInTriangle(_, $, b, _e, j, et, ut.x, ut.y) &&
      area(ut.prev, ut, ut.next) >= 0
    )
      return !1;
    ut = ut.nextZ;
  }
  return !0;
}
function cureLocalIntersections(s, e, o) {
  let a = s;
  do {
    const c = a.prev,
      d = a.next.next;
    !equals(c, d) &&
      intersects(c, a, a.next, d) &&
      locallyInside(c, d) &&
      locallyInside(d, c) &&
      (e.push((c.i / o) | 0),
      e.push((a.i / o) | 0),
      e.push((d.i / o) | 0),
      removeNode(a),
      removeNode(a.next),
      (a = s = d)),
      (a = a.next);
  } while (a !== s);
  return filterPoints(a);
}
function splitEarcut(s, e, o, a, c, d) {
  let g = s;
  do {
    let _ = g.next.next;
    for (; _ !== g.prev; ) {
      if (g.i !== _.i && isValidDiagonal(g, _)) {
        let b = splitPolygon(g, _);
        (g = filterPoints(g, g.next)),
          (b = filterPoints(b, b.next)),
          earcutLinked(g, e, o, a, c, d, 0),
          earcutLinked(b, e, o, a, c, d, 0);
        return;
      }
      _ = _.next;
    }
    g = g.next;
  } while (g !== s);
}
function eliminateHoles(s, e, o, a) {
  const c = [];
  let d, g, _, b, j;
  for (d = 0, g = e.length; d < g; d++)
    (_ = e[d] * a),
      (b = d < g - 1 ? e[d + 1] * a : s.length),
      (j = linkedList(s, _, b, a, !1)),
      j === j.next && (j.steiner = !0),
      c.push(getLeftmost(j));
  for (c.sort(compareX), d = 0; d < c.length; d++) o = eliminateHole(c[d], o);
  return o;
}
function compareX(s, e) {
  return s.x - e.x;
}
function eliminateHole(s, e) {
  const o = findHoleBridge(s, e);
  if (!o) return e;
  const a = splitPolygon(o, s);
  return filterPoints(a, a.next), filterPoints(o, o.next);
}
function findHoleBridge(s, e) {
  let o = e,
    a = -1 / 0,
    c;
  const d = s.x,
    g = s.y;
  do {
    if (g <= o.y && g >= o.next.y && o.next.y !== o.y) {
      const et = o.x + ((g - o.y) * (o.next.x - o.x)) / (o.next.y - o.y);
      if (
        et <= d &&
        et > a &&
        ((a = et), (c = o.x < o.next.x ? o : o.next), et === d)
      )
        return c;
    }
    o = o.next;
  } while (o !== e);
  if (!c) return null;
  const _ = c,
    b = c.x,
    j = c.y;
  let $ = 1 / 0,
    _e;
  o = c;
  do
    d >= o.x &&
      o.x >= b &&
      d !== o.x &&
      pointInTriangle(g < j ? d : a, g, b, j, g < j ? a : d, g, o.x, o.y) &&
      ((_e = Math.abs(g - o.y) / (d - o.x)),
      locallyInside(o, s) &&
        (_e < $ ||
          (_e === $ &&
            (o.x > c.x || (o.x === c.x && sectorContainsSector(c, o))))) &&
        ((c = o), ($ = _e))),
      (o = o.next);
  while (o !== _);
  return c;
}
function sectorContainsSector(s, e) {
  return area(s.prev, s, e.prev) < 0 && area(e.next, s, s.next) < 0;
}
function indexCurve(s, e, o, a) {
  let c = s;
  do
    c.z === 0 && (c.z = zOrder(c.x, c.y, e, o, a)),
      (c.prevZ = c.prev),
      (c.nextZ = c.next),
      (c = c.next);
  while (c !== s);
  (c.prevZ.nextZ = null), (c.prevZ = null), sortLinked(c);
}
function sortLinked(s) {
  let e,
    o,
    a,
    c,
    d,
    g,
    _,
    b,
    j = 1;
  do {
    for (o = s, s = null, d = null, g = 0; o; ) {
      for (g++, a = o, _ = 0, e = 0; e < j && (_++, (a = a.nextZ), !!a); e++);
      for (b = j; _ > 0 || (b > 0 && a); )
        _ !== 0 && (b === 0 || !a || o.z <= a.z)
          ? ((c = o), (o = o.nextZ), _--)
          : ((c = a), (a = a.nextZ), b--),
          d ? (d.nextZ = c) : (s = c),
          (c.prevZ = d),
          (d = c);
      o = a;
    }
    (d.nextZ = null), (j *= 2);
  } while (g > 1);
  return s;
}
function zOrder(s, e, o, a, c) {
  return (
    (s = ((s - o) * c) | 0),
    (e = ((e - a) * c) | 0),
    (s = (s | (s << 8)) & 16711935),
    (s = (s | (s << 4)) & 252645135),
    (s = (s | (s << 2)) & 858993459),
    (s = (s | (s << 1)) & 1431655765),
    (e = (e | (e << 8)) & 16711935),
    (e = (e | (e << 4)) & 252645135),
    (e = (e | (e << 2)) & 858993459),
    (e = (e | (e << 1)) & 1431655765),
    s | (e << 1)
  );
}
function getLeftmost(s) {
  let e = s,
    o = s;
  do (e.x < o.x || (e.x === o.x && e.y < o.y)) && (o = e), (e = e.next);
  while (e !== s);
  return o;
}
function pointInTriangle(s, e, o, a, c, d, g, _) {
  return (
    (c - g) * (e - _) >= (s - g) * (d - _) &&
    (s - g) * (a - _) >= (o - g) * (e - _) &&
    (o - g) * (d - _) >= (c - g) * (a - _)
  );
}
function isValidDiagonal(s, e) {
  return (
    s.next.i !== e.i &&
    s.prev.i !== e.i &&
    !intersectsPolygon(s, e) &&
    ((locallyInside(s, e) &&
      locallyInside(e, s) &&
      middleInside(s, e) &&
      (area(s.prev, s, e.prev) || area(s, e.prev, e))) ||
      (equals(s, e) &&
        area(s.prev, s, s.next) > 0 &&
        area(e.prev, e, e.next) > 0))
  );
}
function area(s, e, o) {
  return (e.y - s.y) * (o.x - e.x) - (e.x - s.x) * (o.y - e.y);
}
function equals(s, e) {
  return s.x === e.x && s.y === e.y;
}
function intersects(s, e, o, a) {
  const c = sign(area(s, e, o)),
    d = sign(area(s, e, a)),
    g = sign(area(o, a, s)),
    _ = sign(area(o, a, e));
  return !!(
    (c !== d && g !== _) ||
    (c === 0 && onSegment(s, o, e)) ||
    (d === 0 && onSegment(s, a, e)) ||
    (g === 0 && onSegment(o, s, a)) ||
    (_ === 0 && onSegment(o, e, a))
  );
}
function onSegment(s, e, o) {
  return (
    e.x <= Math.max(s.x, o.x) &&
    e.x >= Math.min(s.x, o.x) &&
    e.y <= Math.max(s.y, o.y) &&
    e.y >= Math.min(s.y, o.y)
  );
}
function sign(s) {
  return s > 0 ? 1 : s < 0 ? -1 : 0;
}
function intersectsPolygon(s, e) {
  let o = s;
  do {
    if (
      o.i !== s.i &&
      o.next.i !== s.i &&
      o.i !== e.i &&
      o.next.i !== e.i &&
      intersects(o, o.next, s, e)
    )
      return !0;
    o = o.next;
  } while (o !== s);
  return !1;
}
function locallyInside(s, e) {
  return area(s.prev, s, s.next) < 0
    ? area(s, e, s.next) >= 0 && area(s, s.prev, e) >= 0
    : area(s, e, s.prev) < 0 || area(s, s.next, e) < 0;
}
function middleInside(s, e) {
  let o = s,
    a = !1;
  const c = (s.x + e.x) / 2,
    d = (s.y + e.y) / 2;
  do
    o.y > d != o.next.y > d &&
      o.next.y !== o.y &&
      c < ((o.next.x - o.x) * (d - o.y)) / (o.next.y - o.y) + o.x &&
      (a = !a),
      (o = o.next);
  while (o !== s);
  return a;
}
function splitPolygon(s, e) {
  const o = new Node(s.i, s.x, s.y),
    a = new Node(e.i, e.x, e.y),
    c = s.next,
    d = e.prev;
  return (
    (s.next = e),
    (e.prev = s),
    (o.next = c),
    (c.prev = o),
    (a.next = o),
    (o.prev = a),
    (d.next = a),
    (a.prev = d),
    a
  );
}
function insertNode(s, e, o, a) {
  const c = new Node(s, e, o);
  return (
    a
      ? ((c.next = a.next), (c.prev = a), (a.next.prev = c), (a.next = c))
      : ((c.prev = c), (c.next = c)),
    c
  );
}
function removeNode(s) {
  (s.next.prev = s.prev),
    (s.prev.next = s.next),
    s.prevZ && (s.prevZ.nextZ = s.nextZ),
    s.nextZ && (s.nextZ.prevZ = s.prevZ);
}
function Node(s, e, o) {
  (this.i = s),
    (this.x = e),
    (this.y = o),
    (this.prev = null),
    (this.next = null),
    (this.z = 0),
    (this.prevZ = null),
    (this.nextZ = null),
    (this.steiner = !1);
}
function signedArea(s, e, o, a) {
  let c = 0;
  for (let d = e, g = o - a; d < o; d += a)
    (c += (s[g] - s[d]) * (s[d + 1] + s[g + 1])), (g = d);
  return c;
}
class ShapeUtils {
  static area(e) {
    const o = e.length;
    let a = 0;
    for (let c = o - 1, d = 0; d < o; c = d++)
      a += e[c].x * e[d].y - e[d].x * e[c].y;
    return a * 0.5;
  }
  static isClockWise(e) {
    return ShapeUtils.area(e) < 0;
  }
  static triangulateShape(e, o) {
    const a = [],
      c = [],
      d = [];
    removeDupEndPts(e), addContour(a, e);
    let g = e.length;
    o.forEach(removeDupEndPts);
    for (let b = 0; b < o.length; b++)
      c.push(g), (g += o[b].length), addContour(a, o[b]);
    const _ = Earcut.triangulate(a, c);
    for (let b = 0; b < _.length; b += 3) d.push(_.slice(b, b + 3));
    return d;
  }
}
function removeDupEndPts(s) {
  const e = s.length;
  e > 2 && s[e - 1].equals(s[0]) && s.pop();
}
function addContour(s, e) {
  for (let o = 0; o < e.length; o++) s.push(e[o].x), s.push(e[o].y);
}
class ExtrudeGeometry extends BufferGeometry {
  constructor(
    e = new Shape([
      new Vector2(0.5, 0.5),
      new Vector2(-0.5, 0.5),
      new Vector2(-0.5, -0.5),
      new Vector2(0.5, -0.5),
    ]),
    o = {}
  ) {
    super(),
      (this.type = "ExtrudeGeometry"),
      (this.parameters = { shapes: e, options: o }),
      (e = Array.isArray(e) ? e : [e]);
    const a = this,
      c = [],
      d = [];
    for (let _ = 0, b = e.length; _ < b; _++) {
      const j = e[_];
      g(j);
    }
    this.setAttribute("position", new Float32BufferAttribute(c, 3)),
      this.setAttribute("uv", new Float32BufferAttribute(d, 2)),
      this.computeVertexNormals();
    function g(_) {
      const b = [],
        j = o.curveSegments !== void 0 ? o.curveSegments : 12,
        $ = o.steps !== void 0 ? o.steps : 1,
        _e = o.depth !== void 0 ? o.depth : 1;
      let et = o.bevelEnabled !== void 0 ? o.bevelEnabled : !0,
        rt = o.bevelThickness !== void 0 ? o.bevelThickness : 0.2,
        st = o.bevelSize !== void 0 ? o.bevelSize : rt - 0.1,
        at = o.bevelOffset !== void 0 ? o.bevelOffset : 0,
        ct = o.bevelSegments !== void 0 ? o.bevelSegments : 3;
      const it = o.extrudePath,
        lt = o.UVGenerator !== void 0 ? o.UVGenerator : WorldUVGenerator;
      let ot,
        ut = !1,
        pt,
        ft,
        gt,
        xt;
      it &&
        ((ot = it.getSpacedPoints($)),
        (ut = !0),
        (et = !1),
        (pt = it.computeFrenetFrames($, !1)),
        (ft = new Vector3()),
        (gt = new Vector3()),
        (xt = new Vector3())),
        et || ((ct = 0), (rt = 0), (st = 0), (at = 0));
      const _t = _.extractPoints(j);
      let St = _t.shape;
      const Mt = _t.holes;
      if (!ShapeUtils.isClockWise(St)) {
        St = St.reverse();
        for (let Bt = 0, qt = Mt.length; Bt < qt; Bt++) {
          const $t = Mt[Bt];
          ShapeUtils.isClockWise($t) && (Mt[Bt] = $t.reverse());
        }
      }
      const Ft = ShapeUtils.triangulateShape(St, Mt),
        Ot = St;
      for (let Bt = 0, qt = Mt.length; Bt < qt; Bt++) {
        const $t = Mt[Bt];
        St = St.concat($t);
      }
      function Lt(Bt, qt, $t) {
        return (
          qt || console.error("THREE.ExtrudeGeometry: vec does not exist"),
          Bt.clone().addScaledVector(qt, $t)
        );
      }
      const Et = St.length,
        bt = Ft.length;
      function mt(Bt, qt, $t) {
        let yn, nn, Pn;
        const xn = Bt.x - qt.x,
          An = Bt.y - qt.y,
          kt = $t.x - Bt.x,
          wt = $t.y - Bt.y,
          Kt = xn * xn + An * An,
          on = xn * wt - An * kt;
        if (Math.abs(on) > Number.EPSILON) {
          const sn = Math.sqrt(Kt),
            cn = Math.sqrt(kt * kt + wt * wt),
            bn = qt.x - An / sn,
            vn = qt.y + xn / sn,
            wn = $t.x - wt / cn,
            zn = $t.y + kt / cn,
            gn = ((wn - bn) * wt - (zn - vn) * kt) / (xn * wt - An * kt);
          (yn = bn + xn * gn - Bt.x), (nn = vn + An * gn - Bt.y);
          const Rn = yn * yn + nn * nn;
          if (Rn <= 2) return new Vector2(yn, nn);
          Pn = Math.sqrt(Rn / 2);
        } else {
          let sn = !1;
          xn > Number.EPSILON
            ? kt > Number.EPSILON && (sn = !0)
            : xn < -Number.EPSILON
            ? kt < -Number.EPSILON && (sn = !0)
            : Math.sign(An) === Math.sign(wt) && (sn = !0),
            sn
              ? ((yn = -An), (nn = xn), (Pn = Math.sqrt(Kt)))
              : ((yn = xn), (nn = An), (Pn = Math.sqrt(Kt / 2)));
        }
        return new Vector2(yn / Pn, nn / Pn);
      }
      const vt = [];
      for (
        let Bt = 0, qt = Ot.length, $t = qt - 1, yn = Bt + 1;
        Bt < qt;
        Bt++, $t++, yn++
      )
        $t === qt && ($t = 0),
          yn === qt && (yn = 0),
          (vt[Bt] = mt(Ot[Bt], Ot[$t], Ot[yn]));
      const Ct = [];
      let Tt,
        Dt = vt.concat();
      for (let Bt = 0, qt = Mt.length; Bt < qt; Bt++) {
        const $t = Mt[Bt];
        Tt = [];
        for (
          let yn = 0, nn = $t.length, Pn = nn - 1, xn = yn + 1;
          yn < nn;
          yn++, Pn++, xn++
        )
          Pn === nn && (Pn = 0),
            xn === nn && (xn = 0),
            (Tt[yn] = mt($t[yn], $t[Pn], $t[xn]));
        Ct.push(Tt), (Dt = Dt.concat(Tt));
      }
      for (let Bt = 0; Bt < ct; Bt++) {
        const qt = Bt / ct,
          $t = rt * Math.cos((qt * Math.PI) / 2),
          yn = st * Math.sin((qt * Math.PI) / 2) + at;
        for (let nn = 0, Pn = Ot.length; nn < Pn; nn++) {
          const xn = Lt(Ot[nn], vt[nn], yn);
          en(xn.x, xn.y, -$t);
        }
        for (let nn = 0, Pn = Mt.length; nn < Pn; nn++) {
          const xn = Mt[nn];
          Tt = Ct[nn];
          for (let An = 0, kt = xn.length; An < kt; An++) {
            const wt = Lt(xn[An], Tt[An], yn);
            en(wt.x, wt.y, -$t);
          }
        }
      }
      const Wt = st + at;
      for (let Bt = 0; Bt < Et; Bt++) {
        const qt = et ? Lt(St[Bt], Dt[Bt], Wt) : St[Bt];
        ut
          ? (gt.copy(pt.normals[0]).multiplyScalar(qt.x),
            ft.copy(pt.binormals[0]).multiplyScalar(qt.y),
            xt.copy(ot[0]).add(gt).add(ft),
            en(xt.x, xt.y, xt.z))
          : en(qt.x, qt.y, 0);
      }
      for (let Bt = 1; Bt <= $; Bt++)
        for (let qt = 0; qt < Et; qt++) {
          const $t = et ? Lt(St[qt], Dt[qt], Wt) : St[qt];
          ut
            ? (gt.copy(pt.normals[Bt]).multiplyScalar($t.x),
              ft.copy(pt.binormals[Bt]).multiplyScalar($t.y),
              xt.copy(ot[Bt]).add(gt).add(ft),
              en(xt.x, xt.y, xt.z))
            : en($t.x, $t.y, (_e / $) * Bt);
        }
      for (let Bt = ct - 1; Bt >= 0; Bt--) {
        const qt = Bt / ct,
          $t = rt * Math.cos((qt * Math.PI) / 2),
          yn = st * Math.sin((qt * Math.PI) / 2) + at;
        for (let nn = 0, Pn = Ot.length; nn < Pn; nn++) {
          const xn = Lt(Ot[nn], vt[nn], yn);
          en(xn.x, xn.y, _e + $t);
        }
        for (let nn = 0, Pn = Mt.length; nn < Pn; nn++) {
          const xn = Mt[nn];
          Tt = Ct[nn];
          for (let An = 0, kt = xn.length; An < kt; An++) {
            const wt = Lt(xn[An], Tt[An], yn);
            ut
              ? en(wt.x, wt.y + ot[$ - 1].y, ot[$ - 1].x + $t)
              : en(wt.x, wt.y, _e + $t);
          }
        }
      }
      Pt(), Jt();
      function Pt() {
        const Bt = c.length / 3;
        if (et) {
          let qt = 0,
            $t = Et * qt;
          for (let yn = 0; yn < bt; yn++) {
            const nn = Ft[yn];
            _n(nn[2] + $t, nn[1] + $t, nn[0] + $t);
          }
          (qt = $ + ct * 2), ($t = Et * qt);
          for (let yn = 0; yn < bt; yn++) {
            const nn = Ft[yn];
            _n(nn[0] + $t, nn[1] + $t, nn[2] + $t);
          }
        } else {
          for (let qt = 0; qt < bt; qt++) {
            const $t = Ft[qt];
            _n($t[2], $t[1], $t[0]);
          }
          for (let qt = 0; qt < bt; qt++) {
            const $t = Ft[qt];
            _n($t[0] + Et * $, $t[1] + Et * $, $t[2] + Et * $);
          }
        }
        a.addGroup(Bt, c.length / 3 - Bt, 0);
      }
      function Jt() {
        const Bt = c.length / 3;
        let qt = 0;
        Gt(Ot, qt), (qt += Ot.length);
        for (let $t = 0, yn = Mt.length; $t < yn; $t++) {
          const nn = Mt[$t];
          Gt(nn, qt), (qt += nn.length);
        }
        a.addGroup(Bt, c.length / 3 - Bt, 1);
      }
      function Gt(Bt, qt) {
        let $t = Bt.length;
        for (; --$t >= 0; ) {
          const yn = $t;
          let nn = $t - 1;
          nn < 0 && (nn = Bt.length - 1);
          for (let Pn = 0, xn = $ + ct * 2; Pn < xn; Pn++) {
            const An = Et * Pn,
              kt = Et * (Pn + 1),
              wt = qt + yn + An,
              Kt = qt + nn + An,
              on = qt + nn + kt,
              sn = qt + yn + kt;
            Tn(wt, Kt, on, sn);
          }
        }
      }
      function en(Bt, qt, $t) {
        b.push(Bt), b.push(qt), b.push($t);
      }
      function _n(Bt, qt, $t) {
        fn(Bt), fn(qt), fn($t);
        const yn = c.length / 3,
          nn = lt.generateTopUV(a, c, yn - 3, yn - 2, yn - 1);
        pn(nn[0]), pn(nn[1]), pn(nn[2]);
      }
      function Tn(Bt, qt, $t, yn) {
        fn(Bt), fn(qt), fn(yn), fn(qt), fn($t), fn(yn);
        const nn = c.length / 3,
          Pn = lt.generateSideWallUV(a, c, nn - 6, nn - 3, nn - 2, nn - 1);
        pn(Pn[0]), pn(Pn[1]), pn(Pn[3]), pn(Pn[1]), pn(Pn[2]), pn(Pn[3]);
      }
      function fn(Bt) {
        c.push(b[Bt * 3 + 0]), c.push(b[Bt * 3 + 1]), c.push(b[Bt * 3 + 2]);
      }
      function pn(Bt) {
        d.push(Bt.x), d.push(Bt.y);
      }
    }
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  toJSON() {
    const e = super.toJSON(),
      o = this.parameters.shapes,
      a = this.parameters.options;
    return toJSON$1(o, a, e);
  }
  static fromJSON(e, o) {
    const a = [];
    for (let d = 0, g = e.shapes.length; d < g; d++) {
      const _ = o[e.shapes[d]];
      a.push(_);
    }
    const c = e.options.extrudePath;
    return (
      c !== void 0 &&
        (e.options.extrudePath = new Curves[c.type]().fromJSON(c)),
      new ExtrudeGeometry(a, e.options)
    );
  }
}
const WorldUVGenerator = {
  generateTopUV: function (s, e, o, a, c) {
    const d = e[o * 3],
      g = e[o * 3 + 1],
      _ = e[a * 3],
      b = e[a * 3 + 1],
      j = e[c * 3],
      $ = e[c * 3 + 1];
    return [new Vector2(d, g), new Vector2(_, b), new Vector2(j, $)];
  },
  generateSideWallUV: function (s, e, o, a, c, d) {
    const g = e[o * 3],
      _ = e[o * 3 + 1],
      b = e[o * 3 + 2],
      j = e[a * 3],
      $ = e[a * 3 + 1],
      _e = e[a * 3 + 2],
      et = e[c * 3],
      rt = e[c * 3 + 1],
      st = e[c * 3 + 2],
      at = e[d * 3],
      ct = e[d * 3 + 1],
      it = e[d * 3 + 2];
    return Math.abs(_ - $) < Math.abs(g - j)
      ? [
          new Vector2(g, 1 - b),
          new Vector2(j, 1 - _e),
          new Vector2(et, 1 - st),
          new Vector2(at, 1 - it),
        ]
      : [
          new Vector2(_, 1 - b),
          new Vector2($, 1 - _e),
          new Vector2(rt, 1 - st),
          new Vector2(ct, 1 - it),
        ];
  },
};
function toJSON$1(s, e, o) {
  if (((o.shapes = []), Array.isArray(s)))
    for (let a = 0, c = s.length; a < c; a++) {
      const d = s[a];
      o.shapes.push(d.uuid);
    }
  else o.shapes.push(s.uuid);
  return (
    (o.options = Object.assign({}, e)),
    e.extrudePath !== void 0 &&
      (o.options.extrudePath = e.extrudePath.toJSON()),
    o
  );
}
class IcosahedronGeometry extends PolyhedronGeometry {
  constructor(e = 1, o = 0) {
    const a = (1 + Math.sqrt(5)) / 2,
      c = [
        -1,
        a,
        0,
        1,
        a,
        0,
        -1,
        -a,
        0,
        1,
        -a,
        0,
        0,
        -1,
        a,
        0,
        1,
        a,
        0,
        -1,
        -a,
        0,
        1,
        -a,
        a,
        0,
        -1,
        a,
        0,
        1,
        -a,
        0,
        -1,
        -a,
        0,
        1,
      ],
      d = [
        0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11,
        10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9,
        4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1,
      ];
    super(c, d, e, o),
      (this.type = "IcosahedronGeometry"),
      (this.parameters = { radius: e, detail: o });
  }
  static fromJSON(e) {
    return new IcosahedronGeometry(e.radius, e.detail);
  }
}
class OctahedronGeometry extends PolyhedronGeometry {
  constructor(e = 1, o = 0) {
    const a = [1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1],
      c = [
        0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2,
      ];
    super(a, c, e, o),
      (this.type = "OctahedronGeometry"),
      (this.parameters = { radius: e, detail: o });
  }
  static fromJSON(e) {
    return new OctahedronGeometry(e.radius, e.detail);
  }
}
class RingGeometry extends BufferGeometry {
  constructor(e = 0.5, o = 1, a = 32, c = 1, d = 0, g = Math.PI * 2) {
    super(),
      (this.type = "RingGeometry"),
      (this.parameters = {
        innerRadius: e,
        outerRadius: o,
        thetaSegments: a,
        phiSegments: c,
        thetaStart: d,
        thetaLength: g,
      }),
      (a = Math.max(3, a)),
      (c = Math.max(1, c));
    const _ = [],
      b = [],
      j = [],
      $ = [];
    let _e = e;
    const et = (o - e) / c,
      rt = new Vector3(),
      st = new Vector2();
    for (let at = 0; at <= c; at++) {
      for (let ct = 0; ct <= a; ct++) {
        const it = d + (ct / a) * g;
        (rt.x = _e * Math.cos(it)),
          (rt.y = _e * Math.sin(it)),
          b.push(rt.x, rt.y, rt.z),
          j.push(0, 0, 1),
          (st.x = (rt.x / o + 1) / 2),
          (st.y = (rt.y / o + 1) / 2),
          $.push(st.x, st.y);
      }
      _e += et;
    }
    for (let at = 0; at < c; at++) {
      const ct = at * (a + 1);
      for (let it = 0; it < a; it++) {
        const lt = it + ct,
          ot = lt,
          ut = lt + a + 1,
          pt = lt + a + 2,
          ft = lt + 1;
        _.push(ot, ut, ft), _.push(ut, pt, ft);
      }
    }
    this.setIndex(_),
      this.setAttribute("position", new Float32BufferAttribute(b, 3)),
      this.setAttribute("normal", new Float32BufferAttribute(j, 3)),
      this.setAttribute("uv", new Float32BufferAttribute($, 2));
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  static fromJSON(e) {
    return new RingGeometry(
      e.innerRadius,
      e.outerRadius,
      e.thetaSegments,
      e.phiSegments,
      e.thetaStart,
      e.thetaLength
    );
  }
}
class ShapeGeometry extends BufferGeometry {
  constructor(
    e = new Shape([
      new Vector2(0, 0.5),
      new Vector2(-0.5, -0.5),
      new Vector2(0.5, -0.5),
    ]),
    o = 12
  ) {
    super(),
      (this.type = "ShapeGeometry"),
      (this.parameters = { shapes: e, curveSegments: o });
    const a = [],
      c = [],
      d = [],
      g = [];
    let _ = 0,
      b = 0;
    if (Array.isArray(e) === !1) j(e);
    else
      for (let $ = 0; $ < e.length; $++)
        j(e[$]), this.addGroup(_, b, $), (_ += b), (b = 0);
    this.setIndex(a),
      this.setAttribute("position", new Float32BufferAttribute(c, 3)),
      this.setAttribute("normal", new Float32BufferAttribute(d, 3)),
      this.setAttribute("uv", new Float32BufferAttribute(g, 2));
    function j($) {
      const _e = c.length / 3,
        et = $.extractPoints(o);
      let rt = et.shape;
      const st = et.holes;
      ShapeUtils.isClockWise(rt) === !1 && (rt = rt.reverse());
      for (let ct = 0, it = st.length; ct < it; ct++) {
        const lt = st[ct];
        ShapeUtils.isClockWise(lt) === !0 && (st[ct] = lt.reverse());
      }
      const at = ShapeUtils.triangulateShape(rt, st);
      for (let ct = 0, it = st.length; ct < it; ct++) {
        const lt = st[ct];
        rt = rt.concat(lt);
      }
      for (let ct = 0, it = rt.length; ct < it; ct++) {
        const lt = rt[ct];
        c.push(lt.x, lt.y, 0), d.push(0, 0, 1), g.push(lt.x, lt.y);
      }
      for (let ct = 0, it = at.length; ct < it; ct++) {
        const lt = at[ct],
          ot = lt[0] + _e,
          ut = lt[1] + _e,
          pt = lt[2] + _e;
        a.push(ot, ut, pt), (b += 3);
      }
    }
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  toJSON() {
    const e = super.toJSON(),
      o = this.parameters.shapes;
    return toJSON(o, e);
  }
  static fromJSON(e, o) {
    const a = [];
    for (let c = 0, d = e.shapes.length; c < d; c++) {
      const g = o[e.shapes[c]];
      a.push(g);
    }
    return new ShapeGeometry(a, e.curveSegments);
  }
}
function toJSON(s, e) {
  if (((e.shapes = []), Array.isArray(s)))
    for (let o = 0, a = s.length; o < a; o++) {
      const c = s[o];
      e.shapes.push(c.uuid);
    }
  else e.shapes.push(s.uuid);
  return e;
}
class SphereGeometry extends BufferGeometry {
  constructor(
    e = 1,
    o = 32,
    a = 16,
    c = 0,
    d = Math.PI * 2,
    g = 0,
    _ = Math.PI
  ) {
    super(),
      (this.type = "SphereGeometry"),
      (this.parameters = {
        radius: e,
        widthSegments: o,
        heightSegments: a,
        phiStart: c,
        phiLength: d,
        thetaStart: g,
        thetaLength: _,
      }),
      (o = Math.max(3, Math.floor(o))),
      (a = Math.max(2, Math.floor(a)));
    const b = Math.min(g + _, Math.PI);
    let j = 0;
    const $ = [],
      _e = new Vector3(),
      et = new Vector3(),
      rt = [],
      st = [],
      at = [],
      ct = [];
    for (let it = 0; it <= a; it++) {
      const lt = [],
        ot = it / a;
      let ut = 0;
      it === 0 && g === 0
        ? (ut = 0.5 / o)
        : it === a && b === Math.PI && (ut = -0.5 / o);
      for (let pt = 0; pt <= o; pt++) {
        const ft = pt / o;
        (_e.x = -e * Math.cos(c + ft * d) * Math.sin(g + ot * _)),
          (_e.y = e * Math.cos(g + ot * _)),
          (_e.z = e * Math.sin(c + ft * d) * Math.sin(g + ot * _)),
          st.push(_e.x, _e.y, _e.z),
          et.copy(_e).normalize(),
          at.push(et.x, et.y, et.z),
          ct.push(ft + ut, 1 - ot),
          lt.push(j++);
      }
      $.push(lt);
    }
    for (let it = 0; it < a; it++)
      for (let lt = 0; lt < o; lt++) {
        const ot = $[it][lt + 1],
          ut = $[it][lt],
          pt = $[it + 1][lt],
          ft = $[it + 1][lt + 1];
        (it !== 0 || g > 0) && rt.push(ot, ut, ft),
          (it !== a - 1 || b < Math.PI) && rt.push(ut, pt, ft);
      }
    this.setIndex(rt),
      this.setAttribute("position", new Float32BufferAttribute(st, 3)),
      this.setAttribute("normal", new Float32BufferAttribute(at, 3)),
      this.setAttribute("uv", new Float32BufferAttribute(ct, 2));
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  static fromJSON(e) {
    return new SphereGeometry(
      e.radius,
      e.widthSegments,
      e.heightSegments,
      e.phiStart,
      e.phiLength,
      e.thetaStart,
      e.thetaLength
    );
  }
}
class TetrahedronGeometry extends PolyhedronGeometry {
  constructor(e = 1, o = 0) {
    const a = [1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1],
      c = [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1];
    super(a, c, e, o),
      (this.type = "TetrahedronGeometry"),
      (this.parameters = { radius: e, detail: o });
  }
  static fromJSON(e) {
    return new TetrahedronGeometry(e.radius, e.detail);
  }
}
class TorusGeometry extends BufferGeometry {
  constructor(e = 1, o = 0.4, a = 12, c = 48, d = Math.PI * 2) {
    super(),
      (this.type = "TorusGeometry"),
      (this.parameters = {
        radius: e,
        tube: o,
        radialSegments: a,
        tubularSegments: c,
        arc: d,
      }),
      (a = Math.floor(a)),
      (c = Math.floor(c));
    const g = [],
      _ = [],
      b = [],
      j = [],
      $ = new Vector3(),
      _e = new Vector3(),
      et = new Vector3();
    for (let rt = 0; rt <= a; rt++)
      for (let st = 0; st <= c; st++) {
        const at = (st / c) * d,
          ct = (rt / a) * Math.PI * 2;
        (_e.x = (e + o * Math.cos(ct)) * Math.cos(at)),
          (_e.y = (e + o * Math.cos(ct)) * Math.sin(at)),
          (_e.z = o * Math.sin(ct)),
          _.push(_e.x, _e.y, _e.z),
          ($.x = e * Math.cos(at)),
          ($.y = e * Math.sin(at)),
          et.subVectors(_e, $).normalize(),
          b.push(et.x, et.y, et.z),
          j.push(st / c),
          j.push(rt / a);
      }
    for (let rt = 1; rt <= a; rt++)
      for (let st = 1; st <= c; st++) {
        const at = (c + 1) * rt + st - 1,
          ct = (c + 1) * (rt - 1) + st - 1,
          it = (c + 1) * (rt - 1) + st,
          lt = (c + 1) * rt + st;
        g.push(at, ct, lt), g.push(ct, it, lt);
      }
    this.setIndex(g),
      this.setAttribute("position", new Float32BufferAttribute(_, 3)),
      this.setAttribute("normal", new Float32BufferAttribute(b, 3)),
      this.setAttribute("uv", new Float32BufferAttribute(j, 2));
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  static fromJSON(e) {
    return new TorusGeometry(
      e.radius,
      e.tube,
      e.radialSegments,
      e.tubularSegments,
      e.arc
    );
  }
}
class TorusKnotGeometry extends BufferGeometry {
  constructor(e = 1, o = 0.4, a = 64, c = 8, d = 2, g = 3) {
    super(),
      (this.type = "TorusKnotGeometry"),
      (this.parameters = {
        radius: e,
        tube: o,
        tubularSegments: a,
        radialSegments: c,
        p: d,
        q: g,
      }),
      (a = Math.floor(a)),
      (c = Math.floor(c));
    const _ = [],
      b = [],
      j = [],
      $ = [],
      _e = new Vector3(),
      et = new Vector3(),
      rt = new Vector3(),
      st = new Vector3(),
      at = new Vector3(),
      ct = new Vector3(),
      it = new Vector3();
    for (let ot = 0; ot <= a; ++ot) {
      const ut = (ot / a) * d * Math.PI * 2;
      lt(ut, d, g, e, rt),
        lt(ut + 0.01, d, g, e, st),
        ct.subVectors(st, rt),
        it.addVectors(st, rt),
        at.crossVectors(ct, it),
        it.crossVectors(at, ct),
        at.normalize(),
        it.normalize();
      for (let pt = 0; pt <= c; ++pt) {
        const ft = (pt / c) * Math.PI * 2,
          gt = -o * Math.cos(ft),
          xt = o * Math.sin(ft);
        (_e.x = rt.x + (gt * it.x + xt * at.x)),
          (_e.y = rt.y + (gt * it.y + xt * at.y)),
          (_e.z = rt.z + (gt * it.z + xt * at.z)),
          b.push(_e.x, _e.y, _e.z),
          et.subVectors(_e, rt).normalize(),
          j.push(et.x, et.y, et.z),
          $.push(ot / a),
          $.push(pt / c);
      }
    }
    for (let ot = 1; ot <= a; ot++)
      for (let ut = 1; ut <= c; ut++) {
        const pt = (c + 1) * (ot - 1) + (ut - 1),
          ft = (c + 1) * ot + (ut - 1),
          gt = (c + 1) * ot + ut,
          xt = (c + 1) * (ot - 1) + ut;
        _.push(pt, ft, xt), _.push(ft, gt, xt);
      }
    this.setIndex(_),
      this.setAttribute("position", new Float32BufferAttribute(b, 3)),
      this.setAttribute("normal", new Float32BufferAttribute(j, 3)),
      this.setAttribute("uv", new Float32BufferAttribute($, 2));
    function lt(ot, ut, pt, ft, gt) {
      const xt = Math.cos(ot),
        _t = Math.sin(ot),
        St = (pt / ut) * ot,
        Mt = Math.cos(St);
      (gt.x = ft * (2 + Mt) * 0.5 * xt),
        (gt.y = ft * (2 + Mt) * _t * 0.5),
        (gt.z = ft * Math.sin(St) * 0.5);
    }
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  static fromJSON(e) {
    return new TorusKnotGeometry(
      e.radius,
      e.tube,
      e.tubularSegments,
      e.radialSegments,
      e.p,
      e.q
    );
  }
}
class TubeGeometry extends BufferGeometry {
  constructor(
    e = new QuadraticBezierCurve3(
      new Vector3(-1, -1, 0),
      new Vector3(-1, 1, 0),
      new Vector3(1, 1, 0)
    ),
    o = 64,
    a = 1,
    c = 8,
    d = !1
  ) {
    super(),
      (this.type = "TubeGeometry"),
      (this.parameters = {
        path: e,
        tubularSegments: o,
        radius: a,
        radialSegments: c,
        closed: d,
      });
    const g = e.computeFrenetFrames(o, d);
    (this.tangents = g.tangents),
      (this.normals = g.normals),
      (this.binormals = g.binormals);
    const _ = new Vector3(),
      b = new Vector3(),
      j = new Vector2();
    let $ = new Vector3();
    const _e = [],
      et = [],
      rt = [],
      st = [];
    at(),
      this.setIndex(st),
      this.setAttribute("position", new Float32BufferAttribute(_e, 3)),
      this.setAttribute("normal", new Float32BufferAttribute(et, 3)),
      this.setAttribute("uv", new Float32BufferAttribute(rt, 2));
    function at() {
      for (let ot = 0; ot < o; ot++) ct(ot);
      ct(d === !1 ? o : 0), lt(), it();
    }
    function ct(ot) {
      $ = e.getPointAt(ot / o, $);
      const ut = g.normals[ot],
        pt = g.binormals[ot];
      for (let ft = 0; ft <= c; ft++) {
        const gt = (ft / c) * Math.PI * 2,
          xt = Math.sin(gt),
          _t = -Math.cos(gt);
        (b.x = _t * ut.x + xt * pt.x),
          (b.y = _t * ut.y + xt * pt.y),
          (b.z = _t * ut.z + xt * pt.z),
          b.normalize(),
          et.push(b.x, b.y, b.z),
          (_.x = $.x + a * b.x),
          (_.y = $.y + a * b.y),
          (_.z = $.z + a * b.z),
          _e.push(_.x, _.y, _.z);
      }
    }
    function it() {
      for (let ot = 1; ot <= o; ot++)
        for (let ut = 1; ut <= c; ut++) {
          const pt = (c + 1) * (ot - 1) + (ut - 1),
            ft = (c + 1) * ot + (ut - 1),
            gt = (c + 1) * ot + ut,
            xt = (c + 1) * (ot - 1) + ut;
          st.push(pt, ft, xt), st.push(ft, gt, xt);
        }
    }
    function lt() {
      for (let ot = 0; ot <= o; ot++)
        for (let ut = 0; ut <= c; ut++)
          (j.x = ot / o), (j.y = ut / c), rt.push(j.x, j.y);
    }
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  toJSON() {
    const e = super.toJSON();
    return (e.path = this.parameters.path.toJSON()), e;
  }
  static fromJSON(e) {
    return new TubeGeometry(
      new Curves[e.path.type]().fromJSON(e.path),
      e.tubularSegments,
      e.radius,
      e.radialSegments,
      e.closed
    );
  }
}
class WireframeGeometry extends BufferGeometry {
  constructor(e = null) {
    if (
      (super(),
      (this.type = "WireframeGeometry"),
      (this.parameters = { geometry: e }),
      e !== null)
    ) {
      const o = [],
        a = new Set(),
        c = new Vector3(),
        d = new Vector3();
      if (e.index !== null) {
        const g = e.attributes.position,
          _ = e.index;
        let b = e.groups;
        b.length === 0 &&
          (b = [{ start: 0, count: _.count, materialIndex: 0 }]);
        for (let j = 0, $ = b.length; j < $; ++j) {
          const _e = b[j],
            et = _e.start,
            rt = _e.count;
          for (let st = et, at = et + rt; st < at; st += 3)
            for (let ct = 0; ct < 3; ct++) {
              const it = _.getX(st + ct),
                lt = _.getX(st + ((ct + 1) % 3));
              c.fromBufferAttribute(g, it),
                d.fromBufferAttribute(g, lt),
                isUniqueEdge(c, d, a) === !0 &&
                  (o.push(c.x, c.y, c.z), o.push(d.x, d.y, d.z));
            }
        }
      } else {
        const g = e.attributes.position;
        for (let _ = 0, b = g.count / 3; _ < b; _++)
          for (let j = 0; j < 3; j++) {
            const $ = 3 * _ + j,
              _e = 3 * _ + ((j + 1) % 3);
            c.fromBufferAttribute(g, $),
              d.fromBufferAttribute(g, _e),
              isUniqueEdge(c, d, a) === !0 &&
                (o.push(c.x, c.y, c.z), o.push(d.x, d.y, d.z));
          }
      }
      this.setAttribute("position", new Float32BufferAttribute(o, 3));
    }
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
}
function isUniqueEdge(s, e, o) {
  const a = `${s.x},${s.y},${s.z}-${e.x},${e.y},${e.z}`,
    c = `${e.x},${e.y},${e.z}-${s.x},${s.y},${s.z}`;
  return o.has(a) === !0 || o.has(c) === !0 ? !1 : (o.add(a), o.add(c), !0);
}
var Geometries = Object.freeze({
  __proto__: null,
  BoxGeometry,
  CapsuleGeometry,
  CircleGeometry,
  ConeGeometry,
  CylinderGeometry,
  DodecahedronGeometry,
  EdgesGeometry,
  ExtrudeGeometry,
  IcosahedronGeometry,
  LatheGeometry,
  OctahedronGeometry,
  PlaneGeometry,
  PolyhedronGeometry,
  RingGeometry,
  ShapeGeometry,
  SphereGeometry,
  TetrahedronGeometry,
  TorusGeometry,
  TorusKnotGeometry,
  TubeGeometry,
  WireframeGeometry,
});
class ShadowMaterial extends Material {
  constructor(e) {
    super(),
      (this.isShadowMaterial = !0),
      (this.type = "ShadowMaterial"),
      (this.color = new Color(0)),
      (this.transparent = !0),
      (this.fog = !0),
      this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), (this.fog = e.fog), this;
  }
}
class RawShaderMaterial extends ShaderMaterial {
  constructor(e) {
    super(e),
      (this.isRawShaderMaterial = !0),
      (this.type = "RawShaderMaterial");
  }
}
class MeshStandardMaterial extends Material {
  constructor(e) {
    super(),
      (this.isMeshStandardMaterial = !0),
      (this.defines = { STANDARD: "" }),
      (this.type = "MeshStandardMaterial"),
      (this.color = new Color(16777215)),
      (this.roughness = 1),
      (this.metalness = 0),
      (this.map = null),
      (this.lightMap = null),
      (this.lightMapIntensity = 1),
      (this.aoMap = null),
      (this.aoMapIntensity = 1),
      (this.emissive = new Color(0)),
      (this.emissiveIntensity = 1),
      (this.emissiveMap = null),
      (this.bumpMap = null),
      (this.bumpScale = 1),
      (this.normalMap = null),
      (this.normalMapType = TangentSpaceNormalMap),
      (this.normalScale = new Vector2(1, 1)),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.roughnessMap = null),
      (this.metalnessMap = null),
      (this.alphaMap = null),
      (this.envMap = null),
      (this.envMapRotation = new Euler()),
      (this.envMapIntensity = 1),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.wireframeLinecap = "round"),
      (this.wireframeLinejoin = "round"),
      (this.flatShading = !1),
      (this.fog = !0),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      (this.defines = { STANDARD: "" }),
      this.color.copy(e.color),
      (this.roughness = e.roughness),
      (this.metalness = e.metalness),
      (this.map = e.map),
      (this.lightMap = e.lightMap),
      (this.lightMapIntensity = e.lightMapIntensity),
      (this.aoMap = e.aoMap),
      (this.aoMapIntensity = e.aoMapIntensity),
      this.emissive.copy(e.emissive),
      (this.emissiveMap = e.emissiveMap),
      (this.emissiveIntensity = e.emissiveIntensity),
      (this.bumpMap = e.bumpMap),
      (this.bumpScale = e.bumpScale),
      (this.normalMap = e.normalMap),
      (this.normalMapType = e.normalMapType),
      this.normalScale.copy(e.normalScale),
      (this.displacementMap = e.displacementMap),
      (this.displacementScale = e.displacementScale),
      (this.displacementBias = e.displacementBias),
      (this.roughnessMap = e.roughnessMap),
      (this.metalnessMap = e.metalnessMap),
      (this.alphaMap = e.alphaMap),
      (this.envMap = e.envMap),
      this.envMapRotation.copy(e.envMapRotation),
      (this.envMapIntensity = e.envMapIntensity),
      (this.wireframe = e.wireframe),
      (this.wireframeLinewidth = e.wireframeLinewidth),
      (this.wireframeLinecap = e.wireframeLinecap),
      (this.wireframeLinejoin = e.wireframeLinejoin),
      (this.flatShading = e.flatShading),
      (this.fog = e.fog),
      this
    );
  }
}
class MeshPhysicalMaterial extends MeshStandardMaterial {
  constructor(e) {
    super(),
      (this.isMeshPhysicalMaterial = !0),
      (this.defines = { STANDARD: "", PHYSICAL: "" }),
      (this.type = "MeshPhysicalMaterial"),
      (this.anisotropyRotation = 0),
      (this.anisotropyMap = null),
      (this.clearcoatMap = null),
      (this.clearcoatRoughness = 0),
      (this.clearcoatRoughnessMap = null),
      (this.clearcoatNormalScale = new Vector2(1, 1)),
      (this.clearcoatNormalMap = null),
      (this.ior = 1.5),
      Object.defineProperty(this, "reflectivity", {
        get: function () {
          return clamp((2.5 * (this.ior - 1)) / (this.ior + 1), 0, 1);
        },
        set: function (o) {
          this.ior = (1 + 0.4 * o) / (1 - 0.4 * o);
        },
      }),
      (this.iridescenceMap = null),
      (this.iridescenceIOR = 1.3),
      (this.iridescenceThicknessRange = [100, 400]),
      (this.iridescenceThicknessMap = null),
      (this.sheenColor = new Color(0)),
      (this.sheenColorMap = null),
      (this.sheenRoughness = 1),
      (this.sheenRoughnessMap = null),
      (this.transmissionMap = null),
      (this.thickness = 0),
      (this.thicknessMap = null),
      (this.attenuationDistance = 1 / 0),
      (this.attenuationColor = new Color(1, 1, 1)),
      (this.specularIntensity = 1),
      (this.specularIntensityMap = null),
      (this.specularColor = new Color(1, 1, 1)),
      (this.specularColorMap = null),
      (this._anisotropy = 0),
      (this._clearcoat = 0),
      (this._dispersion = 0),
      (this._iridescence = 0),
      (this._sheen = 0),
      (this._transmission = 0),
      this.setValues(e);
  }
  get anisotropy() {
    return this._anisotropy;
  }
  set anisotropy(e) {
    this._anisotropy > 0 != e > 0 && this.version++, (this._anisotropy = e);
  }
  get clearcoat() {
    return this._clearcoat;
  }
  set clearcoat(e) {
    this._clearcoat > 0 != e > 0 && this.version++, (this._clearcoat = e);
  }
  get iridescence() {
    return this._iridescence;
  }
  set iridescence(e) {
    this._iridescence > 0 != e > 0 && this.version++, (this._iridescence = e);
  }
  get dispersion() {
    return this._dispersion;
  }
  set dispersion(e) {
    this._dispersion > 0 != e > 0 && this.version++, (this._dispersion = e);
  }
  get sheen() {
    return this._sheen;
  }
  set sheen(e) {
    this._sheen > 0 != e > 0 && this.version++, (this._sheen = e);
  }
  get transmission() {
    return this._transmission;
  }
  set transmission(e) {
    this._transmission > 0 != e > 0 && this.version++, (this._transmission = e);
  }
  copy(e) {
    return (
      super.copy(e),
      (this.defines = { STANDARD: "", PHYSICAL: "" }),
      (this.anisotropy = e.anisotropy),
      (this.anisotropyRotation = e.anisotropyRotation),
      (this.anisotropyMap = e.anisotropyMap),
      (this.clearcoat = e.clearcoat),
      (this.clearcoatMap = e.clearcoatMap),
      (this.clearcoatRoughness = e.clearcoatRoughness),
      (this.clearcoatRoughnessMap = e.clearcoatRoughnessMap),
      (this.clearcoatNormalMap = e.clearcoatNormalMap),
      this.clearcoatNormalScale.copy(e.clearcoatNormalScale),
      (this.dispersion = e.dispersion),
      (this.ior = e.ior),
      (this.iridescence = e.iridescence),
      (this.iridescenceMap = e.iridescenceMap),
      (this.iridescenceIOR = e.iridescenceIOR),
      (this.iridescenceThicknessRange = [...e.iridescenceThicknessRange]),
      (this.iridescenceThicknessMap = e.iridescenceThicknessMap),
      (this.sheen = e.sheen),
      this.sheenColor.copy(e.sheenColor),
      (this.sheenColorMap = e.sheenColorMap),
      (this.sheenRoughness = e.sheenRoughness),
      (this.sheenRoughnessMap = e.sheenRoughnessMap),
      (this.transmission = e.transmission),
      (this.transmissionMap = e.transmissionMap),
      (this.thickness = e.thickness),
      (this.thicknessMap = e.thicknessMap),
      (this.attenuationDistance = e.attenuationDistance),
      this.attenuationColor.copy(e.attenuationColor),
      (this.specularIntensity = e.specularIntensity),
      (this.specularIntensityMap = e.specularIntensityMap),
      this.specularColor.copy(e.specularColor),
      (this.specularColorMap = e.specularColorMap),
      this
    );
  }
}
class MeshPhongMaterial extends Material {
  constructor(e) {
    super(),
      (this.isMeshPhongMaterial = !0),
      (this.type = "MeshPhongMaterial"),
      (this.color = new Color(16777215)),
      (this.specular = new Color(1118481)),
      (this.shininess = 30),
      (this.map = null),
      (this.lightMap = null),
      (this.lightMapIntensity = 1),
      (this.aoMap = null),
      (this.aoMapIntensity = 1),
      (this.emissive = new Color(0)),
      (this.emissiveIntensity = 1),
      (this.emissiveMap = null),
      (this.bumpMap = null),
      (this.bumpScale = 1),
      (this.normalMap = null),
      (this.normalMapType = TangentSpaceNormalMap),
      (this.normalScale = new Vector2(1, 1)),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.specularMap = null),
      (this.alphaMap = null),
      (this.envMap = null),
      (this.envMapRotation = new Euler()),
      (this.combine = MultiplyOperation),
      (this.reflectivity = 1),
      (this.refractionRatio = 0.98),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.wireframeLinecap = "round"),
      (this.wireframeLinejoin = "round"),
      (this.flatShading = !1),
      (this.fog = !0),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      this.color.copy(e.color),
      this.specular.copy(e.specular),
      (this.shininess = e.shininess),
      (this.map = e.map),
      (this.lightMap = e.lightMap),
      (this.lightMapIntensity = e.lightMapIntensity),
      (this.aoMap = e.aoMap),
      (this.aoMapIntensity = e.aoMapIntensity),
      this.emissive.copy(e.emissive),
      (this.emissiveMap = e.emissiveMap),
      (this.emissiveIntensity = e.emissiveIntensity),
      (this.bumpMap = e.bumpMap),
      (this.bumpScale = e.bumpScale),
      (this.normalMap = e.normalMap),
      (this.normalMapType = e.normalMapType),
      this.normalScale.copy(e.normalScale),
      (this.displacementMap = e.displacementMap),
      (this.displacementScale = e.displacementScale),
      (this.displacementBias = e.displacementBias),
      (this.specularMap = e.specularMap),
      (this.alphaMap = e.alphaMap),
      (this.envMap = e.envMap),
      this.envMapRotation.copy(e.envMapRotation),
      (this.combine = e.combine),
      (this.reflectivity = e.reflectivity),
      (this.refractionRatio = e.refractionRatio),
      (this.wireframe = e.wireframe),
      (this.wireframeLinewidth = e.wireframeLinewidth),
      (this.wireframeLinecap = e.wireframeLinecap),
      (this.wireframeLinejoin = e.wireframeLinejoin),
      (this.flatShading = e.flatShading),
      (this.fog = e.fog),
      this
    );
  }
}
class MeshToonMaterial extends Material {
  constructor(e) {
    super(),
      (this.isMeshToonMaterial = !0),
      (this.defines = { TOON: "" }),
      (this.type = "MeshToonMaterial"),
      (this.color = new Color(16777215)),
      (this.map = null),
      (this.gradientMap = null),
      (this.lightMap = null),
      (this.lightMapIntensity = 1),
      (this.aoMap = null),
      (this.aoMapIntensity = 1),
      (this.emissive = new Color(0)),
      (this.emissiveIntensity = 1),
      (this.emissiveMap = null),
      (this.bumpMap = null),
      (this.bumpScale = 1),
      (this.normalMap = null),
      (this.normalMapType = TangentSpaceNormalMap),
      (this.normalScale = new Vector2(1, 1)),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.alphaMap = null),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.wireframeLinecap = "round"),
      (this.wireframeLinejoin = "round"),
      (this.fog = !0),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      this.color.copy(e.color),
      (this.map = e.map),
      (this.gradientMap = e.gradientMap),
      (this.lightMap = e.lightMap),
      (this.lightMapIntensity = e.lightMapIntensity),
      (this.aoMap = e.aoMap),
      (this.aoMapIntensity = e.aoMapIntensity),
      this.emissive.copy(e.emissive),
      (this.emissiveMap = e.emissiveMap),
      (this.emissiveIntensity = e.emissiveIntensity),
      (this.bumpMap = e.bumpMap),
      (this.bumpScale = e.bumpScale),
      (this.normalMap = e.normalMap),
      (this.normalMapType = e.normalMapType),
      this.normalScale.copy(e.normalScale),
      (this.displacementMap = e.displacementMap),
      (this.displacementScale = e.displacementScale),
      (this.displacementBias = e.displacementBias),
      (this.alphaMap = e.alphaMap),
      (this.wireframe = e.wireframe),
      (this.wireframeLinewidth = e.wireframeLinewidth),
      (this.wireframeLinecap = e.wireframeLinecap),
      (this.wireframeLinejoin = e.wireframeLinejoin),
      (this.fog = e.fog),
      this
    );
  }
}
class MeshNormalMaterial extends Material {
  constructor(e) {
    super(),
      (this.isMeshNormalMaterial = !0),
      (this.type = "MeshNormalMaterial"),
      (this.bumpMap = null),
      (this.bumpScale = 1),
      (this.normalMap = null),
      (this.normalMapType = TangentSpaceNormalMap),
      (this.normalScale = new Vector2(1, 1)),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.flatShading = !1),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      (this.bumpMap = e.bumpMap),
      (this.bumpScale = e.bumpScale),
      (this.normalMap = e.normalMap),
      (this.normalMapType = e.normalMapType),
      this.normalScale.copy(e.normalScale),
      (this.displacementMap = e.displacementMap),
      (this.displacementScale = e.displacementScale),
      (this.displacementBias = e.displacementBias),
      (this.wireframe = e.wireframe),
      (this.wireframeLinewidth = e.wireframeLinewidth),
      (this.flatShading = e.flatShading),
      this
    );
  }
}
class MeshLambertMaterial extends Material {
  constructor(e) {
    super(),
      (this.isMeshLambertMaterial = !0),
      (this.type = "MeshLambertMaterial"),
      (this.color = new Color(16777215)),
      (this.map = null),
      (this.lightMap = null),
      (this.lightMapIntensity = 1),
      (this.aoMap = null),
      (this.aoMapIntensity = 1),
      (this.emissive = new Color(0)),
      (this.emissiveIntensity = 1),
      (this.emissiveMap = null),
      (this.bumpMap = null),
      (this.bumpScale = 1),
      (this.normalMap = null),
      (this.normalMapType = TangentSpaceNormalMap),
      (this.normalScale = new Vector2(1, 1)),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.specularMap = null),
      (this.alphaMap = null),
      (this.envMap = null),
      (this.envMapRotation = new Euler()),
      (this.combine = MultiplyOperation),
      (this.reflectivity = 1),
      (this.refractionRatio = 0.98),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.wireframeLinecap = "round"),
      (this.wireframeLinejoin = "round"),
      (this.flatShading = !1),
      (this.fog = !0),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      this.color.copy(e.color),
      (this.map = e.map),
      (this.lightMap = e.lightMap),
      (this.lightMapIntensity = e.lightMapIntensity),
      (this.aoMap = e.aoMap),
      (this.aoMapIntensity = e.aoMapIntensity),
      this.emissive.copy(e.emissive),
      (this.emissiveMap = e.emissiveMap),
      (this.emissiveIntensity = e.emissiveIntensity),
      (this.bumpMap = e.bumpMap),
      (this.bumpScale = e.bumpScale),
      (this.normalMap = e.normalMap),
      (this.normalMapType = e.normalMapType),
      this.normalScale.copy(e.normalScale),
      (this.displacementMap = e.displacementMap),
      (this.displacementScale = e.displacementScale),
      (this.displacementBias = e.displacementBias),
      (this.specularMap = e.specularMap),
      (this.alphaMap = e.alphaMap),
      (this.envMap = e.envMap),
      this.envMapRotation.copy(e.envMapRotation),
      (this.combine = e.combine),
      (this.reflectivity = e.reflectivity),
      (this.refractionRatio = e.refractionRatio),
      (this.wireframe = e.wireframe),
      (this.wireframeLinewidth = e.wireframeLinewidth),
      (this.wireframeLinecap = e.wireframeLinecap),
      (this.wireframeLinejoin = e.wireframeLinejoin),
      (this.flatShading = e.flatShading),
      (this.fog = e.fog),
      this
    );
  }
}
class MeshMatcapMaterial extends Material {
  constructor(e) {
    super(),
      (this.isMeshMatcapMaterial = !0),
      (this.defines = { MATCAP: "" }),
      (this.type = "MeshMatcapMaterial"),
      (this.color = new Color(16777215)),
      (this.matcap = null),
      (this.map = null),
      (this.bumpMap = null),
      (this.bumpScale = 1),
      (this.normalMap = null),
      (this.normalMapType = TangentSpaceNormalMap),
      (this.normalScale = new Vector2(1, 1)),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.alphaMap = null),
      (this.flatShading = !1),
      (this.fog = !0),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      (this.defines = { MATCAP: "" }),
      this.color.copy(e.color),
      (this.matcap = e.matcap),
      (this.map = e.map),
      (this.bumpMap = e.bumpMap),
      (this.bumpScale = e.bumpScale),
      (this.normalMap = e.normalMap),
      (this.normalMapType = e.normalMapType),
      this.normalScale.copy(e.normalScale),
      (this.displacementMap = e.displacementMap),
      (this.displacementScale = e.displacementScale),
      (this.displacementBias = e.displacementBias),
      (this.alphaMap = e.alphaMap),
      (this.flatShading = e.flatShading),
      (this.fog = e.fog),
      this
    );
  }
}
class LineDashedMaterial extends LineBasicMaterial {
  constructor(e) {
    super(),
      (this.isLineDashedMaterial = !0),
      (this.type = "LineDashedMaterial"),
      (this.scale = 1),
      (this.dashSize = 3),
      (this.gapSize = 1),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      (this.scale = e.scale),
      (this.dashSize = e.dashSize),
      (this.gapSize = e.gapSize),
      this
    );
  }
}
function convertArray(s, e, o) {
  return !s || (!o && s.constructor === e)
    ? s
    : typeof e.BYTES_PER_ELEMENT == "number"
    ? new e(s)
    : Array.prototype.slice.call(s);
}
function isTypedArray(s) {
  return ArrayBuffer.isView(s) && !(s instanceof DataView);
}
function getKeyframeOrder(s) {
  function e(c, d) {
    return s[c] - s[d];
  }
  const o = s.length,
    a = new Array(o);
  for (let c = 0; c !== o; ++c) a[c] = c;
  return a.sort(e), a;
}
function sortedArray(s, e, o) {
  const a = s.length,
    c = new s.constructor(a);
  for (let d = 0, g = 0; g !== a; ++d) {
    const _ = o[d] * e;
    for (let b = 0; b !== e; ++b) c[g++] = s[_ + b];
  }
  return c;
}
function flattenJSON(s, e, o, a) {
  let c = 1,
    d = s[0];
  for (; d !== void 0 && d[a] === void 0; ) d = s[c++];
  if (d === void 0) return;
  let g = d[a];
  if (g !== void 0)
    if (Array.isArray(g))
      do
        (g = d[a]),
          g !== void 0 && (e.push(d.time), o.push.apply(o, g)),
          (d = s[c++]);
      while (d !== void 0);
    else if (g.toArray !== void 0)
      do
        (g = d[a]),
          g !== void 0 && (e.push(d.time), g.toArray(o, o.length)),
          (d = s[c++]);
      while (d !== void 0);
    else
      do (g = d[a]), g !== void 0 && (e.push(d.time), o.push(g)), (d = s[c++]);
      while (d !== void 0);
}
function subclip(s, e, o, a, c = 30) {
  const d = s.clone();
  d.name = e;
  const g = [];
  for (let b = 0; b < d.tracks.length; ++b) {
    const j = d.tracks[b],
      $ = j.getValueSize(),
      _e = [],
      et = [];
    for (let rt = 0; rt < j.times.length; ++rt) {
      const st = j.times[rt] * c;
      if (!(st < o || st >= a)) {
        _e.push(j.times[rt]);
        for (let at = 0; at < $; ++at) et.push(j.values[rt * $ + at]);
      }
    }
    _e.length !== 0 &&
      ((j.times = convertArray(_e, j.times.constructor)),
      (j.values = convertArray(et, j.values.constructor)),
      g.push(j));
  }
  d.tracks = g;
  let _ = 1 / 0;
  for (let b = 0; b < d.tracks.length; ++b)
    _ > d.tracks[b].times[0] && (_ = d.tracks[b].times[0]);
  for (let b = 0; b < d.tracks.length; ++b) d.tracks[b].shift(-1 * _);
  return d.resetDuration(), d;
}
function makeClipAdditive(s, e = 0, o = s, a = 30) {
  a <= 0 && (a = 30);
  const c = o.tracks.length,
    d = e / a;
  for (let g = 0; g < c; ++g) {
    const _ = o.tracks[g],
      b = _.ValueTypeName;
    if (b === "bool" || b === "string") continue;
    const j = s.tracks.find(function (it) {
      return it.name === _.name && it.ValueTypeName === b;
    });
    if (j === void 0) continue;
    let $ = 0;
    const _e = _.getValueSize();
    _.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline &&
      ($ = _e / 3);
    let et = 0;
    const rt = j.getValueSize();
    j.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline &&
      (et = rt / 3);
    const st = _.times.length - 1;
    let at;
    if (d <= _.times[0]) {
      const it = $,
        lt = _e - $;
      at = _.values.slice(it, lt);
    } else if (d >= _.times[st]) {
      const it = st * _e + $,
        lt = it + _e - $;
      at = _.values.slice(it, lt);
    } else {
      const it = _.createInterpolant(),
        lt = $,
        ot = _e - $;
      it.evaluate(d), (at = it.resultBuffer.slice(lt, ot));
    }
    b === "quaternion" &&
      new Quaternion().fromArray(at).normalize().conjugate().toArray(at);
    const ct = j.times.length;
    for (let it = 0; it < ct; ++it) {
      const lt = it * rt + et;
      if (b === "quaternion")
        Quaternion.multiplyQuaternionsFlat(j.values, lt, at, 0, j.values, lt);
      else {
        const ot = rt - et * 2;
        for (let ut = 0; ut < ot; ++ut) j.values[lt + ut] -= at[ut];
      }
    }
  }
  return (s.blendMode = AdditiveAnimationBlendMode), s;
}
const AnimationUtils = {
  convertArray,
  isTypedArray,
  getKeyframeOrder,
  sortedArray,
  flattenJSON,
  subclip,
  makeClipAdditive,
};
class Interpolant {
  constructor(e, o, a, c) {
    (this.parameterPositions = e),
      (this._cachedIndex = 0),
      (this.resultBuffer = c !== void 0 ? c : new o.constructor(a)),
      (this.sampleValues = o),
      (this.valueSize = a),
      (this.settings = null),
      (this.DefaultSettings_ = {});
  }
  evaluate(e) {
    const o = this.parameterPositions;
    let a = this._cachedIndex,
      c = o[a],
      d = o[a - 1];
    e: {
      t: {
        let g;
        n: {
          r: if (!(e < c)) {
            for (let _ = a + 2; ; ) {
              if (c === void 0) {
                if (e < d) break r;
                return (
                  (a = o.length),
                  (this._cachedIndex = a),
                  this.copySampleValue_(a - 1)
                );
              }
              if (a === _) break;
              if (((d = c), (c = o[++a]), e < c)) break t;
            }
            g = o.length;
            break n;
          }
          if (!(e >= d)) {
            const _ = o[1];
            e < _ && ((a = 2), (d = _));
            for (let b = a - 2; ; ) {
              if (d === void 0)
                return (this._cachedIndex = 0), this.copySampleValue_(0);
              if (a === b) break;
              if (((c = d), (d = o[--a - 1]), e >= d)) break t;
            }
            (g = a), (a = 0);
            break n;
          }
          break e;
        }
        for (; a < g; ) {
          const _ = (a + g) >>> 1;
          e < o[_] ? (g = _) : (a = _ + 1);
        }
        if (((c = o[a]), (d = o[a - 1]), d === void 0))
          return (this._cachedIndex = 0), this.copySampleValue_(0);
        if (c === void 0)
          return (
            (a = o.length),
            (this._cachedIndex = a),
            this.copySampleValue_(a - 1)
          );
      }
      (this._cachedIndex = a), this.intervalChanged_(a, d, c);
    }
    return this.interpolate_(a, d, e, c);
  }
  getSettings_() {
    return this.settings || this.DefaultSettings_;
  }
  copySampleValue_(e) {
    const o = this.resultBuffer,
      a = this.sampleValues,
      c = this.valueSize,
      d = e * c;
    for (let g = 0; g !== c; ++g) o[g] = a[d + g];
    return o;
  }
  interpolate_() {
    throw new Error("call to abstract method");
  }
  intervalChanged_() {}
}
class CubicInterpolant extends Interpolant {
  constructor(e, o, a, c) {
    super(e, o, a, c),
      (this._weightPrev = -0),
      (this._offsetPrev = -0),
      (this._weightNext = -0),
      (this._offsetNext = -0),
      (this.DefaultSettings_ = {
        endingStart: ZeroCurvatureEnding,
        endingEnd: ZeroCurvatureEnding,
      });
  }
  intervalChanged_(e, o, a) {
    const c = this.parameterPositions;
    let d = e - 2,
      g = e + 1,
      _ = c[d],
      b = c[g];
    if (_ === void 0)
      switch (this.getSettings_().endingStart) {
        case ZeroSlopeEnding:
          (d = e), (_ = 2 * o - a);
          break;
        case WrapAroundEnding:
          (d = c.length - 2), (_ = o + c[d] - c[d + 1]);
          break;
        default:
          (d = e), (_ = a);
      }
    if (b === void 0)
      switch (this.getSettings_().endingEnd) {
        case ZeroSlopeEnding:
          (g = e), (b = 2 * a - o);
          break;
        case WrapAroundEnding:
          (g = 1), (b = a + c[1] - c[0]);
          break;
        default:
          (g = e - 1), (b = o);
      }
    const j = (a - o) * 0.5,
      $ = this.valueSize;
    (this._weightPrev = j / (o - _)),
      (this._weightNext = j / (b - a)),
      (this._offsetPrev = d * $),
      (this._offsetNext = g * $);
  }
  interpolate_(e, o, a, c) {
    const d = this.resultBuffer,
      g = this.sampleValues,
      _ = this.valueSize,
      b = e * _,
      j = b - _,
      $ = this._offsetPrev,
      _e = this._offsetNext,
      et = this._weightPrev,
      rt = this._weightNext,
      st = (a - o) / (c - o),
      at = st * st,
      ct = at * st,
      it = -et * ct + 2 * et * at - et * st,
      lt = (1 + et) * ct + (-1.5 - 2 * et) * at + (-0.5 + et) * st + 1,
      ot = (-1 - rt) * ct + (1.5 + rt) * at + 0.5 * st,
      ut = rt * ct - rt * at;
    for (let pt = 0; pt !== _; ++pt)
      d[pt] =
        it * g[$ + pt] + lt * g[j + pt] + ot * g[b + pt] + ut * g[_e + pt];
    return d;
  }
}
class LinearInterpolant extends Interpolant {
  constructor(e, o, a, c) {
    super(e, o, a, c);
  }
  interpolate_(e, o, a, c) {
    const d = this.resultBuffer,
      g = this.sampleValues,
      _ = this.valueSize,
      b = e * _,
      j = b - _,
      $ = (a - o) / (c - o),
      _e = 1 - $;
    for (let et = 0; et !== _; ++et) d[et] = g[j + et] * _e + g[b + et] * $;
    return d;
  }
}
class DiscreteInterpolant extends Interpolant {
  constructor(e, o, a, c) {
    super(e, o, a, c);
  }
  interpolate_(e) {
    return this.copySampleValue_(e - 1);
  }
}
class KeyframeTrack {
  constructor(e, o, a, c) {
    if (e === void 0)
      throw new Error("THREE.KeyframeTrack: track name is undefined");
    if (o === void 0 || o.length === 0)
      throw new Error("THREE.KeyframeTrack: no keyframes in track named " + e);
    (this.name = e),
      (this.times = convertArray(o, this.TimeBufferType)),
      (this.values = convertArray(a, this.ValueBufferType)),
      this.setInterpolation(c || this.DefaultInterpolation);
  }
  static toJSON(e) {
    const o = e.constructor;
    let a;
    if (o.toJSON !== this.toJSON) a = o.toJSON(e);
    else {
      a = {
        name: e.name,
        times: convertArray(e.times, Array),
        values: convertArray(e.values, Array),
      };
      const c = e.getInterpolation();
      c !== e.DefaultInterpolation && (a.interpolation = c);
    }
    return (a.type = e.ValueTypeName), a;
  }
  InterpolantFactoryMethodDiscrete(e) {
    return new DiscreteInterpolant(
      this.times,
      this.values,
      this.getValueSize(),
      e
    );
  }
  InterpolantFactoryMethodLinear(e) {
    return new LinearInterpolant(
      this.times,
      this.values,
      this.getValueSize(),
      e
    );
  }
  InterpolantFactoryMethodSmooth(e) {
    return new CubicInterpolant(
      this.times,
      this.values,
      this.getValueSize(),
      e
    );
  }
  setInterpolation(e) {
    let o;
    switch (e) {
      case InterpolateDiscrete:
        o = this.InterpolantFactoryMethodDiscrete;
        break;
      case InterpolateLinear:
        o = this.InterpolantFactoryMethodLinear;
        break;
      case InterpolateSmooth:
        o = this.InterpolantFactoryMethodSmooth;
        break;
    }
    if (o === void 0) {
      const a =
        "unsupported interpolation for " +
        this.ValueTypeName +
        " keyframe track named " +
        this.name;
      if (this.createInterpolant === void 0)
        if (e !== this.DefaultInterpolation)
          this.setInterpolation(this.DefaultInterpolation);
        else throw new Error(a);
      return console.warn("THREE.KeyframeTrack:", a), this;
    }
    return (this.createInterpolant = o), this;
  }
  getInterpolation() {
    switch (this.createInterpolant) {
      case this.InterpolantFactoryMethodDiscrete:
        return InterpolateDiscrete;
      case this.InterpolantFactoryMethodLinear:
        return InterpolateLinear;
      case this.InterpolantFactoryMethodSmooth:
        return InterpolateSmooth;
    }
  }
  getValueSize() {
    return this.values.length / this.times.length;
  }
  shift(e) {
    if (e !== 0) {
      const o = this.times;
      for (let a = 0, c = o.length; a !== c; ++a) o[a] += e;
    }
    return this;
  }
  scale(e) {
    if (e !== 1) {
      const o = this.times;
      for (let a = 0, c = o.length; a !== c; ++a) o[a] *= e;
    }
    return this;
  }
  trim(e, o) {
    const a = this.times,
      c = a.length;
    let d = 0,
      g = c - 1;
    for (; d !== c && a[d] < e; ) ++d;
    for (; g !== -1 && a[g] > o; ) --g;
    if ((++g, d !== 0 || g !== c)) {
      d >= g && ((g = Math.max(g, 1)), (d = g - 1));
      const _ = this.getValueSize();
      (this.times = a.slice(d, g)),
        (this.values = this.values.slice(d * _, g * _));
    }
    return this;
  }
  validate() {
    let e = !0;
    const o = this.getValueSize();
    o - Math.floor(o) !== 0 &&
      (console.error("THREE.KeyframeTrack: Invalid value size in track.", this),
      (e = !1));
    const a = this.times,
      c = this.values,
      d = a.length;
    d === 0 &&
      (console.error("THREE.KeyframeTrack: Track is empty.", this), (e = !1));
    let g = null;
    for (let _ = 0; _ !== d; _++) {
      const b = a[_];
      if (typeof b == "number" && isNaN(b)) {
        console.error(
          "THREE.KeyframeTrack: Time is not a valid number.",
          this,
          _,
          b
        ),
          (e = !1);
        break;
      }
      if (g !== null && g > b) {
        console.error("THREE.KeyframeTrack: Out of order keys.", this, _, b, g),
          (e = !1);
        break;
      }
      g = b;
    }
    if (c !== void 0 && isTypedArray(c))
      for (let _ = 0, b = c.length; _ !== b; ++_) {
        const j = c[_];
        if (isNaN(j)) {
          console.error(
            "THREE.KeyframeTrack: Value is not a valid number.",
            this,
            _,
            j
          ),
            (e = !1);
          break;
        }
      }
    return e;
  }
  optimize() {
    const e = this.times.slice(),
      o = this.values.slice(),
      a = this.getValueSize(),
      c = this.getInterpolation() === InterpolateSmooth,
      d = e.length - 1;
    let g = 1;
    for (let _ = 1; _ < d; ++_) {
      let b = !1;
      const j = e[_],
        $ = e[_ + 1];
      if (j !== $ && (_ !== 1 || j !== e[0]))
        if (c) b = !0;
        else {
          const _e = _ * a,
            et = _e - a,
            rt = _e + a;
          for (let st = 0; st !== a; ++st) {
            const at = o[_e + st];
            if (at !== o[et + st] || at !== o[rt + st]) {
              b = !0;
              break;
            }
          }
        }
      if (b) {
        if (_ !== g) {
          e[g] = e[_];
          const _e = _ * a,
            et = g * a;
          for (let rt = 0; rt !== a; ++rt) o[et + rt] = o[_e + rt];
        }
        ++g;
      }
    }
    if (d > 0) {
      e[g] = e[d];
      for (let _ = d * a, b = g * a, j = 0; j !== a; ++j) o[b + j] = o[_ + j];
      ++g;
    }
    return (
      g !== e.length
        ? ((this.times = e.slice(0, g)), (this.values = o.slice(0, g * a)))
        : ((this.times = e), (this.values = o)),
      this
    );
  }
  clone() {
    const e = this.times.slice(),
      o = this.values.slice(),
      a = this.constructor,
      c = new a(this.name, e, o);
    return (c.createInterpolant = this.createInterpolant), c;
  }
}
KeyframeTrack.prototype.TimeBufferType = Float32Array;
KeyframeTrack.prototype.ValueBufferType = Float32Array;
KeyframeTrack.prototype.DefaultInterpolation = InterpolateLinear;
class BooleanKeyframeTrack extends KeyframeTrack {
  constructor(e, o, a) {
    super(e, o, a);
  }
}
BooleanKeyframeTrack.prototype.ValueTypeName = "bool";
BooleanKeyframeTrack.prototype.ValueBufferType = Array;
BooleanKeyframeTrack.prototype.DefaultInterpolation = InterpolateDiscrete;
BooleanKeyframeTrack.prototype.InterpolantFactoryMethodLinear = void 0;
BooleanKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = void 0;
class ColorKeyframeTrack extends KeyframeTrack {}
ColorKeyframeTrack.prototype.ValueTypeName = "color";
class NumberKeyframeTrack extends KeyframeTrack {}
NumberKeyframeTrack.prototype.ValueTypeName = "number";
class QuaternionLinearInterpolant extends Interpolant {
  constructor(e, o, a, c) {
    super(e, o, a, c);
  }
  interpolate_(e, o, a, c) {
    const d = this.resultBuffer,
      g = this.sampleValues,
      _ = this.valueSize,
      b = (a - o) / (c - o);
    let j = e * _;
    for (let $ = j + _; j !== $; j += 4)
      Quaternion.slerpFlat(d, 0, g, j - _, g, j, b);
    return d;
  }
}
class QuaternionKeyframeTrack extends KeyframeTrack {
  InterpolantFactoryMethodLinear(e) {
    return new QuaternionLinearInterpolant(
      this.times,
      this.values,
      this.getValueSize(),
      e
    );
  }
}
QuaternionKeyframeTrack.prototype.ValueTypeName = "quaternion";
QuaternionKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = void 0;
class StringKeyframeTrack extends KeyframeTrack {
  constructor(e, o, a) {
    super(e, o, a);
  }
}
StringKeyframeTrack.prototype.ValueTypeName = "string";
StringKeyframeTrack.prototype.ValueBufferType = Array;
StringKeyframeTrack.prototype.DefaultInterpolation = InterpolateDiscrete;
StringKeyframeTrack.prototype.InterpolantFactoryMethodLinear = void 0;
StringKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = void 0;
class VectorKeyframeTrack extends KeyframeTrack {}
VectorKeyframeTrack.prototype.ValueTypeName = "vector";
class AnimationClip {
  constructor(e = "", o = -1, a = [], c = NormalAnimationBlendMode) {
    (this.name = e),
      (this.tracks = a),
      (this.duration = o),
      (this.blendMode = c),
      (this.uuid = generateUUID()),
      this.duration < 0 && this.resetDuration();
  }
  static parse(e) {
    const o = [],
      a = e.tracks,
      c = 1 / (e.fps || 1);
    for (let g = 0, _ = a.length; g !== _; ++g)
      o.push(parseKeyframeTrack(a[g]).scale(c));
    const d = new this(e.name, e.duration, o, e.blendMode);
    return (d.uuid = e.uuid), d;
  }
  static toJSON(e) {
    const o = [],
      a = e.tracks,
      c = {
        name: e.name,
        duration: e.duration,
        tracks: o,
        uuid: e.uuid,
        blendMode: e.blendMode,
      };
    for (let d = 0, g = a.length; d !== g; ++d)
      o.push(KeyframeTrack.toJSON(a[d]));
    return c;
  }
  static CreateFromMorphTargetSequence(e, o, a, c) {
    const d = o.length,
      g = [];
    for (let _ = 0; _ < d; _++) {
      let b = [],
        j = [];
      b.push((_ + d - 1) % d, _, (_ + 1) % d), j.push(0, 1, 0);
      const $ = getKeyframeOrder(b);
      (b = sortedArray(b, 1, $)),
        (j = sortedArray(j, 1, $)),
        !c && b[0] === 0 && (b.push(d), j.push(j[0])),
        g.push(
          new NumberKeyframeTrack(
            ".morphTargetInfluences[" + o[_].name + "]",
            b,
            j
          ).scale(1 / a)
        );
    }
    return new this(e, -1, g);
  }
  static findByName(e, o) {
    let a = e;
    if (!Array.isArray(e)) {
      const c = e;
      a = (c.geometry && c.geometry.animations) || c.animations;
    }
    for (let c = 0; c < a.length; c++) if (a[c].name === o) return a[c];
    return null;
  }
  static CreateClipsFromMorphTargetSequences(e, o, a) {
    const c = {},
      d = /^([\w-]*?)([\d]+)$/;
    for (let _ = 0, b = e.length; _ < b; _++) {
      const j = e[_],
        $ = j.name.match(d);
      if ($ && $.length > 1) {
        const _e = $[1];
        let et = c[_e];
        et || (c[_e] = et = []), et.push(j);
      }
    }
    const g = [];
    for (const _ in c)
      g.push(this.CreateFromMorphTargetSequence(_, c[_], o, a));
    return g;
  }
  static parseAnimation(e, o) {
    if (!e)
      return (
        console.error("THREE.AnimationClip: No animation in JSONLoader data."),
        null
      );
    const a = function (_e, et, rt, st, at) {
        if (rt.length !== 0) {
          const ct = [],
            it = [];
          flattenJSON(rt, ct, it, st),
            ct.length !== 0 && at.push(new _e(et, ct, it));
        }
      },
      c = [],
      d = e.name || "default",
      g = e.fps || 30,
      _ = e.blendMode;
    let b = e.length || -1;
    const j = e.hierarchy || [];
    for (let _e = 0; _e < j.length; _e++) {
      const et = j[_e].keys;
      if (!(!et || et.length === 0))
        if (et[0].morphTargets) {
          const rt = {};
          let st;
          for (st = 0; st < et.length; st++)
            if (et[st].morphTargets)
              for (let at = 0; at < et[st].morphTargets.length; at++)
                rt[et[st].morphTargets[at]] = -1;
          for (const at in rt) {
            const ct = [],
              it = [];
            for (let lt = 0; lt !== et[st].morphTargets.length; ++lt) {
              const ot = et[st];
              ct.push(ot.time), it.push(ot.morphTarget === at ? 1 : 0);
            }
            c.push(
              new NumberKeyframeTrack(
                ".morphTargetInfluence[" + at + "]",
                ct,
                it
              )
            );
          }
          b = rt.length * g;
        } else {
          const rt = ".bones[" + o[_e].name + "]";
          a(VectorKeyframeTrack, rt + ".position", et, "pos", c),
            a(QuaternionKeyframeTrack, rt + ".quaternion", et, "rot", c),
            a(VectorKeyframeTrack, rt + ".scale", et, "scl", c);
        }
    }
    return c.length === 0 ? null : new this(d, b, c, _);
  }
  resetDuration() {
    const e = this.tracks;
    let o = 0;
    for (let a = 0, c = e.length; a !== c; ++a) {
      const d = this.tracks[a];
      o = Math.max(o, d.times[d.times.length - 1]);
    }
    return (this.duration = o), this;
  }
  trim() {
    for (let e = 0; e < this.tracks.length; e++)
      this.tracks[e].trim(0, this.duration);
    return this;
  }
  validate() {
    let e = !0;
    for (let o = 0; o < this.tracks.length; o++)
      e = e && this.tracks[o].validate();
    return e;
  }
  optimize() {
    for (let e = 0; e < this.tracks.length; e++) this.tracks[e].optimize();
    return this;
  }
  clone() {
    const e = [];
    for (let o = 0; o < this.tracks.length; o++) e.push(this.tracks[o].clone());
    return new this.constructor(this.name, this.duration, e, this.blendMode);
  }
  toJSON() {
    return this.constructor.toJSON(this);
  }
}
function getTrackTypeForValueTypeName(s) {
  switch (s.toLowerCase()) {
    case "scalar":
    case "double":
    case "float":
    case "number":
    case "integer":
      return NumberKeyframeTrack;
    case "vector":
    case "vector2":
    case "vector3":
    case "vector4":
      return VectorKeyframeTrack;
    case "color":
      return ColorKeyframeTrack;
    case "quaternion":
      return QuaternionKeyframeTrack;
    case "bool":
    case "boolean":
      return BooleanKeyframeTrack;
    case "string":
      return StringKeyframeTrack;
  }
  throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + s);
}
function parseKeyframeTrack(s) {
  if (s.type === void 0)
    throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
  const e = getTrackTypeForValueTypeName(s.type);
  if (s.times === void 0) {
    const o = [],
      a = [];
    flattenJSON(s.keys, o, a, "value"), (s.times = o), (s.values = a);
  }
  return e.parse !== void 0
    ? e.parse(s)
    : new e(s.name, s.times, s.values, s.interpolation);
}
const Cache = {
  enabled: !1,
  files: {},
  add: function (s, e) {
    this.enabled !== !1 && (this.files[s] = e);
  },
  get: function (s) {
    if (this.enabled !== !1) return this.files[s];
  },
  remove: function (s) {
    delete this.files[s];
  },
  clear: function () {
    this.files = {};
  },
};
class LoadingManager {
  constructor(e, o, a) {
    const c = this;
    let d = !1,
      g = 0,
      _ = 0,
      b;
    const j = [];
    (this.onStart = void 0),
      (this.onLoad = e),
      (this.onProgress = o),
      (this.onError = a),
      (this.itemStart = function ($) {
        _++, d === !1 && c.onStart !== void 0 && c.onStart($, g, _), (d = !0);
      }),
      (this.itemEnd = function ($) {
        g++,
          c.onProgress !== void 0 && c.onProgress($, g, _),
          g === _ && ((d = !1), c.onLoad !== void 0 && c.onLoad());
      }),
      (this.itemError = function ($) {
        c.onError !== void 0 && c.onError($);
      }),
      (this.resolveURL = function ($) {
        return b ? b($) : $;
      }),
      (this.setURLModifier = function ($) {
        return (b = $), this;
      }),
      (this.addHandler = function ($, _e) {
        return j.push($, _e), this;
      }),
      (this.removeHandler = function ($) {
        const _e = j.indexOf($);
        return _e !== -1 && j.splice(_e, 2), this;
      }),
      (this.getHandler = function ($) {
        for (let _e = 0, et = j.length; _e < et; _e += 2) {
          const rt = j[_e],
            st = j[_e + 1];
          if ((rt.global && (rt.lastIndex = 0), rt.test($))) return st;
        }
        return null;
      });
  }
}
const DefaultLoadingManager = new LoadingManager();
let Loader$2 = class {
  constructor(e) {
    (this.manager = e !== void 0 ? e : DefaultLoadingManager),
      (this.crossOrigin = "anonymous"),
      (this.withCredentials = !1),
      (this.path = ""),
      (this.resourcePath = ""),
      (this.requestHeader = {});
  }
  load() {}
  loadAsync(e, o) {
    const a = this;
    return new Promise(function (c, d) {
      a.load(e, c, o, d);
    });
  }
  parse() {}
  setCrossOrigin(e) {
    return (this.crossOrigin = e), this;
  }
  setWithCredentials(e) {
    return (this.withCredentials = e), this;
  }
  setPath(e) {
    return (this.path = e), this;
  }
  setResourcePath(e) {
    return (this.resourcePath = e), this;
  }
  setRequestHeader(e) {
    return (this.requestHeader = e), this;
  }
};
Loader$2.DEFAULT_MATERIAL_NAME = "__DEFAULT";
const loading = {};
class HttpError extends Error {
  constructor(e, o) {
    super(e), (this.response = o);
  }
}
class FileLoader extends Loader$2 {
  constructor(e) {
    super(e);
  }
  load(e, o, a, c) {
    e === void 0 && (e = ""),
      this.path !== void 0 && (e = this.path + e),
      (e = this.manager.resolveURL(e));
    const d = Cache.get(e);
    if (d !== void 0)
      return (
        this.manager.itemStart(e),
        setTimeout(() => {
          o && o(d), this.manager.itemEnd(e);
        }, 0),
        d
      );
    if (loading[e] !== void 0) {
      loading[e].push({ onLoad: o, onProgress: a, onError: c });
      return;
    }
    (loading[e] = []),
      loading[e].push({ onLoad: o, onProgress: a, onError: c });
    const g = new Request(e, {
        headers: new Headers(this.requestHeader),
        credentials: this.withCredentials ? "include" : "same-origin",
      }),
      _ = this.mimeType,
      b = this.responseType;
    fetch(g)
      .then((j) => {
        if (j.status === 200 || j.status === 0) {
          if (
            (j.status === 0 &&
              console.warn("THREE.FileLoader: HTTP Status 0 received."),
            typeof ReadableStream > "u" ||
              j.body === void 0 ||
              j.body.getReader === void 0)
          )
            return j;
          const $ = loading[e],
            _e = j.body.getReader(),
            et =
              j.headers.get("X-File-Size") || j.headers.get("Content-Length"),
            rt = et ? parseInt(et) : 0,
            st = rt !== 0;
          let at = 0;
          const ct = new ReadableStream({
            start(it) {
              lt();
              function lt() {
                _e.read().then(
                  ({ done: ot, value: ut }) => {
                    if (ot) it.close();
                    else {
                      at += ut.byteLength;
                      const pt = new ProgressEvent("progress", {
                        lengthComputable: st,
                        loaded: at,
                        total: rt,
                      });
                      for (let ft = 0, gt = $.length; ft < gt; ft++) {
                        const xt = $[ft];
                        xt.onProgress && xt.onProgress(pt);
                      }
                      it.enqueue(ut), lt();
                    }
                  },
                  (ot) => {
                    it.error(ot);
                  }
                );
              }
            },
          });
          return new Response(ct);
        } else
          throw new HttpError(
            `fetch for "${j.url}" responded with ${j.status}: ${j.statusText}`,
            j
          );
      })
      .then((j) => {
        switch (b) {
          case "arraybuffer":
            return j.arrayBuffer();
          case "blob":
            return j.blob();
          case "document":
            return j.text().then(($) => new DOMParser().parseFromString($, _));
          case "json":
            return j.json();
          default:
            if (_ === void 0) return j.text();
            {
              const _e = /charset="?([^;"\s]*)"?/i.exec(_),
                et = _e && _e[1] ? _e[1].toLowerCase() : void 0,
                rt = new TextDecoder(et);
              return j.arrayBuffer().then((st) => rt.decode(st));
            }
        }
      })
      .then((j) => {
        Cache.add(e, j);
        const $ = loading[e];
        delete loading[e];
        for (let _e = 0, et = $.length; _e < et; _e++) {
          const rt = $[_e];
          rt.onLoad && rt.onLoad(j);
        }
      })
      .catch((j) => {
        const $ = loading[e];
        if ($ === void 0) throw (this.manager.itemError(e), j);
        delete loading[e];
        for (let _e = 0, et = $.length; _e < et; _e++) {
          const rt = $[_e];
          rt.onError && rt.onError(j);
        }
        this.manager.itemError(e);
      })
      .finally(() => {
        this.manager.itemEnd(e);
      }),
      this.manager.itemStart(e);
  }
  setResponseType(e) {
    return (this.responseType = e), this;
  }
  setMimeType(e) {
    return (this.mimeType = e), this;
  }
}
class AnimationLoader extends Loader$2 {
  constructor(e) {
    super(e);
  }
  load(e, o, a, c) {
    const d = this,
      g = new FileLoader(this.manager);
    g.setPath(this.path),
      g.setRequestHeader(this.requestHeader),
      g.setWithCredentials(this.withCredentials),
      g.load(
        e,
        function (_) {
          try {
            o(d.parse(JSON.parse(_)));
          } catch (b) {
            c ? c(b) : console.error(b), d.manager.itemError(e);
          }
        },
        a,
        c
      );
  }
  parse(e) {
    const o = [];
    for (let a = 0; a < e.length; a++) {
      const c = AnimationClip.parse(e[a]);
      o.push(c);
    }
    return o;
  }
}
class CompressedTextureLoader extends Loader$2 {
  constructor(e) {
    super(e);
  }
  load(e, o, a, c) {
    const d = this,
      g = [],
      _ = new CompressedTexture(),
      b = new FileLoader(this.manager);
    b.setPath(this.path),
      b.setResponseType("arraybuffer"),
      b.setRequestHeader(this.requestHeader),
      b.setWithCredentials(d.withCredentials);
    let j = 0;
    function $(_e) {
      b.load(
        e[_e],
        function (et) {
          const rt = d.parse(et, !0);
          (g[_e] = {
            width: rt.width,
            height: rt.height,
            format: rt.format,
            mipmaps: rt.mipmaps,
          }),
            (j += 1),
            j === 6 &&
              (rt.mipmapCount === 1 && (_.minFilter = LinearFilter),
              (_.image = g),
              (_.format = rt.format),
              (_.needsUpdate = !0),
              o && o(_));
        },
        a,
        c
      );
    }
    if (Array.isArray(e)) for (let _e = 0, et = e.length; _e < et; ++_e) $(_e);
    else
      b.load(
        e,
        function (_e) {
          const et = d.parse(_e, !0);
          if (et.isCubemap) {
            const rt = et.mipmaps.length / et.mipmapCount;
            for (let st = 0; st < rt; st++) {
              g[st] = { mipmaps: [] };
              for (let at = 0; at < et.mipmapCount; at++)
                g[st].mipmaps.push(et.mipmaps[st * et.mipmapCount + at]),
                  (g[st].format = et.format),
                  (g[st].width = et.width),
                  (g[st].height = et.height);
            }
            _.image = g;
          } else
            (_.image.width = et.width),
              (_.image.height = et.height),
              (_.mipmaps = et.mipmaps);
          et.mipmapCount === 1 && (_.minFilter = LinearFilter),
            (_.format = et.format),
            (_.needsUpdate = !0),
            o && o(_);
        },
        a,
        c
      );
    return _;
  }
}
class ImageLoader extends Loader$2 {
  constructor(e) {
    super(e);
  }
  load(e, o, a, c) {
    this.path !== void 0 && (e = this.path + e),
      (e = this.manager.resolveURL(e));
    const d = this,
      g = Cache.get(e);
    if (g !== void 0)
      return (
        d.manager.itemStart(e),
        setTimeout(function () {
          o && o(g), d.manager.itemEnd(e);
        }, 0),
        g
      );
    const _ = createElementNS("img");
    function b() {
      $(), Cache.add(e, this), o && o(this), d.manager.itemEnd(e);
    }
    function j(_e) {
      $(), c && c(_e), d.manager.itemError(e), d.manager.itemEnd(e);
    }
    function $() {
      _.removeEventListener("load", b, !1),
        _.removeEventListener("error", j, !1);
    }
    return (
      _.addEventListener("load", b, !1),
      _.addEventListener("error", j, !1),
      e.slice(0, 5) !== "data:" &&
        this.crossOrigin !== void 0 &&
        (_.crossOrigin = this.crossOrigin),
      d.manager.itemStart(e),
      (_.src = e),
      _
    );
  }
}
class CubeTextureLoader extends Loader$2 {
  constructor(e) {
    super(e);
  }
  load(e, o, a, c) {
    const d = new CubeTexture();
    d.colorSpace = SRGBColorSpace$1;
    const g = new ImageLoader(this.manager);
    g.setCrossOrigin(this.crossOrigin), g.setPath(this.path);
    let _ = 0;
    function b(j) {
      g.load(
        e[j],
        function ($) {
          (d.images[j] = $), _++, _ === 6 && ((d.needsUpdate = !0), o && o(d));
        },
        void 0,
        c
      );
    }
    for (let j = 0; j < e.length; ++j) b(j);
    return d;
  }
}
class DataTextureLoader extends Loader$2 {
  constructor(e) {
    super(e);
  }
  load(e, o, a, c) {
    const d = this,
      g = new DataTexture(),
      _ = new FileLoader(this.manager);
    return (
      _.setResponseType("arraybuffer"),
      _.setRequestHeader(this.requestHeader),
      _.setPath(this.path),
      _.setWithCredentials(d.withCredentials),
      _.load(
        e,
        function (b) {
          let j;
          try {
            j = d.parse(b);
          } catch ($) {
            if (c !== void 0) c($);
            else {
              console.error($);
              return;
            }
          }
          j.image !== void 0
            ? (g.image = j.image)
            : j.data !== void 0 &&
              ((g.image.width = j.width),
              (g.image.height = j.height),
              (g.image.data = j.data)),
            (g.wrapS = j.wrapS !== void 0 ? j.wrapS : ClampToEdgeWrapping),
            (g.wrapT = j.wrapT !== void 0 ? j.wrapT : ClampToEdgeWrapping),
            (g.magFilter = j.magFilter !== void 0 ? j.magFilter : LinearFilter),
            (g.minFilter = j.minFilter !== void 0 ? j.minFilter : LinearFilter),
            (g.anisotropy = j.anisotropy !== void 0 ? j.anisotropy : 1),
            j.colorSpace !== void 0 && (g.colorSpace = j.colorSpace),
            j.flipY !== void 0 && (g.flipY = j.flipY),
            j.format !== void 0 && (g.format = j.format),
            j.type !== void 0 && (g.type = j.type),
            j.mipmaps !== void 0 &&
              ((g.mipmaps = j.mipmaps),
              (g.minFilter = LinearMipmapLinearFilter)),
            j.mipmapCount === 1 && (g.minFilter = LinearFilter),
            j.generateMipmaps !== void 0 &&
              (g.generateMipmaps = j.generateMipmaps),
            (g.needsUpdate = !0),
            o && o(g, j);
        },
        a,
        c
      ),
      g
    );
  }
}
class TextureLoader extends Loader$2 {
  constructor(e) {
    super(e);
  }
  load(e, o, a, c) {
    const d = new Texture(),
      g = new ImageLoader(this.manager);
    return (
      g.setCrossOrigin(this.crossOrigin),
      g.setPath(this.path),
      g.load(
        e,
        function (_) {
          (d.image = _), (d.needsUpdate = !0), o !== void 0 && o(d);
        },
        a,
        c
      ),
      d
    );
  }
}
class Light extends Object3D {
  constructor(e, o = 1) {
    super(),
      (this.isLight = !0),
      (this.type = "Light"),
      (this.color = new Color(e)),
      (this.intensity = o);
  }
  dispose() {}
  copy(e, o) {
    return (
      super.copy(e, o),
      this.color.copy(e.color),
      (this.intensity = e.intensity),
      this
    );
  }
  toJSON(e) {
    const o = super.toJSON(e);
    return (
      (o.object.color = this.color.getHex()),
      (o.object.intensity = this.intensity),
      this.groundColor !== void 0 &&
        (o.object.groundColor = this.groundColor.getHex()),
      this.distance !== void 0 && (o.object.distance = this.distance),
      this.angle !== void 0 && (o.object.angle = this.angle),
      this.decay !== void 0 && (o.object.decay = this.decay),
      this.penumbra !== void 0 && (o.object.penumbra = this.penumbra),
      this.shadow !== void 0 && (o.object.shadow = this.shadow.toJSON()),
      this.target !== void 0 && (o.object.target = this.target.uuid),
      o
    );
  }
}
class HemisphereLight extends Light {
  constructor(e, o, a) {
    super(e, a),
      (this.isHemisphereLight = !0),
      (this.type = "HemisphereLight"),
      this.position.copy(Object3D.DEFAULT_UP),
      this.updateMatrix(),
      (this.groundColor = new Color(o));
  }
  copy(e, o) {
    return super.copy(e, o), this.groundColor.copy(e.groundColor), this;
  }
}
const _projScreenMatrix$1 = new Matrix4(),
  _lightPositionWorld$1 = new Vector3(),
  _lookTarget$1 = new Vector3();
class LightShadow {
  constructor(e) {
    (this.camera = e),
      (this.intensity = 1),
      (this.bias = 0),
      (this.normalBias = 0),
      (this.radius = 1),
      (this.blurSamples = 8),
      (this.mapSize = new Vector2(512, 512)),
      (this.map = null),
      (this.mapPass = null),
      (this.matrix = new Matrix4()),
      (this.autoUpdate = !0),
      (this.needsUpdate = !1),
      (this._frustum = new Frustum()),
      (this._frameExtents = new Vector2(1, 1)),
      (this._viewportCount = 1),
      (this._viewports = [new Vector4(0, 0, 1, 1)]);
  }
  getViewportCount() {
    return this._viewportCount;
  }
  getFrustum() {
    return this._frustum;
  }
  updateMatrices(e) {
    const o = this.camera,
      a = this.matrix;
    _lightPositionWorld$1.setFromMatrixPosition(e.matrixWorld),
      o.position.copy(_lightPositionWorld$1),
      _lookTarget$1.setFromMatrixPosition(e.target.matrixWorld),
      o.lookAt(_lookTarget$1),
      o.updateMatrixWorld(),
      _projScreenMatrix$1.multiplyMatrices(
        o.projectionMatrix,
        o.matrixWorldInverse
      ),
      this._frustum.setFromProjectionMatrix(_projScreenMatrix$1),
      a.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1),
      a.multiply(_projScreenMatrix$1);
  }
  getViewport(e) {
    return this._viewports[e];
  }
  getFrameExtents() {
    return this._frameExtents;
  }
  dispose() {
    this.map && this.map.dispose(), this.mapPass && this.mapPass.dispose();
  }
  copy(e) {
    return (
      (this.camera = e.camera.clone()),
      (this.intensity = e.intensity),
      (this.bias = e.bias),
      (this.radius = e.radius),
      this.mapSize.copy(e.mapSize),
      this
    );
  }
  clone() {
    return new this.constructor().copy(this);
  }
  toJSON() {
    const e = {};
    return (
      this.intensity !== 1 && (e.intensity = this.intensity),
      this.bias !== 0 && (e.bias = this.bias),
      this.normalBias !== 0 && (e.normalBias = this.normalBias),
      this.radius !== 1 && (e.radius = this.radius),
      (this.mapSize.x !== 512 || this.mapSize.y !== 512) &&
        (e.mapSize = this.mapSize.toArray()),
      (e.camera = this.camera.toJSON(!1).object),
      delete e.camera.matrix,
      e
    );
  }
}
class SpotLightShadow extends LightShadow {
  constructor() {
    super(new PerspectiveCamera(50, 1, 0.5, 500)),
      (this.isSpotLightShadow = !0),
      (this.focus = 1);
  }
  updateMatrices(e) {
    const o = this.camera,
      a = RAD2DEG * 2 * e.angle * this.focus,
      c = this.mapSize.width / this.mapSize.height,
      d = e.distance || o.far;
    (a !== o.fov || c !== o.aspect || d !== o.far) &&
      ((o.fov = a), (o.aspect = c), (o.far = d), o.updateProjectionMatrix()),
      super.updateMatrices(e);
  }
  copy(e) {
    return super.copy(e), (this.focus = e.focus), this;
  }
}
class SpotLight extends Light {
  constructor(e, o, a = 0, c = Math.PI / 3, d = 0, g = 2) {
    super(e, o),
      (this.isSpotLight = !0),
      (this.type = "SpotLight"),
      this.position.copy(Object3D.DEFAULT_UP),
      this.updateMatrix(),
      (this.target = new Object3D()),
      (this.distance = a),
      (this.angle = c),
      (this.penumbra = d),
      (this.decay = g),
      (this.map = null),
      (this.shadow = new SpotLightShadow());
  }
  get power() {
    return this.intensity * Math.PI;
  }
  set power(e) {
    this.intensity = e / Math.PI;
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(e, o) {
    return (
      super.copy(e, o),
      (this.distance = e.distance),
      (this.angle = e.angle),
      (this.penumbra = e.penumbra),
      (this.decay = e.decay),
      (this.target = e.target.clone()),
      (this.shadow = e.shadow.clone()),
      this
    );
  }
}
const _projScreenMatrix = new Matrix4(),
  _lightPositionWorld = new Vector3(),
  _lookTarget = new Vector3();
class PointLightShadow extends LightShadow {
  constructor() {
    super(new PerspectiveCamera(90, 1, 0.5, 500)),
      (this.isPointLightShadow = !0),
      (this._frameExtents = new Vector2(4, 2)),
      (this._viewportCount = 6),
      (this._viewports = [
        new Vector4(2, 1, 1, 1),
        new Vector4(0, 1, 1, 1),
        new Vector4(3, 1, 1, 1),
        new Vector4(1, 1, 1, 1),
        new Vector4(3, 0, 1, 1),
        new Vector4(1, 0, 1, 1),
      ]),
      (this._cubeDirections = [
        new Vector3(1, 0, 0),
        new Vector3(-1, 0, 0),
        new Vector3(0, 0, 1),
        new Vector3(0, 0, -1),
        new Vector3(0, 1, 0),
        new Vector3(0, -1, 0),
      ]),
      (this._cubeUps = [
        new Vector3(0, 1, 0),
        new Vector3(0, 1, 0),
        new Vector3(0, 1, 0),
        new Vector3(0, 1, 0),
        new Vector3(0, 0, 1),
        new Vector3(0, 0, -1),
      ]);
  }
  updateMatrices(e, o = 0) {
    const a = this.camera,
      c = this.matrix,
      d = e.distance || a.far;
    d !== a.far && ((a.far = d), a.updateProjectionMatrix()),
      _lightPositionWorld.setFromMatrixPosition(e.matrixWorld),
      a.position.copy(_lightPositionWorld),
      _lookTarget.copy(a.position),
      _lookTarget.add(this._cubeDirections[o]),
      a.up.copy(this._cubeUps[o]),
      a.lookAt(_lookTarget),
      a.updateMatrixWorld(),
      c.makeTranslation(
        -_lightPositionWorld.x,
        -_lightPositionWorld.y,
        -_lightPositionWorld.z
      ),
      _projScreenMatrix.multiplyMatrices(
        a.projectionMatrix,
        a.matrixWorldInverse
      ),
      this._frustum.setFromProjectionMatrix(_projScreenMatrix);
  }
}
class PointLight extends Light {
  constructor(e, o, a = 0, c = 2) {
    super(e, o),
      (this.isPointLight = !0),
      (this.type = "PointLight"),
      (this.distance = a),
      (this.decay = c),
      (this.shadow = new PointLightShadow());
  }
  get power() {
    return this.intensity * 4 * Math.PI;
  }
  set power(e) {
    this.intensity = e / (4 * Math.PI);
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(e, o) {
    return (
      super.copy(e, o),
      (this.distance = e.distance),
      (this.decay = e.decay),
      (this.shadow = e.shadow.clone()),
      this
    );
  }
}
class DirectionalLightShadow extends LightShadow {
  constructor() {
    super(new OrthographicCamera(-5, 5, 5, -5, 0.5, 500)),
      (this.isDirectionalLightShadow = !0);
  }
}
class DirectionalLight extends Light {
  constructor(e, o) {
    super(e, o),
      (this.isDirectionalLight = !0),
      (this.type = "DirectionalLight"),
      this.position.copy(Object3D.DEFAULT_UP),
      this.updateMatrix(),
      (this.target = new Object3D()),
      (this.shadow = new DirectionalLightShadow());
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(e) {
    return (
      super.copy(e),
      (this.target = e.target.clone()),
      (this.shadow = e.shadow.clone()),
      this
    );
  }
}
class AmbientLight extends Light {
  constructor(e, o) {
    super(e, o), (this.isAmbientLight = !0), (this.type = "AmbientLight");
  }
}
class RectAreaLight extends Light {
  constructor(e, o, a = 10, c = 10) {
    super(e, o),
      (this.isRectAreaLight = !0),
      (this.type = "RectAreaLight"),
      (this.width = a),
      (this.height = c);
  }
  get power() {
    return this.intensity * this.width * this.height * Math.PI;
  }
  set power(e) {
    this.intensity = e / (this.width * this.height * Math.PI);
  }
  copy(e) {
    return (
      super.copy(e), (this.width = e.width), (this.height = e.height), this
    );
  }
  toJSON(e) {
    const o = super.toJSON(e);
    return (o.object.width = this.width), (o.object.height = this.height), o;
  }
}
class SphericalHarmonics3 {
  constructor() {
    (this.isSphericalHarmonics3 = !0), (this.coefficients = []);
    for (let e = 0; e < 9; e++) this.coefficients.push(new Vector3());
  }
  set(e) {
    for (let o = 0; o < 9; o++) this.coefficients[o].copy(e[o]);
    return this;
  }
  zero() {
    for (let e = 0; e < 9; e++) this.coefficients[e].set(0, 0, 0);
    return this;
  }
  getAt(e, o) {
    const a = e.x,
      c = e.y,
      d = e.z,
      g = this.coefficients;
    return (
      o.copy(g[0]).multiplyScalar(0.282095),
      o.addScaledVector(g[1], 0.488603 * c),
      o.addScaledVector(g[2], 0.488603 * d),
      o.addScaledVector(g[3], 0.488603 * a),
      o.addScaledVector(g[4], 1.092548 * (a * c)),
      o.addScaledVector(g[5], 1.092548 * (c * d)),
      o.addScaledVector(g[6], 0.315392 * (3 * d * d - 1)),
      o.addScaledVector(g[7], 1.092548 * (a * d)),
      o.addScaledVector(g[8], 0.546274 * (a * a - c * c)),
      o
    );
  }
  getIrradianceAt(e, o) {
    const a = e.x,
      c = e.y,
      d = e.z,
      g = this.coefficients;
    return (
      o.copy(g[0]).multiplyScalar(0.886227),
      o.addScaledVector(g[1], 2 * 0.511664 * c),
      o.addScaledVector(g[2], 2 * 0.511664 * d),
      o.addScaledVector(g[3], 2 * 0.511664 * a),
      o.addScaledVector(g[4], 2 * 0.429043 * a * c),
      o.addScaledVector(g[5], 2 * 0.429043 * c * d),
      o.addScaledVector(g[6], 0.743125 * d * d - 0.247708),
      o.addScaledVector(g[7], 2 * 0.429043 * a * d),
      o.addScaledVector(g[8], 0.429043 * (a * a - c * c)),
      o
    );
  }
  add(e) {
    for (let o = 0; o < 9; o++) this.coefficients[o].add(e.coefficients[o]);
    return this;
  }
  addScaledSH(e, o) {
    for (let a = 0; a < 9; a++)
      this.coefficients[a].addScaledVector(e.coefficients[a], o);
    return this;
  }
  scale(e) {
    for (let o = 0; o < 9; o++) this.coefficients[o].multiplyScalar(e);
    return this;
  }
  lerp(e, o) {
    for (let a = 0; a < 9; a++) this.coefficients[a].lerp(e.coefficients[a], o);
    return this;
  }
  equals(e) {
    for (let o = 0; o < 9; o++)
      if (!this.coefficients[o].equals(e.coefficients[o])) return !1;
    return !0;
  }
  copy(e) {
    return this.set(e.coefficients);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  fromArray(e, o = 0) {
    const a = this.coefficients;
    for (let c = 0; c < 9; c++) a[c].fromArray(e, o + c * 3);
    return this;
  }
  toArray(e = [], o = 0) {
    const a = this.coefficients;
    for (let c = 0; c < 9; c++) a[c].toArray(e, o + c * 3);
    return e;
  }
  static getBasisAt(e, o) {
    const a = e.x,
      c = e.y,
      d = e.z;
    (o[0] = 0.282095),
      (o[1] = 0.488603 * c),
      (o[2] = 0.488603 * d),
      (o[3] = 0.488603 * a),
      (o[4] = 1.092548 * a * c),
      (o[5] = 1.092548 * c * d),
      (o[6] = 0.315392 * (3 * d * d - 1)),
      (o[7] = 1.092548 * a * d),
      (o[8] = 0.546274 * (a * a - c * c));
  }
}
class LightProbe extends Light {
  constructor(e = new SphericalHarmonics3(), o = 1) {
    super(void 0, o), (this.isLightProbe = !0), (this.sh = e);
  }
  copy(e) {
    return super.copy(e), this.sh.copy(e.sh), this;
  }
  fromJSON(e) {
    return (this.intensity = e.intensity), this.sh.fromArray(e.sh), this;
  }
  toJSON(e) {
    const o = super.toJSON(e);
    return (o.object.sh = this.sh.toArray()), o;
  }
}
class MaterialLoader extends Loader$2 {
  constructor(e) {
    super(e), (this.textures = {});
  }
  load(e, o, a, c) {
    const d = this,
      g = new FileLoader(d.manager);
    g.setPath(d.path),
      g.setRequestHeader(d.requestHeader),
      g.setWithCredentials(d.withCredentials),
      g.load(
        e,
        function (_) {
          try {
            o(d.parse(JSON.parse(_)));
          } catch (b) {
            c ? c(b) : console.error(b), d.manager.itemError(e);
          }
        },
        a,
        c
      );
  }
  parse(e) {
    const o = this.textures;
    function a(d) {
      return (
        o[d] === void 0 &&
          console.warn("THREE.MaterialLoader: Undefined texture", d),
        o[d]
      );
    }
    const c = MaterialLoader.createMaterialFromType(e.type);
    if (
      (e.uuid !== void 0 && (c.uuid = e.uuid),
      e.name !== void 0 && (c.name = e.name),
      e.color !== void 0 && c.color !== void 0 && c.color.setHex(e.color),
      e.roughness !== void 0 && (c.roughness = e.roughness),
      e.metalness !== void 0 && (c.metalness = e.metalness),
      e.sheen !== void 0 && (c.sheen = e.sheen),
      e.sheenColor !== void 0 &&
        (c.sheenColor = new Color().setHex(e.sheenColor)),
      e.sheenRoughness !== void 0 && (c.sheenRoughness = e.sheenRoughness),
      e.emissive !== void 0 &&
        c.emissive !== void 0 &&
        c.emissive.setHex(e.emissive),
      e.specular !== void 0 &&
        c.specular !== void 0 &&
        c.specular.setHex(e.specular),
      e.specularIntensity !== void 0 &&
        (c.specularIntensity = e.specularIntensity),
      e.specularColor !== void 0 &&
        c.specularColor !== void 0 &&
        c.specularColor.setHex(e.specularColor),
      e.shininess !== void 0 && (c.shininess = e.shininess),
      e.clearcoat !== void 0 && (c.clearcoat = e.clearcoat),
      e.clearcoatRoughness !== void 0 &&
        (c.clearcoatRoughness = e.clearcoatRoughness),
      e.dispersion !== void 0 && (c.dispersion = e.dispersion),
      e.iridescence !== void 0 && (c.iridescence = e.iridescence),
      e.iridescenceIOR !== void 0 && (c.iridescenceIOR = e.iridescenceIOR),
      e.iridescenceThicknessRange !== void 0 &&
        (c.iridescenceThicknessRange = e.iridescenceThicknessRange),
      e.transmission !== void 0 && (c.transmission = e.transmission),
      e.thickness !== void 0 && (c.thickness = e.thickness),
      e.attenuationDistance !== void 0 &&
        (c.attenuationDistance = e.attenuationDistance),
      e.attenuationColor !== void 0 &&
        c.attenuationColor !== void 0 &&
        c.attenuationColor.setHex(e.attenuationColor),
      e.anisotropy !== void 0 && (c.anisotropy = e.anisotropy),
      e.anisotropyRotation !== void 0 &&
        (c.anisotropyRotation = e.anisotropyRotation),
      e.fog !== void 0 && (c.fog = e.fog),
      e.flatShading !== void 0 && (c.flatShading = e.flatShading),
      e.blending !== void 0 && (c.blending = e.blending),
      e.combine !== void 0 && (c.combine = e.combine),
      e.side !== void 0 && (c.side = e.side),
      e.shadowSide !== void 0 && (c.shadowSide = e.shadowSide),
      e.opacity !== void 0 && (c.opacity = e.opacity),
      e.transparent !== void 0 && (c.transparent = e.transparent),
      e.alphaTest !== void 0 && (c.alphaTest = e.alphaTest),
      e.alphaHash !== void 0 && (c.alphaHash = e.alphaHash),
      e.depthFunc !== void 0 && (c.depthFunc = e.depthFunc),
      e.depthTest !== void 0 && (c.depthTest = e.depthTest),
      e.depthWrite !== void 0 && (c.depthWrite = e.depthWrite),
      e.colorWrite !== void 0 && (c.colorWrite = e.colorWrite),
      e.blendSrc !== void 0 && (c.blendSrc = e.blendSrc),
      e.blendDst !== void 0 && (c.blendDst = e.blendDst),
      e.blendEquation !== void 0 && (c.blendEquation = e.blendEquation),
      e.blendSrcAlpha !== void 0 && (c.blendSrcAlpha = e.blendSrcAlpha),
      e.blendDstAlpha !== void 0 && (c.blendDstAlpha = e.blendDstAlpha),
      e.blendEquationAlpha !== void 0 &&
        (c.blendEquationAlpha = e.blendEquationAlpha),
      e.blendColor !== void 0 &&
        c.blendColor !== void 0 &&
        c.blendColor.setHex(e.blendColor),
      e.blendAlpha !== void 0 && (c.blendAlpha = e.blendAlpha),
      e.stencilWriteMask !== void 0 &&
        (c.stencilWriteMask = e.stencilWriteMask),
      e.stencilFunc !== void 0 && (c.stencilFunc = e.stencilFunc),
      e.stencilRef !== void 0 && (c.stencilRef = e.stencilRef),
      e.stencilFuncMask !== void 0 && (c.stencilFuncMask = e.stencilFuncMask),
      e.stencilFail !== void 0 && (c.stencilFail = e.stencilFail),
      e.stencilZFail !== void 0 && (c.stencilZFail = e.stencilZFail),
      e.stencilZPass !== void 0 && (c.stencilZPass = e.stencilZPass),
      e.stencilWrite !== void 0 && (c.stencilWrite = e.stencilWrite),
      e.wireframe !== void 0 && (c.wireframe = e.wireframe),
      e.wireframeLinewidth !== void 0 &&
        (c.wireframeLinewidth = e.wireframeLinewidth),
      e.wireframeLinecap !== void 0 &&
        (c.wireframeLinecap = e.wireframeLinecap),
      e.wireframeLinejoin !== void 0 &&
        (c.wireframeLinejoin = e.wireframeLinejoin),
      e.rotation !== void 0 && (c.rotation = e.rotation),
      e.linewidth !== void 0 && (c.linewidth = e.linewidth),
      e.dashSize !== void 0 && (c.dashSize = e.dashSize),
      e.gapSize !== void 0 && (c.gapSize = e.gapSize),
      e.scale !== void 0 && (c.scale = e.scale),
      e.polygonOffset !== void 0 && (c.polygonOffset = e.polygonOffset),
      e.polygonOffsetFactor !== void 0 &&
        (c.polygonOffsetFactor = e.polygonOffsetFactor),
      e.polygonOffsetUnits !== void 0 &&
        (c.polygonOffsetUnits = e.polygonOffsetUnits),
      e.dithering !== void 0 && (c.dithering = e.dithering),
      e.alphaToCoverage !== void 0 && (c.alphaToCoverage = e.alphaToCoverage),
      e.premultipliedAlpha !== void 0 &&
        (c.premultipliedAlpha = e.premultipliedAlpha),
      e.forceSinglePass !== void 0 && (c.forceSinglePass = e.forceSinglePass),
      e.visible !== void 0 && (c.visible = e.visible),
      e.toneMapped !== void 0 && (c.toneMapped = e.toneMapped),
      e.userData !== void 0 && (c.userData = e.userData),
      e.vertexColors !== void 0 &&
        (typeof e.vertexColors == "number"
          ? (c.vertexColors = e.vertexColors > 0)
          : (c.vertexColors = e.vertexColors)),
      e.uniforms !== void 0)
    )
      for (const d in e.uniforms) {
        const g = e.uniforms[d];
        switch (((c.uniforms[d] = {}), g.type)) {
          case "t":
            c.uniforms[d].value = a(g.value);
            break;
          case "c":
            c.uniforms[d].value = new Color().setHex(g.value);
            break;
          case "v2":
            c.uniforms[d].value = new Vector2().fromArray(g.value);
            break;
          case "v3":
            c.uniforms[d].value = new Vector3().fromArray(g.value);
            break;
          case "v4":
            c.uniforms[d].value = new Vector4().fromArray(g.value);
            break;
          case "m3":
            c.uniforms[d].value = new Matrix3().fromArray(g.value);
            break;
          case "m4":
            c.uniforms[d].value = new Matrix4().fromArray(g.value);
            break;
          default:
            c.uniforms[d].value = g.value;
        }
      }
    if (
      (e.defines !== void 0 && (c.defines = e.defines),
      e.vertexShader !== void 0 && (c.vertexShader = e.vertexShader),
      e.fragmentShader !== void 0 && (c.fragmentShader = e.fragmentShader),
      e.glslVersion !== void 0 && (c.glslVersion = e.glslVersion),
      e.extensions !== void 0)
    )
      for (const d in e.extensions) c.extensions[d] = e.extensions[d];
    if (
      (e.lights !== void 0 && (c.lights = e.lights),
      e.clipping !== void 0 && (c.clipping = e.clipping),
      e.size !== void 0 && (c.size = e.size),
      e.sizeAttenuation !== void 0 && (c.sizeAttenuation = e.sizeAttenuation),
      e.map !== void 0 && (c.map = a(e.map)),
      e.matcap !== void 0 && (c.matcap = a(e.matcap)),
      e.alphaMap !== void 0 && (c.alphaMap = a(e.alphaMap)),
      e.bumpMap !== void 0 && (c.bumpMap = a(e.bumpMap)),
      e.bumpScale !== void 0 && (c.bumpScale = e.bumpScale),
      e.normalMap !== void 0 && (c.normalMap = a(e.normalMap)),
      e.normalMapType !== void 0 && (c.normalMapType = e.normalMapType),
      e.normalScale !== void 0)
    ) {
      let d = e.normalScale;
      Array.isArray(d) === !1 && (d = [d, d]),
        (c.normalScale = new Vector2().fromArray(d));
    }
    return (
      e.displacementMap !== void 0 &&
        (c.displacementMap = a(e.displacementMap)),
      e.displacementScale !== void 0 &&
        (c.displacementScale = e.displacementScale),
      e.displacementBias !== void 0 &&
        (c.displacementBias = e.displacementBias),
      e.roughnessMap !== void 0 && (c.roughnessMap = a(e.roughnessMap)),
      e.metalnessMap !== void 0 && (c.metalnessMap = a(e.metalnessMap)),
      e.emissiveMap !== void 0 && (c.emissiveMap = a(e.emissiveMap)),
      e.emissiveIntensity !== void 0 &&
        (c.emissiveIntensity = e.emissiveIntensity),
      e.specularMap !== void 0 && (c.specularMap = a(e.specularMap)),
      e.specularIntensityMap !== void 0 &&
        (c.specularIntensityMap = a(e.specularIntensityMap)),
      e.specularColorMap !== void 0 &&
        (c.specularColorMap = a(e.specularColorMap)),
      e.envMap !== void 0 && (c.envMap = a(e.envMap)),
      e.envMapRotation !== void 0 &&
        c.envMapRotation.fromArray(e.envMapRotation),
      e.envMapIntensity !== void 0 && (c.envMapIntensity = e.envMapIntensity),
      e.reflectivity !== void 0 && (c.reflectivity = e.reflectivity),
      e.refractionRatio !== void 0 && (c.refractionRatio = e.refractionRatio),
      e.lightMap !== void 0 && (c.lightMap = a(e.lightMap)),
      e.lightMapIntensity !== void 0 &&
        (c.lightMapIntensity = e.lightMapIntensity),
      e.aoMap !== void 0 && (c.aoMap = a(e.aoMap)),
      e.aoMapIntensity !== void 0 && (c.aoMapIntensity = e.aoMapIntensity),
      e.gradientMap !== void 0 && (c.gradientMap = a(e.gradientMap)),
      e.clearcoatMap !== void 0 && (c.clearcoatMap = a(e.clearcoatMap)),
      e.clearcoatRoughnessMap !== void 0 &&
        (c.clearcoatRoughnessMap = a(e.clearcoatRoughnessMap)),
      e.clearcoatNormalMap !== void 0 &&
        (c.clearcoatNormalMap = a(e.clearcoatNormalMap)),
      e.clearcoatNormalScale !== void 0 &&
        (c.clearcoatNormalScale = new Vector2().fromArray(
          e.clearcoatNormalScale
        )),
      e.iridescenceMap !== void 0 && (c.iridescenceMap = a(e.iridescenceMap)),
      e.iridescenceThicknessMap !== void 0 &&
        (c.iridescenceThicknessMap = a(e.iridescenceThicknessMap)),
      e.transmissionMap !== void 0 &&
        (c.transmissionMap = a(e.transmissionMap)),
      e.thicknessMap !== void 0 && (c.thicknessMap = a(e.thicknessMap)),
      e.anisotropyMap !== void 0 && (c.anisotropyMap = a(e.anisotropyMap)),
      e.sheenColorMap !== void 0 && (c.sheenColorMap = a(e.sheenColorMap)),
      e.sheenRoughnessMap !== void 0 &&
        (c.sheenRoughnessMap = a(e.sheenRoughnessMap)),
      c
    );
  }
  setTextures(e) {
    return (this.textures = e), this;
  }
  static createMaterialFromType(e) {
    const o = {
      ShadowMaterial,
      SpriteMaterial,
      RawShaderMaterial,
      ShaderMaterial,
      PointsMaterial,
      MeshPhysicalMaterial,
      MeshStandardMaterial,
      MeshPhongMaterial,
      MeshToonMaterial,
      MeshNormalMaterial,
      MeshLambertMaterial,
      MeshDepthMaterial,
      MeshDistanceMaterial,
      MeshBasicMaterial,
      MeshMatcapMaterial,
      LineDashedMaterial,
      LineBasicMaterial,
      Material,
    };
    return new o[e]();
  }
}
class LoaderUtils {
  static decodeText(e) {
    if (
      (console.warn(
        "THREE.LoaderUtils: decodeText() has been deprecated with r165 and will be removed with r175. Use TextDecoder instead."
      ),
      typeof TextDecoder < "u")
    )
      return new TextDecoder().decode(e);
    let o = "";
    for (let a = 0, c = e.length; a < c; a++) o += String.fromCharCode(e[a]);
    try {
      return decodeURIComponent(escape(o));
    } catch {
      return o;
    }
  }
  static extractUrlBase(e) {
    const o = e.lastIndexOf("/");
    return o === -1 ? "./" : e.slice(0, o + 1);
  }
  static resolveURL(e, o) {
    return typeof e != "string" || e === ""
      ? ""
      : (/^https?:\/\//i.test(o) &&
          /^\//.test(e) &&
          (o = o.replace(/(^https?:\/\/[^\/]+).*/i, "$1")),
        /^(https?:)?\/\//i.test(e) ||
        /^data:.*,.*$/i.test(e) ||
        /^blob:.*$/i.test(e)
          ? e
          : o + e);
  }
}
class InstancedBufferGeometry extends BufferGeometry {
  constructor() {
    super(),
      (this.isInstancedBufferGeometry = !0),
      (this.type = "InstancedBufferGeometry"),
      (this.instanceCount = 1 / 0);
  }
  copy(e) {
    return super.copy(e), (this.instanceCount = e.instanceCount), this;
  }
  toJSON() {
    const e = super.toJSON();
    return (
      (e.instanceCount = this.instanceCount),
      (e.isInstancedBufferGeometry = !0),
      e
    );
  }
}
class BufferGeometryLoader extends Loader$2 {
  constructor(e) {
    super(e);
  }
  load(e, o, a, c) {
    const d = this,
      g = new FileLoader(d.manager);
    g.setPath(d.path),
      g.setRequestHeader(d.requestHeader),
      g.setWithCredentials(d.withCredentials),
      g.load(
        e,
        function (_) {
          try {
            o(d.parse(JSON.parse(_)));
          } catch (b) {
            c ? c(b) : console.error(b), d.manager.itemError(e);
          }
        },
        a,
        c
      );
  }
  parse(e) {
    const o = {},
      a = {};
    function c(rt, st) {
      if (o[st] !== void 0) return o[st];
      const ct = rt.interleavedBuffers[st],
        it = d(rt, ct.buffer),
        lt = getTypedArray(ct.type, it),
        ot = new InterleavedBuffer(lt, ct.stride);
      return (ot.uuid = ct.uuid), (o[st] = ot), ot;
    }
    function d(rt, st) {
      if (a[st] !== void 0) return a[st];
      const ct = rt.arrayBuffers[st],
        it = new Uint32Array(ct).buffer;
      return (a[st] = it), it;
    }
    const g = e.isInstancedBufferGeometry
        ? new InstancedBufferGeometry()
        : new BufferGeometry(),
      _ = e.data.index;
    if (_ !== void 0) {
      const rt = getTypedArray(_.type, _.array);
      g.setIndex(new BufferAttribute(rt, 1));
    }
    const b = e.data.attributes;
    for (const rt in b) {
      const st = b[rt];
      let at;
      if (st.isInterleavedBufferAttribute) {
        const ct = c(e.data, st.data);
        at = new InterleavedBufferAttribute(
          ct,
          st.itemSize,
          st.offset,
          st.normalized
        );
      } else {
        const ct = getTypedArray(st.type, st.array),
          it = st.isInstancedBufferAttribute
            ? InstancedBufferAttribute
            : BufferAttribute;
        at = new it(ct, st.itemSize, st.normalized);
      }
      st.name !== void 0 && (at.name = st.name),
        st.usage !== void 0 && at.setUsage(st.usage),
        g.setAttribute(rt, at);
    }
    const j = e.data.morphAttributes;
    if (j)
      for (const rt in j) {
        const st = j[rt],
          at = [];
        for (let ct = 0, it = st.length; ct < it; ct++) {
          const lt = st[ct];
          let ot;
          if (lt.isInterleavedBufferAttribute) {
            const ut = c(e.data, lt.data);
            ot = new InterleavedBufferAttribute(
              ut,
              lt.itemSize,
              lt.offset,
              lt.normalized
            );
          } else {
            const ut = getTypedArray(lt.type, lt.array);
            ot = new BufferAttribute(ut, lt.itemSize, lt.normalized);
          }
          lt.name !== void 0 && (ot.name = lt.name), at.push(ot);
        }
        g.morphAttributes[rt] = at;
      }
    e.data.morphTargetsRelative && (g.morphTargetsRelative = !0);
    const _e = e.data.groups || e.data.drawcalls || e.data.offsets;
    if (_e !== void 0)
      for (let rt = 0, st = _e.length; rt !== st; ++rt) {
        const at = _e[rt];
        g.addGroup(at.start, at.count, at.materialIndex);
      }
    const et = e.data.boundingSphere;
    if (et !== void 0) {
      const rt = new Vector3();
      et.center !== void 0 && rt.fromArray(et.center),
        (g.boundingSphere = new Sphere(rt, et.radius));
    }
    return (
      e.name && (g.name = e.name), e.userData && (g.userData = e.userData), g
    );
  }
}
class ObjectLoader extends Loader$2 {
  constructor(e) {
    super(e);
  }
  load(e, o, a, c) {
    const d = this,
      g = this.path === "" ? LoaderUtils.extractUrlBase(e) : this.path;
    this.resourcePath = this.resourcePath || g;
    const _ = new FileLoader(this.manager);
    _.setPath(this.path),
      _.setRequestHeader(this.requestHeader),
      _.setWithCredentials(this.withCredentials),
      _.load(
        e,
        function (b) {
          let j = null;
          try {
            j = JSON.parse(b);
          } catch (_e) {
            c !== void 0 && c(_e),
              console.error(
                "THREE:ObjectLoader: Can't parse " + e + ".",
                _e.message
              );
            return;
          }
          const $ = j.metadata;
          if (
            $ === void 0 ||
            $.type === void 0 ||
            $.type.toLowerCase() === "geometry"
          ) {
            c !== void 0 && c(new Error("THREE.ObjectLoader: Can't load " + e)),
              console.error("THREE.ObjectLoader: Can't load " + e);
            return;
          }
          d.parse(j, o);
        },
        a,
        c
      );
  }
  async loadAsync(e, o) {
    const a = this,
      c = this.path === "" ? LoaderUtils.extractUrlBase(e) : this.path;
    this.resourcePath = this.resourcePath || c;
    const d = new FileLoader(this.manager);
    d.setPath(this.path),
      d.setRequestHeader(this.requestHeader),
      d.setWithCredentials(this.withCredentials);
    const g = await d.loadAsync(e, o),
      _ = JSON.parse(g),
      b = _.metadata;
    if (
      b === void 0 ||
      b.type === void 0 ||
      b.type.toLowerCase() === "geometry"
    )
      throw new Error("THREE.ObjectLoader: Can't load " + e);
    return await a.parseAsync(_);
  }
  parse(e, o) {
    const a = this.parseAnimations(e.animations),
      c = this.parseShapes(e.shapes),
      d = this.parseGeometries(e.geometries, c),
      g = this.parseImages(e.images, function () {
        o !== void 0 && o(j);
      }),
      _ = this.parseTextures(e.textures, g),
      b = this.parseMaterials(e.materials, _),
      j = this.parseObject(e.object, d, b, _, a),
      $ = this.parseSkeletons(e.skeletons, j);
    if ((this.bindSkeletons(j, $), this.bindLightTargets(j), o !== void 0)) {
      let _e = !1;
      for (const et in g)
        if (g[et].data instanceof HTMLImageElement) {
          _e = !0;
          break;
        }
      _e === !1 && o(j);
    }
    return j;
  }
  async parseAsync(e) {
    const o = this.parseAnimations(e.animations),
      a = this.parseShapes(e.shapes),
      c = this.parseGeometries(e.geometries, a),
      d = await this.parseImagesAsync(e.images),
      g = this.parseTextures(e.textures, d),
      _ = this.parseMaterials(e.materials, g),
      b = this.parseObject(e.object, c, _, g, o),
      j = this.parseSkeletons(e.skeletons, b);
    return this.bindSkeletons(b, j), this.bindLightTargets(b), b;
  }
  parseShapes(e) {
    const o = {};
    if (e !== void 0)
      for (let a = 0, c = e.length; a < c; a++) {
        const d = new Shape().fromJSON(e[a]);
        o[d.uuid] = d;
      }
    return o;
  }
  parseSkeletons(e, o) {
    const a = {},
      c = {};
    if (
      (o.traverse(function (d) {
        d.isBone && (c[d.uuid] = d);
      }),
      e !== void 0)
    )
      for (let d = 0, g = e.length; d < g; d++) {
        const _ = new Skeleton().fromJSON(e[d], c);
        a[_.uuid] = _;
      }
    return a;
  }
  parseGeometries(e, o) {
    const a = {};
    if (e !== void 0) {
      const c = new BufferGeometryLoader();
      for (let d = 0, g = e.length; d < g; d++) {
        let _;
        const b = e[d];
        switch (b.type) {
          case "BufferGeometry":
          case "InstancedBufferGeometry":
            _ = c.parse(b);
            break;
          default:
            b.type in Geometries
              ? (_ = Geometries[b.type].fromJSON(b, o))
              : console.warn(
                  `THREE.ObjectLoader: Unsupported geometry type "${b.type}"`
                );
        }
        (_.uuid = b.uuid),
          b.name !== void 0 && (_.name = b.name),
          b.userData !== void 0 && (_.userData = b.userData),
          (a[b.uuid] = _);
      }
    }
    return a;
  }
  parseMaterials(e, o) {
    const a = {},
      c = {};
    if (e !== void 0) {
      const d = new MaterialLoader();
      d.setTextures(o);
      for (let g = 0, _ = e.length; g < _; g++) {
        const b = e[g];
        a[b.uuid] === void 0 && (a[b.uuid] = d.parse(b)),
          (c[b.uuid] = a[b.uuid]);
      }
    }
    return c;
  }
  parseAnimations(e) {
    const o = {};
    if (e !== void 0)
      for (let a = 0; a < e.length; a++) {
        const c = e[a],
          d = AnimationClip.parse(c);
        o[d.uuid] = d;
      }
    return o;
  }
  parseImages(e, o) {
    const a = this,
      c = {};
    let d;
    function g(b) {
      return (
        a.manager.itemStart(b),
        d.load(
          b,
          function () {
            a.manager.itemEnd(b);
          },
          void 0,
          function () {
            a.manager.itemError(b), a.manager.itemEnd(b);
          }
        )
      );
    }
    function _(b) {
      if (typeof b == "string") {
        const j = b,
          $ = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(j) ? j : a.resourcePath + j;
        return g($);
      } else
        return b.data
          ? {
              data: getTypedArray(b.type, b.data),
              width: b.width,
              height: b.height,
            }
          : null;
    }
    if (e !== void 0 && e.length > 0) {
      const b = new LoadingManager(o);
      (d = new ImageLoader(b)), d.setCrossOrigin(this.crossOrigin);
      for (let j = 0, $ = e.length; j < $; j++) {
        const _e = e[j],
          et = _e.url;
        if (Array.isArray(et)) {
          const rt = [];
          for (let st = 0, at = et.length; st < at; st++) {
            const ct = et[st],
              it = _(ct);
            it !== null &&
              (it instanceof HTMLImageElement
                ? rt.push(it)
                : rt.push(new DataTexture(it.data, it.width, it.height)));
          }
          c[_e.uuid] = new Source(rt);
        } else {
          const rt = _(_e.url);
          c[_e.uuid] = new Source(rt);
        }
      }
    }
    return c;
  }
  async parseImagesAsync(e) {
    const o = this,
      a = {};
    let c;
    async function d(g) {
      if (typeof g == "string") {
        const _ = g,
          b = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(_) ? _ : o.resourcePath + _;
        return await c.loadAsync(b);
      } else
        return g.data
          ? {
              data: getTypedArray(g.type, g.data),
              width: g.width,
              height: g.height,
            }
          : null;
    }
    if (e !== void 0 && e.length > 0) {
      (c = new ImageLoader(this.manager)), c.setCrossOrigin(this.crossOrigin);
      for (let g = 0, _ = e.length; g < _; g++) {
        const b = e[g],
          j = b.url;
        if (Array.isArray(j)) {
          const $ = [];
          for (let _e = 0, et = j.length; _e < et; _e++) {
            const rt = j[_e],
              st = await d(rt);
            st !== null &&
              (st instanceof HTMLImageElement
                ? $.push(st)
                : $.push(new DataTexture(st.data, st.width, st.height)));
          }
          a[b.uuid] = new Source($);
        } else {
          const $ = await d(b.url);
          a[b.uuid] = new Source($);
        }
      }
    }
    return a;
  }
  parseTextures(e, o) {
    function a(d, g) {
      return typeof d == "number"
        ? d
        : (console.warn(
            "THREE.ObjectLoader.parseTexture: Constant should be in numeric form.",
            d
          ),
          g[d]);
    }
    const c = {};
    if (e !== void 0)
      for (let d = 0, g = e.length; d < g; d++) {
        const _ = e[d];
        _.image === void 0 &&
          console.warn('THREE.ObjectLoader: No "image" specified for', _.uuid),
          o[_.image] === void 0 &&
            console.warn("THREE.ObjectLoader: Undefined image", _.image);
        const b = o[_.image],
          j = b.data;
        let $;
        Array.isArray(j)
          ? (($ = new CubeTexture()), j.length === 6 && ($.needsUpdate = !0))
          : (j && j.data ? ($ = new DataTexture()) : ($ = new Texture()),
            j && ($.needsUpdate = !0)),
          ($.source = b),
          ($.uuid = _.uuid),
          _.name !== void 0 && ($.name = _.name),
          _.mapping !== void 0 && ($.mapping = a(_.mapping, TEXTURE_MAPPING)),
          _.channel !== void 0 && ($.channel = _.channel),
          _.offset !== void 0 && $.offset.fromArray(_.offset),
          _.repeat !== void 0 && $.repeat.fromArray(_.repeat),
          _.center !== void 0 && $.center.fromArray(_.center),
          _.rotation !== void 0 && ($.rotation = _.rotation),
          _.wrap !== void 0 &&
            (($.wrapS = a(_.wrap[0], TEXTURE_WRAPPING)),
            ($.wrapT = a(_.wrap[1], TEXTURE_WRAPPING))),
          _.format !== void 0 && ($.format = _.format),
          _.internalFormat !== void 0 && ($.internalFormat = _.internalFormat),
          _.type !== void 0 && ($.type = _.type),
          _.colorSpace !== void 0 && ($.colorSpace = _.colorSpace),
          _.minFilter !== void 0 &&
            ($.minFilter = a(_.minFilter, TEXTURE_FILTER)),
          _.magFilter !== void 0 &&
            ($.magFilter = a(_.magFilter, TEXTURE_FILTER)),
          _.anisotropy !== void 0 && ($.anisotropy = _.anisotropy),
          _.flipY !== void 0 && ($.flipY = _.flipY),
          _.generateMipmaps !== void 0 &&
            ($.generateMipmaps = _.generateMipmaps),
          _.premultiplyAlpha !== void 0 &&
            ($.premultiplyAlpha = _.premultiplyAlpha),
          _.unpackAlignment !== void 0 &&
            ($.unpackAlignment = _.unpackAlignment),
          _.compareFunction !== void 0 &&
            ($.compareFunction = _.compareFunction),
          _.userData !== void 0 && ($.userData = _.userData),
          (c[_.uuid] = $);
      }
    return c;
  }
  parseObject(e, o, a, c, d) {
    let g;
    function _(et) {
      return (
        o[et] === void 0 &&
          console.warn("THREE.ObjectLoader: Undefined geometry", et),
        o[et]
      );
    }
    function b(et) {
      if (et !== void 0) {
        if (Array.isArray(et)) {
          const rt = [];
          for (let st = 0, at = et.length; st < at; st++) {
            const ct = et[st];
            a[ct] === void 0 &&
              console.warn("THREE.ObjectLoader: Undefined material", ct),
              rt.push(a[ct]);
          }
          return rt;
        }
        return (
          a[et] === void 0 &&
            console.warn("THREE.ObjectLoader: Undefined material", et),
          a[et]
        );
      }
    }
    function j(et) {
      return (
        c[et] === void 0 &&
          console.warn("THREE.ObjectLoader: Undefined texture", et),
        c[et]
      );
    }
    let $, _e;
    switch (e.type) {
      case "Scene":
        (g = new Scene()),
          e.background !== void 0 &&
            (Number.isInteger(e.background)
              ? (g.background = new Color(e.background))
              : (g.background = j(e.background))),
          e.environment !== void 0 && (g.environment = j(e.environment)),
          e.fog !== void 0 &&
            (e.fog.type === "Fog"
              ? (g.fog = new Fog(e.fog.color, e.fog.near, e.fog.far))
              : e.fog.type === "FogExp2" &&
                (g.fog = new FogExp2(e.fog.color, e.fog.density)),
            e.fog.name !== "" && (g.fog.name = e.fog.name)),
          e.backgroundBlurriness !== void 0 &&
            (g.backgroundBlurriness = e.backgroundBlurriness),
          e.backgroundIntensity !== void 0 &&
            (g.backgroundIntensity = e.backgroundIntensity),
          e.backgroundRotation !== void 0 &&
            g.backgroundRotation.fromArray(e.backgroundRotation),
          e.environmentIntensity !== void 0 &&
            (g.environmentIntensity = e.environmentIntensity),
          e.environmentRotation !== void 0 &&
            g.environmentRotation.fromArray(e.environmentRotation);
        break;
      case "PerspectiveCamera":
        (g = new PerspectiveCamera(e.fov, e.aspect, e.near, e.far)),
          e.focus !== void 0 && (g.focus = e.focus),
          e.zoom !== void 0 && (g.zoom = e.zoom),
          e.filmGauge !== void 0 && (g.filmGauge = e.filmGauge),
          e.filmOffset !== void 0 && (g.filmOffset = e.filmOffset),
          e.view !== void 0 && (g.view = Object.assign({}, e.view));
        break;
      case "OrthographicCamera":
        (g = new OrthographicCamera(
          e.left,
          e.right,
          e.top,
          e.bottom,
          e.near,
          e.far
        )),
          e.zoom !== void 0 && (g.zoom = e.zoom),
          e.view !== void 0 && (g.view = Object.assign({}, e.view));
        break;
      case "AmbientLight":
        g = new AmbientLight(e.color, e.intensity);
        break;
      case "DirectionalLight":
        (g = new DirectionalLight(e.color, e.intensity)),
          (g.target = e.target || "");
        break;
      case "PointLight":
        g = new PointLight(e.color, e.intensity, e.distance, e.decay);
        break;
      case "RectAreaLight":
        g = new RectAreaLight(e.color, e.intensity, e.width, e.height);
        break;
      case "SpotLight":
        (g = new SpotLight(
          e.color,
          e.intensity,
          e.distance,
          e.angle,
          e.penumbra,
          e.decay
        )),
          (g.target = e.target || "");
        break;
      case "HemisphereLight":
        g = new HemisphereLight(e.color, e.groundColor, e.intensity);
        break;
      case "LightProbe":
        g = new LightProbe().fromJSON(e);
        break;
      case "SkinnedMesh":
        ($ = _(e.geometry)),
          (_e = b(e.material)),
          (g = new SkinnedMesh($, _e)),
          e.bindMode !== void 0 && (g.bindMode = e.bindMode),
          e.bindMatrix !== void 0 && g.bindMatrix.fromArray(e.bindMatrix),
          e.skeleton !== void 0 && (g.skeleton = e.skeleton);
        break;
      case "Mesh":
        ($ = _(e.geometry)), (_e = b(e.material)), (g = new Mesh($, _e));
        break;
      case "InstancedMesh":
        ($ = _(e.geometry)), (_e = b(e.material));
        const et = e.count,
          rt = e.instanceMatrix,
          st = e.instanceColor;
        (g = new InstancedMesh($, _e, et)),
          (g.instanceMatrix = new InstancedBufferAttribute(
            new Float32Array(rt.array),
            16
          )),
          st !== void 0 &&
            (g.instanceColor = new InstancedBufferAttribute(
              new Float32Array(st.array),
              st.itemSize
            ));
        break;
      case "BatchedMesh":
        ($ = _(e.geometry)),
          (_e = b(e.material)),
          (g = new BatchedMesh(
            e.maxInstanceCount,
            e.maxVertexCount,
            e.maxIndexCount,
            _e
          )),
          (g.geometry = $),
          (g.perObjectFrustumCulled = e.perObjectFrustumCulled),
          (g.sortObjects = e.sortObjects),
          (g._drawRanges = e.drawRanges),
          (g._reservedRanges = e.reservedRanges),
          (g._visibility = e.visibility),
          (g._active = e.active),
          (g._bounds = e.bounds.map((at) => {
            const ct = new Box3();
            ct.min.fromArray(at.boxMin), ct.max.fromArray(at.boxMax);
            const it = new Sphere();
            return (
              (it.radius = at.sphereRadius),
              it.center.fromArray(at.sphereCenter),
              {
                boxInitialized: at.boxInitialized,
                box: ct,
                sphereInitialized: at.sphereInitialized,
                sphere: it,
              }
            );
          })),
          (g._maxInstanceCount = e.maxInstanceCount),
          (g._maxVertexCount = e.maxVertexCount),
          (g._maxIndexCount = e.maxIndexCount),
          (g._geometryInitialized = e.geometryInitialized),
          (g._geometryCount = e.geometryCount),
          (g._matricesTexture = j(e.matricesTexture.uuid)),
          e.colorsTexture !== void 0 &&
            (g._colorsTexture = j(e.colorsTexture.uuid));
        break;
      case "LOD":
        g = new LOD();
        break;
      case "Line":
        g = new Line(_(e.geometry), b(e.material));
        break;
      case "LineLoop":
        g = new LineLoop(_(e.geometry), b(e.material));
        break;
      case "LineSegments":
        g = new LineSegments(_(e.geometry), b(e.material));
        break;
      case "PointCloud":
      case "Points":
        g = new Points(_(e.geometry), b(e.material));
        break;
      case "Sprite":
        g = new Sprite(b(e.material));
        break;
      case "Group":
        g = new Group();
        break;
      case "Bone":
        g = new Bone();
        break;
      default:
        g = new Object3D();
    }
    if (
      ((g.uuid = e.uuid),
      e.name !== void 0 && (g.name = e.name),
      e.matrix !== void 0
        ? (g.matrix.fromArray(e.matrix),
          e.matrixAutoUpdate !== void 0 &&
            (g.matrixAutoUpdate = e.matrixAutoUpdate),
          g.matrixAutoUpdate &&
            g.matrix.decompose(g.position, g.quaternion, g.scale))
        : (e.position !== void 0 && g.position.fromArray(e.position),
          e.rotation !== void 0 && g.rotation.fromArray(e.rotation),
          e.quaternion !== void 0 && g.quaternion.fromArray(e.quaternion),
          e.scale !== void 0 && g.scale.fromArray(e.scale)),
      e.up !== void 0 && g.up.fromArray(e.up),
      e.castShadow !== void 0 && (g.castShadow = e.castShadow),
      e.receiveShadow !== void 0 && (g.receiveShadow = e.receiveShadow),
      e.shadow &&
        (e.shadow.intensity !== void 0 &&
          (g.shadow.intensity = e.shadow.intensity),
        e.shadow.bias !== void 0 && (g.shadow.bias = e.shadow.bias),
        e.shadow.normalBias !== void 0 &&
          (g.shadow.normalBias = e.shadow.normalBias),
        e.shadow.radius !== void 0 && (g.shadow.radius = e.shadow.radius),
        e.shadow.mapSize !== void 0 &&
          g.shadow.mapSize.fromArray(e.shadow.mapSize),
        e.shadow.camera !== void 0 &&
          (g.shadow.camera = this.parseObject(e.shadow.camera))),
      e.visible !== void 0 && (g.visible = e.visible),
      e.frustumCulled !== void 0 && (g.frustumCulled = e.frustumCulled),
      e.renderOrder !== void 0 && (g.renderOrder = e.renderOrder),
      e.userData !== void 0 && (g.userData = e.userData),
      e.layers !== void 0 && (g.layers.mask = e.layers),
      e.children !== void 0)
    ) {
      const et = e.children;
      for (let rt = 0; rt < et.length; rt++)
        g.add(this.parseObject(et[rt], o, a, c, d));
    }
    if (e.animations !== void 0) {
      const et = e.animations;
      for (let rt = 0; rt < et.length; rt++) {
        const st = et[rt];
        g.animations.push(d[st]);
      }
    }
    if (e.type === "LOD") {
      e.autoUpdate !== void 0 && (g.autoUpdate = e.autoUpdate);
      const et = e.levels;
      for (let rt = 0; rt < et.length; rt++) {
        const st = et[rt],
          at = g.getObjectByProperty("uuid", st.object);
        at !== void 0 && g.addLevel(at, st.distance, st.hysteresis);
      }
    }
    return g;
  }
  bindSkeletons(e, o) {
    Object.keys(o).length !== 0 &&
      e.traverse(function (a) {
        if (a.isSkinnedMesh === !0 && a.skeleton !== void 0) {
          const c = o[a.skeleton];
          c === void 0
            ? console.warn(
                "THREE.ObjectLoader: No skeleton found with UUID:",
                a.skeleton
              )
            : a.bind(c, a.bindMatrix);
        }
      });
  }
  bindLightTargets(e) {
    e.traverse(function (o) {
      if (o.isDirectionalLight || o.isSpotLight) {
        const a = o.target,
          c = e.getObjectByProperty("uuid", a);
        c !== void 0 ? (o.target = c) : (o.target = new Object3D());
      }
    });
  }
}
const TEXTURE_MAPPING = {
    UVMapping,
    CubeReflectionMapping,
    CubeRefractionMapping,
    EquirectangularReflectionMapping,
    EquirectangularRefractionMapping,
    CubeUVReflectionMapping,
  },
  TEXTURE_WRAPPING = {
    RepeatWrapping,
    ClampToEdgeWrapping,
    MirroredRepeatWrapping,
  },
  TEXTURE_FILTER = {
    NearestFilter,
    NearestMipmapNearestFilter,
    NearestMipmapLinearFilter,
    LinearFilter,
    LinearMipmapNearestFilter,
    LinearMipmapLinearFilter,
  };
class ImageBitmapLoader extends Loader$2 {
  constructor(e) {
    super(e),
      (this.isImageBitmapLoader = !0),
      typeof createImageBitmap > "u" &&
        console.warn(
          "THREE.ImageBitmapLoader: createImageBitmap() not supported."
        ),
      typeof fetch > "u" &&
        console.warn("THREE.ImageBitmapLoader: fetch() not supported."),
      (this.options = { premultiplyAlpha: "none" });
  }
  setOptions(e) {
    return (this.options = e), this;
  }
  load(e, o, a, c) {
    e === void 0 && (e = ""),
      this.path !== void 0 && (e = this.path + e),
      (e = this.manager.resolveURL(e));
    const d = this,
      g = Cache.get(e);
    if (g !== void 0) {
      if ((d.manager.itemStart(e), g.then)) {
        g.then((j) => {
          o && o(j), d.manager.itemEnd(e);
        }).catch((j) => {
          c && c(j);
        });
        return;
      }
      return (
        setTimeout(function () {
          o && o(g), d.manager.itemEnd(e);
        }, 0),
        g
      );
    }
    const _ = {};
    (_.credentials =
      this.crossOrigin === "anonymous" ? "same-origin" : "include"),
      (_.headers = this.requestHeader);
    const b = fetch(e, _)
      .then(function (j) {
        return j.blob();
      })
      .then(function (j) {
        return createImageBitmap(
          j,
          Object.assign(d.options, { colorSpaceConversion: "none" })
        );
      })
      .then(function (j) {
        return Cache.add(e, j), o && o(j), d.manager.itemEnd(e), j;
      })
      .catch(function (j) {
        c && c(j),
          Cache.remove(e),
          d.manager.itemError(e),
          d.manager.itemEnd(e);
      });
    Cache.add(e, b), d.manager.itemStart(e);
  }
}
let _context;
class AudioContext {
  static getContext() {
    return (
      _context === void 0 &&
        (_context = new (window.AudioContext || window.webkitAudioContext)()),
      _context
    );
  }
  static setContext(e) {
    _context = e;
  }
}
class AudioLoader extends Loader$2 {
  constructor(e) {
    super(e);
  }
  load(e, o, a, c) {
    const d = this,
      g = new FileLoader(this.manager);
    g.setResponseType("arraybuffer"),
      g.setPath(this.path),
      g.setRequestHeader(this.requestHeader),
      g.setWithCredentials(this.withCredentials),
      g.load(
        e,
        function (b) {
          try {
            const j = b.slice(0);
            AudioContext.getContext()
              .decodeAudioData(j, function (_e) {
                o(_e);
              })
              .catch(_);
          } catch (j) {
            _(j);
          }
        },
        a,
        c
      );
    function _(b) {
      c ? c(b) : console.error(b), d.manager.itemError(e);
    }
  }
}
const _eyeRight = new Matrix4(),
  _eyeLeft = new Matrix4(),
  _projectionMatrix = new Matrix4();
class StereoCamera {
  constructor() {
    (this.type = "StereoCamera"),
      (this.aspect = 1),
      (this.eyeSep = 0.064),
      (this.cameraL = new PerspectiveCamera()),
      this.cameraL.layers.enable(1),
      (this.cameraL.matrixAutoUpdate = !1),
      (this.cameraR = new PerspectiveCamera()),
      this.cameraR.layers.enable(2),
      (this.cameraR.matrixAutoUpdate = !1),
      (this._cache = {
        focus: null,
        fov: null,
        aspect: null,
        near: null,
        far: null,
        zoom: null,
        eyeSep: null,
      });
  }
  update(e) {
    const o = this._cache;
    if (
      o.focus !== e.focus ||
      o.fov !== e.fov ||
      o.aspect !== e.aspect * this.aspect ||
      o.near !== e.near ||
      o.far !== e.far ||
      o.zoom !== e.zoom ||
      o.eyeSep !== this.eyeSep
    ) {
      (o.focus = e.focus),
        (o.fov = e.fov),
        (o.aspect = e.aspect * this.aspect),
        (o.near = e.near),
        (o.far = e.far),
        (o.zoom = e.zoom),
        (o.eyeSep = this.eyeSep),
        _projectionMatrix.copy(e.projectionMatrix);
      const c = o.eyeSep / 2,
        d = (c * o.near) / o.focus,
        g = (o.near * Math.tan(DEG2RAD * o.fov * 0.5)) / o.zoom;
      let _, b;
      (_eyeLeft.elements[12] = -c),
        (_eyeRight.elements[12] = c),
        (_ = -g * o.aspect + d),
        (b = g * o.aspect + d),
        (_projectionMatrix.elements[0] = (2 * o.near) / (b - _)),
        (_projectionMatrix.elements[8] = (b + _) / (b - _)),
        this.cameraL.projectionMatrix.copy(_projectionMatrix),
        (_ = -g * o.aspect - d),
        (b = g * o.aspect - d),
        (_projectionMatrix.elements[0] = (2 * o.near) / (b - _)),
        (_projectionMatrix.elements[8] = (b + _) / (b - _)),
        this.cameraR.projectionMatrix.copy(_projectionMatrix);
    }
    this.cameraL.matrixWorld.copy(e.matrixWorld).multiply(_eyeLeft),
      this.cameraR.matrixWorld.copy(e.matrixWorld).multiply(_eyeRight);
  }
}
class Clock {
  constructor(e = !0) {
    (this.autoStart = e),
      (this.startTime = 0),
      (this.oldTime = 0),
      (this.elapsedTime = 0),
      (this.running = !1);
  }
  start() {
    (this.startTime = now()),
      (this.oldTime = this.startTime),
      (this.elapsedTime = 0),
      (this.running = !0);
  }
  stop() {
    this.getElapsedTime(), (this.running = !1), (this.autoStart = !1);
  }
  getElapsedTime() {
    return this.getDelta(), this.elapsedTime;
  }
  getDelta() {
    let e = 0;
    if (this.autoStart && !this.running) return this.start(), 0;
    if (this.running) {
      const o = now();
      (e = (o - this.oldTime) / 1e3),
        (this.oldTime = o),
        (this.elapsedTime += e);
    }
    return e;
  }
}
function now() {
  return (typeof performance > "u" ? Date : performance).now();
}
const _position$1 = new Vector3(),
  _quaternion$1 = new Quaternion(),
  _scale$1 = new Vector3(),
  _orientation$1 = new Vector3();
class AudioListener extends Object3D {
  constructor() {
    super(),
      (this.type = "AudioListener"),
      (this.context = AudioContext.getContext()),
      (this.gain = this.context.createGain()),
      this.gain.connect(this.context.destination),
      (this.filter = null),
      (this.timeDelta = 0),
      (this._clock = new Clock());
  }
  getInput() {
    return this.gain;
  }
  removeFilter() {
    return (
      this.filter !== null &&
        (this.gain.disconnect(this.filter),
        this.filter.disconnect(this.context.destination),
        this.gain.connect(this.context.destination),
        (this.filter = null)),
      this
    );
  }
  getFilter() {
    return this.filter;
  }
  setFilter(e) {
    return (
      this.filter !== null
        ? (this.gain.disconnect(this.filter),
          this.filter.disconnect(this.context.destination))
        : this.gain.disconnect(this.context.destination),
      (this.filter = e),
      this.gain.connect(this.filter),
      this.filter.connect(this.context.destination),
      this
    );
  }
  getMasterVolume() {
    return this.gain.gain.value;
  }
  setMasterVolume(e) {
    return (
      this.gain.gain.setTargetAtTime(e, this.context.currentTime, 0.01), this
    );
  }
  updateMatrixWorld(e) {
    super.updateMatrixWorld(e);
    const o = this.context.listener,
      a = this.up;
    if (
      ((this.timeDelta = this._clock.getDelta()),
      this.matrixWorld.decompose(_position$1, _quaternion$1, _scale$1),
      _orientation$1.set(0, 0, -1).applyQuaternion(_quaternion$1),
      o.positionX)
    ) {
      const c = this.context.currentTime + this.timeDelta;
      o.positionX.linearRampToValueAtTime(_position$1.x, c),
        o.positionY.linearRampToValueAtTime(_position$1.y, c),
        o.positionZ.linearRampToValueAtTime(_position$1.z, c),
        o.forwardX.linearRampToValueAtTime(_orientation$1.x, c),
        o.forwardY.linearRampToValueAtTime(_orientation$1.y, c),
        o.forwardZ.linearRampToValueAtTime(_orientation$1.z, c),
        o.upX.linearRampToValueAtTime(a.x, c),
        o.upY.linearRampToValueAtTime(a.y, c),
        o.upZ.linearRampToValueAtTime(a.z, c);
    } else
      o.setPosition(_position$1.x, _position$1.y, _position$1.z),
        o.setOrientation(
          _orientation$1.x,
          _orientation$1.y,
          _orientation$1.z,
          a.x,
          a.y,
          a.z
        );
  }
}
class Audio extends Object3D {
  constructor(e) {
    super(),
      (this.type = "Audio"),
      (this.listener = e),
      (this.context = e.context),
      (this.gain = this.context.createGain()),
      this.gain.connect(e.getInput()),
      (this.autoplay = !1),
      (this.buffer = null),
      (this.detune = 0),
      (this.loop = !1),
      (this.loopStart = 0),
      (this.loopEnd = 0),
      (this.offset = 0),
      (this.duration = void 0),
      (this.playbackRate = 1),
      (this.isPlaying = !1),
      (this.hasPlaybackControl = !0),
      (this.source = null),
      (this.sourceType = "empty"),
      (this._startedAt = 0),
      (this._progress = 0),
      (this._connected = !1),
      (this.filters = []);
  }
  getOutput() {
    return this.gain;
  }
  setNodeSource(e) {
    return (
      (this.hasPlaybackControl = !1),
      (this.sourceType = "audioNode"),
      (this.source = e),
      this.connect(),
      this
    );
  }
  setMediaElementSource(e) {
    return (
      (this.hasPlaybackControl = !1),
      (this.sourceType = "mediaNode"),
      (this.source = this.context.createMediaElementSource(e)),
      this.connect(),
      this
    );
  }
  setMediaStreamSource(e) {
    return (
      (this.hasPlaybackControl = !1),
      (this.sourceType = "mediaStreamNode"),
      (this.source = this.context.createMediaStreamSource(e)),
      this.connect(),
      this
    );
  }
  setBuffer(e) {
    return (
      (this.buffer = e),
      (this.sourceType = "buffer"),
      this.autoplay && this.play(),
      this
    );
  }
  play(e = 0) {
    if (this.isPlaying === !0) {
      console.warn("THREE.Audio: Audio is already playing.");
      return;
    }
    if (this.hasPlaybackControl === !1) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    this._startedAt = this.context.currentTime + e;
    const o = this.context.createBufferSource();
    return (
      (o.buffer = this.buffer),
      (o.loop = this.loop),
      (o.loopStart = this.loopStart),
      (o.loopEnd = this.loopEnd),
      (o.onended = this.onEnded.bind(this)),
      o.start(this._startedAt, this._progress + this.offset, this.duration),
      (this.isPlaying = !0),
      (this.source = o),
      this.setDetune(this.detune),
      this.setPlaybackRate(this.playbackRate),
      this.connect()
    );
  }
  pause() {
    if (this.hasPlaybackControl === !1) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    return (
      this.isPlaying === !0 &&
        ((this._progress +=
          Math.max(this.context.currentTime - this._startedAt, 0) *
          this.playbackRate),
        this.loop === !0 &&
          (this._progress =
            this._progress % (this.duration || this.buffer.duration)),
        this.source.stop(),
        (this.source.onended = null),
        (this.isPlaying = !1)),
      this
    );
  }
  stop() {
    if (this.hasPlaybackControl === !1) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    return (
      (this._progress = 0),
      this.source !== null &&
        (this.source.stop(), (this.source.onended = null)),
      (this.isPlaying = !1),
      this
    );
  }
  connect() {
    if (this.filters.length > 0) {
      this.source.connect(this.filters[0]);
      for (let e = 1, o = this.filters.length; e < o; e++)
        this.filters[e - 1].connect(this.filters[e]);
      this.filters[this.filters.length - 1].connect(this.getOutput());
    } else this.source.connect(this.getOutput());
    return (this._connected = !0), this;
  }
  disconnect() {
    if (this._connected !== !1) {
      if (this.filters.length > 0) {
        this.source.disconnect(this.filters[0]);
        for (let e = 1, o = this.filters.length; e < o; e++)
          this.filters[e - 1].disconnect(this.filters[e]);
        this.filters[this.filters.length - 1].disconnect(this.getOutput());
      } else this.source.disconnect(this.getOutput());
      return (this._connected = !1), this;
    }
  }
  getFilters() {
    return this.filters;
  }
  setFilters(e) {
    return (
      e || (e = []),
      this._connected === !0
        ? (this.disconnect(), (this.filters = e.slice()), this.connect())
        : (this.filters = e.slice()),
      this
    );
  }
  setDetune(e) {
    return (
      (this.detune = e),
      this.isPlaying === !0 &&
        this.source.detune !== void 0 &&
        this.source.detune.setTargetAtTime(
          this.detune,
          this.context.currentTime,
          0.01
        ),
      this
    );
  }
  getDetune() {
    return this.detune;
  }
  getFilter() {
    return this.getFilters()[0];
  }
  setFilter(e) {
    return this.setFilters(e ? [e] : []);
  }
  setPlaybackRate(e) {
    if (this.hasPlaybackControl === !1) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    return (
      (this.playbackRate = e),
      this.isPlaying === !0 &&
        this.source.playbackRate.setTargetAtTime(
          this.playbackRate,
          this.context.currentTime,
          0.01
        ),
      this
    );
  }
  getPlaybackRate() {
    return this.playbackRate;
  }
  onEnded() {
    this.isPlaying = !1;
  }
  getLoop() {
    return this.hasPlaybackControl === !1
      ? (console.warn("THREE.Audio: this Audio has no playback control."), !1)
      : this.loop;
  }
  setLoop(e) {
    if (this.hasPlaybackControl === !1) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    return (
      (this.loop = e),
      this.isPlaying === !0 && (this.source.loop = this.loop),
      this
    );
  }
  setLoopStart(e) {
    return (this.loopStart = e), this;
  }
  setLoopEnd(e) {
    return (this.loopEnd = e), this;
  }
  getVolume() {
    return this.gain.gain.value;
  }
  setVolume(e) {
    return (
      this.gain.gain.setTargetAtTime(e, this.context.currentTime, 0.01), this
    );
  }
}
const _position = new Vector3(),
  _quaternion = new Quaternion(),
  _scale = new Vector3(),
  _orientation = new Vector3();
class PositionalAudio extends Audio {
  constructor(e) {
    super(e),
      (this.panner = this.context.createPanner()),
      (this.panner.panningModel = "HRTF"),
      this.panner.connect(this.gain);
  }
  connect() {
    super.connect(), this.panner.connect(this.gain);
  }
  disconnect() {
    super.disconnect(), this.panner.disconnect(this.gain);
  }
  getOutput() {
    return this.panner;
  }
  getRefDistance() {
    return this.panner.refDistance;
  }
  setRefDistance(e) {
    return (this.panner.refDistance = e), this;
  }
  getRolloffFactor() {
    return this.panner.rolloffFactor;
  }
  setRolloffFactor(e) {
    return (this.panner.rolloffFactor = e), this;
  }
  getDistanceModel() {
    return this.panner.distanceModel;
  }
  setDistanceModel(e) {
    return (this.panner.distanceModel = e), this;
  }
  getMaxDistance() {
    return this.panner.maxDistance;
  }
  setMaxDistance(e) {
    return (this.panner.maxDistance = e), this;
  }
  setDirectionalCone(e, o, a) {
    return (
      (this.panner.coneInnerAngle = e),
      (this.panner.coneOuterAngle = o),
      (this.panner.coneOuterGain = a),
      this
    );
  }
  updateMatrixWorld(e) {
    if (
      (super.updateMatrixWorld(e),
      this.hasPlaybackControl === !0 && this.isPlaying === !1)
    )
      return;
    this.matrixWorld.decompose(_position, _quaternion, _scale),
      _orientation.set(0, 0, 1).applyQuaternion(_quaternion);
    const o = this.panner;
    if (o.positionX) {
      const a = this.context.currentTime + this.listener.timeDelta;
      o.positionX.linearRampToValueAtTime(_position.x, a),
        o.positionY.linearRampToValueAtTime(_position.y, a),
        o.positionZ.linearRampToValueAtTime(_position.z, a),
        o.orientationX.linearRampToValueAtTime(_orientation.x, a),
        o.orientationY.linearRampToValueAtTime(_orientation.y, a),
        o.orientationZ.linearRampToValueAtTime(_orientation.z, a);
    } else
      o.setPosition(_position.x, _position.y, _position.z),
        o.setOrientation(_orientation.x, _orientation.y, _orientation.z);
  }
}
class AudioAnalyser {
  constructor(e, o = 2048) {
    (this.analyser = e.context.createAnalyser()),
      (this.analyser.fftSize = o),
      (this.data = new Uint8Array(this.analyser.frequencyBinCount)),
      e.getOutput().connect(this.analyser);
  }
  getFrequencyData() {
    return this.analyser.getByteFrequencyData(this.data), this.data;
  }
  getAverageFrequency() {
    let e = 0;
    const o = this.getFrequencyData();
    for (let a = 0; a < o.length; a++) e += o[a];
    return e / o.length;
  }
}
class PropertyMixer {
  constructor(e, o, a) {
    (this.binding = e), (this.valueSize = a);
    let c, d, g;
    switch (o) {
      case "quaternion":
        (c = this._slerp),
          (d = this._slerpAdditive),
          (g = this._setAdditiveIdentityQuaternion),
          (this.buffer = new Float64Array(a * 6)),
          (this._workIndex = 5);
        break;
      case "string":
      case "bool":
        (c = this._select),
          (d = this._select),
          (g = this._setAdditiveIdentityOther),
          (this.buffer = new Array(a * 5));
        break;
      default:
        (c = this._lerp),
          (d = this._lerpAdditive),
          (g = this._setAdditiveIdentityNumeric),
          (this.buffer = new Float64Array(a * 5));
    }
    (this._mixBufferRegion = c),
      (this._mixBufferRegionAdditive = d),
      (this._setIdentity = g),
      (this._origIndex = 3),
      (this._addIndex = 4),
      (this.cumulativeWeight = 0),
      (this.cumulativeWeightAdditive = 0),
      (this.useCount = 0),
      (this.referenceCount = 0);
  }
  accumulate(e, o) {
    const a = this.buffer,
      c = this.valueSize,
      d = e * c + c;
    let g = this.cumulativeWeight;
    if (g === 0) {
      for (let _ = 0; _ !== c; ++_) a[d + _] = a[_];
      g = o;
    } else {
      g += o;
      const _ = o / g;
      this._mixBufferRegion(a, d, 0, _, c);
    }
    this.cumulativeWeight = g;
  }
  accumulateAdditive(e) {
    const o = this.buffer,
      a = this.valueSize,
      c = a * this._addIndex;
    this.cumulativeWeightAdditive === 0 && this._setIdentity(),
      this._mixBufferRegionAdditive(o, c, 0, e, a),
      (this.cumulativeWeightAdditive += e);
  }
  apply(e) {
    const o = this.valueSize,
      a = this.buffer,
      c = e * o + o,
      d = this.cumulativeWeight,
      g = this.cumulativeWeightAdditive,
      _ = this.binding;
    if (
      ((this.cumulativeWeight = 0), (this.cumulativeWeightAdditive = 0), d < 1)
    ) {
      const b = o * this._origIndex;
      this._mixBufferRegion(a, c, b, 1 - d, o);
    }
    g > 0 && this._mixBufferRegionAdditive(a, c, this._addIndex * o, 1, o);
    for (let b = o, j = o + o; b !== j; ++b)
      if (a[b] !== a[b + o]) {
        _.setValue(a, c);
        break;
      }
  }
  saveOriginalState() {
    const e = this.binding,
      o = this.buffer,
      a = this.valueSize,
      c = a * this._origIndex;
    e.getValue(o, c);
    for (let d = a, g = c; d !== g; ++d) o[d] = o[c + (d % a)];
    this._setIdentity(),
      (this.cumulativeWeight = 0),
      (this.cumulativeWeightAdditive = 0);
  }
  restoreOriginalState() {
    const e = this.valueSize * 3;
    this.binding.setValue(this.buffer, e);
  }
  _setAdditiveIdentityNumeric() {
    const e = this._addIndex * this.valueSize,
      o = e + this.valueSize;
    for (let a = e; a < o; a++) this.buffer[a] = 0;
  }
  _setAdditiveIdentityQuaternion() {
    this._setAdditiveIdentityNumeric(),
      (this.buffer[this._addIndex * this.valueSize + 3] = 1);
  }
  _setAdditiveIdentityOther() {
    const e = this._origIndex * this.valueSize,
      o = this._addIndex * this.valueSize;
    for (let a = 0; a < this.valueSize; a++)
      this.buffer[o + a] = this.buffer[e + a];
  }
  _select(e, o, a, c, d) {
    if (c >= 0.5) for (let g = 0; g !== d; ++g) e[o + g] = e[a + g];
  }
  _slerp(e, o, a, c) {
    Quaternion.slerpFlat(e, o, e, o, e, a, c);
  }
  _slerpAdditive(e, o, a, c, d) {
    const g = this._workIndex * d;
    Quaternion.multiplyQuaternionsFlat(e, g, e, o, e, a),
      Quaternion.slerpFlat(e, o, e, o, e, g, c);
  }
  _lerp(e, o, a, c, d) {
    const g = 1 - c;
    for (let _ = 0; _ !== d; ++_) {
      const b = o + _;
      e[b] = e[b] * g + e[a + _] * c;
    }
  }
  _lerpAdditive(e, o, a, c, d) {
    for (let g = 0; g !== d; ++g) {
      const _ = o + g;
      e[_] = e[_] + e[a + g] * c;
    }
  }
}
const _RESERVED_CHARS_RE = "\\[\\]\\.:\\/",
  _reservedRe = new RegExp("[" + _RESERVED_CHARS_RE + "]", "g"),
  _wordChar = "[^" + _RESERVED_CHARS_RE + "]",
  _wordCharOrDot = "[^" + _RESERVED_CHARS_RE.replace("\\.", "") + "]",
  _directoryRe = /((?:WC+[\/:])*)/.source.replace("WC", _wordChar),
  _nodeRe = /(WCOD+)?/.source.replace("WCOD", _wordCharOrDot),
  _objectRe = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", _wordChar),
  _propertyRe = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", _wordChar),
  _trackRe = new RegExp(
    "^" + _directoryRe + _nodeRe + _objectRe + _propertyRe + "$"
  ),
  _supportedObjectNames = ["material", "materials", "bones", "map"];
class Composite {
  constructor(e, o, a) {
    const c = a || PropertyBinding.parseTrackName(o);
    (this._targetGroup = e), (this._bindings = e.subscribe_(o, c));
  }
  getValue(e, o) {
    this.bind();
    const a = this._targetGroup.nCachedObjects_,
      c = this._bindings[a];
    c !== void 0 && c.getValue(e, o);
  }
  setValue(e, o) {
    const a = this._bindings;
    for (let c = this._targetGroup.nCachedObjects_, d = a.length; c !== d; ++c)
      a[c].setValue(e, o);
  }
  bind() {
    const e = this._bindings;
    for (let o = this._targetGroup.nCachedObjects_, a = e.length; o !== a; ++o)
      e[o].bind();
  }
  unbind() {
    const e = this._bindings;
    for (let o = this._targetGroup.nCachedObjects_, a = e.length; o !== a; ++o)
      e[o].unbind();
  }
}
class PropertyBinding {
  constructor(e, o, a) {
    (this.path = o),
      (this.parsedPath = a || PropertyBinding.parseTrackName(o)),
      (this.node = PropertyBinding.findNode(e, this.parsedPath.nodeName)),
      (this.rootNode = e),
      (this.getValue = this._getValue_unbound),
      (this.setValue = this._setValue_unbound);
  }
  static create(e, o, a) {
    return e && e.isAnimationObjectGroup
      ? new PropertyBinding.Composite(e, o, a)
      : new PropertyBinding(e, o, a);
  }
  static sanitizeNodeName(e) {
    return e.replace(/\s/g, "_").replace(_reservedRe, "");
  }
  static parseTrackName(e) {
    const o = _trackRe.exec(e);
    if (o === null)
      throw new Error("PropertyBinding: Cannot parse trackName: " + e);
    const a = {
        nodeName: o[2],
        objectName: o[3],
        objectIndex: o[4],
        propertyName: o[5],
        propertyIndex: o[6],
      },
      c = a.nodeName && a.nodeName.lastIndexOf(".");
    if (c !== void 0 && c !== -1) {
      const d = a.nodeName.substring(c + 1);
      _supportedObjectNames.indexOf(d) !== -1 &&
        ((a.nodeName = a.nodeName.substring(0, c)), (a.objectName = d));
    }
    if (a.propertyName === null || a.propertyName.length === 0)
      throw new Error(
        "PropertyBinding: can not parse propertyName from trackName: " + e
      );
    return a;
  }
  static findNode(e, o) {
    if (
      o === void 0 ||
      o === "" ||
      o === "." ||
      o === -1 ||
      o === e.name ||
      o === e.uuid
    )
      return e;
    if (e.skeleton) {
      const a = e.skeleton.getBoneByName(o);
      if (a !== void 0) return a;
    }
    if (e.children) {
      const a = function (d) {
          for (let g = 0; g < d.length; g++) {
            const _ = d[g];
            if (_.name === o || _.uuid === o) return _;
            const b = a(_.children);
            if (b) return b;
          }
          return null;
        },
        c = a(e.children);
      if (c) return c;
    }
    return null;
  }
  _getValue_unavailable() {}
  _setValue_unavailable() {}
  _getValue_direct(e, o) {
    e[o] = this.targetObject[this.propertyName];
  }
  _getValue_array(e, o) {
    const a = this.resolvedProperty;
    for (let c = 0, d = a.length; c !== d; ++c) e[o++] = a[c];
  }
  _getValue_arrayElement(e, o) {
    e[o] = this.resolvedProperty[this.propertyIndex];
  }
  _getValue_toArray(e, o) {
    this.resolvedProperty.toArray(e, o);
  }
  _setValue_direct(e, o) {
    this.targetObject[this.propertyName] = e[o];
  }
  _setValue_direct_setNeedsUpdate(e, o) {
    (this.targetObject[this.propertyName] = e[o]),
      (this.targetObject.needsUpdate = !0);
  }
  _setValue_direct_setMatrixWorldNeedsUpdate(e, o) {
    (this.targetObject[this.propertyName] = e[o]),
      (this.targetObject.matrixWorldNeedsUpdate = !0);
  }
  _setValue_array(e, o) {
    const a = this.resolvedProperty;
    for (let c = 0, d = a.length; c !== d; ++c) a[c] = e[o++];
  }
  _setValue_array_setNeedsUpdate(e, o) {
    const a = this.resolvedProperty;
    for (let c = 0, d = a.length; c !== d; ++c) a[c] = e[o++];
    this.targetObject.needsUpdate = !0;
  }
  _setValue_array_setMatrixWorldNeedsUpdate(e, o) {
    const a = this.resolvedProperty;
    for (let c = 0, d = a.length; c !== d; ++c) a[c] = e[o++];
    this.targetObject.matrixWorldNeedsUpdate = !0;
  }
  _setValue_arrayElement(e, o) {
    this.resolvedProperty[this.propertyIndex] = e[o];
  }
  _setValue_arrayElement_setNeedsUpdate(e, o) {
    (this.resolvedProperty[this.propertyIndex] = e[o]),
      (this.targetObject.needsUpdate = !0);
  }
  _setValue_arrayElement_setMatrixWorldNeedsUpdate(e, o) {
    (this.resolvedProperty[this.propertyIndex] = e[o]),
      (this.targetObject.matrixWorldNeedsUpdate = !0);
  }
  _setValue_fromArray(e, o) {
    this.resolvedProperty.fromArray(e, o);
  }
  _setValue_fromArray_setNeedsUpdate(e, o) {
    this.resolvedProperty.fromArray(e, o), (this.targetObject.needsUpdate = !0);
  }
  _setValue_fromArray_setMatrixWorldNeedsUpdate(e, o) {
    this.resolvedProperty.fromArray(e, o),
      (this.targetObject.matrixWorldNeedsUpdate = !0);
  }
  _getValue_unbound(e, o) {
    this.bind(), this.getValue(e, o);
  }
  _setValue_unbound(e, o) {
    this.bind(), this.setValue(e, o);
  }
  bind() {
    let e = this.node;
    const o = this.parsedPath,
      a = o.objectName,
      c = o.propertyName;
    let d = o.propertyIndex;
    if (
      (e ||
        ((e = PropertyBinding.findNode(this.rootNode, o.nodeName)),
        (this.node = e)),
      (this.getValue = this._getValue_unavailable),
      (this.setValue = this._setValue_unavailable),
      !e)
    ) {
      console.warn(
        "THREE.PropertyBinding: No target node found for track: " +
          this.path +
          "."
      );
      return;
    }
    if (a) {
      let j = o.objectIndex;
      switch (a) {
        case "materials":
          if (!e.material) {
            console.error(
              "THREE.PropertyBinding: Can not bind to material as node does not have a material.",
              this
            );
            return;
          }
          if (!e.material.materials) {
            console.error(
              "THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.",
              this
            );
            return;
          }
          e = e.material.materials;
          break;
        case "bones":
          if (!e.skeleton) {
            console.error(
              "THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.",
              this
            );
            return;
          }
          e = e.skeleton.bones;
          for (let $ = 0; $ < e.length; $++)
            if (e[$].name === j) {
              j = $;
              break;
            }
          break;
        case "map":
          if ("map" in e) {
            e = e.map;
            break;
          }
          if (!e.material) {
            console.error(
              "THREE.PropertyBinding: Can not bind to material as node does not have a material.",
              this
            );
            return;
          }
          if (!e.material.map) {
            console.error(
              "THREE.PropertyBinding: Can not bind to material.map as node.material does not have a map.",
              this
            );
            return;
          }
          e = e.material.map;
          break;
        default:
          if (e[a] === void 0) {
            console.error(
              "THREE.PropertyBinding: Can not bind to objectName of node undefined.",
              this
            );
            return;
          }
          e = e[a];
      }
      if (j !== void 0) {
        if (e[j] === void 0) {
          console.error(
            "THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.",
            this,
            e
          );
          return;
        }
        e = e[j];
      }
    }
    const g = e[c];
    if (g === void 0) {
      const j = o.nodeName;
      console.error(
        "THREE.PropertyBinding: Trying to update property for track: " +
          j +
          "." +
          c +
          " but it wasn't found.",
        e
      );
      return;
    }
    let _ = this.Versioning.None;
    (this.targetObject = e),
      e.needsUpdate !== void 0
        ? (_ = this.Versioning.NeedsUpdate)
        : e.matrixWorldNeedsUpdate !== void 0 &&
          (_ = this.Versioning.MatrixWorldNeedsUpdate);
    let b = this.BindingType.Direct;
    if (d !== void 0) {
      if (c === "morphTargetInfluences") {
        if (!e.geometry) {
          console.error(
            "THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.",
            this
          );
          return;
        }
        if (!e.geometry.morphAttributes) {
          console.error(
            "THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.",
            this
          );
          return;
        }
        e.morphTargetDictionary[d] !== void 0 &&
          (d = e.morphTargetDictionary[d]);
      }
      (b = this.BindingType.ArrayElement),
        (this.resolvedProperty = g),
        (this.propertyIndex = d);
    } else
      g.fromArray !== void 0 && g.toArray !== void 0
        ? ((b = this.BindingType.HasFromToArray), (this.resolvedProperty = g))
        : Array.isArray(g)
        ? ((b = this.BindingType.EntireArray), (this.resolvedProperty = g))
        : (this.propertyName = c);
    (this.getValue = this.GetterByBindingType[b]),
      (this.setValue = this.SetterByBindingTypeAndVersioning[b][_]);
  }
  unbind() {
    (this.node = null),
      (this.getValue = this._getValue_unbound),
      (this.setValue = this._setValue_unbound);
  }
}
PropertyBinding.Composite = Composite;
PropertyBinding.prototype.BindingType = {
  Direct: 0,
  EntireArray: 1,
  ArrayElement: 2,
  HasFromToArray: 3,
};
PropertyBinding.prototype.Versioning = {
  None: 0,
  NeedsUpdate: 1,
  MatrixWorldNeedsUpdate: 2,
};
PropertyBinding.prototype.GetterByBindingType = [
  PropertyBinding.prototype._getValue_direct,
  PropertyBinding.prototype._getValue_array,
  PropertyBinding.prototype._getValue_arrayElement,
  PropertyBinding.prototype._getValue_toArray,
];
PropertyBinding.prototype.SetterByBindingTypeAndVersioning = [
  [
    PropertyBinding.prototype._setValue_direct,
    PropertyBinding.prototype._setValue_direct_setNeedsUpdate,
    PropertyBinding.prototype._setValue_direct_setMatrixWorldNeedsUpdate,
  ],
  [
    PropertyBinding.prototype._setValue_array,
    PropertyBinding.prototype._setValue_array_setNeedsUpdate,
    PropertyBinding.prototype._setValue_array_setMatrixWorldNeedsUpdate,
  ],
  [
    PropertyBinding.prototype._setValue_arrayElement,
    PropertyBinding.prototype._setValue_arrayElement_setNeedsUpdate,
    PropertyBinding.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate,
  ],
  [
    PropertyBinding.prototype._setValue_fromArray,
    PropertyBinding.prototype._setValue_fromArray_setNeedsUpdate,
    PropertyBinding.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate,
  ],
];
class AnimationObjectGroup {
  constructor() {
    (this.isAnimationObjectGroup = !0),
      (this.uuid = generateUUID()),
      (this._objects = Array.prototype.slice.call(arguments)),
      (this.nCachedObjects_ = 0);
    const e = {};
    this._indicesByUUID = e;
    for (let a = 0, c = arguments.length; a !== c; ++a)
      e[arguments[a].uuid] = a;
    (this._paths = []),
      (this._parsedPaths = []),
      (this._bindings = []),
      (this._bindingsIndicesByPath = {});
    const o = this;
    this.stats = {
      objects: {
        get total() {
          return o._objects.length;
        },
        get inUse() {
          return this.total - o.nCachedObjects_;
        },
      },
      get bindingsPerObject() {
        return o._bindings.length;
      },
    };
  }
  add() {
    const e = this._objects,
      o = this._indicesByUUID,
      a = this._paths,
      c = this._parsedPaths,
      d = this._bindings,
      g = d.length;
    let _,
      b = e.length,
      j = this.nCachedObjects_;
    for (let $ = 0, _e = arguments.length; $ !== _e; ++$) {
      const et = arguments[$],
        rt = et.uuid;
      let st = o[rt];
      if (st === void 0) {
        (st = b++), (o[rt] = st), e.push(et);
        for (let at = 0, ct = g; at !== ct; ++at)
          d[at].push(new PropertyBinding(et, a[at], c[at]));
      } else if (st < j) {
        _ = e[st];
        const at = --j,
          ct = e[at];
        (o[ct.uuid] = st), (e[st] = ct), (o[rt] = at), (e[at] = et);
        for (let it = 0, lt = g; it !== lt; ++it) {
          const ot = d[it],
            ut = ot[at];
          let pt = ot[st];
          (ot[st] = ut),
            pt === void 0 && (pt = new PropertyBinding(et, a[it], c[it])),
            (ot[at] = pt);
        }
      } else
        e[st] !== _ &&
          console.error(
            "THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes."
          );
    }
    this.nCachedObjects_ = j;
  }
  remove() {
    const e = this._objects,
      o = this._indicesByUUID,
      a = this._bindings,
      c = a.length;
    let d = this.nCachedObjects_;
    for (let g = 0, _ = arguments.length; g !== _; ++g) {
      const b = arguments[g],
        j = b.uuid,
        $ = o[j];
      if ($ !== void 0 && $ >= d) {
        const _e = d++,
          et = e[_e];
        (o[et.uuid] = $), (e[$] = et), (o[j] = _e), (e[_e] = b);
        for (let rt = 0, st = c; rt !== st; ++rt) {
          const at = a[rt],
            ct = at[_e],
            it = at[$];
          (at[$] = ct), (at[_e] = it);
        }
      }
    }
    this.nCachedObjects_ = d;
  }
  uncache() {
    const e = this._objects,
      o = this._indicesByUUID,
      a = this._bindings,
      c = a.length;
    let d = this.nCachedObjects_,
      g = e.length;
    for (let _ = 0, b = arguments.length; _ !== b; ++_) {
      const j = arguments[_],
        $ = j.uuid,
        _e = o[$];
      if (_e !== void 0)
        if ((delete o[$], _e < d)) {
          const et = --d,
            rt = e[et],
            st = --g,
            at = e[st];
          (o[rt.uuid] = _e),
            (e[_e] = rt),
            (o[at.uuid] = et),
            (e[et] = at),
            e.pop();
          for (let ct = 0, it = c; ct !== it; ++ct) {
            const lt = a[ct],
              ot = lt[et],
              ut = lt[st];
            (lt[_e] = ot), (lt[et] = ut), lt.pop();
          }
        } else {
          const et = --g,
            rt = e[et];
          et > 0 && (o[rt.uuid] = _e), (e[_e] = rt), e.pop();
          for (let st = 0, at = c; st !== at; ++st) {
            const ct = a[st];
            (ct[_e] = ct[et]), ct.pop();
          }
        }
    }
    this.nCachedObjects_ = d;
  }
  subscribe_(e, o) {
    const a = this._bindingsIndicesByPath;
    let c = a[e];
    const d = this._bindings;
    if (c !== void 0) return d[c];
    const g = this._paths,
      _ = this._parsedPaths,
      b = this._objects,
      j = b.length,
      $ = this.nCachedObjects_,
      _e = new Array(j);
    (c = d.length), (a[e] = c), g.push(e), _.push(o), d.push(_e);
    for (let et = $, rt = b.length; et !== rt; ++et) {
      const st = b[et];
      _e[et] = new PropertyBinding(st, e, o);
    }
    return _e;
  }
  unsubscribe_(e) {
    const o = this._bindingsIndicesByPath,
      a = o[e];
    if (a !== void 0) {
      const c = this._paths,
        d = this._parsedPaths,
        g = this._bindings,
        _ = g.length - 1,
        b = g[_],
        j = e[_];
      (o[j] = a),
        (g[a] = b),
        g.pop(),
        (d[a] = d[_]),
        d.pop(),
        (c[a] = c[_]),
        c.pop();
    }
  }
}
class AnimationAction {
  constructor(e, o, a = null, c = o.blendMode) {
    (this._mixer = e),
      (this._clip = o),
      (this._localRoot = a),
      (this.blendMode = c);
    const d = o.tracks,
      g = d.length,
      _ = new Array(g),
      b = { endingStart: ZeroCurvatureEnding, endingEnd: ZeroCurvatureEnding };
    for (let j = 0; j !== g; ++j) {
      const $ = d[j].createInterpolant(null);
      (_[j] = $), ($.settings = b);
    }
    (this._interpolantSettings = b),
      (this._interpolants = _),
      (this._propertyBindings = new Array(g)),
      (this._cacheIndex = null),
      (this._byClipCacheIndex = null),
      (this._timeScaleInterpolant = null),
      (this._weightInterpolant = null),
      (this.loop = LoopRepeat),
      (this._loopCount = -1),
      (this._startTime = null),
      (this.time = 0),
      (this.timeScale = 1),
      (this._effectiveTimeScale = 1),
      (this.weight = 1),
      (this._effectiveWeight = 1),
      (this.repetitions = 1 / 0),
      (this.paused = !1),
      (this.enabled = !0),
      (this.clampWhenFinished = !1),
      (this.zeroSlopeAtStart = !0),
      (this.zeroSlopeAtEnd = !0);
  }
  play() {
    return this._mixer._activateAction(this), this;
  }
  stop() {
    return this._mixer._deactivateAction(this), this.reset();
  }
  reset() {
    return (
      (this.paused = !1),
      (this.enabled = !0),
      (this.time = 0),
      (this._loopCount = -1),
      (this._startTime = null),
      this.stopFading().stopWarping()
    );
  }
  isRunning() {
    return (
      this.enabled &&
      !this.paused &&
      this.timeScale !== 0 &&
      this._startTime === null &&
      this._mixer._isActiveAction(this)
    );
  }
  isScheduled() {
    return this._mixer._isActiveAction(this);
  }
  startAt(e) {
    return (this._startTime = e), this;
  }
  setLoop(e, o) {
    return (this.loop = e), (this.repetitions = o), this;
  }
  setEffectiveWeight(e) {
    return (
      (this.weight = e),
      (this._effectiveWeight = this.enabled ? e : 0),
      this.stopFading()
    );
  }
  getEffectiveWeight() {
    return this._effectiveWeight;
  }
  fadeIn(e) {
    return this._scheduleFading(e, 0, 1);
  }
  fadeOut(e) {
    return this._scheduleFading(e, 1, 0);
  }
  crossFadeFrom(e, o, a) {
    if ((e.fadeOut(o), this.fadeIn(o), a)) {
      const c = this._clip.duration,
        d = e._clip.duration,
        g = d / c,
        _ = c / d;
      e.warp(1, g, o), this.warp(_, 1, o);
    }
    return this;
  }
  crossFadeTo(e, o, a) {
    return e.crossFadeFrom(this, o, a);
  }
  stopFading() {
    const e = this._weightInterpolant;
    return (
      e !== null &&
        ((this._weightInterpolant = null),
        this._mixer._takeBackControlInterpolant(e)),
      this
    );
  }
  setEffectiveTimeScale(e) {
    return (
      (this.timeScale = e),
      (this._effectiveTimeScale = this.paused ? 0 : e),
      this.stopWarping()
    );
  }
  getEffectiveTimeScale() {
    return this._effectiveTimeScale;
  }
  setDuration(e) {
    return (this.timeScale = this._clip.duration / e), this.stopWarping();
  }
  syncWith(e) {
    return (
      (this.time = e.time), (this.timeScale = e.timeScale), this.stopWarping()
    );
  }
  halt(e) {
    return this.warp(this._effectiveTimeScale, 0, e);
  }
  warp(e, o, a) {
    const c = this._mixer,
      d = c.time,
      g = this.timeScale;
    let _ = this._timeScaleInterpolant;
    _ === null &&
      ((_ = c._lendControlInterpolant()), (this._timeScaleInterpolant = _));
    const b = _.parameterPositions,
      j = _.sampleValues;
    return (b[0] = d), (b[1] = d + a), (j[0] = e / g), (j[1] = o / g), this;
  }
  stopWarping() {
    const e = this._timeScaleInterpolant;
    return (
      e !== null &&
        ((this._timeScaleInterpolant = null),
        this._mixer._takeBackControlInterpolant(e)),
      this
    );
  }
  getMixer() {
    return this._mixer;
  }
  getClip() {
    return this._clip;
  }
  getRoot() {
    return this._localRoot || this._mixer._root;
  }
  _update(e, o, a, c) {
    if (!this.enabled) {
      this._updateWeight(e);
      return;
    }
    const d = this._startTime;
    if (d !== null) {
      const b = (e - d) * a;
      b < 0 || a === 0 ? (o = 0) : ((this._startTime = null), (o = a * b));
    }
    o *= this._updateTimeScale(e);
    const g = this._updateTime(o),
      _ = this._updateWeight(e);
    if (_ > 0) {
      const b = this._interpolants,
        j = this._propertyBindings;
      switch (this.blendMode) {
        case AdditiveAnimationBlendMode:
          for (let $ = 0, _e = b.length; $ !== _e; ++$)
            b[$].evaluate(g), j[$].accumulateAdditive(_);
          break;
        case NormalAnimationBlendMode:
        default:
          for (let $ = 0, _e = b.length; $ !== _e; ++$)
            b[$].evaluate(g), j[$].accumulate(c, _);
      }
    }
  }
  _updateWeight(e) {
    let o = 0;
    if (this.enabled) {
      o = this.weight;
      const a = this._weightInterpolant;
      if (a !== null) {
        const c = a.evaluate(e)[0];
        (o *= c),
          e > a.parameterPositions[1] &&
            (this.stopFading(), c === 0 && (this.enabled = !1));
      }
    }
    return (this._effectiveWeight = o), o;
  }
  _updateTimeScale(e) {
    let o = 0;
    if (!this.paused) {
      o = this.timeScale;
      const a = this._timeScaleInterpolant;
      if (a !== null) {
        const c = a.evaluate(e)[0];
        (o *= c),
          e > a.parameterPositions[1] &&
            (this.stopWarping(),
            o === 0 ? (this.paused = !0) : (this.timeScale = o));
      }
    }
    return (this._effectiveTimeScale = o), o;
  }
  _updateTime(e) {
    const o = this._clip.duration,
      a = this.loop;
    let c = this.time + e,
      d = this._loopCount;
    const g = a === LoopPingPong;
    if (e === 0) return d === -1 ? c : g && (d & 1) === 1 ? o - c : c;
    if (a === LoopOnce) {
      d === -1 && ((this._loopCount = 0), this._setEndings(!0, !0, !1));
      e: {
        if (c >= o) c = o;
        else if (c < 0) c = 0;
        else {
          this.time = c;
          break e;
        }
        this.clampWhenFinished ? (this.paused = !0) : (this.enabled = !1),
          (this.time = c),
          this._mixer.dispatchEvent({
            type: "finished",
            action: this,
            direction: e < 0 ? -1 : 1,
          });
      }
    } else {
      if (
        (d === -1 &&
          (e >= 0
            ? ((d = 0), this._setEndings(!0, this.repetitions === 0, g))
            : this._setEndings(this.repetitions === 0, !0, g)),
        c >= o || c < 0)
      ) {
        const _ = Math.floor(c / o);
        (c -= o * _), (d += Math.abs(_));
        const b = this.repetitions - d;
        if (b <= 0)
          this.clampWhenFinished ? (this.paused = !0) : (this.enabled = !1),
            (c = e > 0 ? o : 0),
            (this.time = c),
            this._mixer.dispatchEvent({
              type: "finished",
              action: this,
              direction: e > 0 ? 1 : -1,
            });
        else {
          if (b === 1) {
            const j = e < 0;
            this._setEndings(j, !j, g);
          } else this._setEndings(!1, !1, g);
          (this._loopCount = d),
            (this.time = c),
            this._mixer.dispatchEvent({
              type: "loop",
              action: this,
              loopDelta: _,
            });
        }
      } else this.time = c;
      if (g && (d & 1) === 1) return o - c;
    }
    return c;
  }
  _setEndings(e, o, a) {
    const c = this._interpolantSettings;
    a
      ? ((c.endingStart = ZeroSlopeEnding), (c.endingEnd = ZeroSlopeEnding))
      : (e
          ? (c.endingStart = this.zeroSlopeAtStart
              ? ZeroSlopeEnding
              : ZeroCurvatureEnding)
          : (c.endingStart = WrapAroundEnding),
        o
          ? (c.endingEnd = this.zeroSlopeAtEnd
              ? ZeroSlopeEnding
              : ZeroCurvatureEnding)
          : (c.endingEnd = WrapAroundEnding));
  }
  _scheduleFading(e, o, a) {
    const c = this._mixer,
      d = c.time;
    let g = this._weightInterpolant;
    g === null &&
      ((g = c._lendControlInterpolant()), (this._weightInterpolant = g));
    const _ = g.parameterPositions,
      b = g.sampleValues;
    return (_[0] = d), (b[0] = o), (_[1] = d + e), (b[1] = a), this;
  }
}
const _controlInterpolantsResultBuffer = new Float32Array(1);
class AnimationMixer extends EventDispatcher {
  constructor(e) {
    super(),
      (this._root = e),
      this._initMemoryManager(),
      (this._accuIndex = 0),
      (this.time = 0),
      (this.timeScale = 1);
  }
  _bindAction(e, o) {
    const a = e._localRoot || this._root,
      c = e._clip.tracks,
      d = c.length,
      g = e._propertyBindings,
      _ = e._interpolants,
      b = a.uuid,
      j = this._bindingsByRootAndName;
    let $ = j[b];
    $ === void 0 && (($ = {}), (j[b] = $));
    for (let _e = 0; _e !== d; ++_e) {
      const et = c[_e],
        rt = et.name;
      let st = $[rt];
      if (st !== void 0) ++st.referenceCount, (g[_e] = st);
      else {
        if (((st = g[_e]), st !== void 0)) {
          st._cacheIndex === null &&
            (++st.referenceCount, this._addInactiveBinding(st, b, rt));
          continue;
        }
        const at = o && o._propertyBindings[_e].binding.parsedPath;
        (st = new PropertyMixer(
          PropertyBinding.create(a, rt, at),
          et.ValueTypeName,
          et.getValueSize()
        )),
          ++st.referenceCount,
          this._addInactiveBinding(st, b, rt),
          (g[_e] = st);
      }
      _[_e].resultBuffer = st.buffer;
    }
  }
  _activateAction(e) {
    if (!this._isActiveAction(e)) {
      if (e._cacheIndex === null) {
        const a = (e._localRoot || this._root).uuid,
          c = e._clip.uuid,
          d = this._actionsByClip[c];
        this._bindAction(e, d && d.knownActions[0]),
          this._addInactiveAction(e, c, a);
      }
      const o = e._propertyBindings;
      for (let a = 0, c = o.length; a !== c; ++a) {
        const d = o[a];
        d.useCount++ === 0 && (this._lendBinding(d), d.saveOriginalState());
      }
      this._lendAction(e);
    }
  }
  _deactivateAction(e) {
    if (this._isActiveAction(e)) {
      const o = e._propertyBindings;
      for (let a = 0, c = o.length; a !== c; ++a) {
        const d = o[a];
        --d.useCount === 0 &&
          (d.restoreOriginalState(), this._takeBackBinding(d));
      }
      this._takeBackAction(e);
    }
  }
  _initMemoryManager() {
    (this._actions = []),
      (this._nActiveActions = 0),
      (this._actionsByClip = {}),
      (this._bindings = []),
      (this._nActiveBindings = 0),
      (this._bindingsByRootAndName = {}),
      (this._controlInterpolants = []),
      (this._nActiveControlInterpolants = 0);
    const e = this;
    this.stats = {
      actions: {
        get total() {
          return e._actions.length;
        },
        get inUse() {
          return e._nActiveActions;
        },
      },
      bindings: {
        get total() {
          return e._bindings.length;
        },
        get inUse() {
          return e._nActiveBindings;
        },
      },
      controlInterpolants: {
        get total() {
          return e._controlInterpolants.length;
        },
        get inUse() {
          return e._nActiveControlInterpolants;
        },
      },
    };
  }
  _isActiveAction(e) {
    const o = e._cacheIndex;
    return o !== null && o < this._nActiveActions;
  }
  _addInactiveAction(e, o, a) {
    const c = this._actions,
      d = this._actionsByClip;
    let g = d[o];
    if (g === void 0)
      (g = { knownActions: [e], actionByRoot: {} }),
        (e._byClipCacheIndex = 0),
        (d[o] = g);
    else {
      const _ = g.knownActions;
      (e._byClipCacheIndex = _.length), _.push(e);
    }
    (e._cacheIndex = c.length), c.push(e), (g.actionByRoot[a] = e);
  }
  _removeInactiveAction(e) {
    const o = this._actions,
      a = o[o.length - 1],
      c = e._cacheIndex;
    (a._cacheIndex = c), (o[c] = a), o.pop(), (e._cacheIndex = null);
    const d = e._clip.uuid,
      g = this._actionsByClip,
      _ = g[d],
      b = _.knownActions,
      j = b[b.length - 1],
      $ = e._byClipCacheIndex;
    (j._byClipCacheIndex = $),
      (b[$] = j),
      b.pop(),
      (e._byClipCacheIndex = null);
    const _e = _.actionByRoot,
      et = (e._localRoot || this._root).uuid;
    delete _e[et],
      b.length === 0 && delete g[d],
      this._removeInactiveBindingsForAction(e);
  }
  _removeInactiveBindingsForAction(e) {
    const o = e._propertyBindings;
    for (let a = 0, c = o.length; a !== c; ++a) {
      const d = o[a];
      --d.referenceCount === 0 && this._removeInactiveBinding(d);
    }
  }
  _lendAction(e) {
    const o = this._actions,
      a = e._cacheIndex,
      c = this._nActiveActions++,
      d = o[c];
    (e._cacheIndex = c), (o[c] = e), (d._cacheIndex = a), (o[a] = d);
  }
  _takeBackAction(e) {
    const o = this._actions,
      a = e._cacheIndex,
      c = --this._nActiveActions,
      d = o[c];
    (e._cacheIndex = c), (o[c] = e), (d._cacheIndex = a), (o[a] = d);
  }
  _addInactiveBinding(e, o, a) {
    const c = this._bindingsByRootAndName,
      d = this._bindings;
    let g = c[o];
    g === void 0 && ((g = {}), (c[o] = g)),
      (g[a] = e),
      (e._cacheIndex = d.length),
      d.push(e);
  }
  _removeInactiveBinding(e) {
    const o = this._bindings,
      a = e.binding,
      c = a.rootNode.uuid,
      d = a.path,
      g = this._bindingsByRootAndName,
      _ = g[c],
      b = o[o.length - 1],
      j = e._cacheIndex;
    (b._cacheIndex = j),
      (o[j] = b),
      o.pop(),
      delete _[d],
      Object.keys(_).length === 0 && delete g[c];
  }
  _lendBinding(e) {
    const o = this._bindings,
      a = e._cacheIndex,
      c = this._nActiveBindings++,
      d = o[c];
    (e._cacheIndex = c), (o[c] = e), (d._cacheIndex = a), (o[a] = d);
  }
  _takeBackBinding(e) {
    const o = this._bindings,
      a = e._cacheIndex,
      c = --this._nActiveBindings,
      d = o[c];
    (e._cacheIndex = c), (o[c] = e), (d._cacheIndex = a), (o[a] = d);
  }
  _lendControlInterpolant() {
    const e = this._controlInterpolants,
      o = this._nActiveControlInterpolants++;
    let a = e[o];
    return (
      a === void 0 &&
        ((a = new LinearInterpolant(
          new Float32Array(2),
          new Float32Array(2),
          1,
          _controlInterpolantsResultBuffer
        )),
        (a.__cacheIndex = o),
        (e[o] = a)),
      a
    );
  }
  _takeBackControlInterpolant(e) {
    const o = this._controlInterpolants,
      a = e.__cacheIndex,
      c = --this._nActiveControlInterpolants,
      d = o[c];
    (e.__cacheIndex = c), (o[c] = e), (d.__cacheIndex = a), (o[a] = d);
  }
  clipAction(e, o, a) {
    const c = o || this._root,
      d = c.uuid;
    let g = typeof e == "string" ? AnimationClip.findByName(c, e) : e;
    const _ = g !== null ? g.uuid : e,
      b = this._actionsByClip[_];
    let j = null;
    if (
      (a === void 0 &&
        (g !== null ? (a = g.blendMode) : (a = NormalAnimationBlendMode)),
      b !== void 0)
    ) {
      const _e = b.actionByRoot[d];
      if (_e !== void 0 && _e.blendMode === a) return _e;
      (j = b.knownActions[0]), g === null && (g = j._clip);
    }
    if (g === null) return null;
    const $ = new AnimationAction(this, g, o, a);
    return this._bindAction($, j), this._addInactiveAction($, _, d), $;
  }
  existingAction(e, o) {
    const a = o || this._root,
      c = a.uuid,
      d = typeof e == "string" ? AnimationClip.findByName(a, e) : e,
      g = d ? d.uuid : e,
      _ = this._actionsByClip[g];
    return (_ !== void 0 && _.actionByRoot[c]) || null;
  }
  stopAllAction() {
    const e = this._actions,
      o = this._nActiveActions;
    for (let a = o - 1; a >= 0; --a) e[a].stop();
    return this;
  }
  update(e) {
    e *= this.timeScale;
    const o = this._actions,
      a = this._nActiveActions,
      c = (this.time += e),
      d = Math.sign(e),
      g = (this._accuIndex ^= 1);
    for (let j = 0; j !== a; ++j) o[j]._update(c, e, d, g);
    const _ = this._bindings,
      b = this._nActiveBindings;
    for (let j = 0; j !== b; ++j) _[j].apply(g);
    return this;
  }
  setTime(e) {
    this.time = 0;
    for (let o = 0; o < this._actions.length; o++) this._actions[o].time = 0;
    return this.update(e);
  }
  getRoot() {
    return this._root;
  }
  uncacheClip(e) {
    const o = this._actions,
      a = e.uuid,
      c = this._actionsByClip,
      d = c[a];
    if (d !== void 0) {
      const g = d.knownActions;
      for (let _ = 0, b = g.length; _ !== b; ++_) {
        const j = g[_];
        this._deactivateAction(j);
        const $ = j._cacheIndex,
          _e = o[o.length - 1];
        (j._cacheIndex = null),
          (j._byClipCacheIndex = null),
          (_e._cacheIndex = $),
          (o[$] = _e),
          o.pop(),
          this._removeInactiveBindingsForAction(j);
      }
      delete c[a];
    }
  }
  uncacheRoot(e) {
    const o = e.uuid,
      a = this._actionsByClip;
    for (const g in a) {
      const _ = a[g].actionByRoot,
        b = _[o];
      b !== void 0 &&
        (this._deactivateAction(b), this._removeInactiveAction(b));
    }
    const c = this._bindingsByRootAndName,
      d = c[o];
    if (d !== void 0)
      for (const g in d) {
        const _ = d[g];
        _.restoreOriginalState(), this._removeInactiveBinding(_);
      }
  }
  uncacheAction(e, o) {
    const a = this.existingAction(e, o);
    a !== null && (this._deactivateAction(a), this._removeInactiveAction(a));
  }
}
class Uniform {
  constructor(e) {
    this.value = e;
  }
  clone() {
    return new Uniform(
      this.value.clone === void 0 ? this.value : this.value.clone()
    );
  }
}
let _id = 0;
class UniformsGroup extends EventDispatcher {
  constructor() {
    super(),
      (this.isUniformsGroup = !0),
      Object.defineProperty(this, "id", { value: _id++ }),
      (this.name = ""),
      (this.usage = StaticDrawUsage),
      (this.uniforms = []);
  }
  add(e) {
    return this.uniforms.push(e), this;
  }
  remove(e) {
    const o = this.uniforms.indexOf(e);
    return o !== -1 && this.uniforms.splice(o, 1), this;
  }
  setName(e) {
    return (this.name = e), this;
  }
  setUsage(e) {
    return (this.usage = e), this;
  }
  dispose() {
    return this.dispatchEvent({ type: "dispose" }), this;
  }
  copy(e) {
    (this.name = e.name), (this.usage = e.usage);
    const o = e.uniforms;
    this.uniforms.length = 0;
    for (let a = 0, c = o.length; a < c; a++) {
      const d = Array.isArray(o[a]) ? o[a] : [o[a]];
      for (let g = 0; g < d.length; g++) this.uniforms.push(d[g].clone());
    }
    return this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
class InstancedInterleavedBuffer extends InterleavedBuffer {
  constructor(e, o, a = 1) {
    super(e, o),
      (this.isInstancedInterleavedBuffer = !0),
      (this.meshPerAttribute = a);
  }
  copy(e) {
    return super.copy(e), (this.meshPerAttribute = e.meshPerAttribute), this;
  }
  clone(e) {
    const o = super.clone(e);
    return (o.meshPerAttribute = this.meshPerAttribute), o;
  }
  toJSON(e) {
    const o = super.toJSON(e);
    return (
      (o.isInstancedInterleavedBuffer = !0),
      (o.meshPerAttribute = this.meshPerAttribute),
      o
    );
  }
}
class GLBufferAttribute {
  constructor(e, o, a, c, d) {
    (this.isGLBufferAttribute = !0),
      (this.name = ""),
      (this.buffer = e),
      (this.type = o),
      (this.itemSize = a),
      (this.elementSize = c),
      (this.count = d),
      (this.version = 0);
  }
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  setBuffer(e) {
    return (this.buffer = e), this;
  }
  setType(e, o) {
    return (this.type = e), (this.elementSize = o), this;
  }
  setItemSize(e) {
    return (this.itemSize = e), this;
  }
  setCount(e) {
    return (this.count = e), this;
  }
}
const _matrix = new Matrix4();
class Raycaster {
  constructor(e, o, a = 0, c = 1 / 0) {
    (this.ray = new Ray(e, o)),
      (this.near = a),
      (this.far = c),
      (this.camera = null),
      (this.layers = new Layers()),
      (this.params = {
        Mesh: {},
        Line: { threshold: 1 },
        LOD: {},
        Points: { threshold: 1 },
        Sprite: {},
      });
  }
  set(e, o) {
    this.ray.set(e, o);
  }
  setFromCamera(e, o) {
    o.isPerspectiveCamera
      ? (this.ray.origin.setFromMatrixPosition(o.matrixWorld),
        this.ray.direction
          .set(e.x, e.y, 0.5)
          .unproject(o)
          .sub(this.ray.origin)
          .normalize(),
        (this.camera = o))
      : o.isOrthographicCamera
      ? (this.ray.origin
          .set(e.x, e.y, (o.near + o.far) / (o.near - o.far))
          .unproject(o),
        this.ray.direction.set(0, 0, -1).transformDirection(o.matrixWorld),
        (this.camera = o))
      : console.error("THREE.Raycaster: Unsupported camera type: " + o.type);
  }
  setFromXRController(e) {
    return (
      _matrix.identity().extractRotation(e.matrixWorld),
      this.ray.origin.setFromMatrixPosition(e.matrixWorld),
      this.ray.direction.set(0, 0, -1).applyMatrix4(_matrix),
      this
    );
  }
  intersectObject(e, o = !0, a = []) {
    return intersect(e, this, a, o), a.sort(ascSort), a;
  }
  intersectObjects(e, o = !0, a = []) {
    for (let c = 0, d = e.length; c < d; c++) intersect(e[c], this, a, o);
    return a.sort(ascSort), a;
  }
}
function ascSort(s, e) {
  return s.distance - e.distance;
}
function intersect(s, e, o, a) {
  let c = !0;
  if (
    (s.layers.test(e.layers) && s.raycast(e, o) === !1 && (c = !1),
    c === !0 && a === !0)
  ) {
    const d = s.children;
    for (let g = 0, _ = d.length; g < _; g++) intersect(d[g], e, o, !0);
  }
}
class Spherical {
  constructor(e = 1, o = 0, a = 0) {
    return (this.radius = e), (this.phi = o), (this.theta = a), this;
  }
  set(e, o, a) {
    return (this.radius = e), (this.phi = o), (this.theta = a), this;
  }
  copy(e) {
    return (
      (this.radius = e.radius), (this.phi = e.phi), (this.theta = e.theta), this
    );
  }
  makeSafe() {
    return (
      (this.phi = Math.max(1e-6, Math.min(Math.PI - 1e-6, this.phi))), this
    );
  }
  setFromVector3(e) {
    return this.setFromCartesianCoords(e.x, e.y, e.z);
  }
  setFromCartesianCoords(e, o, a) {
    return (
      (this.radius = Math.sqrt(e * e + o * o + a * a)),
      this.radius === 0
        ? ((this.theta = 0), (this.phi = 0))
        : ((this.theta = Math.atan2(e, a)),
          (this.phi = Math.acos(clamp(o / this.radius, -1, 1)))),
      this
    );
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
class Cylindrical {
  constructor(e = 1, o = 0, a = 0) {
    return (this.radius = e), (this.theta = o), (this.y = a), this;
  }
  set(e, o, a) {
    return (this.radius = e), (this.theta = o), (this.y = a), this;
  }
  copy(e) {
    return (
      (this.radius = e.radius), (this.theta = e.theta), (this.y = e.y), this
    );
  }
  setFromVector3(e) {
    return this.setFromCartesianCoords(e.x, e.y, e.z);
  }
  setFromCartesianCoords(e, o, a) {
    return (
      (this.radius = Math.sqrt(e * e + a * a)),
      (this.theta = Math.atan2(e, a)),
      (this.y = o),
      this
    );
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
class Matrix2 {
  constructor(e, o, a, c) {
    (Matrix2.prototype.isMatrix2 = !0),
      (this.elements = [1, 0, 0, 1]),
      e !== void 0 && this.set(e, o, a, c);
  }
  identity() {
    return this.set(1, 0, 0, 1), this;
  }
  fromArray(e, o = 0) {
    for (let a = 0; a < 4; a++) this.elements[a] = e[a + o];
    return this;
  }
  set(e, o, a, c) {
    const d = this.elements;
    return (d[0] = e), (d[2] = o), (d[1] = a), (d[3] = c), this;
  }
}
const _vector$4 = new Vector2();
class Box2 {
  constructor(e = new Vector2(1 / 0, 1 / 0), o = new Vector2(-1 / 0, -1 / 0)) {
    (this.isBox2 = !0), (this.min = e), (this.max = o);
  }
  set(e, o) {
    return this.min.copy(e), this.max.copy(o), this;
  }
  setFromPoints(e) {
    this.makeEmpty();
    for (let o = 0, a = e.length; o < a; o++) this.expandByPoint(e[o]);
    return this;
  }
  setFromCenterAndSize(e, o) {
    const a = _vector$4.copy(o).multiplyScalar(0.5);
    return this.min.copy(e).sub(a), this.max.copy(e).add(a), this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.min.copy(e.min), this.max.copy(e.max), this;
  }
  makeEmpty() {
    return (
      (this.min.x = this.min.y = 1 / 0),
      (this.max.x = this.max.y = -1 / 0),
      this
    );
  }
  isEmpty() {
    return this.max.x < this.min.x || this.max.y < this.min.y;
  }
  getCenter(e) {
    return this.isEmpty()
      ? e.set(0, 0)
      : e.addVectors(this.min, this.max).multiplyScalar(0.5);
  }
  getSize(e) {
    return this.isEmpty() ? e.set(0, 0) : e.subVectors(this.max, this.min);
  }
  expandByPoint(e) {
    return this.min.min(e), this.max.max(e), this;
  }
  expandByVector(e) {
    return this.min.sub(e), this.max.add(e), this;
  }
  expandByScalar(e) {
    return this.min.addScalar(-e), this.max.addScalar(e), this;
  }
  containsPoint(e) {
    return (
      e.x >= this.min.x &&
      e.x <= this.max.x &&
      e.y >= this.min.y &&
      e.y <= this.max.y
    );
  }
  containsBox(e) {
    return (
      this.min.x <= e.min.x &&
      e.max.x <= this.max.x &&
      this.min.y <= e.min.y &&
      e.max.y <= this.max.y
    );
  }
  getParameter(e, o) {
    return o.set(
      (e.x - this.min.x) / (this.max.x - this.min.x),
      (e.y - this.min.y) / (this.max.y - this.min.y)
    );
  }
  intersectsBox(e) {
    return (
      e.max.x >= this.min.x &&
      e.min.x <= this.max.x &&
      e.max.y >= this.min.y &&
      e.min.y <= this.max.y
    );
  }
  clampPoint(e, o) {
    return o.copy(e).clamp(this.min, this.max);
  }
  distanceToPoint(e) {
    return this.clampPoint(e, _vector$4).distanceTo(e);
  }
  intersect(e) {
    return (
      this.min.max(e.min),
      this.max.min(e.max),
      this.isEmpty() && this.makeEmpty(),
      this
    );
  }
  union(e) {
    return this.min.min(e.min), this.max.max(e.max), this;
  }
  translate(e) {
    return this.min.add(e), this.max.add(e), this;
  }
  equals(e) {
    return e.min.equals(this.min) && e.max.equals(this.max);
  }
}
const _startP = new Vector3(),
  _startEnd = new Vector3();
class Line3 {
  constructor(e = new Vector3(), o = new Vector3()) {
    (this.start = e), (this.end = o);
  }
  set(e, o) {
    return this.start.copy(e), this.end.copy(o), this;
  }
  copy(e) {
    return this.start.copy(e.start), this.end.copy(e.end), this;
  }
  getCenter(e) {
    return e.addVectors(this.start, this.end).multiplyScalar(0.5);
  }
  delta(e) {
    return e.subVectors(this.end, this.start);
  }
  distanceSq() {
    return this.start.distanceToSquared(this.end);
  }
  distance() {
    return this.start.distanceTo(this.end);
  }
  at(e, o) {
    return this.delta(o).multiplyScalar(e).add(this.start);
  }
  closestPointToPointParameter(e, o) {
    _startP.subVectors(e, this.start),
      _startEnd.subVectors(this.end, this.start);
    const a = _startEnd.dot(_startEnd);
    let d = _startEnd.dot(_startP) / a;
    return o && (d = clamp(d, 0, 1)), d;
  }
  closestPointToPoint(e, o, a) {
    const c = this.closestPointToPointParameter(e, o);
    return this.delta(a).multiplyScalar(c).add(this.start);
  }
  applyMatrix4(e) {
    return this.start.applyMatrix4(e), this.end.applyMatrix4(e), this;
  }
  equals(e) {
    return e.start.equals(this.start) && e.end.equals(this.end);
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const _vector$3 = new Vector3();
class SpotLightHelper extends Object3D {
  constructor(e, o) {
    super(),
      (this.light = e),
      (this.matrixAutoUpdate = !1),
      (this.color = o),
      (this.type = "SpotLightHelper");
    const a = new BufferGeometry(),
      c = [
        0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, -1, 0, 1, 0, 0, 0, 0, 1, 1,
        0, 0, 0, 0, -1, 1,
      ];
    for (let g = 0, _ = 1, b = 32; g < b; g++, _++) {
      const j = (g / b) * Math.PI * 2,
        $ = (_ / b) * Math.PI * 2;
      c.push(Math.cos(j), Math.sin(j), 1, Math.cos($), Math.sin($), 1);
    }
    a.setAttribute("position", new Float32BufferAttribute(c, 3));
    const d = new LineBasicMaterial({ fog: !1, toneMapped: !1 });
    (this.cone = new LineSegments(a, d)), this.add(this.cone), this.update();
  }
  dispose() {
    this.cone.geometry.dispose(), this.cone.material.dispose();
  }
  update() {
    this.light.updateWorldMatrix(!0, !1),
      this.light.target.updateWorldMatrix(!0, !1),
      this.parent
        ? (this.parent.updateWorldMatrix(!0),
          this.matrix
            .copy(this.parent.matrixWorld)
            .invert()
            .multiply(this.light.matrixWorld))
        : this.matrix.copy(this.light.matrixWorld),
      this.matrixWorld.copy(this.light.matrixWorld);
    const e = this.light.distance ? this.light.distance : 1e3,
      o = e * Math.tan(this.light.angle);
    this.cone.scale.set(o, o, e),
      _vector$3.setFromMatrixPosition(this.light.target.matrixWorld),
      this.cone.lookAt(_vector$3),
      this.color !== void 0
        ? this.cone.material.color.set(this.color)
        : this.cone.material.color.copy(this.light.color);
  }
}
const _vector$2 = new Vector3(),
  _boneMatrix = new Matrix4(),
  _matrixWorldInv = new Matrix4();
class SkeletonHelper extends LineSegments {
  constructor(e) {
    const o = getBoneList(e),
      a = new BufferGeometry(),
      c = [],
      d = [],
      g = new Color(0, 0, 1),
      _ = new Color(0, 1, 0);
    for (let j = 0; j < o.length; j++) {
      const $ = o[j];
      $.parent &&
        $.parent.isBone &&
        (c.push(0, 0, 0),
        c.push(0, 0, 0),
        d.push(g.r, g.g, g.b),
        d.push(_.r, _.g, _.b));
    }
    a.setAttribute("position", new Float32BufferAttribute(c, 3)),
      a.setAttribute("color", new Float32BufferAttribute(d, 3));
    const b = new LineBasicMaterial({
      vertexColors: !0,
      depthTest: !1,
      depthWrite: !1,
      toneMapped: !1,
      transparent: !0,
    });
    super(a, b),
      (this.isSkeletonHelper = !0),
      (this.type = "SkeletonHelper"),
      (this.root = e),
      (this.bones = o),
      (this.matrix = e.matrixWorld),
      (this.matrixAutoUpdate = !1);
  }
  updateMatrixWorld(e) {
    const o = this.bones,
      a = this.geometry,
      c = a.getAttribute("position");
    _matrixWorldInv.copy(this.root.matrixWorld).invert();
    for (let d = 0, g = 0; d < o.length; d++) {
      const _ = o[d];
      _.parent &&
        _.parent.isBone &&
        (_boneMatrix.multiplyMatrices(_matrixWorldInv, _.matrixWorld),
        _vector$2.setFromMatrixPosition(_boneMatrix),
        c.setXYZ(g, _vector$2.x, _vector$2.y, _vector$2.z),
        _boneMatrix.multiplyMatrices(_matrixWorldInv, _.parent.matrixWorld),
        _vector$2.setFromMatrixPosition(_boneMatrix),
        c.setXYZ(g + 1, _vector$2.x, _vector$2.y, _vector$2.z),
        (g += 2));
    }
    (a.getAttribute("position").needsUpdate = !0), super.updateMatrixWorld(e);
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
function getBoneList(s) {
  const e = [];
  s.isBone === !0 && e.push(s);
  for (let o = 0; o < s.children.length; o++)
    e.push.apply(e, getBoneList(s.children[o]));
  return e;
}
class PointLightHelper extends Mesh {
  constructor(e, o, a) {
    const c = new SphereGeometry(o, 4, 2),
      d = new MeshBasicMaterial({ wireframe: !0, fog: !1, toneMapped: !1 });
    super(c, d),
      (this.light = e),
      (this.color = a),
      (this.type = "PointLightHelper"),
      (this.matrix = this.light.matrixWorld),
      (this.matrixAutoUpdate = !1),
      this.update();
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
  update() {
    this.light.updateWorldMatrix(!0, !1),
      this.color !== void 0
        ? this.material.color.set(this.color)
        : this.material.color.copy(this.light.color);
  }
}
const _vector$1 = new Vector3(),
  _color1 = new Color(),
  _color2 = new Color();
class HemisphereLightHelper extends Object3D {
  constructor(e, o, a) {
    super(),
      (this.light = e),
      (this.matrix = e.matrixWorld),
      (this.matrixAutoUpdate = !1),
      (this.color = a),
      (this.type = "HemisphereLightHelper");
    const c = new OctahedronGeometry(o);
    c.rotateY(Math.PI * 0.5),
      (this.material = new MeshBasicMaterial({
        wireframe: !0,
        fog: !1,
        toneMapped: !1,
      })),
      this.color === void 0 && (this.material.vertexColors = !0);
    const d = c.getAttribute("position"),
      g = new Float32Array(d.count * 3);
    c.setAttribute("color", new BufferAttribute(g, 3)),
      this.add(new Mesh(c, this.material)),
      this.update();
  }
  dispose() {
    this.children[0].geometry.dispose(), this.children[0].material.dispose();
  }
  update() {
    const e = this.children[0];
    if (this.color !== void 0) this.material.color.set(this.color);
    else {
      const o = e.geometry.getAttribute("color");
      _color1.copy(this.light.color), _color2.copy(this.light.groundColor);
      for (let a = 0, c = o.count; a < c; a++) {
        const d = a < c / 2 ? _color1 : _color2;
        o.setXYZ(a, d.r, d.g, d.b);
      }
      o.needsUpdate = !0;
    }
    this.light.updateWorldMatrix(!0, !1),
      e.lookAt(
        _vector$1.setFromMatrixPosition(this.light.matrixWorld).negate()
      );
  }
}
class GridHelper extends LineSegments {
  constructor(e = 10, o = 10, a = 4473924, c = 8947848) {
    (a = new Color(a)), (c = new Color(c));
    const d = o / 2,
      g = e / o,
      _ = e / 2,
      b = [],
      j = [];
    for (let et = 0, rt = 0, st = -_; et <= o; et++, st += g) {
      b.push(-_, 0, st, _, 0, st), b.push(st, 0, -_, st, 0, _);
      const at = et === d ? a : c;
      at.toArray(j, rt),
        (rt += 3),
        at.toArray(j, rt),
        (rt += 3),
        at.toArray(j, rt),
        (rt += 3),
        at.toArray(j, rt),
        (rt += 3);
    }
    const $ = new BufferGeometry();
    $.setAttribute("position", new Float32BufferAttribute(b, 3)),
      $.setAttribute("color", new Float32BufferAttribute(j, 3));
    const _e = new LineBasicMaterial({ vertexColors: !0, toneMapped: !1 });
    super($, _e), (this.type = "GridHelper");
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
class PolarGridHelper extends LineSegments {
  constructor(e = 10, o = 16, a = 8, c = 64, d = 4473924, g = 8947848) {
    (d = new Color(d)), (g = new Color(g));
    const _ = [],
      b = [];
    if (o > 1)
      for (let _e = 0; _e < o; _e++) {
        const et = (_e / o) * (Math.PI * 2),
          rt = Math.sin(et) * e,
          st = Math.cos(et) * e;
        _.push(0, 0, 0), _.push(rt, 0, st);
        const at = _e & 1 ? d : g;
        b.push(at.r, at.g, at.b), b.push(at.r, at.g, at.b);
      }
    for (let _e = 0; _e < a; _e++) {
      const et = _e & 1 ? d : g,
        rt = e - (e / a) * _e;
      for (let st = 0; st < c; st++) {
        let at = (st / c) * (Math.PI * 2),
          ct = Math.sin(at) * rt,
          it = Math.cos(at) * rt;
        _.push(ct, 0, it),
          b.push(et.r, et.g, et.b),
          (at = ((st + 1) / c) * (Math.PI * 2)),
          (ct = Math.sin(at) * rt),
          (it = Math.cos(at) * rt),
          _.push(ct, 0, it),
          b.push(et.r, et.g, et.b);
      }
    }
    const j = new BufferGeometry();
    j.setAttribute("position", new Float32BufferAttribute(_, 3)),
      j.setAttribute("color", new Float32BufferAttribute(b, 3));
    const $ = new LineBasicMaterial({ vertexColors: !0, toneMapped: !1 });
    super(j, $), (this.type = "PolarGridHelper");
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
const _v1 = new Vector3(),
  _v2 = new Vector3(),
  _v3 = new Vector3();
class DirectionalLightHelper extends Object3D {
  constructor(e, o, a) {
    super(),
      (this.light = e),
      (this.matrix = e.matrixWorld),
      (this.matrixAutoUpdate = !1),
      (this.color = a),
      (this.type = "DirectionalLightHelper"),
      o === void 0 && (o = 1);
    let c = new BufferGeometry();
    c.setAttribute(
      "position",
      new Float32BufferAttribute(
        [-o, o, 0, o, o, 0, o, -o, 0, -o, -o, 0, -o, o, 0],
        3
      )
    );
    const d = new LineBasicMaterial({ fog: !1, toneMapped: !1 });
    (this.lightPlane = new Line(c, d)),
      this.add(this.lightPlane),
      (c = new BufferGeometry()),
      c.setAttribute(
        "position",
        new Float32BufferAttribute([0, 0, 0, 0, 0, 1], 3)
      ),
      (this.targetLine = new Line(c, d)),
      this.add(this.targetLine),
      this.update();
  }
  dispose() {
    this.lightPlane.geometry.dispose(),
      this.lightPlane.material.dispose(),
      this.targetLine.geometry.dispose(),
      this.targetLine.material.dispose();
  }
  update() {
    this.light.updateWorldMatrix(!0, !1),
      this.light.target.updateWorldMatrix(!0, !1),
      _v1.setFromMatrixPosition(this.light.matrixWorld),
      _v2.setFromMatrixPosition(this.light.target.matrixWorld),
      _v3.subVectors(_v2, _v1),
      this.lightPlane.lookAt(_v2),
      this.color !== void 0
        ? (this.lightPlane.material.color.set(this.color),
          this.targetLine.material.color.set(this.color))
        : (this.lightPlane.material.color.copy(this.light.color),
          this.targetLine.material.color.copy(this.light.color)),
      this.targetLine.lookAt(_v2),
      (this.targetLine.scale.z = _v3.length());
  }
}
const _vector = new Vector3(),
  _camera = new Camera();
class CameraHelper extends LineSegments {
  constructor(e) {
    const o = new BufferGeometry(),
      a = new LineBasicMaterial({
        color: 16777215,
        vertexColors: !0,
        toneMapped: !1,
      }),
      c = [],
      d = [],
      g = {};
    _("n1", "n2"),
      _("n2", "n4"),
      _("n4", "n3"),
      _("n3", "n1"),
      _("f1", "f2"),
      _("f2", "f4"),
      _("f4", "f3"),
      _("f3", "f1"),
      _("n1", "f1"),
      _("n2", "f2"),
      _("n3", "f3"),
      _("n4", "f4"),
      _("p", "n1"),
      _("p", "n2"),
      _("p", "n3"),
      _("p", "n4"),
      _("u1", "u2"),
      _("u2", "u3"),
      _("u3", "u1"),
      _("c", "t"),
      _("p", "c"),
      _("cn1", "cn2"),
      _("cn3", "cn4"),
      _("cf1", "cf2"),
      _("cf3", "cf4");
    function _(st, at) {
      b(st), b(at);
    }
    function b(st) {
      c.push(0, 0, 0),
        d.push(0, 0, 0),
        g[st] === void 0 && (g[st] = []),
        g[st].push(c.length / 3 - 1);
    }
    o.setAttribute("position", new Float32BufferAttribute(c, 3)),
      o.setAttribute("color", new Float32BufferAttribute(d, 3)),
      super(o, a),
      (this.type = "CameraHelper"),
      (this.camera = e),
      this.camera.updateProjectionMatrix &&
        this.camera.updateProjectionMatrix(),
      (this.matrix = e.matrixWorld),
      (this.matrixAutoUpdate = !1),
      (this.pointMap = g),
      this.update();
    const j = new Color(16755200),
      $ = new Color(16711680),
      _e = new Color(43775),
      et = new Color(16777215),
      rt = new Color(3355443);
    this.setColors(j, $, _e, et, rt);
  }
  setColors(e, o, a, c, d) {
    const _ = this.geometry.getAttribute("color");
    _.setXYZ(0, e.r, e.g, e.b),
      _.setXYZ(1, e.r, e.g, e.b),
      _.setXYZ(2, e.r, e.g, e.b),
      _.setXYZ(3, e.r, e.g, e.b),
      _.setXYZ(4, e.r, e.g, e.b),
      _.setXYZ(5, e.r, e.g, e.b),
      _.setXYZ(6, e.r, e.g, e.b),
      _.setXYZ(7, e.r, e.g, e.b),
      _.setXYZ(8, e.r, e.g, e.b),
      _.setXYZ(9, e.r, e.g, e.b),
      _.setXYZ(10, e.r, e.g, e.b),
      _.setXYZ(11, e.r, e.g, e.b),
      _.setXYZ(12, e.r, e.g, e.b),
      _.setXYZ(13, e.r, e.g, e.b),
      _.setXYZ(14, e.r, e.g, e.b),
      _.setXYZ(15, e.r, e.g, e.b),
      _.setXYZ(16, e.r, e.g, e.b),
      _.setXYZ(17, e.r, e.g, e.b),
      _.setXYZ(18, e.r, e.g, e.b),
      _.setXYZ(19, e.r, e.g, e.b),
      _.setXYZ(20, e.r, e.g, e.b),
      _.setXYZ(21, e.r, e.g, e.b),
      _.setXYZ(22, e.r, e.g, e.b),
      _.setXYZ(23, e.r, e.g, e.b),
      _.setXYZ(24, o.r, o.g, o.b),
      _.setXYZ(25, o.r, o.g, o.b),
      _.setXYZ(26, o.r, o.g, o.b),
      _.setXYZ(27, o.r, o.g, o.b),
      _.setXYZ(28, o.r, o.g, o.b),
      _.setXYZ(29, o.r, o.g, o.b),
      _.setXYZ(30, o.r, o.g, o.b),
      _.setXYZ(31, o.r, o.g, o.b),
      _.setXYZ(32, a.r, a.g, a.b),
      _.setXYZ(33, a.r, a.g, a.b),
      _.setXYZ(34, a.r, a.g, a.b),
      _.setXYZ(35, a.r, a.g, a.b),
      _.setXYZ(36, a.r, a.g, a.b),
      _.setXYZ(37, a.r, a.g, a.b),
      _.setXYZ(38, c.r, c.g, c.b),
      _.setXYZ(39, c.r, c.g, c.b),
      _.setXYZ(40, d.r, d.g, d.b),
      _.setXYZ(41, d.r, d.g, d.b),
      _.setXYZ(42, d.r, d.g, d.b),
      _.setXYZ(43, d.r, d.g, d.b),
      _.setXYZ(44, d.r, d.g, d.b),
      _.setXYZ(45, d.r, d.g, d.b),
      _.setXYZ(46, d.r, d.g, d.b),
      _.setXYZ(47, d.r, d.g, d.b),
      _.setXYZ(48, d.r, d.g, d.b),
      _.setXYZ(49, d.r, d.g, d.b),
      (_.needsUpdate = !0);
  }
  update() {
    const e = this.geometry,
      o = this.pointMap,
      a = 1,
      c = 1;
    _camera.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse),
      setPoint("c", o, e, _camera, 0, 0, -1),
      setPoint("t", o, e, _camera, 0, 0, 1),
      setPoint("n1", o, e, _camera, -a, -c, -1),
      setPoint("n2", o, e, _camera, a, -c, -1),
      setPoint("n3", o, e, _camera, -a, c, -1),
      setPoint("n4", o, e, _camera, a, c, -1),
      setPoint("f1", o, e, _camera, -a, -c, 1),
      setPoint("f2", o, e, _camera, a, -c, 1),
      setPoint("f3", o, e, _camera, -a, c, 1),
      setPoint("f4", o, e, _camera, a, c, 1),
      setPoint("u1", o, e, _camera, a * 0.7, c * 1.1, -1),
      setPoint("u2", o, e, _camera, -a * 0.7, c * 1.1, -1),
      setPoint("u3", o, e, _camera, 0, c * 2, -1),
      setPoint("cf1", o, e, _camera, -a, 0, 1),
      setPoint("cf2", o, e, _camera, a, 0, 1),
      setPoint("cf3", o, e, _camera, 0, -c, 1),
      setPoint("cf4", o, e, _camera, 0, c, 1),
      setPoint("cn1", o, e, _camera, -a, 0, -1),
      setPoint("cn2", o, e, _camera, a, 0, -1),
      setPoint("cn3", o, e, _camera, 0, -c, -1),
      setPoint("cn4", o, e, _camera, 0, c, -1),
      (e.getAttribute("position").needsUpdate = !0);
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
function setPoint(s, e, o, a, c, d, g) {
  _vector.set(c, d, g).unproject(a);
  const _ = e[s];
  if (_ !== void 0) {
    const b = o.getAttribute("position");
    for (let j = 0, $ = _.length; j < $; j++)
      b.setXYZ(_[j], _vector.x, _vector.y, _vector.z);
  }
}
const _box = new Box3();
class BoxHelper extends LineSegments {
  constructor(e, o = 16776960) {
    const a = new Uint16Array([
        0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7,
      ]),
      c = new Float32Array(8 * 3),
      d = new BufferGeometry();
    d.setIndex(new BufferAttribute(a, 1)),
      d.setAttribute("position", new BufferAttribute(c, 3)),
      super(d, new LineBasicMaterial({ color: o, toneMapped: !1 })),
      (this.object = e),
      (this.type = "BoxHelper"),
      (this.matrixAutoUpdate = !1),
      this.update();
  }
  update(e) {
    if (
      (e !== void 0 &&
        console.warn("THREE.BoxHelper: .update() has no longer arguments."),
      this.object !== void 0 && _box.setFromObject(this.object),
      _box.isEmpty())
    )
      return;
    const o = _box.min,
      a = _box.max,
      c = this.geometry.attributes.position,
      d = c.array;
    (d[0] = a.x),
      (d[1] = a.y),
      (d[2] = a.z),
      (d[3] = o.x),
      (d[4] = a.y),
      (d[5] = a.z),
      (d[6] = o.x),
      (d[7] = o.y),
      (d[8] = a.z),
      (d[9] = a.x),
      (d[10] = o.y),
      (d[11] = a.z),
      (d[12] = a.x),
      (d[13] = a.y),
      (d[14] = o.z),
      (d[15] = o.x),
      (d[16] = a.y),
      (d[17] = o.z),
      (d[18] = o.x),
      (d[19] = o.y),
      (d[20] = o.z),
      (d[21] = a.x),
      (d[22] = o.y),
      (d[23] = o.z),
      (c.needsUpdate = !0),
      this.geometry.computeBoundingSphere();
  }
  setFromObject(e) {
    return (this.object = e), this.update(), this;
  }
  copy(e, o) {
    return super.copy(e, o), (this.object = e.object), this;
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
class Box3Helper extends LineSegments {
  constructor(e, o = 16776960) {
    const a = new Uint16Array([
        0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7,
      ]),
      c = [
        1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1,
        1, -1, -1,
      ],
      d = new BufferGeometry();
    d.setIndex(new BufferAttribute(a, 1)),
      d.setAttribute("position", new Float32BufferAttribute(c, 3)),
      super(d, new LineBasicMaterial({ color: o, toneMapped: !1 })),
      (this.box = e),
      (this.type = "Box3Helper"),
      this.geometry.computeBoundingSphere();
  }
  updateMatrixWorld(e) {
    const o = this.box;
    o.isEmpty() ||
      (o.getCenter(this.position),
      o.getSize(this.scale),
      this.scale.multiplyScalar(0.5),
      super.updateMatrixWorld(e));
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
class PlaneHelper extends Line {
  constructor(e, o = 1, a = 16776960) {
    const c = a,
      d = [
        1, -1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, 1, 0, -1, -1, 0, 1, -1, 0,
        1, 1, 0,
      ],
      g = new BufferGeometry();
    g.setAttribute("position", new Float32BufferAttribute(d, 3)),
      g.computeBoundingSphere(),
      super(g, new LineBasicMaterial({ color: c, toneMapped: !1 })),
      (this.type = "PlaneHelper"),
      (this.plane = e),
      (this.size = o);
    const _ = [1, 1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, -1, 0, 1, -1, 0],
      b = new BufferGeometry();
    b.setAttribute("position", new Float32BufferAttribute(_, 3)),
      b.computeBoundingSphere(),
      this.add(
        new Mesh(
          b,
          new MeshBasicMaterial({
            color: c,
            opacity: 0.2,
            transparent: !0,
            depthWrite: !1,
            toneMapped: !1,
          })
        )
      );
  }
  updateMatrixWorld(e) {
    this.position.set(0, 0, 0),
      this.scale.set(0.5 * this.size, 0.5 * this.size, 1),
      this.lookAt(this.plane.normal),
      this.translateZ(-this.plane.constant),
      super.updateMatrixWorld(e);
  }
  dispose() {
    this.geometry.dispose(),
      this.material.dispose(),
      this.children[0].geometry.dispose(),
      this.children[0].material.dispose();
  }
}
const _axis = new Vector3();
let _lineGeometry, _coneGeometry;
class ArrowHelper extends Object3D {
  constructor(
    e = new Vector3(0, 0, 1),
    o = new Vector3(0, 0, 0),
    a = 1,
    c = 16776960,
    d = a * 0.2,
    g = d * 0.2
  ) {
    super(),
      (this.type = "ArrowHelper"),
      _lineGeometry === void 0 &&
        ((_lineGeometry = new BufferGeometry()),
        _lineGeometry.setAttribute(
          "position",
          new Float32BufferAttribute([0, 0, 0, 0, 1, 0], 3)
        ),
        (_coneGeometry = new CylinderGeometry(0, 0.5, 1, 5, 1)),
        _coneGeometry.translate(0, -0.5, 0)),
      this.position.copy(o),
      (this.line = new Line(
        _lineGeometry,
        new LineBasicMaterial({ color: c, toneMapped: !1 })
      )),
      (this.line.matrixAutoUpdate = !1),
      this.add(this.line),
      (this.cone = new Mesh(
        _coneGeometry,
        new MeshBasicMaterial({ color: c, toneMapped: !1 })
      )),
      (this.cone.matrixAutoUpdate = !1),
      this.add(this.cone),
      this.setDirection(e),
      this.setLength(a, d, g);
  }
  setDirection(e) {
    if (e.y > 0.99999) this.quaternion.set(0, 0, 0, 1);
    else if (e.y < -0.99999) this.quaternion.set(1, 0, 0, 0);
    else {
      _axis.set(e.z, 0, -e.x).normalize();
      const o = Math.acos(e.y);
      this.quaternion.setFromAxisAngle(_axis, o);
    }
  }
  setLength(e, o = e * 0.2, a = o * 0.2) {
    this.line.scale.set(1, Math.max(1e-4, e - o), 1),
      this.line.updateMatrix(),
      this.cone.scale.set(a, o, a),
      (this.cone.position.y = e),
      this.cone.updateMatrix();
  }
  setColor(e) {
    this.line.material.color.set(e), this.cone.material.color.set(e);
  }
  copy(e) {
    return (
      super.copy(e, !1), this.line.copy(e.line), this.cone.copy(e.cone), this
    );
  }
  dispose() {
    this.line.geometry.dispose(),
      this.line.material.dispose(),
      this.cone.geometry.dispose(),
      this.cone.material.dispose();
  }
}
class AxesHelper extends LineSegments {
  constructor(e = 1) {
    const o = [0, 0, 0, e, 0, 0, 0, 0, 0, 0, e, 0, 0, 0, 0, 0, 0, e],
      a = [1, 0, 0, 1, 0.6, 0, 0, 1, 0, 0.6, 1, 0, 0, 0, 1, 0, 0.6, 1],
      c = new BufferGeometry();
    c.setAttribute("position", new Float32BufferAttribute(o, 3)),
      c.setAttribute("color", new Float32BufferAttribute(a, 3));
    const d = new LineBasicMaterial({ vertexColors: !0, toneMapped: !1 });
    super(c, d), (this.type = "AxesHelper");
  }
  setColors(e, o, a) {
    const c = new Color(),
      d = this.geometry.attributes.color.array;
    return (
      c.set(e),
      c.toArray(d, 0),
      c.toArray(d, 3),
      c.set(o),
      c.toArray(d, 6),
      c.toArray(d, 9),
      c.set(a),
      c.toArray(d, 12),
      c.toArray(d, 15),
      (this.geometry.attributes.color.needsUpdate = !0),
      this
    );
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
class ShapePath {
  constructor() {
    (this.type = "ShapePath"),
      (this.color = new Color()),
      (this.subPaths = []),
      (this.currentPath = null);
  }
  moveTo(e, o) {
    return (
      (this.currentPath = new Path()),
      this.subPaths.push(this.currentPath),
      this.currentPath.moveTo(e, o),
      this
    );
  }
  lineTo(e, o) {
    return this.currentPath.lineTo(e, o), this;
  }
  quadraticCurveTo(e, o, a, c) {
    return this.currentPath.quadraticCurveTo(e, o, a, c), this;
  }
  bezierCurveTo(e, o, a, c, d, g) {
    return this.currentPath.bezierCurveTo(e, o, a, c, d, g), this;
  }
  splineThru(e) {
    return this.currentPath.splineThru(e), this;
  }
  toShapes(e) {
    function o(it) {
      const lt = [];
      for (let ot = 0, ut = it.length; ot < ut; ot++) {
        const pt = it[ot],
          ft = new Shape();
        (ft.curves = pt.curves), lt.push(ft);
      }
      return lt;
    }
    function a(it, lt) {
      const ot = lt.length;
      let ut = !1;
      for (let pt = ot - 1, ft = 0; ft < ot; pt = ft++) {
        let gt = lt[pt],
          xt = lt[ft],
          _t = xt.x - gt.x,
          St = xt.y - gt.y;
        if (Math.abs(St) > Number.EPSILON) {
          if (
            (St < 0 && ((gt = lt[ft]), (_t = -_t), (xt = lt[pt]), (St = -St)),
            it.y < gt.y || it.y > xt.y)
          )
            continue;
          if (it.y === gt.y) {
            if (it.x === gt.x) return !0;
          } else {
            const Mt = St * (it.x - gt.x) - _t * (it.y - gt.y);
            if (Mt === 0) return !0;
            if (Mt < 0) continue;
            ut = !ut;
          }
        } else {
          if (it.y !== gt.y) continue;
          if ((xt.x <= it.x && it.x <= gt.x) || (gt.x <= it.x && it.x <= xt.x))
            return !0;
        }
      }
      return ut;
    }
    const c = ShapeUtils.isClockWise,
      d = this.subPaths;
    if (d.length === 0) return [];
    let g, _, b;
    const j = [];
    if (d.length === 1)
      return (_ = d[0]), (b = new Shape()), (b.curves = _.curves), j.push(b), j;
    let $ = !c(d[0].getPoints());
    $ = e ? !$ : $;
    const _e = [],
      et = [];
    let rt = [],
      st = 0,
      at;
    (et[st] = void 0), (rt[st] = []);
    for (let it = 0, lt = d.length; it < lt; it++)
      (_ = d[it]),
        (at = _.getPoints()),
        (g = c(at)),
        (g = e ? !g : g),
        g
          ? (!$ && et[st] && st++,
            (et[st] = { s: new Shape(), p: at }),
            (et[st].s.curves = _.curves),
            $ && st++,
            (rt[st] = []))
          : rt[st].push({ h: _, p: at[0] });
    if (!et[0]) return o(d);
    if (et.length > 1) {
      let it = !1,
        lt = 0;
      for (let ot = 0, ut = et.length; ot < ut; ot++) _e[ot] = [];
      for (let ot = 0, ut = et.length; ot < ut; ot++) {
        const pt = rt[ot];
        for (let ft = 0; ft < pt.length; ft++) {
          const gt = pt[ft];
          let xt = !0;
          for (let _t = 0; _t < et.length; _t++)
            a(gt.p, et[_t].p) &&
              (ot !== _t && lt++,
              xt ? ((xt = !1), _e[_t].push(gt)) : (it = !0));
          xt && _e[ot].push(gt);
        }
      }
      lt > 0 && it === !1 && (rt = _e);
    }
    let ct;
    for (let it = 0, lt = et.length; it < lt; it++) {
      (b = et[it].s), j.push(b), (ct = rt[it]);
      for (let ot = 0, ut = ct.length; ot < ut; ot++) b.holes.push(ct[ot].h);
    }
    return j;
  }
}
class WebGLMultipleRenderTargets extends WebGLRenderTarget {
  constructor(e = 1, o = 1, a = 1, c = {}) {
    console.warn(
      'THREE.WebGLMultipleRenderTargets has been deprecated and will be removed in r172. Use THREE.WebGLRenderTarget and set the "count" parameter to enable MRT.'
    ),
      super(e, o, { ...c, count: a }),
      (this.isWebGLMultipleRenderTargets = !0);
  }
  get texture() {
    return this.textures;
  }
}
typeof __THREE_DEVTOOLS__ < "u" &&
  __THREE_DEVTOOLS__.dispatchEvent(
    new CustomEvent("register", { detail: { revision: REVISION } })
  );
typeof window < "u" &&
  (window.__THREE__
    ? console.warn("WARNING: Multiple instances of Three.js being imported.")
    : (window.__THREE__ = REVISION));
const THREE = Object.freeze(
  Object.defineProperty(
    {
      __proto__: null,
      ACESFilmicToneMapping,
      AddEquation,
      AddOperation,
      AdditiveAnimationBlendMode,
      AdditiveBlending,
      AgXToneMapping,
      AlphaFormat,
      AlwaysCompare,
      AlwaysDepth,
      AlwaysStencilFunc,
      AmbientLight,
      AnimationAction,
      AnimationClip,
      AnimationLoader,
      AnimationMixer,
      AnimationObjectGroup,
      AnimationUtils,
      ArcCurve,
      ArrayCamera,
      ArrowHelper,
      AttachedBindMode,
      Audio,
      AudioAnalyser,
      AudioContext,
      AudioListener,
      AudioLoader,
      AxesHelper,
      BackSide,
      BasicDepthPacking,
      BasicShadowMap,
      BatchedMesh,
      Bone,
      BooleanKeyframeTrack,
      Box2,
      Box3,
      Box3Helper,
      BoxGeometry,
      BoxHelper,
      BufferAttribute,
      BufferGeometry,
      BufferGeometryLoader,
      ByteType,
      Cache,
      Camera,
      CameraHelper,
      CanvasTexture,
      CapsuleGeometry,
      CatmullRomCurve3,
      CineonToneMapping,
      CircleGeometry,
      ClampToEdgeWrapping,
      Clock,
      Color,
      ColorKeyframeTrack,
      ColorManagement,
      CompressedArrayTexture,
      CompressedCubeTexture,
      CompressedTexture,
      CompressedTextureLoader,
      ConeGeometry,
      ConstantAlphaFactor,
      ConstantColorFactor,
      CubeCamera,
      CubeReflectionMapping,
      CubeRefractionMapping,
      CubeTexture,
      CubeTextureLoader,
      CubeUVReflectionMapping,
      CubicBezierCurve,
      CubicBezierCurve3,
      CubicInterpolant,
      CullFaceBack,
      CullFaceFront,
      CullFaceFrontBack,
      CullFaceNone,
      Curve,
      CurvePath,
      CustomBlending,
      CustomToneMapping,
      CylinderGeometry,
      Cylindrical,
      Data3DTexture,
      DataArrayTexture,
      DataTexture,
      DataTextureLoader,
      DataUtils,
      DecrementStencilOp,
      DecrementWrapStencilOp,
      DefaultLoadingManager,
      DepthFormat,
      DepthStencilFormat,
      DepthTexture,
      DetachedBindMode,
      DirectionalLight,
      DirectionalLightHelper,
      DiscreteInterpolant,
      DisplayP3ColorSpace,
      DodecahedronGeometry,
      DoubleSide,
      DstAlphaFactor,
      DstColorFactor,
      DynamicCopyUsage,
      DynamicDrawUsage,
      DynamicReadUsage,
      EdgesGeometry,
      EllipseCurve,
      EqualCompare,
      EqualDepth,
      EqualStencilFunc,
      EquirectangularReflectionMapping,
      EquirectangularRefractionMapping,
      Euler,
      EventDispatcher,
      ExtrudeGeometry,
      FileLoader,
      Float16BufferAttribute,
      Float32BufferAttribute,
      FloatType,
      Fog,
      FogExp2,
      FramebufferTexture,
      FrontSide,
      Frustum,
      GLBufferAttribute,
      GLSL1,
      GLSL3,
      GreaterCompare,
      GreaterDepth,
      GreaterEqualCompare,
      GreaterEqualDepth,
      GreaterEqualStencilFunc,
      GreaterStencilFunc,
      GridHelper,
      Group,
      HalfFloatType,
      HemisphereLight,
      HemisphereLightHelper,
      IcosahedronGeometry,
      ImageBitmapLoader,
      ImageLoader,
      ImageUtils,
      IncrementStencilOp,
      IncrementWrapStencilOp,
      InstancedBufferAttribute,
      InstancedBufferGeometry,
      InstancedInterleavedBuffer,
      InstancedMesh,
      Int16BufferAttribute,
      Int32BufferAttribute,
      Int8BufferAttribute,
      IntType,
      InterleavedBuffer,
      InterleavedBufferAttribute,
      Interpolant,
      InterpolateDiscrete,
      InterpolateLinear,
      InterpolateSmooth,
      InvertStencilOp,
      KeepStencilOp,
      KeyframeTrack,
      LOD,
      LatheGeometry,
      Layers,
      LessCompare,
      LessDepth,
      LessEqualCompare,
      LessEqualDepth,
      LessEqualStencilFunc,
      LessStencilFunc,
      Light,
      LightProbe,
      Line,
      Line3,
      LineBasicMaterial,
      LineCurve,
      LineCurve3,
      LineDashedMaterial,
      LineLoop,
      LineSegments,
      LinearDisplayP3ColorSpace,
      LinearFilter,
      LinearInterpolant,
      LinearMipMapLinearFilter,
      LinearMipMapNearestFilter,
      LinearMipmapLinearFilter,
      LinearMipmapNearestFilter,
      LinearSRGBColorSpace: LinearSRGBColorSpace$1,
      LinearToneMapping,
      LinearTransfer,
      Loader: Loader$2,
      LoaderUtils,
      LoadingManager,
      LoopOnce,
      LoopPingPong,
      LoopRepeat,
      LuminanceAlphaFormat,
      LuminanceFormat,
      MOUSE,
      Material,
      MaterialLoader,
      MathUtils,
      Matrix2,
      Matrix3,
      Matrix4,
      MaxEquation,
      Mesh,
      MeshBasicMaterial,
      MeshDepthMaterial,
      MeshDistanceMaterial,
      MeshLambertMaterial,
      MeshMatcapMaterial,
      MeshNormalMaterial,
      MeshPhongMaterial,
      MeshPhysicalMaterial,
      MeshStandardMaterial,
      MeshToonMaterial,
      MinEquation,
      MirroredRepeatWrapping,
      MixOperation,
      MultiplyBlending,
      MultiplyOperation,
      NearestFilter,
      NearestMipMapLinearFilter,
      NearestMipMapNearestFilter,
      NearestMipmapLinearFilter,
      NearestMipmapNearestFilter,
      NeutralToneMapping,
      NeverCompare,
      NeverDepth,
      NeverStencilFunc,
      NoBlending,
      NoColorSpace,
      NoToneMapping,
      NormalAnimationBlendMode,
      NormalBlending,
      NotEqualCompare,
      NotEqualDepth,
      NotEqualStencilFunc,
      NumberKeyframeTrack,
      Object3D,
      ObjectLoader,
      ObjectSpaceNormalMap,
      OctahedronGeometry,
      OneFactor,
      OneMinusConstantAlphaFactor,
      OneMinusConstantColorFactor,
      OneMinusDstAlphaFactor,
      OneMinusDstColorFactor,
      OneMinusSrcAlphaFactor,
      OneMinusSrcColorFactor,
      OrthographicCamera,
      P3Primaries,
      PCFShadowMap,
      PCFSoftShadowMap,
      PMREMGenerator,
      Path,
      PerspectiveCamera,
      Plane,
      PlaneGeometry,
      PlaneHelper,
      PointLight,
      PointLightHelper,
      Points,
      PointsMaterial,
      PolarGridHelper,
      PolyhedronGeometry,
      PositionalAudio,
      PropertyBinding,
      PropertyMixer,
      QuadraticBezierCurve,
      QuadraticBezierCurve3,
      Quaternion,
      QuaternionKeyframeTrack,
      QuaternionLinearInterpolant,
      RED_GREEN_RGTC2_Format,
      RED_RGTC1_Format,
      REVISION,
      RGBADepthPacking,
      RGBAFormat,
      RGBAIntegerFormat,
      RGBA_ASTC_10x10_Format,
      RGBA_ASTC_10x5_Format,
      RGBA_ASTC_10x6_Format,
      RGBA_ASTC_10x8_Format,
      RGBA_ASTC_12x10_Format,
      RGBA_ASTC_12x12_Format,
      RGBA_ASTC_4x4_Format,
      RGBA_ASTC_5x4_Format,
      RGBA_ASTC_5x5_Format,
      RGBA_ASTC_6x5_Format,
      RGBA_ASTC_6x6_Format,
      RGBA_ASTC_8x5_Format,
      RGBA_ASTC_8x6_Format,
      RGBA_ASTC_8x8_Format,
      RGBA_BPTC_Format,
      RGBA_ETC2_EAC_Format,
      RGBA_PVRTC_2BPPV1_Format,
      RGBA_PVRTC_4BPPV1_Format,
      RGBA_S3TC_DXT1_Format,
      RGBA_S3TC_DXT3_Format,
      RGBA_S3TC_DXT5_Format,
      RGBDepthPacking,
      RGBFormat,
      RGBIntegerFormat,
      RGB_BPTC_SIGNED_Format,
      RGB_BPTC_UNSIGNED_Format,
      RGB_ETC1_Format,
      RGB_ETC2_Format,
      RGB_PVRTC_2BPPV1_Format,
      RGB_PVRTC_4BPPV1_Format,
      RGB_S3TC_DXT1_Format,
      RGDepthPacking,
      RGFormat,
      RGIntegerFormat,
      RawShaderMaterial,
      Ray,
      Raycaster,
      Rec709Primaries,
      RectAreaLight,
      RedFormat,
      RedIntegerFormat,
      ReinhardToneMapping,
      RenderTarget,
      RepeatWrapping,
      ReplaceStencilOp,
      ReverseSubtractEquation,
      RingGeometry,
      SIGNED_RED_GREEN_RGTC2_Format,
      SIGNED_RED_RGTC1_Format,
      SRGBColorSpace: SRGBColorSpace$1,
      SRGBTransfer,
      Scene,
      ShaderChunk,
      ShaderLib,
      ShaderMaterial,
      ShadowMaterial,
      Shape,
      ShapeGeometry,
      ShapePath,
      ShapeUtils,
      ShortType,
      Skeleton,
      SkeletonHelper,
      SkinnedMesh,
      Source,
      Sphere,
      SphereGeometry,
      Spherical,
      SphericalHarmonics3,
      SplineCurve,
      SpotLight,
      SpotLightHelper,
      Sprite,
      SpriteMaterial,
      SrcAlphaFactor,
      SrcAlphaSaturateFactor,
      SrcColorFactor,
      StaticCopyUsage,
      StaticDrawUsage,
      StaticReadUsage,
      StereoCamera,
      StreamCopyUsage,
      StreamDrawUsage,
      StreamReadUsage,
      StringKeyframeTrack,
      SubtractEquation,
      SubtractiveBlending,
      TOUCH,
      TangentSpaceNormalMap,
      TetrahedronGeometry,
      Texture,
      TextureLoader,
      TextureUtils,
      TorusGeometry,
      TorusKnotGeometry,
      Triangle,
      TriangleFanDrawMode,
      TriangleStripDrawMode,
      TrianglesDrawMode,
      TubeGeometry,
      UVMapping,
      Uint16BufferAttribute,
      Uint32BufferAttribute,
      Uint8BufferAttribute,
      Uint8ClampedBufferAttribute,
      Uniform,
      UniformsGroup,
      UniformsLib,
      UniformsUtils,
      UnsignedByteType,
      UnsignedInt248Type,
      UnsignedInt5999Type,
      UnsignedIntType,
      UnsignedShort4444Type,
      UnsignedShort5551Type,
      UnsignedShortType,
      VSMShadowMap,
      Vector2,
      Vector3,
      Vector4,
      VectorKeyframeTrack,
      VideoTexture,
      WebGL3DRenderTarget,
      WebGLArrayRenderTarget,
      WebGLCoordinateSystem,
      WebGLCubeRenderTarget,
      WebGLMultipleRenderTargets,
      WebGLRenderTarget,
      WebGLRenderer,
      WebGLUtils,
      WebGPUCoordinateSystem,
      WireframeGeometry,
      WrapAroundEnding,
      ZeroCurvatureEnding,
      ZeroFactor,
      ZeroSlopeEnding,
      ZeroStencilOp,
      createCanvasElement,
    },
    Symbol.toStringTag,
    { value: "Module" }
  )
);
var constants = { exports: {} },
  reactReconcilerConstants_production_min = {};
/**
 * @license React
 * react-reconciler-constants.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ reactReconcilerConstants_production_min.ConcurrentRoot = 1;
reactReconcilerConstants_production_min.ContinuousEventPriority = 4;
reactReconcilerConstants_production_min.DefaultEventPriority = 16;
reactReconcilerConstants_production_min.DiscreteEventPriority = 1;
reactReconcilerConstants_production_min.IdleEventPriority = 536870912;
reactReconcilerConstants_production_min.LegacyRoot = 0;
constants.exports = reactReconcilerConstants_production_min;
var constantsExports = constants.exports;
function createStore$1(s) {
  let e;
  const o = new Set(),
    a = (j, $) => {
      const _e = typeof j == "function" ? j(e) : j;
      if (_e !== e) {
        const et = e;
        (e = $ ? _e : Object.assign({}, e, _e)), o.forEach((rt) => rt(e, et));
      }
    },
    c = () => e,
    d = (j, $ = c, _e = Object.is) => {
      console.warn(
        "[DEPRECATED] Please use `subscribeWithSelector` middleware"
      );
      let et = $(e);
      function rt() {
        const st = $(e);
        if (!_e(et, st)) {
          const at = et;
          j((et = st), at);
        }
      }
      return o.add(rt), () => o.delete(rt);
    },
    b = {
      setState: a,
      getState: c,
      subscribe: (j, $, _e) =>
        $ || _e ? d(j, $, _e) : (o.add(j), () => o.delete(j)),
      destroy: () => o.clear(),
    };
  return (e = s(a, c, b)), b;
}
const isSSR =
    typeof window > "u" ||
    !window.navigator ||
    /ServerSideRendering|^Deno\//.test(window.navigator.userAgent),
  useIsomorphicLayoutEffect$1 = isSSR
    ? reactExports$1.useEffect
    : reactExports$1.useLayoutEffect;
function create(s) {
  const e = typeof s == "function" ? createStore$1(s) : s,
    o = (a = e.getState, c = Object.is) => {
      const [, d] = reactExports$1.useReducer((ct) => ct + 1, 0),
        g = e.getState(),
        _ = reactExports$1.useRef(g),
        b = reactExports$1.useRef(a),
        j = reactExports$1.useRef(c),
        $ = reactExports$1.useRef(!1),
        _e = reactExports$1.useRef();
      _e.current === void 0 && (_e.current = a(g));
      let et,
        rt = !1;
      (_.current !== g || b.current !== a || j.current !== c || $.current) &&
        ((et = a(g)), (rt = !c(_e.current, et))),
        useIsomorphicLayoutEffect$1(() => {
          rt && (_e.current = et),
            (_.current = g),
            (b.current = a),
            (j.current = c),
            ($.current = !1);
        });
      const st = reactExports$1.useRef(g);
      useIsomorphicLayoutEffect$1(() => {
        const ct = () => {
            try {
              const lt = e.getState(),
                ot = b.current(lt);
              j.current(_e.current, ot) ||
                ((_.current = lt), (_e.current = ot), d());
            } catch {
              ($.current = !0), d();
            }
          },
          it = e.subscribe(ct);
        return e.getState() !== st.current && ct(), it;
      }, []);
      const at = rt ? et : _e.current;
      return reactExports$1.useDebugValue(at), at;
    };
  return (
    Object.assign(o, e),
    (o[Symbol.iterator] = function () {
      console.warn(
        "[useStore, api] = create() is deprecated and will be removed in v4"
      );
      const a = [o, e];
      return {
        next() {
          const c = a.length <= 0;
          return { value: a.shift(), done: c };
        },
      };
    }),
    o
  );
}
var reactReconciler = { exports: {} },
  scheduler$1 = { exports: {} },
  scheduler_production_min$1 = {};
/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var hasRequiredScheduler_production_min;
function requireScheduler_production_min() {
  return (
    hasRequiredScheduler_production_min ||
      ((hasRequiredScheduler_production_min = 1),
      (function (s) {
        function e(mt, vt) {
          var Ct = mt.length;
          mt.push(vt);
          e: for (; 0 < Ct; ) {
            var Tt = (Ct - 1) >>> 1,
              Dt = mt[Tt];
            if (0 < c(Dt, vt)) (mt[Tt] = vt), (mt[Ct] = Dt), (Ct = Tt);
            else break e;
          }
        }
        function o(mt) {
          return mt.length === 0 ? null : mt[0];
        }
        function a(mt) {
          if (mt.length === 0) return null;
          var vt = mt[0],
            Ct = mt.pop();
          if (Ct !== vt) {
            mt[0] = Ct;
            e: for (var Tt = 0, Dt = mt.length, Wt = Dt >>> 1; Tt < Wt; ) {
              var Pt = 2 * (Tt + 1) - 1,
                Jt = mt[Pt],
                Gt = Pt + 1,
                en = mt[Gt];
              if (0 > c(Jt, Ct))
                Gt < Dt && 0 > c(en, Jt)
                  ? ((mt[Tt] = en), (mt[Gt] = Ct), (Tt = Gt))
                  : ((mt[Tt] = Jt), (mt[Pt] = Ct), (Tt = Pt));
              else if (Gt < Dt && 0 > c(en, Ct))
                (mt[Tt] = en), (mt[Gt] = Ct), (Tt = Gt);
              else break e;
            }
          }
          return vt;
        }
        function c(mt, vt) {
          var Ct = mt.sortIndex - vt.sortIndex;
          return Ct !== 0 ? Ct : mt.id - vt.id;
        }
        if (
          typeof performance == "object" &&
          typeof performance.now == "function"
        ) {
          var d = performance;
          s.unstable_now = function () {
            return d.now();
          };
        } else {
          var g = Date,
            _ = g.now();
          s.unstable_now = function () {
            return g.now() - _;
          };
        }
        var b = [],
          j = [],
          $ = 1,
          _e = null,
          et = 3,
          rt = !1,
          st = !1,
          at = !1,
          ct = typeof setTimeout == "function" ? setTimeout : null,
          it = typeof clearTimeout == "function" ? clearTimeout : null,
          lt = typeof setImmediate < "u" ? setImmediate : null;
        typeof navigator < "u" &&
          navigator.scheduling !== void 0 &&
          navigator.scheduling.isInputPending !== void 0 &&
          navigator.scheduling.isInputPending.bind(navigator.scheduling);
        function ot(mt) {
          for (var vt = o(j); vt !== null; ) {
            if (vt.callback === null) a(j);
            else if (vt.startTime <= mt)
              a(j), (vt.sortIndex = vt.expirationTime), e(b, vt);
            else break;
            vt = o(j);
          }
        }
        function ut(mt) {
          if (((at = !1), ot(mt), !st))
            if (o(b) !== null) (st = !0), Et(pt);
            else {
              var vt = o(j);
              vt !== null && bt(ut, vt.startTime - mt);
            }
        }
        function pt(mt, vt) {
          (st = !1), at && ((at = !1), it(xt), (xt = -1)), (rt = !0);
          var Ct = et;
          try {
            for (
              ot(vt), _e = o(b);
              _e !== null && (!(_e.expirationTime > vt) || (mt && !Mt()));

            ) {
              var Tt = _e.callback;
              if (typeof Tt == "function") {
                (_e.callback = null), (et = _e.priorityLevel);
                var Dt = Tt(_e.expirationTime <= vt);
                (vt = s.unstable_now()),
                  typeof Dt == "function"
                    ? (_e.callback = Dt)
                    : _e === o(b) && a(b),
                  ot(vt);
              } else a(b);
              _e = o(b);
            }
            if (_e !== null) var Wt = !0;
            else {
              var Pt = o(j);
              Pt !== null && bt(ut, Pt.startTime - vt), (Wt = !1);
            }
            return Wt;
          } finally {
            (_e = null), (et = Ct), (rt = !1);
          }
        }
        var ft = !1,
          gt = null,
          xt = -1,
          _t = 5,
          St = -1;
        function Mt() {
          return !(s.unstable_now() - St < _t);
        }
        function Rt() {
          if (gt !== null) {
            var mt = s.unstable_now();
            St = mt;
            var vt = !0;
            try {
              vt = gt(!0, mt);
            } finally {
              vt ? Ft() : ((ft = !1), (gt = null));
            }
          } else ft = !1;
        }
        var Ft;
        if (typeof lt == "function")
          Ft = function () {
            lt(Rt);
          };
        else if (typeof MessageChannel < "u") {
          var Ot = new MessageChannel(),
            Lt = Ot.port2;
          (Ot.port1.onmessage = Rt),
            (Ft = function () {
              Lt.postMessage(null);
            });
        } else
          Ft = function () {
            ct(Rt, 0);
          };
        function Et(mt) {
          (gt = mt), ft || ((ft = !0), Ft());
        }
        function bt(mt, vt) {
          xt = ct(function () {
            mt(s.unstable_now());
          }, vt);
        }
        (s.unstable_IdlePriority = 5),
          (s.unstable_ImmediatePriority = 1),
          (s.unstable_LowPriority = 4),
          (s.unstable_NormalPriority = 3),
          (s.unstable_Profiling = null),
          (s.unstable_UserBlockingPriority = 2),
          (s.unstable_cancelCallback = function (mt) {
            mt.callback = null;
          }),
          (s.unstable_continueExecution = function () {
            st || rt || ((st = !0), Et(pt));
          }),
          (s.unstable_forceFrameRate = function (mt) {
            0 > mt || 125 < mt
              ? console.error(
                  "forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"
                )
              : (_t = 0 < mt ? Math.floor(1e3 / mt) : 5);
          }),
          (s.unstable_getCurrentPriorityLevel = function () {
            return et;
          }),
          (s.unstable_getFirstCallbackNode = function () {
            return o(b);
          }),
          (s.unstable_next = function (mt) {
            switch (et) {
              case 1:
              case 2:
              case 3:
                var vt = 3;
                break;
              default:
                vt = et;
            }
            var Ct = et;
            et = vt;
            try {
              return mt();
            } finally {
              et = Ct;
            }
          }),
          (s.unstable_pauseExecution = function () {}),
          (s.unstable_requestPaint = function () {}),
          (s.unstable_runWithPriority = function (mt, vt) {
            switch (mt) {
              case 1:
              case 2:
              case 3:
              case 4:
              case 5:
                break;
              default:
                mt = 3;
            }
            var Ct = et;
            et = mt;
            try {
              return vt();
            } finally {
              et = Ct;
            }
          }),
          (s.unstable_scheduleCallback = function (mt, vt, Ct) {
            var Tt = s.unstable_now();
            switch (
              (typeof Ct == "object" && Ct !== null
                ? ((Ct = Ct.delay),
                  (Ct = typeof Ct == "number" && 0 < Ct ? Tt + Ct : Tt))
                : (Ct = Tt),
              mt)
            ) {
              case 1:
                var Dt = -1;
                break;
              case 2:
                Dt = 250;
                break;
              case 5:
                Dt = 1073741823;
                break;
              case 4:
                Dt = 1e4;
                break;
              default:
                Dt = 5e3;
            }
            return (
              (Dt = Ct + Dt),
              (mt = {
                id: $++,
                callback: vt,
                priorityLevel: mt,
                startTime: Ct,
                expirationTime: Dt,
                sortIndex: -1,
              }),
              Ct > Tt
                ? ((mt.sortIndex = Ct),
                  e(j, mt),
                  o(b) === null &&
                    mt === o(j) &&
                    (at ? (it(xt), (xt = -1)) : (at = !0), bt(ut, Ct - Tt)))
                : ((mt.sortIndex = Dt),
                  e(b, mt),
                  st || rt || ((st = !0), Et(pt))),
              mt
            );
          }),
          (s.unstable_shouldYield = Mt),
          (s.unstable_wrapCallback = function (mt) {
            var vt = et;
            return function () {
              var Ct = et;
              et = vt;
              try {
                return mt.apply(this, arguments);
              } finally {
                et = Ct;
              }
            };
          });
      })(scheduler_production_min$1)),
    scheduler_production_min$1
  );
}
var hasRequiredScheduler;
function requireScheduler() {
  return (
    hasRequiredScheduler ||
      ((hasRequiredScheduler = 1),
      (scheduler$1.exports = requireScheduler_production_min())),
    scheduler$1.exports
  );
}
/**
 * @license React
 * react-reconciler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var reactReconciler_production_min = function s(e) {
  var o = {},
    a = reactExports$1,
    c = requireScheduler(),
    d = Object.assign;
  function g(tt) {
    for (
      var nt = "https://reactjs.org/docs/error-decoder.html?invariant=" + tt,
        ht = 1;
      ht < arguments.length;
      ht++
    )
      nt += "&args[]=" + encodeURIComponent(arguments[ht]);
    return (
      "Minified React error #" +
      tt +
      "; visit " +
      nt +
      " for the full message or use the non-minified dev environment for full errors and additional helpful warnings."
    );
  }
  var _ = a.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,
    b = Symbol.for("react.element"),
    j = Symbol.for("react.portal"),
    $ = Symbol.for("react.fragment"),
    _e = Symbol.for("react.strict_mode"),
    et = Symbol.for("react.profiler"),
    rt = Symbol.for("react.provider"),
    st = Symbol.for("react.context"),
    at = Symbol.for("react.forward_ref"),
    ct = Symbol.for("react.suspense"),
    it = Symbol.for("react.suspense_list"),
    lt = Symbol.for("react.memo"),
    ot = Symbol.for("react.lazy"),
    ut = Symbol.for("react.offscreen"),
    pt = Symbol.iterator;
  function ft(tt) {
    return tt === null || typeof tt != "object"
      ? null
      : ((tt = (pt && tt[pt]) || tt["@@iterator"]),
        typeof tt == "function" ? tt : null);
  }
  function gt(tt) {
    if (tt == null) return null;
    if (typeof tt == "function") return tt.displayName || tt.name || null;
    if (typeof tt == "string") return tt;
    switch (tt) {
      case $:
        return "Fragment";
      case j:
        return "Portal";
      case et:
        return "Profiler";
      case _e:
        return "StrictMode";
      case ct:
        return "Suspense";
      case it:
        return "SuspenseList";
    }
    if (typeof tt == "object")
      switch (tt.$$typeof) {
        case st:
          return (tt.displayName || "Context") + ".Consumer";
        case rt:
          return (tt._context.displayName || "Context") + ".Provider";
        case at:
          var nt = tt.render;
          return (
            (tt = tt.displayName),
            tt ||
              ((tt = nt.displayName || nt.name || ""),
              (tt = tt !== "" ? "ForwardRef(" + tt + ")" : "ForwardRef")),
            tt
          );
        case lt:
          return (
            (nt = tt.displayName || null),
            nt !== null ? nt : gt(tt.type) || "Memo"
          );
        case ot:
          (nt = tt._payload), (tt = tt._init);
          try {
            return gt(tt(nt));
          } catch {}
      }
    return null;
  }
  function xt(tt) {
    var nt = tt.type;
    switch (tt.tag) {
      case 24:
        return "Cache";
      case 9:
        return (nt.displayName || "Context") + ".Consumer";
      case 10:
        return (nt._context.displayName || "Context") + ".Provider";
      case 18:
        return "DehydratedFragment";
      case 11:
        return (
          (tt = nt.render),
          (tt = tt.displayName || tt.name || ""),
          nt.displayName ||
            (tt !== "" ? "ForwardRef(" + tt + ")" : "ForwardRef")
        );
      case 7:
        return "Fragment";
      case 5:
        return nt;
      case 4:
        return "Portal";
      case 3:
        return "Root";
      case 6:
        return "Text";
      case 16:
        return gt(nt);
      case 8:
        return nt === _e ? "StrictMode" : "Mode";
      case 22:
        return "Offscreen";
      case 12:
        return "Profiler";
      case 21:
        return "Scope";
      case 13:
        return "Suspense";
      case 19:
        return "SuspenseList";
      case 25:
        return "TracingMarker";
      case 1:
      case 0:
      case 17:
      case 2:
      case 14:
      case 15:
        if (typeof nt == "function") return nt.displayName || nt.name || null;
        if (typeof nt == "string") return nt;
    }
    return null;
  }
  function _t(tt) {
    var nt = tt,
      ht = tt;
    if (tt.alternate) for (; nt.return; ) nt = nt.return;
    else {
      tt = nt;
      do (nt = tt), nt.flags & 4098 && (ht = nt.return), (tt = nt.return);
      while (tt);
    }
    return nt.tag === 3 ? ht : null;
  }
  function St(tt) {
    if (_t(tt) !== tt) throw Error(g(188));
  }
  function Mt(tt) {
    var nt = tt.alternate;
    if (!nt) {
      if (((nt = _t(tt)), nt === null)) throw Error(g(188));
      return nt !== tt ? null : tt;
    }
    for (var ht = tt, dt = nt; ; ) {
      var yt = ht.return;
      if (yt === null) break;
      var At = yt.alternate;
      if (At === null) {
        if (((dt = yt.return), dt !== null)) {
          ht = dt;
          continue;
        }
        break;
      }
      if (yt.child === At.child) {
        for (At = yt.child; At; ) {
          if (At === ht) return St(yt), tt;
          if (At === dt) return St(yt), nt;
          At = At.sibling;
        }
        throw Error(g(188));
      }
      if (ht.return !== dt.return) (ht = yt), (dt = At);
      else {
        for (var Nt = !1, jt = yt.child; jt; ) {
          if (jt === ht) {
            (Nt = !0), (ht = yt), (dt = At);
            break;
          }
          if (jt === dt) {
            (Nt = !0), (dt = yt), (ht = At);
            break;
          }
          jt = jt.sibling;
        }
        if (!Nt) {
          for (jt = At.child; jt; ) {
            if (jt === ht) {
              (Nt = !0), (ht = At), (dt = yt);
              break;
            }
            if (jt === dt) {
              (Nt = !0), (dt = At), (ht = yt);
              break;
            }
            jt = jt.sibling;
          }
          if (!Nt) throw Error(g(189));
        }
      }
      if (ht.alternate !== dt) throw Error(g(190));
    }
    if (ht.tag !== 3) throw Error(g(188));
    return ht.stateNode.current === ht ? tt : nt;
  }
  function Rt(tt) {
    return (tt = Mt(tt)), tt !== null ? Ft(tt) : null;
  }
  function Ft(tt) {
    if (tt.tag === 5 || tt.tag === 6) return tt;
    for (tt = tt.child; tt !== null; ) {
      var nt = Ft(tt);
      if (nt !== null) return nt;
      tt = tt.sibling;
    }
    return null;
  }
  function Ot(tt) {
    if (tt.tag === 5 || tt.tag === 6) return tt;
    for (tt = tt.child; tt !== null; ) {
      if (tt.tag !== 4) {
        var nt = Ot(tt);
        if (nt !== null) return nt;
      }
      tt = tt.sibling;
    }
    return null;
  }
  var Lt = Array.isArray,
    Et = e.getPublicInstance,
    bt = e.getRootHostContext,
    mt = e.getChildHostContext,
    vt = e.prepareForCommit,
    Ct = e.resetAfterCommit,
    Tt = e.createInstance,
    Dt = e.appendInitialChild,
    Wt = e.finalizeInitialChildren,
    Pt = e.prepareUpdate,
    Jt = e.shouldSetTextContent,
    Gt = e.createTextInstance,
    en = e.scheduleTimeout,
    _n = e.cancelTimeout,
    Tn = e.noTimeout,
    fn = e.isPrimaryRenderer,
    pn = e.supportsMutation,
    Bt = e.supportsPersistence,
    qt = e.supportsHydration,
    $t = e.getInstanceFromNode,
    yn = e.preparePortalMount,
    nn = e.getCurrentEventPriority,
    Pn = e.detachDeletedInstance,
    xn = e.supportsMicrotasks,
    An = e.scheduleMicrotask,
    kt = e.supportsTestSelectors,
    wt = e.findFiberRoot,
    Kt = e.getBoundingRect,
    on = e.getTextContent,
    sn = e.isHiddenSubtree,
    cn = e.matchAccessibilityRole,
    bn = e.setFocusIfFocusable,
    vn = e.setupIntersectionObserver,
    wn = e.appendChild,
    zn = e.appendChildToContainer,
    gn = e.commitTextUpdate,
    Rn = e.commitMount,
    qn = e.commitUpdate,
    Wn = e.insertBefore,
    kn = e.insertInContainerBefore,
    Vt = e.removeChild,
    un = e.removeChildFromContainer,
    In = e.resetTextContent,
    Ut = e.hideInstance,
    dn = e.hideTextInstance,
    an = e.unhideInstance,
    hn = e.unhideTextInstance,
    Mn = e.clearContainer,
    $n = e.cloneInstance,
    Yn = e.createContainerChildSet,
    rr = e.appendChildToContainerChildSet,
    pr = e.finalizeContainerChildren,
    tr = e.replaceContainerChildren,
    Cr = e.cloneHiddenInstance,
    Tr = e.cloneHiddenTextInstance,
    Ao = e.canHydrateInstance,
    ds = e.canHydrateTextInstance,
    to = e.canHydrateSuspenseInstance,
    no = e.isSuspenseInstancePending,
    Os = e.isSuspenseInstanceFallback,
    Us = e.registerSuspenseInstanceRetry,
    _s = e.getNextHydratableSibling,
    Vs = e.getFirstHydratableChild,
    Mo = e.getFirstHydratableChildWithinContainer,
    Co = e.getFirstHydratableChildWithinSuspenseInstance,
    Fl = e.hydrateInstance,
    Dl = e.hydrateTextInstance,
    Nl = e.hydrateSuspenseInstance,
    It = e.getNextHydratableInstanceAfterSuspenseInstance,
    zt = e.commitHydratedContainer,
    Qt = e.commitHydratedSuspenseInstance,
    Zt = e.clearSuspenseBoundary,
    Xt = e.clearSuspenseBoundaryFromContainer,
    En = e.shouldDeleteUnhydratedTailInstances,
    Fn = e.didNotMatchHydratedContainerTextInstance,
    On = e.didNotMatchHydratedTextInstance,
    Nn;
  function Hn(tt) {
    if (Nn === void 0)
      try {
        throw Error();
      } catch (ht) {
        var nt = ht.stack.trim().match(/\n( *(at )?)/);
        Nn = (nt && nt[1]) || "";
      }
    return (
      `
` +
      Nn +
      tt
    );
  }
  var Kn = !1;
  function jn(tt, nt) {
    if (!tt || Kn) return "";
    Kn = !0;
    var ht = Error.prepareStackTrace;
    Error.prepareStackTrace = void 0;
    try {
      if (nt)
        if (
          ((nt = function () {
            throw Error();
          }),
          Object.defineProperty(nt.prototype, "props", {
            set: function () {
              throw Error();
            },
          }),
          typeof Reflect == "object" && Reflect.construct)
        ) {
          try {
            Reflect.construct(nt, []);
          } catch (Sn) {
            var dt = Sn;
          }
          Reflect.construct(tt, [], nt);
        } else {
          try {
            nt.call();
          } catch (Sn) {
            dt = Sn;
          }
          tt.call(nt.prototype);
        }
      else {
        try {
          throw Error();
        } catch (Sn) {
          dt = Sn;
        }
        tt();
      }
    } catch (Sn) {
      if (Sn && dt && typeof Sn.stack == "string") {
        for (
          var yt = Sn.stack.split(`
`),
            At = dt.stack.split(`
`),
            Nt = yt.length - 1,
            jt = At.length - 1;
          1 <= Nt && 0 <= jt && yt[Nt] !== At[jt];

        )
          jt--;
        for (; 1 <= Nt && 0 <= jt; Nt--, jt--)
          if (yt[Nt] !== At[jt]) {
            if (Nt !== 1 || jt !== 1)
              do
                if ((Nt--, jt--, 0 > jt || yt[Nt] !== At[jt])) {
                  var rn =
                    `
` + yt[Nt].replace(" at new ", " at ");
                  return (
                    tt.displayName &&
                      rn.includes("<anonymous>") &&
                      (rn = rn.replace("<anonymous>", tt.displayName)),
                    rn
                  );
                }
              while (1 <= Nt && 0 <= jt);
            break;
          }
      }
    } finally {
      (Kn = !1), (Error.prepareStackTrace = ht);
    }
    return (tt = tt ? tt.displayName || tt.name : "") ? Hn(tt) : "";
  }
  var ir = Object.prototype.hasOwnProperty,
    ur = [],
    lr = -1;
  function yr(tt) {
    return { current: tt };
  }
  function Gn(tt) {
    0 > lr || ((tt.current = ur[lr]), (ur[lr] = null), lr--);
  }
  function Cn(tt, nt) {
    lr++, (ur[lr] = tt.current), (tt.current = nt);
  }
  var hr = {},
    Jn = yr(hr),
    dr = yr(!1),
    Vr = hr;
  function Sr(tt, nt) {
    var ht = tt.type.contextTypes;
    if (!ht) return hr;
    var dt = tt.stateNode;
    if (dt && dt.__reactInternalMemoizedUnmaskedChildContext === nt)
      return dt.__reactInternalMemoizedMaskedChildContext;
    var yt = {},
      At;
    for (At in ht) yt[At] = nt[At];
    return (
      dt &&
        ((tt = tt.stateNode),
        (tt.__reactInternalMemoizedUnmaskedChildContext = nt),
        (tt.__reactInternalMemoizedMaskedChildContext = yt)),
      yt
    );
  }
  function br(tt) {
    return (tt = tt.childContextTypes), tt != null;
  }
  function mr() {
    Gn(dr), Gn(Jn);
  }
  function ns(tt, nt, ht) {
    if (Jn.current !== hr) throw Error(g(168));
    Cn(Jn, nt), Cn(dr, ht);
  }
  function Gs(tt, nt, ht) {
    var dt = tt.stateNode;
    if (((nt = nt.childContextTypes), typeof dt.getChildContext != "function"))
      return ht;
    dt = dt.getChildContext();
    for (var yt in dt)
      if (!(yt in nt)) throw Error(g(108, xt(tt) || "Unknown", yt));
    return d({}, ht, dt);
  }
  function Br(tt) {
    return (
      (tt =
        ((tt = tt.stateNode) && tt.__reactInternalMemoizedMergedChildContext) ||
        hr),
      (Vr = Jn.current),
      Cn(Jn, tt),
      Cn(dr, dr.current),
      !0
    );
  }
  function js(tt, nt, ht) {
    var dt = tt.stateNode;
    if (!dt) throw Error(g(169));
    ht
      ? ((tt = Gs(tt, nt, Vr)),
        (dt.__reactInternalMemoizedMergedChildContext = tt),
        Gn(dr),
        Gn(Jn),
        Cn(Jn, tt))
      : Gn(dr),
      Cn(dr, ht);
  }
  var Hr = Math.clz32 ? Math.clz32 : Sm,
    To = Math.log,
    _m = Math.LN2;
  function Sm(tt) {
    return (tt >>>= 0), tt === 0 ? 32 : (31 - ((To(tt) / _m) | 0)) | 0;
  }
  var wo = 64,
    Po = 4194304;
  function ro(tt) {
    switch (tt & -tt) {
      case 1:
        return 1;
      case 2:
        return 2;
      case 4:
        return 4;
      case 8:
        return 8;
      case 16:
        return 16;
      case 32:
        return 32;
      case 64:
      case 128:
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
        return tt & 4194240;
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
      case 67108864:
        return tt & 130023424;
      case 134217728:
        return 134217728;
      case 268435456:
        return 268435456;
      case 536870912:
        return 536870912;
      case 1073741824:
        return 1073741824;
      default:
        return tt;
    }
  }
  function Ro(tt, nt) {
    var ht = tt.pendingLanes;
    if (ht === 0) return 0;
    var dt = 0,
      yt = tt.suspendedLanes,
      At = tt.pingedLanes,
      Nt = ht & 268435455;
    if (Nt !== 0) {
      var jt = Nt & ~yt;
      jt !== 0 ? (dt = ro(jt)) : ((At &= Nt), At !== 0 && (dt = ro(At)));
    } else
      (Nt = ht & ~yt), Nt !== 0 ? (dt = ro(Nt)) : At !== 0 && (dt = ro(At));
    if (dt === 0) return 0;
    if (
      nt !== 0 &&
      nt !== dt &&
      !(nt & yt) &&
      ((yt = dt & -dt),
      (At = nt & -nt),
      yt >= At || (yt === 16 && (At & 4194240) !== 0))
    )
      return nt;
    if ((dt & 4 && (dt |= ht & 16), (nt = tt.entangledLanes), nt !== 0))
      for (tt = tt.entanglements, nt &= dt; 0 < nt; )
        (ht = 31 - Hr(nt)), (yt = 1 << ht), (dt |= tt[ht]), (nt &= ~yt);
    return dt;
  }
  function Em(tt, nt) {
    switch (tt) {
      case 1:
      case 2:
      case 4:
        return nt + 250;
      case 8:
      case 16:
      case 32:
      case 64:
      case 128:
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
        return nt + 5e3;
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
      case 67108864:
        return -1;
      case 134217728:
      case 268435456:
      case 536870912:
      case 1073741824:
        return -1;
      default:
        return -1;
    }
  }
  function Am(tt, nt) {
    for (
      var ht = tt.suspendedLanes,
        dt = tt.pingedLanes,
        yt = tt.expirationTimes,
        At = tt.pendingLanes;
      0 < At;

    ) {
      var Nt = 31 - Hr(At),
        jt = 1 << Nt,
        rn = yt[Nt];
      rn === -1
        ? (!(jt & ht) || jt & dt) && (yt[Nt] = Em(jt, nt))
        : rn <= nt && (tt.expiredLanes |= jt),
        (At &= ~jt);
    }
  }
  function Ol(tt) {
    return (
      (tt = tt.pendingLanes & -1073741825),
      tt !== 0 ? tt : tt & 1073741824 ? 1073741824 : 0
    );
  }
  function Ul(tt) {
    for (var nt = [], ht = 0; 31 > ht; ht++) nt.push(tt);
    return nt;
  }
  function io(tt, nt, ht) {
    (tt.pendingLanes |= nt),
      nt !== 536870912 && ((tt.suspendedLanes = 0), (tt.pingedLanes = 0)),
      (tt = tt.eventTimes),
      (nt = 31 - Hr(nt)),
      (tt[nt] = ht);
  }
  function Mm(tt, nt) {
    var ht = tt.pendingLanes & ~nt;
    (tt.pendingLanes = nt),
      (tt.suspendedLanes = 0),
      (tt.pingedLanes = 0),
      (tt.expiredLanes &= nt),
      (tt.mutableReadLanes &= nt),
      (tt.entangledLanes &= nt),
      (nt = tt.entanglements);
    var dt = tt.eventTimes;
    for (tt = tt.expirationTimes; 0 < ht; ) {
      var yt = 31 - Hr(ht),
        At = 1 << yt;
      (nt[yt] = 0), (dt[yt] = -1), (tt[yt] = -1), (ht &= ~At);
    }
  }
  function Vl(tt, nt) {
    var ht = (tt.entangledLanes |= nt);
    for (tt = tt.entanglements; ht; ) {
      var dt = 31 - Hr(ht),
        yt = 1 << dt;
      (yt & nt) | (tt[dt] & nt) && (tt[dt] |= nt), (ht &= ~yt);
    }
  }
  var sr = 0;
  function zu(tt) {
    return (
      (tt &= -tt), 1 < tt ? (4 < tt ? (tt & 268435455 ? 16 : 536870912) : 4) : 1
    );
  }
  var Gl = c.unstable_scheduleCallback,
    Hu = c.unstable_cancelCallback,
    Cm = c.unstable_shouldYield,
    Tm = c.unstable_requestPaint,
    wr = c.unstable_now,
    zl = c.unstable_ImmediatePriority,
    bm = c.unstable_UserBlockingPriority,
    Hl = c.unstable_NormalPriority,
    wm = c.unstable_IdlePriority,
    Bo = null,
    os = null;
  function Pm(tt) {
    if (os && typeof os.onCommitFiberRoot == "function")
      try {
        os.onCommitFiberRoot(Bo, tt, void 0, (tt.current.flags & 128) === 128);
      } catch {}
  }
  function Rm(tt, nt) {
    return (
      (tt === nt && (tt !== 0 || 1 / tt === 1 / nt)) || (tt !== tt && nt !== nt)
    );
  }
  var as = typeof Object.is == "function" ? Object.is : Rm,
    ps = null,
    Io = !1,
    Wl = !1;
  function Wu(tt) {
    ps === null ? (ps = [tt]) : ps.push(tt);
  }
  function Bm(tt) {
    (Io = !0), Wu(tt);
  }
  function ls() {
    if (!Wl && ps !== null) {
      Wl = !0;
      var tt = 0,
        nt = sr;
      try {
        var ht = ps;
        for (sr = 1; tt < ht.length; tt++) {
          var dt = ht[tt];
          do dt = dt(!0);
          while (dt !== null);
        }
        (ps = null), (Io = !1);
      } catch (yt) {
        throw (ps !== null && (ps = ps.slice(tt + 1)), Gl(zl, ls), yt);
      } finally {
        (sr = nt), (Wl = !1);
      }
    }
    return null;
  }
  var Im = _.ReactCurrentBatchConfig;
  function Lo(tt, nt) {
    if (as(tt, nt)) return !0;
    if (
      typeof tt != "object" ||
      tt === null ||
      typeof nt != "object" ||
      nt === null
    )
      return !1;
    var ht = Object.keys(tt),
      dt = Object.keys(nt);
    if (ht.length !== dt.length) return !1;
    for (dt = 0; dt < ht.length; dt++) {
      var yt = ht[dt];
      if (!ir.call(nt, yt) || !as(tt[yt], nt[yt])) return !1;
    }
    return !0;
  }
  function Lm(tt) {
    switch (tt.tag) {
      case 5:
        return Hn(tt.type);
      case 16:
        return Hn("Lazy");
      case 13:
        return Hn("Suspense");
      case 19:
        return Hn("SuspenseList");
      case 0:
      case 2:
      case 15:
        return (tt = jn(tt.type, !1)), tt;
      case 11:
        return (tt = jn(tt.type.render, !1)), tt;
      case 1:
        return (tt = jn(tt.type, !0)), tt;
      default:
        return "";
    }
  }
  function rs(tt, nt) {
    if (tt && tt.defaultProps) {
      (nt = d({}, nt)), (tt = tt.defaultProps);
      for (var ht in tt) nt[ht] === void 0 && (nt[ht] = tt[ht]);
      return nt;
    }
    return nt;
  }
  var Fo = yr(null),
    ko = null,
    zs = null,
    $l = null;
  function Xl() {
    $l = zs = ko = null;
  }
  function $u(tt, nt, ht) {
    fn
      ? (Cn(Fo, nt._currentValue), (nt._currentValue = ht))
      : (Cn(Fo, nt._currentValue2), (nt._currentValue2 = ht));
  }
  function Kl(tt) {
    var nt = Fo.current;
    Gn(Fo), fn ? (tt._currentValue = nt) : (tt._currentValue2 = nt);
  }
  function Jl(tt, nt, ht) {
    for (; tt !== null; ) {
      var dt = tt.alternate;
      if (
        ((tt.childLanes & nt) !== nt
          ? ((tt.childLanes |= nt), dt !== null && (dt.childLanes |= nt))
          : dt !== null && (dt.childLanes & nt) !== nt && (dt.childLanes |= nt),
        tt === ht)
      )
        break;
      tt = tt.return;
    }
  }
  function Hs(tt, nt) {
    (ko = tt),
      ($l = zs = null),
      (tt = tt.dependencies),
      tt !== null &&
        tt.firstContext !== null &&
        (tt.lanes & nt && (Xr = !0), (tt.firstContext = null));
  }
  function Jr(tt) {
    var nt = fn ? tt._currentValue : tt._currentValue2;
    if ($l !== tt)
      if (
        ((tt = { context: tt, memoizedValue: nt, next: null }), zs === null)
      ) {
        if (ko === null) throw Error(g(308));
        (zs = tt), (ko.dependencies = { lanes: 0, firstContext: tt });
      } else zs = zs.next = tt;
    return nt;
  }
  var cs = null,
    Ss = !1;
  function Yl(tt) {
    tt.updateQueue = {
      baseState: tt.memoizedState,
      firstBaseUpdate: null,
      lastBaseUpdate: null,
      shared: { pending: null, interleaved: null, lanes: 0 },
      effects: null,
    };
  }
  function Xu(tt, nt) {
    (tt = tt.updateQueue),
      nt.updateQueue === tt &&
        (nt.updateQueue = {
          baseState: tt.baseState,
          firstBaseUpdate: tt.firstBaseUpdate,
          lastBaseUpdate: tt.lastBaseUpdate,
          shared: tt.shared,
          effects: tt.effects,
        });
  }
  function ms(tt, nt) {
    return {
      eventTime: tt,
      lane: nt,
      tag: 0,
      payload: null,
      callback: null,
      next: null,
    };
  }
  function Es(tt, nt) {
    var ht = tt.updateQueue;
    ht !== null &&
      ((ht = ht.shared),
      Er !== null && tt.mode & 1 && !(nr & 2)
        ? ((tt = ht.interleaved),
          tt === null
            ? ((nt.next = nt), cs === null ? (cs = [ht]) : cs.push(ht))
            : ((nt.next = tt.next), (tt.next = nt)),
          (ht.interleaved = nt))
        : ((tt = ht.pending),
          tt === null ? (nt.next = nt) : ((nt.next = tt.next), (tt.next = nt)),
          (ht.pending = nt)));
  }
  function Do(tt, nt, ht) {
    if (
      ((nt = nt.updateQueue),
      nt !== null && ((nt = nt.shared), (ht & 4194240) !== 0))
    ) {
      var dt = nt.lanes;
      (dt &= tt.pendingLanes), (ht |= dt), (nt.lanes = ht), Vl(tt, ht);
    }
  }
  function Ku(tt, nt) {
    var ht = tt.updateQueue,
      dt = tt.alternate;
    if (dt !== null && ((dt = dt.updateQueue), ht === dt)) {
      var yt = null,
        At = null;
      if (((ht = ht.firstBaseUpdate), ht !== null)) {
        do {
          var Nt = {
            eventTime: ht.eventTime,
            lane: ht.lane,
            tag: ht.tag,
            payload: ht.payload,
            callback: ht.callback,
            next: null,
          };
          At === null ? (yt = At = Nt) : (At = At.next = Nt), (ht = ht.next);
        } while (ht !== null);
        At === null ? (yt = At = nt) : (At = At.next = nt);
      } else yt = At = nt;
      (ht = {
        baseState: dt.baseState,
        firstBaseUpdate: yt,
        lastBaseUpdate: At,
        shared: dt.shared,
        effects: dt.effects,
      }),
        (tt.updateQueue = ht);
      return;
    }
    (tt = ht.lastBaseUpdate),
      tt === null ? (ht.firstBaseUpdate = nt) : (tt.next = nt),
      (ht.lastBaseUpdate = nt);
  }
  function No(tt, nt, ht, dt) {
    var yt = tt.updateQueue;
    Ss = !1;
    var At = yt.firstBaseUpdate,
      Nt = yt.lastBaseUpdate,
      jt = yt.shared.pending;
    if (jt !== null) {
      yt.shared.pending = null;
      var rn = jt,
        Sn = rn.next;
      (rn.next = null), Nt === null ? (At = Sn) : (Nt.next = Sn), (Nt = rn);
      var Dn = tt.alternate;
      Dn !== null &&
        ((Dn = Dn.updateQueue),
        (jt = Dn.lastBaseUpdate),
        jt !== Nt &&
          (jt === null ? (Dn.firstBaseUpdate = Sn) : (jt.next = Sn),
          (Dn.lastBaseUpdate = rn)));
    }
    if (At !== null) {
      var Qn = yt.baseState;
      (Nt = 0), (Dn = Sn = rn = null), (jt = At);
      do {
        var Xn = jt.lane,
          cr = jt.eventTime;
        if ((dt & Xn) === Xn) {
          Dn !== null &&
            (Dn = Dn.next =
              {
                eventTime: cr,
                lane: 0,
                tag: jt.tag,
                payload: jt.payload,
                callback: jt.callback,
                next: null,
              });
          e: {
            var Vn = tt,
              Nr = jt;
            switch (((Xn = nt), (cr = ht), Nr.tag)) {
              case 1:
                if (((Vn = Nr.payload), typeof Vn == "function")) {
                  Qn = Vn.call(cr, Qn, Xn);
                  break e;
                }
                Qn = Vn;
                break e;
              case 3:
                Vn.flags = (Vn.flags & -65537) | 128;
              case 0:
                if (
                  ((Vn = Nr.payload),
                  (Xn = typeof Vn == "function" ? Vn.call(cr, Qn, Xn) : Vn),
                  Xn == null)
                )
                  break e;
                Qn = d({}, Qn, Xn);
                break e;
              case 2:
                Ss = !0;
            }
          }
          jt.callback !== null &&
            jt.lane !== 0 &&
            ((tt.flags |= 64),
            (Xn = yt.effects),
            Xn === null ? (yt.effects = [jt]) : Xn.push(jt));
        } else
          (cr = {
            eventTime: cr,
            lane: Xn,
            tag: jt.tag,
            payload: jt.payload,
            callback: jt.callback,
            next: null,
          }),
            Dn === null ? ((Sn = Dn = cr), (rn = Qn)) : (Dn = Dn.next = cr),
            (Nt |= Xn);
        if (((jt = jt.next), jt === null)) {
          if (((jt = yt.shared.pending), jt === null)) break;
          (Xn = jt),
            (jt = Xn.next),
            (Xn.next = null),
            (yt.lastBaseUpdate = Xn),
            (yt.shared.pending = null);
        }
      } while (!0);
      if (
        (Dn === null && (rn = Qn),
        (yt.baseState = rn),
        (yt.firstBaseUpdate = Sn),
        (yt.lastBaseUpdate = Dn),
        (nt = yt.shared.interleaved),
        nt !== null)
      ) {
        yt = nt;
        do (Nt |= yt.lane), (yt = yt.next);
        while (yt !== nt);
      } else At === null && (yt.shared.lanes = 0);
      (Zs |= Nt), (tt.lanes = Nt), (tt.memoizedState = Qn);
    }
  }
  function Ju(tt, nt, ht) {
    if (((tt = nt.effects), (nt.effects = null), tt !== null))
      for (nt = 0; nt < tt.length; nt++) {
        var dt = tt[nt],
          yt = dt.callback;
        if (yt !== null) {
          if (((dt.callback = null), (dt = ht), typeof yt != "function"))
            throw Error(g(191, yt));
          yt.call(dt);
        }
      }
  }
  var Yu = new a.Component().refs;
  function Ql(tt, nt, ht, dt) {
    (nt = tt.memoizedState),
      (ht = ht(dt, nt)),
      (ht = ht == null ? nt : d({}, nt, ht)),
      (tt.memoizedState = ht),
      tt.lanes === 0 && (tt.updateQueue.baseState = ht);
  }
  var Oo = {
    isMounted: function (tt) {
      return (tt = tt._reactInternals) ? _t(tt) === tt : !1;
    },
    enqueueSetState: function (tt, nt, ht) {
      tt = tt._reactInternals;
      var dt = Ur(),
        yt = Cs(tt),
        At = ms(dt, yt);
      (At.payload = nt),
        ht != null && (At.callback = ht),
        Es(tt, At),
        (nt = _i(tt, yt, dt)),
        nt !== null && Do(nt, tt, yt);
    },
    enqueueReplaceState: function (tt, nt, ht) {
      tt = tt._reactInternals;
      var dt = Ur(),
        yt = Cs(tt),
        At = ms(dt, yt);
      (At.tag = 1),
        (At.payload = nt),
        ht != null && (At.callback = ht),
        Es(tt, At),
        (nt = _i(tt, yt, dt)),
        nt !== null && Do(nt, tt, yt);
    },
    enqueueForceUpdate: function (tt, nt) {
      tt = tt._reactInternals;
      var ht = Ur(),
        dt = Cs(tt),
        yt = ms(ht, dt);
      (yt.tag = 2),
        nt != null && (yt.callback = nt),
        Es(tt, yt),
        (nt = _i(tt, dt, ht)),
        nt !== null && Do(nt, tt, dt);
    },
  };
  function qu(tt, nt, ht, dt, yt, At, Nt) {
    return (
      (tt = tt.stateNode),
      typeof tt.shouldComponentUpdate == "function"
        ? tt.shouldComponentUpdate(dt, At, Nt)
        : nt.prototype && nt.prototype.isPureReactComponent
        ? !Lo(ht, dt) || !Lo(yt, At)
        : !0
    );
  }
  function Qu(tt, nt, ht) {
    var dt = !1,
      yt = hr,
      At = nt.contextType;
    return (
      typeof At == "object" && At !== null
        ? (At = Jr(At))
        : ((yt = br(nt) ? Vr : Jn.current),
          (dt = nt.contextTypes),
          (At = (dt = dt != null) ? Sr(tt, yt) : hr)),
      (nt = new nt(ht, At)),
      (tt.memoizedState =
        nt.state !== null && nt.state !== void 0 ? nt.state : null),
      (nt.updater = Oo),
      (tt.stateNode = nt),
      (nt._reactInternals = tt),
      dt &&
        ((tt = tt.stateNode),
        (tt.__reactInternalMemoizedUnmaskedChildContext = yt),
        (tt.__reactInternalMemoizedMaskedChildContext = At)),
      nt
    );
  }
  function Zu(tt, nt, ht, dt) {
    (tt = nt.state),
      typeof nt.componentWillReceiveProps == "function" &&
        nt.componentWillReceiveProps(ht, dt),
      typeof nt.UNSAFE_componentWillReceiveProps == "function" &&
        nt.UNSAFE_componentWillReceiveProps(ht, dt),
      nt.state !== tt && Oo.enqueueReplaceState(nt, nt.state, null);
  }
  function Zl(tt, nt, ht, dt) {
    var yt = tt.stateNode;
    (yt.props = ht), (yt.state = tt.memoizedState), (yt.refs = Yu), Yl(tt);
    var At = nt.contextType;
    typeof At == "object" && At !== null
      ? (yt.context = Jr(At))
      : ((At = br(nt) ? Vr : Jn.current), (yt.context = Sr(tt, At))),
      (yt.state = tt.memoizedState),
      (At = nt.getDerivedStateFromProps),
      typeof At == "function" &&
        (Ql(tt, nt, At, ht), (yt.state = tt.memoizedState)),
      typeof nt.getDerivedStateFromProps == "function" ||
        typeof yt.getSnapshotBeforeUpdate == "function" ||
        (typeof yt.UNSAFE_componentWillMount != "function" &&
          typeof yt.componentWillMount != "function") ||
        ((nt = yt.state),
        typeof yt.componentWillMount == "function" && yt.componentWillMount(),
        typeof yt.UNSAFE_componentWillMount == "function" &&
          yt.UNSAFE_componentWillMount(),
        nt !== yt.state && Oo.enqueueReplaceState(yt, yt.state, null),
        No(tt, ht, yt, dt),
        (yt.state = tt.memoizedState)),
      typeof yt.componentDidMount == "function" && (tt.flags |= 4194308);
  }
  var Ws = [],
    $s = 0,
    Uo = null,
    Vo = 0,
    Yr = [],
    qr = 0,
    Ps = null,
    gs = 1,
    vs = "";
  function Rs(tt, nt) {
    (Ws[$s++] = Vo), (Ws[$s++] = Uo), (Uo = tt), (Vo = nt);
  }
  function _h(tt, nt, ht) {
    (Yr[qr++] = gs), (Yr[qr++] = vs), (Yr[qr++] = Ps), (Ps = tt);
    var dt = gs;
    tt = vs;
    var yt = 32 - Hr(dt) - 1;
    (dt &= ~(1 << yt)), (ht += 1);
    var At = 32 - Hr(nt) + yt;
    if (30 < At) {
      var Nt = yt - (yt % 5);
      (At = (dt & ((1 << Nt) - 1)).toString(32)),
        (dt >>= Nt),
        (yt -= Nt),
        (gs = (1 << (32 - Hr(nt) + yt)) | (ht << yt) | dt),
        (vs = At + tt);
    } else (gs = (1 << At) | (ht << yt) | dt), (vs = tt);
  }
  function _c(tt) {
    tt.return !== null && (Rs(tt, 1), _h(tt, 1, 0));
  }
  function eu(tt) {
    for (; tt === Uo; )
      (Uo = Ws[--$s]), (Ws[$s] = null), (Vo = Ws[--$s]), (Ws[$s] = null);
    for (; tt === Ps; )
      (Ps = Yr[--qr]),
        (Yr[qr] = null),
        (vs = Yr[--qr]),
        (Yr[qr] = null),
        (gs = Yr[--qr]),
        (Yr[qr] = null);
  }
  var Wr = null,
    $r = null,
    gr = !1,
    so = !1,
    ss = null;
  function _f(tt, nt) {
    var ht = es(5, null, null, 0);
    (ht.elementType = "DELETED"),
      (ht.stateNode = nt),
      (ht.return = tt),
      (nt = tt.deletions),
      nt === null ? ((tt.deletions = [ht]), (tt.flags |= 16)) : nt.push(ht);
  }
  function _d(tt, nt) {
    switch (tt.tag) {
      case 5:
        return (
          (nt = Ao(nt, tt.type, tt.pendingProps)),
          nt !== null ? ((tt.stateNode = nt), (Wr = tt), ($r = Vs(nt)), !0) : !1
        );
      case 6:
        return (
          (nt = ds(nt, tt.pendingProps)),
          nt !== null ? ((tt.stateNode = nt), (Wr = tt), ($r = null), !0) : !1
        );
      case 13:
        if (((nt = to(nt)), nt !== null)) {
          var ht = Ps !== null ? { id: gs, overflow: vs } : null;
          return (
            (tt.memoizedState = {
              dehydrated: nt,
              treeContext: ht,
              retryLane: 1073741824,
            }),
            (ht = es(18, null, null, 0)),
            (ht.stateNode = nt),
            (ht.return = tt),
            (tt.child = ht),
            (Wr = tt),
            ($r = null),
            !0
          );
        }
        return !1;
      default:
        return !1;
    }
  }
  function tu(tt) {
    return (tt.mode & 1) !== 0 && (tt.flags & 128) === 0;
  }
  function nu(tt) {
    if (gr) {
      var nt = $r;
      if (nt) {
        var ht = nt;
        if (!_d(tt, nt)) {
          if (tu(tt)) throw Error(g(418));
          nt = _s(ht);
          var dt = Wr;
          nt && _d(tt, nt)
            ? _f(dt, ht)
            : ((tt.flags = (tt.flags & -4097) | 2), (gr = !1), (Wr = tt));
        }
      } else {
        if (tu(tt)) throw Error(g(418));
        (tt.flags = (tt.flags & -4097) | 2), (gr = !1), (Wr = tt);
      }
    }
  }
  function ep(tt) {
    for (
      tt = tt.return;
      tt !== null && tt.tag !== 5 && tt.tag !== 3 && tt.tag !== 13;

    )
      tt = tt.return;
    Wr = tt;
  }
  function oo(tt) {
    if (!qt || tt !== Wr) return !1;
    if (!gr) return ep(tt), (gr = !0), !1;
    if (
      tt.tag !== 3 &&
      (tt.tag !== 5 || (En(tt.type) && !Jt(tt.type, tt.memoizedProps)))
    ) {
      var nt = $r;
      if (nt) {
        if (tu(tt)) {
          for (tt = $r; tt; ) tt = _s(tt);
          throw Error(g(418));
        }
        for (; nt; ) _f(tt, nt), (nt = _s(nt));
      }
    }
    if ((ep(tt), tt.tag === 13)) {
      if (!qt) throw Error(g(316));
      if (
        ((tt = tt.memoizedState),
        (tt = tt !== null ? tt.dehydrated : null),
        !tt)
      )
        throw Error(g(317));
      $r = It(tt);
    } else $r = Wr ? _s(tt.stateNode) : null;
    return !0;
  }
  function Xs() {
    qt && (($r = Wr = null), (so = gr = !1));
  }
  function ru(tt) {
    ss === null ? (ss = [tt]) : ss.push(tt);
  }
  function ao(tt, nt, ht) {
    if (
      ((tt = ht.ref),
      tt !== null && typeof tt != "function" && typeof tt != "object")
    ) {
      if (ht._owner) {
        if (((ht = ht._owner), ht)) {
          if (ht.tag !== 1) throw Error(g(309));
          var dt = ht.stateNode;
        }
        if (!dt) throw Error(g(147, tt));
        var yt = dt,
          At = "" + tt;
        return nt !== null &&
          nt.ref !== null &&
          typeof nt.ref == "function" &&
          nt.ref._stringRef === At
          ? nt.ref
          : ((nt = function (Nt) {
              var jt = yt.refs;
              jt === Yu && (jt = yt.refs = {}),
                Nt === null ? delete jt[At] : (jt[At] = Nt);
            }),
            (nt._stringRef = At),
            nt);
      }
      if (typeof tt != "string") throw Error(g(284));
      if (!ht._owner) throw Error(g(290, tt));
    }
    return tt;
  }
  function Go(tt, nt) {
    throw (
      ((tt = Object.prototype.toString.call(nt)),
      Error(
        g(
          31,
          tt === "[object Object]"
            ? "object with keys {" + Object.keys(nt).join(", ") + "}"
            : tt
        )
      ))
    );
  }
  function tp(tt) {
    var nt = tt._init;
    return nt(tt._payload);
  }
  function np(tt) {
    function nt(Yt, Ht) {
      if (tt) {
        var tn = Yt.deletions;
        tn === null ? ((Yt.deletions = [Ht]), (Yt.flags |= 16)) : tn.push(Ht);
      }
    }
    function ht(Yt, Ht) {
      if (!tt) return null;
      for (; Ht !== null; ) nt(Yt, Ht), (Ht = Ht.sibling);
      return null;
    }
    function dt(Yt, Ht) {
      for (Yt = new Map(); Ht !== null; )
        Ht.key !== null ? Yt.set(Ht.key, Ht) : Yt.set(Ht.index, Ht),
          (Ht = Ht.sibling);
      return Yt;
    }
    function yt(Yt, Ht) {
      return (Yt = bs(Yt, Ht)), (Yt.index = 0), (Yt.sibling = null), Yt;
    }
    function At(Yt, Ht, tn) {
      return (
        (Yt.index = tn),
        tt
          ? ((tn = Yt.alternate),
            tn !== null
              ? ((tn = tn.index), tn < Ht ? ((Yt.flags |= 2), Ht) : tn)
              : ((Yt.flags |= 2), Ht))
          : ((Yt.flags |= 1048576), Ht)
      );
    }
    function Nt(Yt) {
      return tt && Yt.alternate === null && (Yt.flags |= 2), Yt;
    }
    function jt(Yt, Ht, tn, Ln) {
      return Ht === null || Ht.tag !== 6
        ? ((Ht = Vu(tn, Yt.mode, Ln)), (Ht.return = Yt), Ht)
        : ((Ht = yt(Ht, tn)), (Ht.return = Yt), Ht);
    }
    function rn(Yt, Ht, tn, Ln) {
      var Un = tn.type;
      return Un === $
        ? Dn(Yt, Ht, tn.props.children, Ln, tn.key)
        : Ht !== null &&
          (Ht.elementType === Un ||
            (typeof Un == "object" &&
              Un !== null &&
              Un.$$typeof === ot &&
              tp(Un) === Ht.type))
        ? ((Ln = yt(Ht, tn.props)),
          (Ln.ref = ao(Yt, Ht, tn)),
          (Ln.return = Yt),
          Ln)
        : ((Ln = Il(tn.type, tn.key, tn.props, null, Yt.mode, Ln)),
          (Ln.ref = ao(Yt, Ht, tn)),
          (Ln.return = Yt),
          Ln);
    }
    function Sn(Yt, Ht, tn, Ln) {
      return Ht === null ||
        Ht.tag !== 4 ||
        Ht.stateNode.containerInfo !== tn.containerInfo ||
        Ht.stateNode.implementation !== tn.implementation
        ? ((Ht = Gu(tn, Yt.mode, Ln)), (Ht.return = Yt), Ht)
        : ((Ht = yt(Ht, tn.children || [])), (Ht.return = Yt), Ht);
    }
    function Dn(Yt, Ht, tn, Ln, Un) {
      return Ht === null || Ht.tag !== 7
        ? ((Ht = Ns(tn, Yt.mode, Ln, Un)), (Ht.return = Yt), Ht)
        : ((Ht = yt(Ht, tn)), (Ht.return = Yt), Ht);
    }
    function Qn(Yt, Ht, tn) {
      if ((typeof Ht == "string" && Ht !== "") || typeof Ht == "number")
        return (Ht = Vu("" + Ht, Yt.mode, tn)), (Ht.return = Yt), Ht;
      if (typeof Ht == "object" && Ht !== null) {
        switch (Ht.$$typeof) {
          case b:
            return (
              (tn = Il(Ht.type, Ht.key, Ht.props, null, Yt.mode, tn)),
              (tn.ref = ao(Yt, null, Ht)),
              (tn.return = Yt),
              tn
            );
          case j:
            return (Ht = Gu(Ht, Yt.mode, tn)), (Ht.return = Yt), Ht;
          case ot:
            var Ln = Ht._init;
            return Qn(Yt, Ln(Ht._payload), tn);
        }
        if (Lt(Ht) || ft(Ht))
          return (Ht = Ns(Ht, Yt.mode, tn, null)), (Ht.return = Yt), Ht;
        Go(Yt, Ht);
      }
      return null;
    }
    function Xn(Yt, Ht, tn, Ln) {
      var Un = Ht !== null ? Ht.key : null;
      if ((typeof tn == "string" && tn !== "") || typeof tn == "number")
        return Un !== null ? null : jt(Yt, Ht, "" + tn, Ln);
      if (typeof tn == "object" && tn !== null) {
        switch (tn.$$typeof) {
          case b:
            return tn.key === Un ? rn(Yt, Ht, tn, Ln) : null;
          case j:
            return tn.key === Un ? Sn(Yt, Ht, tn, Ln) : null;
          case ot:
            return (Un = tn._init), Xn(Yt, Ht, Un(tn._payload), Ln);
        }
        if (Lt(tn) || ft(tn))
          return Un !== null ? null : Dn(Yt, Ht, tn, Ln, null);
        Go(Yt, tn);
      }
      return null;
    }
    function cr(Yt, Ht, tn, Ln, Un) {
      if ((typeof Ln == "string" && Ln !== "") || typeof Ln == "number")
        return (Yt = Yt.get(tn) || null), jt(Ht, Yt, "" + Ln, Un);
      if (typeof Ln == "object" && Ln !== null) {
        switch (Ln.$$typeof) {
          case b:
            return (
              (Yt = Yt.get(Ln.key === null ? tn : Ln.key) || null),
              rn(Ht, Yt, Ln, Un)
            );
          case j:
            return (
              (Yt = Yt.get(Ln.key === null ? tn : Ln.key) || null),
              Sn(Ht, Yt, Ln, Un)
            );
          case ot:
            var er = Ln._init;
            return cr(Yt, Ht, tn, er(Ln._payload), Un);
        }
        if (Lt(Ln) || ft(Ln))
          return (Yt = Yt.get(tn) || null), Dn(Ht, Yt, Ln, Un, null);
        Go(Ht, Ln);
      }
      return null;
    }
    function Vn(Yt, Ht, tn, Ln) {
      for (
        var Un = null, er = null, Zn = Ht, or = (Ht = 0), Rr = null;
        Zn !== null && or < tn.length;
        or++
      ) {
        Zn.index > or ? ((Rr = Zn), (Zn = null)) : (Rr = Zn.sibling);
        var ar = Xn(Yt, Zn, tn[or], Ln);
        if (ar === null) {
          Zn === null && (Zn = Rr);
          break;
        }
        tt && Zn && ar.alternate === null && nt(Yt, Zn),
          (Ht = At(ar, Ht, or)),
          er === null ? (Un = ar) : (er.sibling = ar),
          (er = ar),
          (Zn = Rr);
      }
      if (or === tn.length) return ht(Yt, Zn), gr && Rs(Yt, or), Un;
      if (Zn === null) {
        for (; or < tn.length; or++)
          (Zn = Qn(Yt, tn[or], Ln)),
            Zn !== null &&
              ((Ht = At(Zn, Ht, or)),
              er === null ? (Un = Zn) : (er.sibling = Zn),
              (er = Zn));
        return gr && Rs(Yt, or), Un;
      }
      for (Zn = dt(Yt, Zn); or < tn.length; or++)
        (Rr = cr(Zn, Yt, or, tn[or], Ln)),
          Rr !== null &&
            (tt &&
              Rr.alternate !== null &&
              Zn.delete(Rr.key === null ? or : Rr.key),
            (Ht = At(Rr, Ht, or)),
            er === null ? (Un = Rr) : (er.sibling = Rr),
            (er = Rr));
      return (
        tt &&
          Zn.forEach(function (ws) {
            return nt(Yt, ws);
          }),
        gr && Rs(Yt, or),
        Un
      );
    }
    function Nr(Yt, Ht, tn, Ln) {
      var Un = ft(tn);
      if (typeof Un != "function") throw Error(g(150));
      if (((tn = Un.call(tn)), tn == null)) throw Error(g(151));
      for (
        var er = (Un = null), Zn = Ht, or = (Ht = 0), Rr = null, ar = tn.next();
        Zn !== null && !ar.done;
        or++, ar = tn.next()
      ) {
        Zn.index > or ? ((Rr = Zn), (Zn = null)) : (Rr = Zn.sibling);
        var ws = Xn(Yt, Zn, ar.value, Ln);
        if (ws === null) {
          Zn === null && (Zn = Rr);
          break;
        }
        tt && Zn && ws.alternate === null && nt(Yt, Zn),
          (Ht = At(ws, Ht, or)),
          er === null ? (Un = ws) : (er.sibling = ws),
          (er = ws),
          (Zn = Rr);
      }
      if (ar.done) return ht(Yt, Zn), gr && Rs(Yt, or), Un;
      if (Zn === null) {
        for (; !ar.done; or++, ar = tn.next())
          (ar = Qn(Yt, ar.value, Ln)),
            ar !== null &&
              ((Ht = At(ar, Ht, or)),
              er === null ? (Un = ar) : (er.sibling = ar),
              (er = ar));
        return gr && Rs(Yt, or), Un;
      }
      for (Zn = dt(Yt, Zn); !ar.done; or++, ar = tn.next())
        (ar = cr(Zn, Yt, or, ar.value, Ln)),
          ar !== null &&
            (tt &&
              ar.alternate !== null &&
              Zn.delete(ar.key === null ? or : ar.key),
            (Ht = At(ar, Ht, or)),
            er === null ? (Un = ar) : (er.sibling = ar),
            (er = ar));
      return (
        tt &&
          Zn.forEach(function (c0) {
            return nt(Yt, c0);
          }),
        gr && Rs(Yt, or),
        Un
      );
    }
    function ts(Yt, Ht, tn, Ln) {
      if (
        (typeof tn == "object" &&
          tn !== null &&
          tn.type === $ &&
          tn.key === null &&
          (tn = tn.props.children),
        typeof tn == "object" && tn !== null)
      ) {
        switch (tn.$$typeof) {
          case b:
            e: {
              for (var Un = tn.key, er = Ht; er !== null; ) {
                if (er.key === Un) {
                  if (((Un = tn.type), Un === $)) {
                    if (er.tag === 7) {
                      ht(Yt, er.sibling),
                        (Ht = yt(er, tn.props.children)),
                        (Ht.return = Yt),
                        (Yt = Ht);
                      break e;
                    }
                  } else if (
                    er.elementType === Un ||
                    (typeof Un == "object" &&
                      Un !== null &&
                      Un.$$typeof === ot &&
                      tp(Un) === er.type)
                  ) {
                    ht(Yt, er.sibling),
                      (Ht = yt(er, tn.props)),
                      (Ht.ref = ao(Yt, er, tn)),
                      (Ht.return = Yt),
                      (Yt = Ht);
                    break e;
                  }
                  ht(Yt, er);
                  break;
                } else nt(Yt, er);
                er = er.sibling;
              }
              tn.type === $
                ? ((Ht = Ns(tn.props.children, Yt.mode, Ln, tn.key)),
                  (Ht.return = Yt),
                  (Yt = Ht))
                : ((Ln = Il(tn.type, tn.key, tn.props, null, Yt.mode, Ln)),
                  (Ln.ref = ao(Yt, Ht, tn)),
                  (Ln.return = Yt),
                  (Yt = Ln));
            }
            return Nt(Yt);
          case j:
            e: {
              for (er = tn.key; Ht !== null; ) {
                if (Ht.key === er)
                  if (
                    Ht.tag === 4 &&
                    Ht.stateNode.containerInfo === tn.containerInfo &&
                    Ht.stateNode.implementation === tn.implementation
                  ) {
                    ht(Yt, Ht.sibling),
                      (Ht = yt(Ht, tn.children || [])),
                      (Ht.return = Yt),
                      (Yt = Ht);
                    break e;
                  } else {
                    ht(Yt, Ht);
                    break;
                  }
                else nt(Yt, Ht);
                Ht = Ht.sibling;
              }
              (Ht = Gu(tn, Yt.mode, Ln)), (Ht.return = Yt), (Yt = Ht);
            }
            return Nt(Yt);
          case ot:
            return (er = tn._init), ts(Yt, Ht, er(tn._payload), Ln);
        }
        if (Lt(tn)) return Vn(Yt, Ht, tn, Ln);
        if (ft(tn)) return Nr(Yt, Ht, tn, Ln);
        Go(Yt, tn);
      }
      return (typeof tn == "string" && tn !== "") || typeof tn == "number"
        ? ((tn = "" + tn),
          Ht !== null && Ht.tag === 6
            ? (ht(Yt, Ht.sibling),
              (Ht = yt(Ht, tn)),
              (Ht.return = Yt),
              (Yt = Ht))
            : (ht(Yt, Ht),
              (Ht = Vu(tn, Yt.mode, Ln)),
              (Ht.return = Yt),
              (Yt = Ht)),
          Nt(Yt))
        : ht(Yt, Ht);
    }
    return ts;
  }
  var Ks = np(!0),
    rp = np(!1),
    lo = {},
    Qr = yr(lo),
    co = yr(lo),
    Js = yr(lo);
  function us(tt) {
    if (tt === lo) throw Error(g(174));
    return tt;
  }
  function iu(tt, nt) {
    Cn(Js, nt), Cn(co, tt), Cn(Qr, lo), (tt = bt(nt)), Gn(Qr), Cn(Qr, tt);
  }
  function Ys() {
    Gn(Qr), Gn(co), Gn(Js);
  }
  function sp(tt) {
    var nt = us(Js.current),
      ht = us(Qr.current);
    (nt = mt(ht, tt.type, nt)), ht !== nt && (Cn(co, tt), Cn(Qr, nt));
  }
  function su(tt) {
    co.current === tt && (Gn(Qr), Gn(co));
  }
  var vr = yr(0);
  function jo(tt) {
    for (var nt = tt; nt !== null; ) {
      if (nt.tag === 13) {
        var ht = nt.memoizedState;
        if (
          ht !== null &&
          ((ht = ht.dehydrated), ht === null || no(ht) || Os(ht))
        )
          return nt;
      } else if (nt.tag === 19 && nt.memoizedProps.revealOrder !== void 0) {
        if (nt.flags & 128) return nt;
      } else if (nt.child !== null) {
        (nt.child.return = nt), (nt = nt.child);
        continue;
      }
      if (nt === tt) break;
      for (; nt.sibling === null; ) {
        if (nt.return === null || nt.return === tt) return null;
        nt = nt.return;
      }
      (nt.sibling.return = nt.return), (nt = nt.sibling);
    }
    return null;
  }
  var ou = [];
  function au() {
    for (var tt = 0; tt < ou.length; tt++) {
      var nt = ou[tt];
      fn
        ? (nt._workInProgressVersionPrimary = null)
        : (nt._workInProgressVersionSecondary = null);
    }
    ou.length = 0;
  }
  var zo = _.ReactCurrentDispatcher,
    Zr = _.ReactCurrentBatchConfig,
    qs = 0,
    xr = null,
    Lr = null,
    Pr = null,
    Ho = !1,
    uo = !1,
    ho = 0,
    Fm = 0;
  function Fr() {
    throw Error(g(321));
  }
  function lu(tt, nt) {
    if (nt === null) return !1;
    for (var ht = 0; ht < nt.length && ht < tt.length; ht++)
      if (!as(tt[ht], nt[ht])) return !1;
    return !0;
  }
  function cu(tt, nt, ht, dt, yt, At) {
    if (
      ((qs = At),
      (xr = nt),
      (nt.memoizedState = null),
      (nt.updateQueue = null),
      (nt.lanes = 0),
      (zo.current = tt === null || tt.memoizedState === null ? Om : Um),
      (tt = ht(dt, yt)),
      uo)
    ) {
      At = 0;
      do {
        if (((uo = !1), (ho = 0), 25 <= At)) throw Error(g(301));
        (At += 1),
          (Pr = Lr = null),
          (nt.updateQueue = null),
          (zo.current = Vm),
          (tt = ht(dt, yt));
      } while (uo);
    }
    if (
      ((zo.current = Jo),
      (nt = Lr !== null && Lr.next !== null),
      (qs = 0),
      (Pr = Lr = xr = null),
      (Ho = !1),
      nt)
    )
      throw Error(g(300));
    return tt;
  }
  function uu() {
    var tt = ho !== 0;
    return (ho = 0), tt;
  }
  function ys() {
    var tt = {
      memoizedState: null,
      baseState: null,
      baseQueue: null,
      queue: null,
      next: null,
    };
    return Pr === null ? (xr.memoizedState = Pr = tt) : (Pr = Pr.next = tt), Pr;
  }
  function hs() {
    if (Lr === null) {
      var tt = xr.alternate;
      tt = tt !== null ? tt.memoizedState : null;
    } else tt = Lr.next;
    var nt = Pr === null ? xr.memoizedState : Pr.next;
    if (nt !== null) (Pr = nt), (Lr = tt);
    else {
      if (tt === null) throw Error(g(310));
      (Lr = tt),
        (tt = {
          memoizedState: Lr.memoizedState,
          baseState: Lr.baseState,
          baseQueue: Lr.baseQueue,
          queue: Lr.queue,
          next: null,
        }),
        Pr === null ? (xr.memoizedState = Pr = tt) : (Pr = Pr.next = tt);
    }
    return Pr;
  }
  function Bs(tt, nt) {
    return typeof nt == "function" ? nt(tt) : nt;
  }
  function Wo(tt) {
    var nt = hs(),
      ht = nt.queue;
    if (ht === null) throw Error(g(311));
    ht.lastRenderedReducer = tt;
    var dt = Lr,
      yt = dt.baseQueue,
      At = ht.pending;
    if (At !== null) {
      if (yt !== null) {
        var Nt = yt.next;
        (yt.next = At.next), (At.next = Nt);
      }
      (dt.baseQueue = yt = At), (ht.pending = null);
    }
    if (yt !== null) {
      (At = yt.next), (dt = dt.baseState);
      var jt = (Nt = null),
        rn = null,
        Sn = At;
      do {
        var Dn = Sn.lane;
        if ((qs & Dn) === Dn)
          rn !== null &&
            (rn = rn.next =
              {
                lane: 0,
                action: Sn.action,
                hasEagerState: Sn.hasEagerState,
                eagerState: Sn.eagerState,
                next: null,
              }),
            (dt = Sn.hasEagerState ? Sn.eagerState : tt(dt, Sn.action));
        else {
          var Qn = {
            lane: Dn,
            action: Sn.action,
            hasEagerState: Sn.hasEagerState,
            eagerState: Sn.eagerState,
            next: null,
          };
          rn === null ? ((jt = rn = Qn), (Nt = dt)) : (rn = rn.next = Qn),
            (xr.lanes |= Dn),
            (Zs |= Dn);
        }
        Sn = Sn.next;
      } while (Sn !== null && Sn !== At);
      rn === null ? (Nt = dt) : (rn.next = jt),
        as(dt, nt.memoizedState) || (Xr = !0),
        (nt.memoizedState = dt),
        (nt.baseState = Nt),
        (nt.baseQueue = rn),
        (ht.lastRenderedState = dt);
    }
    if (((tt = ht.interleaved), tt !== null)) {
      yt = tt;
      do (At = yt.lane), (xr.lanes |= At), (Zs |= At), (yt = yt.next);
      while (yt !== tt);
    } else yt === null && (ht.lanes = 0);
    return [nt.memoizedState, ht.dispatch];
  }
  function $o(tt) {
    var nt = hs(),
      ht = nt.queue;
    if (ht === null) throw Error(g(311));
    ht.lastRenderedReducer = tt;
    var dt = ht.dispatch,
      yt = ht.pending,
      At = nt.memoizedState;
    if (yt !== null) {
      ht.pending = null;
      var Nt = (yt = yt.next);
      do (At = tt(At, Nt.action)), (Nt = Nt.next);
      while (Nt !== yt);
      as(At, nt.memoizedState) || (Xr = !0),
        (nt.memoizedState = At),
        nt.baseQueue === null && (nt.baseState = At),
        (ht.lastRenderedState = At);
    }
    return [At, dt];
  }
  function ap() {}
  function lp(tt, nt) {
    var ht = xr,
      dt = hs(),
      yt = nt(),
      At = !as(dt.memoizedState, yt);
    if (
      (At && ((dt.memoizedState = yt), (Xr = !0)),
      (dt = dt.queue),
      po(hp.bind(null, ht, dt, tt), [tt]),
      dt.getSnapshot !== nt || At || (Pr !== null && Pr.memoizedState.tag & 1))
    ) {
      if (
        ((ht.flags |= 2048),
        fo(9, up.bind(null, ht, dt, yt, nt), void 0, null),
        Er === null)
      )
        throw Error(g(349));
      qs & 30 || cp(ht, nt, yt);
    }
    return yt;
  }
  function cp(tt, nt, ht) {
    (tt.flags |= 16384),
      (tt = { getSnapshot: nt, value: ht }),
      (nt = xr.updateQueue),
      nt === null
        ? ((nt = { lastEffect: null, stores: null }),
          (xr.updateQueue = nt),
          (nt.stores = [tt]))
        : ((ht = nt.stores), ht === null ? (nt.stores = [tt]) : ht.push(tt));
  }
  function up(tt, nt, ht, dt) {
    (nt.value = ht), (nt.getSnapshot = dt), fp(nt) && _i(tt, 1, -1);
  }
  function hp(tt, nt, ht) {
    return ht(function () {
      fp(nt) && _i(tt, 1, -1);
    });
  }
  function fp(tt) {
    var nt = tt.getSnapshot;
    tt = tt.value;
    try {
      var ht = nt();
      return !as(tt, ht);
    } catch {
      return !0;
    }
  }
  function hu(tt) {
    var nt = ys();
    return (
      typeof tt == "function" && (tt = tt()),
      (nt.memoizedState = nt.baseState = tt),
      (tt = {
        pending: null,
        interleaved: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: Bs,
        lastRenderedState: tt,
      }),
      (nt.queue = tt),
      (tt = tt.dispatch = Nm.bind(null, xr, tt)),
      [nt.memoizedState, tt]
    );
  }
  function fo(tt, nt, ht, dt) {
    return (
      (tt = { tag: tt, create: nt, destroy: ht, deps: dt, next: null }),
      (nt = xr.updateQueue),
      nt === null
        ? ((nt = { lastEffect: null, stores: null }),
          (xr.updateQueue = nt),
          (nt.lastEffect = tt.next = tt))
        : ((ht = nt.lastEffect),
          ht === null
            ? (nt.lastEffect = tt.next = tt)
            : ((dt = ht.next),
              (ht.next = tt),
              (tt.next = dt),
              (nt.lastEffect = tt))),
      tt
    );
  }
  function dp() {
    return hs().memoizedState;
  }
  function Xo(tt, nt, ht, dt) {
    var yt = ys();
    (xr.flags |= tt),
      (yt.memoizedState = fo(1 | nt, ht, void 0, dt === void 0 ? null : dt));
  }
  function Ko(tt, nt, ht, dt) {
    var yt = hs();
    dt = dt === void 0 ? null : dt;
    var At = void 0;
    if (Lr !== null) {
      var Nt = Lr.memoizedState;
      if (((At = Nt.destroy), dt !== null && lu(dt, Nt.deps))) {
        yt.memoizedState = fo(nt, ht, At, dt);
        return;
      }
    }
    (xr.flags |= tt), (yt.memoizedState = fo(1 | nt, ht, At, dt));
  }
  function fu(tt, nt) {
    return Xo(8390656, 8, tt, nt);
  }
  function po(tt, nt) {
    return Ko(2048, 8, tt, nt);
  }
  function pp(tt, nt) {
    return Ko(4, 2, tt, nt);
  }
  function mp(tt, nt) {
    return Ko(4, 4, tt, nt);
  }
  function gp(tt, nt) {
    if (typeof nt == "function")
      return (
        (tt = tt()),
        nt(tt),
        function () {
          nt(null);
        }
      );
    if (nt != null)
      return (
        (tt = tt()),
        (nt.current = tt),
        function () {
          nt.current = null;
        }
      );
  }
  function vp(tt, nt, ht) {
    return (
      (ht = ht != null ? ht.concat([tt]) : null),
      Ko(4, 4, gp.bind(null, nt, tt), ht)
    );
  }
  function du() {}
  function yp(tt, nt) {
    var ht = hs();
    nt = nt === void 0 ? null : nt;
    var dt = ht.memoizedState;
    return dt !== null && nt !== null && lu(nt, dt[1])
      ? dt[0]
      : ((ht.memoizedState = [tt, nt]), tt);
  }
  function xp(tt, nt) {
    var ht = hs();
    nt = nt === void 0 ? null : nt;
    var dt = ht.memoizedState;
    return dt !== null && nt !== null && lu(nt, dt[1])
      ? dt[0]
      : ((tt = tt()), (ht.memoizedState = [tt, nt]), tt);
  }
  function km(tt, nt) {
    var ht = sr;
    (sr = ht !== 0 && 4 > ht ? ht : 4), tt(!0);
    var dt = Zr.transition;
    Zr.transition = {};
    try {
      tt(!1), nt();
    } finally {
      (sr = ht), (Zr.transition = dt);
    }
  }
  function _p() {
    return hs().memoizedState;
  }
  function Dm(tt, nt, ht) {
    var dt = Cs(tt);
    (ht = {
      lane: dt,
      action: ht,
      hasEagerState: !1,
      eagerState: null,
      next: null,
    }),
      Sp(tt)
        ? Ep(nt, ht)
        : (Ap(tt, nt, ht),
          (ht = Ur()),
          (tt = _i(tt, dt, ht)),
          tt !== null && Mp(tt, nt, dt));
  }
  function Nm(tt, nt, ht) {
    var dt = Cs(tt),
      yt = {
        lane: dt,
        action: ht,
        hasEagerState: !1,
        eagerState: null,
        next: null,
      };
    if (Sp(tt)) Ep(nt, yt);
    else {
      Ap(tt, nt, yt);
      var At = tt.alternate;
      if (
        tt.lanes === 0 &&
        (At === null || At.lanes === 0) &&
        ((At = nt.lastRenderedReducer), At !== null)
      )
        try {
          var Nt = nt.lastRenderedState,
            jt = At(Nt, ht);
          if (((yt.hasEagerState = !0), (yt.eagerState = jt), as(jt, Nt)))
            return;
        } catch {
        } finally {
        }
      (ht = Ur()), (tt = _i(tt, dt, ht)), tt !== null && Mp(tt, nt, dt);
    }
  }
  function Sp(tt) {
    var nt = tt.alternate;
    return tt === xr || (nt !== null && nt === xr);
  }
  function Ep(tt, nt) {
    uo = Ho = !0;
    var ht = tt.pending;
    ht === null ? (nt.next = nt) : ((nt.next = ht.next), (ht.next = nt)),
      (tt.pending = nt);
  }
  function Ap(tt, nt, ht) {
    Er !== null && tt.mode & 1 && !(nr & 2)
      ? ((tt = nt.interleaved),
        tt === null
          ? ((ht.next = ht), cs === null ? (cs = [nt]) : cs.push(nt))
          : ((ht.next = tt.next), (tt.next = ht)),
        (nt.interleaved = ht))
      : ((tt = nt.pending),
        tt === null ? (ht.next = ht) : ((ht.next = tt.next), (tt.next = ht)),
        (nt.pending = ht));
  }
  function Mp(tt, nt, ht) {
    if (ht & 4194240) {
      var dt = nt.lanes;
      (dt &= tt.pendingLanes), (ht |= dt), (nt.lanes = ht), Vl(tt, ht);
    }
  }
  var Jo = {
      readContext: Jr,
      useCallback: Fr,
      useContext: Fr,
      useEffect: Fr,
      useImperativeHandle: Fr,
      useInsertionEffect: Fr,
      useLayoutEffect: Fr,
      useMemo: Fr,
      useReducer: Fr,
      useRef: Fr,
      useState: Fr,
      useDebugValue: Fr,
      useDeferredValue: Fr,
      useTransition: Fr,
      useMutableSource: Fr,
      useSyncExternalStore: Fr,
      useId: Fr,
      unstable_isNewReconciler: !1,
    },
    Om = {
      readContext: Jr,
      useCallback: function (tt, nt) {
        return (ys().memoizedState = [tt, nt === void 0 ? null : nt]), tt;
      },
      useContext: Jr,
      useEffect: fu,
      useImperativeHandle: function (tt, nt, ht) {
        return (
          (ht = ht != null ? ht.concat([tt]) : null),
          Xo(4194308, 4, gp.bind(null, nt, tt), ht)
        );
      },
      useLayoutEffect: function (tt, nt) {
        return Xo(4194308, 4, tt, nt);
      },
      useInsertionEffect: function (tt, nt) {
        return Xo(4, 2, tt, nt);
      },
      useMemo: function (tt, nt) {
        var ht = ys();
        return (
          (nt = nt === void 0 ? null : nt),
          (tt = tt()),
          (ht.memoizedState = [tt, nt]),
          tt
        );
      },
      useReducer: function (tt, nt, ht) {
        var dt = ys();
        return (
          (nt = ht !== void 0 ? ht(nt) : nt),
          (dt.memoizedState = dt.baseState = nt),
          (tt = {
            pending: null,
            interleaved: null,
            lanes: 0,
            dispatch: null,
            lastRenderedReducer: tt,
            lastRenderedState: nt,
          }),
          (dt.queue = tt),
          (tt = tt.dispatch = Dm.bind(null, xr, tt)),
          [dt.memoizedState, tt]
        );
      },
      useRef: function (tt) {
        var nt = ys();
        return (tt = { current: tt }), (nt.memoizedState = tt);
      },
      useState: hu,
      useDebugValue: du,
      useDeferredValue: function (tt) {
        var nt = hu(tt),
          ht = nt[0],
          dt = nt[1];
        return (
          fu(
            function () {
              var yt = Zr.transition;
              Zr.transition = {};
              try {
                dt(tt);
              } finally {
                Zr.transition = yt;
              }
            },
            [tt]
          ),
          ht
        );
      },
      useTransition: function () {
        var tt = hu(!1),
          nt = tt[0];
        return (tt = km.bind(null, tt[1])), (ys().memoizedState = tt), [nt, tt];
      },
      useMutableSource: function () {},
      useSyncExternalStore: function (tt, nt, ht) {
        var dt = xr,
          yt = ys();
        if (gr) {
          if (ht === void 0) throw Error(g(407));
          ht = ht();
        } else {
          if (((ht = nt()), Er === null)) throw Error(g(349));
          qs & 30 || cp(dt, nt, ht);
        }
        yt.memoizedState = ht;
        var At = { value: ht, getSnapshot: nt };
        return (
          (yt.queue = At),
          fu(hp.bind(null, dt, At, tt), [tt]),
          (dt.flags |= 2048),
          fo(9, up.bind(null, dt, At, ht, nt), void 0, null),
          ht
        );
      },
      useId: function () {
        var tt = ys(),
          nt = Er.identifierPrefix;
        if (gr) {
          var ht = vs,
            dt = gs;
          (ht = (dt & ~(1 << (32 - Hr(dt) - 1))).toString(32) + ht),
            (nt = ":" + nt + "R" + ht),
            (ht = ho++),
            0 < ht && (nt += "H" + ht.toString(32)),
            (nt += ":");
        } else (ht = Fm++), (nt = ":" + nt + "r" + ht.toString(32) + ":");
        return (tt.memoizedState = nt);
      },
      unstable_isNewReconciler: !1,
    },
    Um = {
      readContext: Jr,
      useCallback: yp,
      useContext: Jr,
      useEffect: po,
      useImperativeHandle: vp,
      useInsertionEffect: pp,
      useLayoutEffect: mp,
      useMemo: xp,
      useReducer: Wo,
      useRef: dp,
      useState: function () {
        return Wo(Bs);
      },
      useDebugValue: du,
      useDeferredValue: function (tt) {
        var nt = Wo(Bs),
          ht = nt[0],
          dt = nt[1];
        return (
          po(
            function () {
              var yt = Zr.transition;
              Zr.transition = {};
              try {
                dt(tt);
              } finally {
                Zr.transition = yt;
              }
            },
            [tt]
          ),
          ht
        );
      },
      useTransition: function () {
        var tt = Wo(Bs)[0],
          nt = hs().memoizedState;
        return [tt, nt];
      },
      useMutableSource: ap,
      useSyncExternalStore: lp,
      useId: _p,
      unstable_isNewReconciler: !1,
    },
    Vm = {
      readContext: Jr,
      useCallback: yp,
      useContext: Jr,
      useEffect: po,
      useImperativeHandle: vp,
      useInsertionEffect: pp,
      useLayoutEffect: mp,
      useMemo: xp,
      useReducer: $o,
      useRef: dp,
      useState: function () {
        return $o(Bs);
      },
      useDebugValue: du,
      useDeferredValue: function (tt) {
        var nt = $o(Bs),
          ht = nt[0],
          dt = nt[1];
        return (
          po(
            function () {
              var yt = Zr.transition;
              Zr.transition = {};
              try {
                dt(tt);
              } finally {
                Zr.transition = yt;
              }
            },
            [tt]
          ),
          ht
        );
      },
      useTransition: function () {
        var tt = $o(Bs)[0],
          nt = hs().memoizedState;
        return [tt, nt];
      },
      useMutableSource: ap,
      useSyncExternalStore: lp,
      useId: _p,
      unstable_isNewReconciler: !1,
    };
  function pu(tt, nt) {
    try {
      var ht = "",
        dt = nt;
      do (ht += Lm(dt)), (dt = dt.return);
      while (dt);
      var yt = ht;
    } catch (At) {
      yt =
        `
Error generating stack: ` +
        At.message +
        `
` +
        At.stack;
    }
    return { value: tt, source: nt, stack: yt };
  }
  function mu(tt, nt) {
    try {
      console.error(nt.value);
    } catch (ht) {
      setTimeout(function () {
        throw ht;
      });
    }
  }
  var Gm = typeof WeakMap == "function" ? WeakMap : Map;
  function Cp(tt, nt, ht) {
    (ht = ms(-1, ht)), (ht.tag = 3), (ht.payload = { element: null });
    var dt = nt.value;
    return (
      (ht.callback = function () {
        Ml || ((Ml = !0), (Lu = dt)), mu(tt, nt);
      }),
      ht
    );
  }
  function Tp(tt, nt, ht) {
    (ht = ms(-1, ht)), (ht.tag = 3);
    var dt = tt.type.getDerivedStateFromError;
    if (typeof dt == "function") {
      var yt = nt.value;
      (ht.payload = function () {
        return dt(yt);
      }),
        (ht.callback = function () {
          mu(tt, nt);
        });
    }
    var At = tt.stateNode;
    return (
      At !== null &&
        typeof At.componentDidCatch == "function" &&
        (ht.callback = function () {
          mu(tt, nt),
            typeof dt != "function" &&
              (As === null ? (As = new Set([this])) : As.add(this));
          var Nt = nt.stack;
          this.componentDidCatch(nt.value, {
            componentStack: Nt !== null ? Nt : "",
          });
        }),
      ht
    );
  }
  function bp(tt, nt, ht) {
    var dt = tt.pingCache;
    if (dt === null) {
      dt = tt.pingCache = new Gm();
      var yt = new Set();
      dt.set(nt, yt);
    } else
      (yt = dt.get(nt)), yt === void 0 && ((yt = new Set()), dt.set(nt, yt));
    yt.has(ht) ||
      (yt.add(ht), (tt = t0.bind(null, tt, nt, ht)), nt.then(tt, tt));
  }
  function wp(tt) {
    do {
      var nt;
      if (
        ((nt = tt.tag === 13) &&
          ((nt = tt.memoizedState),
          (nt = nt !== null ? nt.dehydrated !== null : !0)),
        nt)
      )
        return tt;
      tt = tt.return;
    } while (tt !== null);
    return null;
  }
  function Pp(tt, nt, ht, dt, yt) {
    return tt.mode & 1
      ? ((tt.flags |= 65536), (tt.lanes = yt), tt)
      : (tt === nt
          ? (tt.flags |= 65536)
          : ((tt.flags |= 128),
            (ht.flags |= 131072),
            (ht.flags &= -52805),
            ht.tag === 1 &&
              (ht.alternate === null
                ? (ht.tag = 17)
                : ((nt = ms(-1, 1)), (nt.tag = 2), Es(ht, nt))),
            (ht.lanes |= 1)),
        tt);
  }
  function fs(tt) {
    tt.flags |= 4;
  }
  function Rp(tt, nt) {
    if (tt !== null && tt.child === nt.child) return !0;
    if (nt.flags & 16) return !1;
    for (tt = nt.child; tt !== null; ) {
      if (tt.flags & 12854 || tt.subtreeFlags & 12854) return !1;
      tt = tt.sibling;
    }
    return !0;
  }
  var mo, go, Yo, qo;
  if (pn)
    (mo = function (tt, nt) {
      for (var ht = nt.child; ht !== null; ) {
        if (ht.tag === 5 || ht.tag === 6) Dt(tt, ht.stateNode);
        else if (ht.tag !== 4 && ht.child !== null) {
          (ht.child.return = ht), (ht = ht.child);
          continue;
        }
        if (ht === nt) break;
        for (; ht.sibling === null; ) {
          if (ht.return === null || ht.return === nt) return;
          ht = ht.return;
        }
        (ht.sibling.return = ht.return), (ht = ht.sibling);
      }
    }),
      (go = function () {}),
      (Yo = function (tt, nt, ht, dt, yt) {
        if (((tt = tt.memoizedProps), tt !== dt)) {
          var At = nt.stateNode,
            Nt = us(Qr.current);
          (ht = Pt(At, ht, tt, dt, yt, Nt)), (nt.updateQueue = ht) && fs(nt);
        }
      }),
      (qo = function (tt, nt, ht, dt) {
        ht !== dt && fs(nt);
      });
  else if (Bt) {
    mo = function (tt, nt, ht, dt) {
      for (var yt = nt.child; yt !== null; ) {
        if (yt.tag === 5) {
          var At = yt.stateNode;
          ht && dt && (At = Cr(At, yt.type, yt.memoizedProps, yt)), Dt(tt, At);
        } else if (yt.tag === 6)
          (At = yt.stateNode),
            ht && dt && (At = Tr(At, yt.memoizedProps, yt)),
            Dt(tt, At);
        else if (yt.tag !== 4) {
          if (yt.tag === 22 && yt.memoizedState !== null)
            (At = yt.child),
              At !== null && (At.return = yt),
              mo(tt, yt, !0, !0);
          else if (yt.child !== null) {
            (yt.child.return = yt), (yt = yt.child);
            continue;
          }
        }
        if (yt === nt) break;
        for (; yt.sibling === null; ) {
          if (yt.return === null || yt.return === nt) return;
          yt = yt.return;
        }
        (yt.sibling.return = yt.return), (yt = yt.sibling);
      }
    };
    var Bp = function (tt, nt, ht, dt) {
      for (var yt = nt.child; yt !== null; ) {
        if (yt.tag === 5) {
          var At = yt.stateNode;
          ht && dt && (At = Cr(At, yt.type, yt.memoizedProps, yt)), rr(tt, At);
        } else if (yt.tag === 6)
          (At = yt.stateNode),
            ht && dt && (At = Tr(At, yt.memoizedProps, yt)),
            rr(tt, At);
        else if (yt.tag !== 4) {
          if (yt.tag === 22 && yt.memoizedState !== null)
            (At = yt.child),
              At !== null && (At.return = yt),
              Bp(tt, yt, !0, !0);
          else if (yt.child !== null) {
            (yt.child.return = yt), (yt = yt.child);
            continue;
          }
        }
        if (yt === nt) break;
        for (; yt.sibling === null; ) {
          if (yt.return === null || yt.return === nt) return;
          yt = yt.return;
        }
        (yt.sibling.return = yt.return), (yt = yt.sibling);
      }
    };
    (go = function (tt, nt) {
      var ht = nt.stateNode;
      if (!Rp(tt, nt)) {
        tt = ht.containerInfo;
        var dt = Yn(tt);
        Bp(dt, nt, !1, !1), (ht.pendingChildren = dt), fs(nt), pr(tt, dt);
      }
    }),
      (Yo = function (tt, nt, ht, dt, yt) {
        var At = tt.stateNode,
          Nt = tt.memoizedProps;
        if ((tt = Rp(tt, nt)) && Nt === dt) nt.stateNode = At;
        else {
          var jt = nt.stateNode,
            rn = us(Qr.current),
            Sn = null;
          Nt !== dt && (Sn = Pt(jt, ht, Nt, dt, yt, rn)),
            tt && Sn === null
              ? (nt.stateNode = At)
              : ((At = $n(At, Sn, ht, Nt, dt, nt, tt, jt)),
                Wt(At, ht, dt, yt, rn) && fs(nt),
                (nt.stateNode = At),
                tt ? fs(nt) : mo(At, nt, !1, !1));
        }
      }),
      (qo = function (tt, nt, ht, dt) {
        ht !== dt
          ? ((tt = us(Js.current)),
            (ht = us(Qr.current)),
            (nt.stateNode = Gt(dt, tt, ht, nt)),
            fs(nt))
          : (nt.stateNode = tt.stateNode);
      });
  } else (go = function () {}), (Yo = function () {}), (qo = function () {});
  function vo(tt, nt) {
    if (!gr)
      switch (tt.tailMode) {
        case "hidden":
          nt = tt.tail;
          for (var ht = null; nt !== null; )
            nt.alternate !== null && (ht = nt), (nt = nt.sibling);
          ht === null ? (tt.tail = null) : (ht.sibling = null);
          break;
        case "collapsed":
          ht = tt.tail;
          for (var dt = null; ht !== null; )
            ht.alternate !== null && (dt = ht), (ht = ht.sibling);
          dt === null
            ? nt || tt.tail === null
              ? (tt.tail = null)
              : (tt.tail.sibling = null)
            : (dt.sibling = null);
      }
  }
  function Dr(tt) {
    var nt = tt.alternate !== null && tt.alternate.child === tt.child,
      ht = 0,
      dt = 0;
    if (nt)
      for (var yt = tt.child; yt !== null; )
        (ht |= yt.lanes | yt.childLanes),
          (dt |= yt.subtreeFlags & 14680064),
          (dt |= yt.flags & 14680064),
          (yt.return = tt),
          (yt = yt.sibling);
    else
      for (yt = tt.child; yt !== null; )
        (ht |= yt.lanes | yt.childLanes),
          (dt |= yt.subtreeFlags),
          (dt |= yt.flags),
          (yt.return = tt),
          (yt = yt.sibling);
    return (tt.subtreeFlags |= dt), (tt.childLanes = ht), nt;
  }
  function jm(tt, nt, ht) {
    var dt = nt.pendingProps;
    switch ((eu(nt), nt.tag)) {
      case 2:
      case 16:
      case 15:
      case 0:
      case 11:
      case 7:
      case 8:
      case 12:
      case 9:
      case 14:
        return Dr(nt), null;
      case 1:
        return br(nt.type) && mr(), Dr(nt), null;
      case 3:
        return (
          (dt = nt.stateNode),
          Ys(),
          Gn(dr),
          Gn(Jn),
          au(),
          dt.pendingContext &&
            ((dt.context = dt.pendingContext), (dt.pendingContext = null)),
          (tt === null || tt.child === null) &&
            (oo(nt)
              ? fs(nt)
              : tt === null ||
                (tt.memoizedState.isDehydrated && !(nt.flags & 256)) ||
                ((nt.flags |= 1024), ss !== null && (Du(ss), (ss = null)))),
          go(tt, nt),
          Dr(nt),
          null
        );
      case 5:
        su(nt), (ht = us(Js.current));
        var yt = nt.type;
        if (tt !== null && nt.stateNode != null)
          Yo(tt, nt, yt, dt, ht),
            tt.ref !== nt.ref && ((nt.flags |= 512), (nt.flags |= 2097152));
        else {
          if (!dt) {
            if (nt.stateNode === null) throw Error(g(166));
            return Dr(nt), null;
          }
          if (((tt = us(Qr.current)), oo(nt))) {
            if (!qt) throw Error(g(175));
            (tt = Fl(nt.stateNode, nt.type, nt.memoizedProps, ht, tt, nt, !so)),
              (nt.updateQueue = tt),
              tt !== null && fs(nt);
          } else {
            var At = Tt(yt, dt, ht, tt, nt);
            mo(At, nt, !1, !1),
              (nt.stateNode = At),
              Wt(At, yt, dt, ht, tt) && fs(nt);
          }
          nt.ref !== null && ((nt.flags |= 512), (nt.flags |= 2097152));
        }
        return Dr(nt), null;
      case 6:
        if (tt && nt.stateNode != null) qo(tt, nt, tt.memoizedProps, dt);
        else {
          if (typeof dt != "string" && nt.stateNode === null)
            throw Error(g(166));
          if (((tt = us(Js.current)), (ht = us(Qr.current)), oo(nt))) {
            if (!qt) throw Error(g(176));
            if (
              ((tt = nt.stateNode),
              (dt = nt.memoizedProps),
              (ht = Dl(tt, dt, nt, !so)) && ((yt = Wr), yt !== null))
            )
              switch (((At = (yt.mode & 1) !== 0), yt.tag)) {
                case 3:
                  Fn(yt.stateNode.containerInfo, tt, dt, At);
                  break;
                case 5:
                  On(yt.type, yt.memoizedProps, yt.stateNode, tt, dt, At);
              }
            ht && fs(nt);
          } else nt.stateNode = Gt(dt, tt, ht, nt);
        }
        return Dr(nt), null;
      case 13:
        if (
          (Gn(vr),
          (dt = nt.memoizedState),
          gr && $r !== null && nt.mode & 1 && !(nt.flags & 128))
        ) {
          for (tt = $r; tt; ) tt = _s(tt);
          return Xs(), (nt.flags |= 98560), nt;
        }
        if (dt !== null && dt.dehydrated !== null) {
          if (((dt = oo(nt)), tt === null)) {
            if (!dt) throw Error(g(318));
            if (!qt) throw Error(g(344));
            if (
              ((tt = nt.memoizedState),
              (tt = tt !== null ? tt.dehydrated : null),
              !tt)
            )
              throw Error(g(317));
            Nl(tt, nt);
          } else
            Xs(),
              !(nt.flags & 128) && (nt.memoizedState = null),
              (nt.flags |= 4);
          return Dr(nt), null;
        }
        return (
          ss !== null && (Du(ss), (ss = null)),
          nt.flags & 128
            ? ((nt.lanes = ht), nt)
            : ((dt = dt !== null),
              (ht = !1),
              tt === null ? oo(nt) : (ht = tt.memoizedState !== null),
              dt &&
                !ht &&
                ((nt.child.flags |= 8192),
                nt.mode & 1 &&
                  (tt === null || vr.current & 1
                    ? Mr === 0 && (Mr = 3)
                    : Ou())),
              nt.updateQueue !== null && (nt.flags |= 4),
              Dr(nt),
              null)
        );
      case 4:
        return (
          Ys(),
          go(tt, nt),
          tt === null && yn(nt.stateNode.containerInfo),
          Dr(nt),
          null
        );
      case 10:
        return Kl(nt.type._context), Dr(nt), null;
      case 17:
        return br(nt.type) && mr(), Dr(nt), null;
      case 19:
        if ((Gn(vr), (yt = nt.memoizedState), yt === null)) return Dr(nt), null;
        if (((dt = (nt.flags & 128) !== 0), (At = yt.rendering), At === null))
          if (dt) vo(yt, !1);
          else {
            if (Mr !== 0 || (tt !== null && tt.flags & 128))
              for (tt = nt.child; tt !== null; ) {
                if (((At = jo(tt)), At !== null)) {
                  for (
                    nt.flags |= 128,
                      vo(yt, !1),
                      tt = At.updateQueue,
                      tt !== null && ((nt.updateQueue = tt), (nt.flags |= 4)),
                      nt.subtreeFlags = 0,
                      tt = ht,
                      dt = nt.child;
                    dt !== null;

                  )
                    (ht = dt),
                      (yt = tt),
                      (ht.flags &= 14680066),
                      (At = ht.alternate),
                      At === null
                        ? ((ht.childLanes = 0),
                          (ht.lanes = yt),
                          (ht.child = null),
                          (ht.subtreeFlags = 0),
                          (ht.memoizedProps = null),
                          (ht.memoizedState = null),
                          (ht.updateQueue = null),
                          (ht.dependencies = null),
                          (ht.stateNode = null))
                        : ((ht.childLanes = At.childLanes),
                          (ht.lanes = At.lanes),
                          (ht.child = At.child),
                          (ht.subtreeFlags = 0),
                          (ht.deletions = null),
                          (ht.memoizedProps = At.memoizedProps),
                          (ht.memoizedState = At.memoizedState),
                          (ht.updateQueue = At.updateQueue),
                          (ht.type = At.type),
                          (yt = At.dependencies),
                          (ht.dependencies =
                            yt === null
                              ? null
                              : {
                                  lanes: yt.lanes,
                                  firstContext: yt.firstContext,
                                })),
                      (dt = dt.sibling);
                  return Cn(vr, (vr.current & 1) | 2), nt.child;
                }
                tt = tt.sibling;
              }
            yt.tail !== null &&
              wr() > Iu &&
              ((nt.flags |= 128), (dt = !0), vo(yt, !1), (nt.lanes = 4194304));
          }
        else {
          if (!dt)
            if (((tt = jo(At)), tt !== null)) {
              if (
                ((nt.flags |= 128),
                (dt = !0),
                (tt = tt.updateQueue),
                tt !== null && ((nt.updateQueue = tt), (nt.flags |= 4)),
                vo(yt, !0),
                yt.tail === null &&
                  yt.tailMode === "hidden" &&
                  !At.alternate &&
                  !gr)
              )
                return Dr(nt), null;
            } else
              2 * wr() - yt.renderingStartTime > Iu &&
                ht !== 1073741824 &&
                ((nt.flags |= 128),
                (dt = !0),
                vo(yt, !1),
                (nt.lanes = 4194304));
          yt.isBackwards
            ? ((At.sibling = nt.child), (nt.child = At))
            : ((tt = yt.last),
              tt !== null ? (tt.sibling = At) : (nt.child = At),
              (yt.last = At));
        }
        return yt.tail !== null
          ? ((nt = yt.tail),
            (yt.rendering = nt),
            (yt.tail = nt.sibling),
            (yt.renderingStartTime = wr()),
            (nt.sibling = null),
            (tt = vr.current),
            Cn(vr, dt ? (tt & 1) | 2 : tt & 1),
            nt)
          : (Dr(nt), null);
      case 22:
      case 23:
        return (
          Nu(),
          (dt = nt.memoizedState !== null),
          tt !== null &&
            (tt.memoizedState !== null) !== dt &&
            (nt.flags |= 8192),
          dt && nt.mode & 1
            ? Kr & 1073741824 &&
              (Dr(nt), pn && nt.subtreeFlags & 6 && (nt.flags |= 8192))
            : Dr(nt),
          null
        );
      case 24:
        return null;
      case 25:
        return null;
    }
    throw Error(g(156, nt.tag));
  }
  var zm = _.ReactCurrentOwner,
    Xr = !1;
  function Or(tt, nt, ht, dt) {
    nt.child = tt === null ? rp(nt, null, ht, dt) : Ks(nt, tt.child, ht, dt);
  }
  function Ip(tt, nt, ht, dt, yt) {
    ht = ht.render;
    var At = nt.ref;
    return (
      Hs(nt, yt),
      (dt = cu(tt, nt, ht, dt, At, yt)),
      (ht = uu()),
      tt !== null && !Xr
        ? ((nt.updateQueue = tt.updateQueue),
          (nt.flags &= -2053),
          (tt.lanes &= ~yt),
          xs(tt, nt, yt))
        : (gr && ht && _c(nt), (nt.flags |= 1), Or(tt, nt, dt, yt), nt.child)
    );
  }
  function Lp(tt, nt, ht, dt, yt) {
    if (tt === null) {
      var At = ht.type;
      return typeof At == "function" &&
        !Uu(At) &&
        At.defaultProps === void 0 &&
        ht.compare === null &&
        ht.defaultProps === void 0
        ? ((nt.tag = 15), (nt.type = At), Fp(tt, nt, At, dt, yt))
        : ((tt = Il(ht.type, null, dt, nt, nt.mode, yt)),
          (tt.ref = nt.ref),
          (tt.return = nt),
          (nt.child = tt));
    }
    if (((At = tt.child), !(tt.lanes & yt))) {
      var Nt = At.memoizedProps;
      if (
        ((ht = ht.compare),
        (ht = ht !== null ? ht : Lo),
        ht(Nt, dt) && tt.ref === nt.ref)
      )
        return xs(tt, nt, yt);
    }
    return (
      (nt.flags |= 1),
      (tt = bs(At, dt)),
      (tt.ref = nt.ref),
      (tt.return = nt),
      (nt.child = tt)
    );
  }
  function Fp(tt, nt, ht, dt, yt) {
    if (tt !== null && Lo(tt.memoizedProps, dt) && tt.ref === nt.ref)
      if (((Xr = !1), (tt.lanes & yt) !== 0)) tt.flags & 131072 && (Xr = !0);
      else return (nt.lanes = tt.lanes), xs(tt, nt, yt);
    return gu(tt, nt, ht, dt, yt);
  }
  function kp(tt, nt, ht) {
    var dt = nt.pendingProps,
      yt = dt.children,
      At = tt !== null ? tt.memoizedState : null;
    if (dt.mode === "hidden")
      if (!(nt.mode & 1))
        (nt.memoizedState = { baseLanes: 0, cachePool: null }),
          Cn(Qs, Kr),
          (Kr |= ht);
      else if (ht & 1073741824)
        (nt.memoizedState = { baseLanes: 0, cachePool: null }),
          (dt = At !== null ? At.baseLanes : ht),
          Cn(Qs, Kr),
          (Kr |= dt);
      else
        return (
          (tt = At !== null ? At.baseLanes | ht : ht),
          (nt.lanes = nt.childLanes = 1073741824),
          (nt.memoizedState = { baseLanes: tt, cachePool: null }),
          (nt.updateQueue = null),
          Cn(Qs, Kr),
          (Kr |= tt),
          null
        );
    else
      At !== null
        ? ((dt = At.baseLanes | ht), (nt.memoizedState = null))
        : (dt = ht),
        Cn(Qs, Kr),
        (Kr |= dt);
    return Or(tt, nt, yt, ht), nt.child;
  }
  function Dp(tt, nt) {
    var ht = nt.ref;
    ((tt === null && ht !== null) || (tt !== null && tt.ref !== ht)) &&
      ((nt.flags |= 512), (nt.flags |= 2097152));
  }
  function gu(tt, nt, ht, dt, yt) {
    var At = br(ht) ? Vr : Jn.current;
    return (
      (At = Sr(nt, At)),
      Hs(nt, yt),
      (ht = cu(tt, nt, ht, dt, At, yt)),
      (dt = uu()),
      tt !== null && !Xr
        ? ((nt.updateQueue = tt.updateQueue),
          (nt.flags &= -2053),
          (tt.lanes &= ~yt),
          xs(tt, nt, yt))
        : (gr && dt && _c(nt), (nt.flags |= 1), Or(tt, nt, ht, yt), nt.child)
    );
  }
  function Np(tt, nt, ht, dt, yt) {
    if (br(ht)) {
      var At = !0;
      Br(nt);
    } else At = !1;
    if ((Hs(nt, yt), nt.stateNode === null))
      tt !== null &&
        ((tt.alternate = null), (nt.alternate = null), (nt.flags |= 2)),
        Qu(nt, ht, dt),
        Zl(nt, ht, dt, yt),
        (dt = !0);
    else if (tt === null) {
      var Nt = nt.stateNode,
        jt = nt.memoizedProps;
      Nt.props = jt;
      var rn = Nt.context,
        Sn = ht.contextType;
      typeof Sn == "object" && Sn !== null
        ? (Sn = Jr(Sn))
        : ((Sn = br(ht) ? Vr : Jn.current), (Sn = Sr(nt, Sn)));
      var Dn = ht.getDerivedStateFromProps,
        Qn =
          typeof Dn == "function" ||
          typeof Nt.getSnapshotBeforeUpdate == "function";
      Qn ||
        (typeof Nt.UNSAFE_componentWillReceiveProps != "function" &&
          typeof Nt.componentWillReceiveProps != "function") ||
        ((jt !== dt || rn !== Sn) && Zu(nt, Nt, dt, Sn)),
        (Ss = !1);
      var Xn = nt.memoizedState;
      (Nt.state = Xn),
        No(nt, dt, Nt, yt),
        (rn = nt.memoizedState),
        jt !== dt || Xn !== rn || dr.current || Ss
          ? (typeof Dn == "function" &&
              (Ql(nt, ht, Dn, dt), (rn = nt.memoizedState)),
            (jt = Ss || qu(nt, ht, jt, dt, Xn, rn, Sn))
              ? (Qn ||
                  (typeof Nt.UNSAFE_componentWillMount != "function" &&
                    typeof Nt.componentWillMount != "function") ||
                  (typeof Nt.componentWillMount == "function" &&
                    Nt.componentWillMount(),
                  typeof Nt.UNSAFE_componentWillMount == "function" &&
                    Nt.UNSAFE_componentWillMount()),
                typeof Nt.componentDidMount == "function" &&
                  (nt.flags |= 4194308))
              : (typeof Nt.componentDidMount == "function" &&
                  (nt.flags |= 4194308),
                (nt.memoizedProps = dt),
                (nt.memoizedState = rn)),
            (Nt.props = dt),
            (Nt.state = rn),
            (Nt.context = Sn),
            (dt = jt))
          : (typeof Nt.componentDidMount == "function" && (nt.flags |= 4194308),
            (dt = !1));
    } else {
      (Nt = nt.stateNode),
        Xu(tt, nt),
        (jt = nt.memoizedProps),
        (Sn = nt.type === nt.elementType ? jt : rs(nt.type, jt)),
        (Nt.props = Sn),
        (Qn = nt.pendingProps),
        (Xn = Nt.context),
        (rn = ht.contextType),
        typeof rn == "object" && rn !== null
          ? (rn = Jr(rn))
          : ((rn = br(ht) ? Vr : Jn.current), (rn = Sr(nt, rn)));
      var cr = ht.getDerivedStateFromProps;
      (Dn =
        typeof cr == "function" ||
        typeof Nt.getSnapshotBeforeUpdate == "function") ||
        (typeof Nt.UNSAFE_componentWillReceiveProps != "function" &&
          typeof Nt.componentWillReceiveProps != "function") ||
        ((jt !== Qn || Xn !== rn) && Zu(nt, Nt, dt, rn)),
        (Ss = !1),
        (Xn = nt.memoizedState),
        (Nt.state = Xn),
        No(nt, dt, Nt, yt);
      var Vn = nt.memoizedState;
      jt !== Qn || Xn !== Vn || dr.current || Ss
        ? (typeof cr == "function" &&
            (Ql(nt, ht, cr, dt), (Vn = nt.memoizedState)),
          (Sn = Ss || qu(nt, ht, Sn, dt, Xn, Vn, rn) || !1)
            ? (Dn ||
                (typeof Nt.UNSAFE_componentWillUpdate != "function" &&
                  typeof Nt.componentWillUpdate != "function") ||
                (typeof Nt.componentWillUpdate == "function" &&
                  Nt.componentWillUpdate(dt, Vn, rn),
                typeof Nt.UNSAFE_componentWillUpdate == "function" &&
                  Nt.UNSAFE_componentWillUpdate(dt, Vn, rn)),
              typeof Nt.componentDidUpdate == "function" && (nt.flags |= 4),
              typeof Nt.getSnapshotBeforeUpdate == "function" &&
                (nt.flags |= 1024))
            : (typeof Nt.componentDidUpdate != "function" ||
                (jt === tt.memoizedProps && Xn === tt.memoizedState) ||
                (nt.flags |= 4),
              typeof Nt.getSnapshotBeforeUpdate != "function" ||
                (jt === tt.memoizedProps && Xn === tt.memoizedState) ||
                (nt.flags |= 1024),
              (nt.memoizedProps = dt),
              (nt.memoizedState = Vn)),
          (Nt.props = dt),
          (Nt.state = Vn),
          (Nt.context = rn),
          (dt = Sn))
        : (typeof Nt.componentDidUpdate != "function" ||
            (jt === tt.memoizedProps && Xn === tt.memoizedState) ||
            (nt.flags |= 4),
          typeof Nt.getSnapshotBeforeUpdate != "function" ||
            (jt === tt.memoizedProps && Xn === tt.memoizedState) ||
            (nt.flags |= 1024),
          (dt = !1));
    }
    return vu(tt, nt, ht, dt, At, yt);
  }
  function vu(tt, nt, ht, dt, yt, At) {
    Dp(tt, nt);
    var Nt = (nt.flags & 128) !== 0;
    if (!dt && !Nt) return yt && js(nt, ht, !1), xs(tt, nt, At);
    (dt = nt.stateNode), (zm.current = nt);
    var jt =
      Nt && typeof ht.getDerivedStateFromError != "function"
        ? null
        : dt.render();
    return (
      (nt.flags |= 1),
      tt !== null && Nt
        ? ((nt.child = Ks(nt, tt.child, null, At)),
          (nt.child = Ks(nt, null, jt, At)))
        : Or(tt, nt, jt, At),
      (nt.memoizedState = dt.state),
      yt && js(nt, ht, !0),
      nt.child
    );
  }
  function Op(tt) {
    var nt = tt.stateNode;
    nt.pendingContext
      ? ns(tt, nt.pendingContext, nt.pendingContext !== nt.context)
      : nt.context && ns(tt, nt.context, !1),
      iu(tt, nt.containerInfo);
  }
  function Up(tt, nt, ht, dt, yt) {
    return Xs(), ru(yt), (nt.flags |= 256), Or(tt, nt, ht, dt), nt.child;
  }
  var Qo = { dehydrated: null, treeContext: null, retryLane: 0 };
  function Zo(tt) {
    return { baseLanes: tt, cachePool: null };
  }
  function Vp(tt, nt, ht) {
    var dt = nt.pendingProps,
      yt = vr.current,
      At = !1,
      Nt = (nt.flags & 128) !== 0,
      jt;
    if (
      ((jt = Nt) ||
        (jt = tt !== null && tt.memoizedState === null ? !1 : (yt & 2) !== 0),
      jt
        ? ((At = !0), (nt.flags &= -129))
        : (tt === null || tt.memoizedState !== null) && (yt |= 1),
      Cn(vr, yt & 1),
      tt === null)
    )
      return (
        nu(nt),
        (tt = nt.memoizedState),
        tt !== null && ((tt = tt.dehydrated), tt !== null)
          ? (nt.mode & 1
              ? Os(tt)
                ? (nt.lanes = 8)
                : (nt.lanes = 1073741824)
              : (nt.lanes = 1),
            null)
          : ((yt = dt.children),
            (tt = dt.fallback),
            At
              ? ((dt = nt.mode),
                (At = nt.child),
                (yt = { mode: "hidden", children: yt }),
                !(dt & 1) && At !== null
                  ? ((At.childLanes = 0), (At.pendingProps = yt))
                  : (At = Ll(yt, dt, 0, null)),
                (tt = Ns(tt, dt, ht, null)),
                (At.return = nt),
                (tt.return = nt),
                (At.sibling = tt),
                (nt.child = At),
                (nt.child.memoizedState = Zo(ht)),
                (nt.memoizedState = Qo),
                tt)
              : yu(nt, yt))
      );
    if (((yt = tt.memoizedState), yt !== null)) {
      if (((jt = yt.dehydrated), jt !== null)) {
        if (Nt)
          return nt.flags & 256
            ? ((nt.flags &= -257), na(tt, nt, ht, Error(g(422))))
            : nt.memoizedState !== null
            ? ((nt.child = tt.child), (nt.flags |= 128), null)
            : ((At = dt.fallback),
              (yt = nt.mode),
              (dt = Ll(
                { mode: "visible", children: dt.children },
                yt,
                0,
                null
              )),
              (At = Ns(At, yt, ht, null)),
              (At.flags |= 2),
              (dt.return = nt),
              (At.return = nt),
              (dt.sibling = At),
              (nt.child = dt),
              nt.mode & 1 && Ks(nt, tt.child, null, ht),
              (nt.child.memoizedState = Zo(ht)),
              (nt.memoizedState = Qo),
              At);
        if (!(nt.mode & 1)) nt = na(tt, nt, ht, null);
        else if (Os(jt)) nt = na(tt, nt, ht, Error(g(419)));
        else if (((dt = (ht & tt.childLanes) !== 0), Xr || dt)) {
          if (((dt = Er), dt !== null)) {
            switch (ht & -ht) {
              case 4:
                At = 2;
                break;
              case 16:
                At = 8;
                break;
              case 64:
              case 128:
              case 256:
              case 512:
              case 1024:
              case 2048:
              case 4096:
              case 8192:
              case 16384:
              case 32768:
              case 65536:
              case 131072:
              case 262144:
              case 524288:
              case 1048576:
              case 2097152:
              case 4194304:
              case 8388608:
              case 16777216:
              case 33554432:
              case 67108864:
                At = 32;
                break;
              case 536870912:
                At = 268435456;
                break;
              default:
                At = 0;
            }
            (dt = At & (dt.suspendedLanes | ht) ? 0 : At),
              dt !== 0 &&
                dt !== yt.retryLane &&
                ((yt.retryLane = dt), _i(tt, dt, -1));
          }
          Ou(), (nt = na(tt, nt, ht, Error(g(421))));
        } else
          no(jt)
            ? ((nt.flags |= 128),
              (nt.child = tt.child),
              (nt = n0.bind(null, tt)),
              Us(jt, nt),
              (nt = null))
            : ((ht = yt.treeContext),
              qt &&
                (($r = Co(jt)),
                (Wr = nt),
                (gr = !0),
                (ss = null),
                (so = !1),
                ht !== null &&
                  ((Yr[qr++] = gs),
                  (Yr[qr++] = vs),
                  (Yr[qr++] = Ps),
                  (gs = ht.id),
                  (vs = ht.overflow),
                  (Ps = nt))),
              (nt = yu(nt, nt.pendingProps.children)),
              (nt.flags |= 4096));
        return nt;
      }
      return At
        ? ((dt = jp(tt, nt, dt.children, dt.fallback, ht)),
          (At = nt.child),
          (yt = tt.child.memoizedState),
          (At.memoizedState =
            yt === null
              ? Zo(ht)
              : { baseLanes: yt.baseLanes | ht, cachePool: null }),
          (At.childLanes = tt.childLanes & ~ht),
          (nt.memoizedState = Qo),
          dt)
        : ((ht = Gp(tt, nt, dt.children, ht)), (nt.memoizedState = null), ht);
    }
    return At
      ? ((dt = jp(tt, nt, dt.children, dt.fallback, ht)),
        (At = nt.child),
        (yt = tt.child.memoizedState),
        (At.memoizedState =
          yt === null
            ? Zo(ht)
            : { baseLanes: yt.baseLanes | ht, cachePool: null }),
        (At.childLanes = tt.childLanes & ~ht),
        (nt.memoizedState = Qo),
        dt)
      : ((ht = Gp(tt, nt, dt.children, ht)), (nt.memoizedState = null), ht);
  }
  function yu(tt, nt) {
    return (
      (nt = Ll({ mode: "visible", children: nt }, tt.mode, 0, null)),
      (nt.return = tt),
      (tt.child = nt)
    );
  }
  function Gp(tt, nt, ht, dt) {
    var yt = tt.child;
    return (
      (tt = yt.sibling),
      (ht = bs(yt, { mode: "visible", children: ht })),
      !(nt.mode & 1) && (ht.lanes = dt),
      (ht.return = nt),
      (ht.sibling = null),
      tt !== null &&
        ((dt = nt.deletions),
        dt === null ? ((nt.deletions = [tt]), (nt.flags |= 16)) : dt.push(tt)),
      (nt.child = ht)
    );
  }
  function jp(tt, nt, ht, dt, yt) {
    var At = nt.mode;
    tt = tt.child;
    var Nt = tt.sibling,
      jt = { mode: "hidden", children: ht };
    return (
      !(At & 1) && nt.child !== tt
        ? ((ht = nt.child),
          (ht.childLanes = 0),
          (ht.pendingProps = jt),
          (nt.deletions = null))
        : ((ht = bs(tt, jt)), (ht.subtreeFlags = tt.subtreeFlags & 14680064)),
      Nt !== null
        ? (dt = bs(Nt, dt))
        : ((dt = Ns(dt, At, yt, null)), (dt.flags |= 2)),
      (dt.return = nt),
      (ht.return = nt),
      (ht.sibling = dt),
      (nt.child = ht),
      dt
    );
  }
  function na(tt, nt, ht, dt) {
    return (
      dt !== null && ru(dt),
      Ks(nt, tt.child, null, ht),
      (tt = yu(nt, nt.pendingProps.children)),
      (tt.flags |= 2),
      (nt.memoizedState = null),
      tt
    );
  }
  function zp(tt, nt, ht) {
    tt.lanes |= nt;
    var dt = tt.alternate;
    dt !== null && (dt.lanes |= nt), Jl(tt.return, nt, ht);
  }
  function xu(tt, nt, ht, dt, yt) {
    var At = tt.memoizedState;
    At === null
      ? (tt.memoizedState = {
          isBackwards: nt,
          rendering: null,
          renderingStartTime: 0,
          last: dt,
          tail: ht,
          tailMode: yt,
        })
      : ((At.isBackwards = nt),
        (At.rendering = null),
        (At.renderingStartTime = 0),
        (At.last = dt),
        (At.tail = ht),
        (At.tailMode = yt));
  }
  function Hp(tt, nt, ht) {
    var dt = nt.pendingProps,
      yt = dt.revealOrder,
      At = dt.tail;
    if ((Or(tt, nt, dt.children, ht), (dt = vr.current), dt & 2))
      (dt = (dt & 1) | 2), (nt.flags |= 128);
    else {
      if (tt !== null && tt.flags & 128)
        e: for (tt = nt.child; tt !== null; ) {
          if (tt.tag === 13) tt.memoizedState !== null && zp(tt, ht, nt);
          else if (tt.tag === 19) zp(tt, ht, nt);
          else if (tt.child !== null) {
            (tt.child.return = tt), (tt = tt.child);
            continue;
          }
          if (tt === nt) break e;
          for (; tt.sibling === null; ) {
            if (tt.return === null || tt.return === nt) break e;
            tt = tt.return;
          }
          (tt.sibling.return = tt.return), (tt = tt.sibling);
        }
      dt &= 1;
    }
    if ((Cn(vr, dt), !(nt.mode & 1))) nt.memoizedState = null;
    else
      switch (yt) {
        case "forwards":
          for (ht = nt.child, yt = null; ht !== null; )
            (tt = ht.alternate),
              tt !== null && jo(tt) === null && (yt = ht),
              (ht = ht.sibling);
          (ht = yt),
            ht === null
              ? ((yt = nt.child), (nt.child = null))
              : ((yt = ht.sibling), (ht.sibling = null)),
            xu(nt, !1, yt, ht, At);
          break;
        case "backwards":
          for (ht = null, yt = nt.child, nt.child = null; yt !== null; ) {
            if (((tt = yt.alternate), tt !== null && jo(tt) === null)) {
              nt.child = yt;
              break;
            }
            (tt = yt.sibling), (yt.sibling = ht), (ht = yt), (yt = tt);
          }
          xu(nt, !0, ht, null, At);
          break;
        case "together":
          xu(nt, !1, null, null, void 0);
          break;
        default:
          nt.memoizedState = null;
      }
    return nt.child;
  }
  function xs(tt, nt, ht) {
    if (
      (tt !== null && (nt.dependencies = tt.dependencies),
      (Zs |= nt.lanes),
      !(ht & nt.childLanes))
    )
      return null;
    if (tt !== null && nt.child !== tt.child) throw Error(g(153));
    if (nt.child !== null) {
      for (
        tt = nt.child,
          ht = bs(tt, tt.pendingProps),
          nt.child = ht,
          ht.return = nt;
        tt.sibling !== null;

      )
        (tt = tt.sibling),
          (ht = ht.sibling = bs(tt, tt.pendingProps)),
          (ht.return = nt);
      ht.sibling = null;
    }
    return nt.child;
  }
  function Hm(tt, nt, ht) {
    switch (nt.tag) {
      case 3:
        Op(nt), Xs();
        break;
      case 5:
        sp(nt);
        break;
      case 1:
        br(nt.type) && Br(nt);
        break;
      case 4:
        iu(nt, nt.stateNode.containerInfo);
        break;
      case 10:
        $u(nt, nt.type._context, nt.memoizedProps.value);
        break;
      case 13:
        var dt = nt.memoizedState;
        if (dt !== null)
          return dt.dehydrated !== null
            ? (Cn(vr, vr.current & 1), (nt.flags |= 128), null)
            : ht & nt.child.childLanes
            ? Vp(tt, nt, ht)
            : (Cn(vr, vr.current & 1),
              (tt = xs(tt, nt, ht)),
              tt !== null ? tt.sibling : null);
        Cn(vr, vr.current & 1);
        break;
      case 19:
        if (((dt = (ht & nt.childLanes) !== 0), tt.flags & 128)) {
          if (dt) return Hp(tt, nt, ht);
          nt.flags |= 128;
        }
        var yt = nt.memoizedState;
        if (
          (yt !== null &&
            ((yt.rendering = null), (yt.tail = null), (yt.lastEffect = null)),
          Cn(vr, vr.current),
          dt)
        )
          break;
        return null;
      case 22:
      case 23:
        return (nt.lanes = 0), kp(tt, nt, ht);
    }
    return xs(tt, nt, ht);
  }
  function Wm(tt, nt) {
    switch ((eu(nt), nt.tag)) {
      case 1:
        return (
          br(nt.type) && mr(),
          (tt = nt.flags),
          tt & 65536 ? ((nt.flags = (tt & -65537) | 128), nt) : null
        );
      case 3:
        return (
          Ys(),
          Gn(dr),
          Gn(Jn),
          au(),
          (tt = nt.flags),
          tt & 65536 && !(tt & 128)
            ? ((nt.flags = (tt & -65537) | 128), nt)
            : null
        );
      case 5:
        return su(nt), null;
      case 13:
        if (
          (Gn(vr),
          (tt = nt.memoizedState),
          tt !== null && tt.dehydrated !== null)
        ) {
          if (nt.alternate === null) throw Error(g(340));
          Xs();
        }
        return (
          (tt = nt.flags),
          tt & 65536 ? ((nt.flags = (tt & -65537) | 128), nt) : null
        );
      case 19:
        return Gn(vr), null;
      case 4:
        return Ys(), null;
      case 10:
        return Kl(nt.type._context), null;
      case 22:
      case 23:
        return Nu(), null;
      case 24:
        return null;
      default:
        return null;
    }
  }
  var ga = !1,
    Is = !1,
    $m = typeof WeakSet == "function" ? WeakSet : Set,
    Bn = null;
  function xa(tt, nt) {
    var ht = tt.ref;
    if (ht !== null)
      if (typeof ht == "function")
        try {
          ht(null);
        } catch (dt) {
          zr(tt, nt, dt);
        }
      else ht.current = null;
  }
  function _u(tt, nt, ht) {
    try {
      ht();
    } catch (dt) {
      zr(tt, nt, dt);
    }
  }
  var Wp = !1;
  function Xm(tt, nt) {
    for (vt(tt.containerInfo), Bn = nt; Bn !== null; )
      if (
        ((tt = Bn),
        (nt = tt.child),
        (tt.subtreeFlags & 1028) !== 0 && nt !== null)
      )
        (nt.return = tt), (Bn = nt);
      else
        for (; Bn !== null; ) {
          tt = Bn;
          try {
            var ht = tt.alternate;
            if (tt.flags & 1024)
              switch (tt.tag) {
                case 0:
                case 11:
                case 15:
                  break;
                case 1:
                  if (ht !== null) {
                    var dt = ht.memoizedProps,
                      yt = ht.memoizedState,
                      At = tt.stateNode,
                      Nt = At.getSnapshotBeforeUpdate(
                        tt.elementType === tt.type ? dt : rs(tt.type, dt),
                        yt
                      );
                    At.__reactInternalSnapshotBeforeUpdate = Nt;
                  }
                  break;
                case 3:
                  pn && Mn(tt.stateNode.containerInfo);
                  break;
                case 5:
                case 6:
                case 4:
                case 17:
                  break;
                default:
                  throw Error(g(163));
              }
          } catch (jt) {
            zr(tt, tt.return, jt);
          }
          if (((nt = tt.sibling), nt !== null)) {
            (nt.return = tt.return), (Bn = nt);
            break;
          }
          Bn = tt.return;
        }
    return (ht = Wp), (Wp = !1), ht;
  }
  function Ls(tt, nt, ht) {
    var dt = nt.updateQueue;
    if (((dt = dt !== null ? dt.lastEffect : null), dt !== null)) {
      var yt = (dt = dt.next);
      do {
        if ((yt.tag & tt) === tt) {
          var At = yt.destroy;
          (yt.destroy = void 0), At !== void 0 && _u(nt, ht, At);
        }
        yt = yt.next;
      } while (yt !== dt);
    }
  }
  function yo(tt, nt) {
    if (
      ((nt = nt.updateQueue),
      (nt = nt !== null ? nt.lastEffect : null),
      nt !== null)
    ) {
      var ht = (nt = nt.next);
      do {
        if ((ht.tag & tt) === tt) {
          var dt = ht.create;
          ht.destroy = dt();
        }
        ht = ht.next;
      } while (ht !== nt);
    }
  }
  function Su(tt) {
    var nt = tt.ref;
    if (nt !== null) {
      var ht = tt.stateNode;
      switch (tt.tag) {
        case 5:
          tt = Et(ht);
          break;
        default:
          tt = ht;
      }
      typeof nt == "function" ? nt(tt) : (nt.current = tt);
    }
  }
  function $p(tt, nt, ht) {
    if (os && typeof os.onCommitFiberUnmount == "function")
      try {
        os.onCommitFiberUnmount(Bo, nt);
      } catch {}
    switch (nt.tag) {
      case 0:
      case 11:
      case 14:
      case 15:
        if (
          ((tt = nt.updateQueue),
          tt !== null && ((tt = tt.lastEffect), tt !== null))
        ) {
          var dt = (tt = tt.next);
          do {
            var yt = dt,
              At = yt.destroy;
            (yt = yt.tag),
              At !== void 0 && (yt & 2 || yt & 4) && _u(nt, ht, At),
              (dt = dt.next);
          } while (dt !== tt);
        }
        break;
      case 1:
        if (
          (xa(nt, ht),
          (tt = nt.stateNode),
          typeof tt.componentWillUnmount == "function")
        )
          try {
            (tt.props = nt.memoizedProps),
              (tt.state = nt.memoizedState),
              tt.componentWillUnmount();
          } catch (Nt) {
            zr(nt, ht, Nt);
          }
        break;
      case 5:
        xa(nt, ht);
        break;
      case 4:
        pn
          ? Qp(tt, nt, ht)
          : Bt &&
            Bt &&
            ((nt = nt.stateNode.containerInfo), (ht = Yn(nt)), tr(nt, ht));
    }
  }
  function Xp(tt, nt, ht) {
    for (var dt = nt; ; )
      if (($p(tt, dt, ht), dt.child === null || (pn && dt.tag === 4))) {
        if (dt === nt) break;
        for (; dt.sibling === null; ) {
          if (dt.return === null || dt.return === nt) return;
          dt = dt.return;
        }
        (dt.sibling.return = dt.return), (dt = dt.sibling);
      } else (dt.child.return = dt), (dt = dt.child);
  }
  function Kp(tt) {
    var nt = tt.alternate;
    nt !== null && ((tt.alternate = null), Kp(nt)),
      (tt.child = null),
      (tt.deletions = null),
      (tt.sibling = null),
      tt.tag === 5 && ((nt = tt.stateNode), nt !== null && Pn(nt)),
      (tt.stateNode = null),
      (tt.return = null),
      (tt.dependencies = null),
      (tt.memoizedProps = null),
      (tt.memoizedState = null),
      (tt.pendingProps = null),
      (tt.stateNode = null),
      (tt.updateQueue = null);
  }
  function Jp(tt) {
    return tt.tag === 5 || tt.tag === 3 || tt.tag === 4;
  }
  function Yp(tt) {
    e: for (;;) {
      for (; tt.sibling === null; ) {
        if (tt.return === null || Jp(tt.return)) return null;
        tt = tt.return;
      }
      for (
        tt.sibling.return = tt.return, tt = tt.sibling;
        tt.tag !== 5 && tt.tag !== 6 && tt.tag !== 18;

      ) {
        if (tt.flags & 2 || tt.child === null || tt.tag === 4) continue e;
        (tt.child.return = tt), (tt = tt.child);
      }
      if (!(tt.flags & 2)) return tt.stateNode;
    }
  }
  function qp(tt) {
    if (pn) {
      e: {
        for (var nt = tt.return; nt !== null; ) {
          if (Jp(nt)) break e;
          nt = nt.return;
        }
        throw Error(g(160));
      }
      var ht = nt;
      switch (ht.tag) {
        case 5:
          (nt = ht.stateNode),
            ht.flags & 32 && (In(nt), (ht.flags &= -33)),
            (ht = Yp(tt)),
            Au(tt, ht, nt);
          break;
        case 3:
        case 4:
          (nt = ht.stateNode.containerInfo), (ht = Yp(tt)), Eu(tt, ht, nt);
          break;
        default:
          throw Error(g(161));
      }
    }
  }
  function Eu(tt, nt, ht) {
    var dt = tt.tag;
    if (dt === 5 || dt === 6)
      (tt = tt.stateNode), nt ? kn(ht, tt, nt) : zn(ht, tt);
    else if (dt !== 4 && ((tt = tt.child), tt !== null))
      for (Eu(tt, nt, ht), tt = tt.sibling; tt !== null; )
        Eu(tt, nt, ht), (tt = tt.sibling);
  }
  function Au(tt, nt, ht) {
    var dt = tt.tag;
    if (dt === 5 || dt === 6)
      (tt = tt.stateNode), nt ? Wn(ht, tt, nt) : wn(ht, tt);
    else if (dt !== 4 && ((tt = tt.child), tt !== null))
      for (Au(tt, nt, ht), tt = tt.sibling; tt !== null; )
        Au(tt, nt, ht), (tt = tt.sibling);
  }
  function Qp(tt, nt, ht) {
    for (var dt = nt, yt = !1, At, Nt; ; ) {
      if (!yt) {
        yt = dt.return;
        e: for (;;) {
          if (yt === null) throw Error(g(160));
          switch (((At = yt.stateNode), yt.tag)) {
            case 5:
              Nt = !1;
              break e;
            case 3:
              (At = At.containerInfo), (Nt = !0);
              break e;
            case 4:
              (At = At.containerInfo), (Nt = !0);
              break e;
          }
          yt = yt.return;
        }
        yt = !0;
      }
      if (dt.tag === 5 || dt.tag === 6)
        Xp(tt, dt, ht), Nt ? un(At, dt.stateNode) : Vt(At, dt.stateNode);
      else if (dt.tag === 18) Nt ? Xt(At, dt.stateNode) : Zt(At, dt.stateNode);
      else if (dt.tag === 4) {
        if (dt.child !== null) {
          (At = dt.stateNode.containerInfo),
            (Nt = !0),
            (dt.child.return = dt),
            (dt = dt.child);
          continue;
        }
      } else if (($p(tt, dt, ht), dt.child !== null)) {
        (dt.child.return = dt), (dt = dt.child);
        continue;
      }
      if (dt === nt) break;
      for (; dt.sibling === null; ) {
        if (dt.return === null || dt.return === nt) return;
        (dt = dt.return), dt.tag === 4 && (yt = !1);
      }
      (dt.sibling.return = dt.return), (dt = dt.sibling);
    }
  }
  function Mu(tt, nt) {
    if (pn) {
      switch (nt.tag) {
        case 0:
        case 11:
        case 14:
        case 15:
          Ls(3, nt, nt.return), yo(3, nt), Ls(5, nt, nt.return);
          return;
        case 1:
          return;
        case 5:
          var ht = nt.stateNode;
          if (ht != null) {
            var dt = nt.memoizedProps;
            tt = tt !== null ? tt.memoizedProps : dt;
            var yt = nt.type,
              At = nt.updateQueue;
            (nt.updateQueue = null), At !== null && qn(ht, At, yt, tt, dt, nt);
          }
          return;
        case 6:
          if (nt.stateNode === null) throw Error(g(162));
          (ht = nt.memoizedProps),
            gn(nt.stateNode, tt !== null ? tt.memoizedProps : ht, ht);
          return;
        case 3:
          qt &&
            tt !== null &&
            tt.memoizedState.isDehydrated &&
            zt(nt.stateNode.containerInfo);
          return;
        case 12:
          return;
        case 13:
          ba(nt);
          return;
        case 19:
          ba(nt);
          return;
        case 17:
          return;
      }
      throw Error(g(163));
    }
    switch (nt.tag) {
      case 0:
      case 11:
      case 14:
      case 15:
        Ls(3, nt, nt.return), yo(3, nt), Ls(5, nt, nt.return);
        return;
      case 12:
        return;
      case 13:
        ba(nt);
        return;
      case 19:
        ba(nt);
        return;
      case 3:
        qt &&
          tt !== null &&
          tt.memoizedState.isDehydrated &&
          zt(nt.stateNode.containerInfo);
        break;
      case 22:
      case 23:
        return;
    }
    e: if (Bt) {
      switch (nt.tag) {
        case 1:
        case 5:
        case 6:
          break e;
        case 3:
        case 4:
          (nt = nt.stateNode), tr(nt.containerInfo, nt.pendingChildren);
          break e;
      }
      throw Error(g(163));
    }
  }
  function ba(tt) {
    var nt = tt.updateQueue;
    if (nt !== null) {
      tt.updateQueue = null;
      var ht = tt.stateNode;
      ht === null && (ht = tt.stateNode = new $m()),
        nt.forEach(function (dt) {
          var yt = r0.bind(null, tt, dt);
          ht.has(dt) || (ht.add(dt), dt.then(yt, yt));
        });
    }
  }
  function Km(tt, nt) {
    for (Bn = nt; Bn !== null; ) {
      nt = Bn;
      var ht = nt.deletions;
      if (ht !== null)
        for (var dt = 0; dt < ht.length; dt++) {
          var yt = ht[dt];
          try {
            var At = tt;
            pn ? Qp(At, yt, nt) : Xp(At, yt, nt);
            var Nt = yt.alternate;
            Nt !== null && (Nt.return = null), (yt.return = null);
          } catch (Un) {
            zr(yt, nt, Un);
          }
        }
      if (((ht = nt.child), nt.subtreeFlags & 12854 && ht !== null))
        (ht.return = nt), (Bn = ht);
      else
        for (; Bn !== null; ) {
          nt = Bn;
          try {
            var jt = nt.flags;
            if ((jt & 32 && pn && In(nt.stateNode), jt & 512)) {
              var rn = nt.alternate;
              if (rn !== null) {
                var Sn = rn.ref;
                Sn !== null &&
                  (typeof Sn == "function" ? Sn(null) : (Sn.current = null));
              }
            }
            if (jt & 8192)
              switch (nt.tag) {
                case 13:
                  if (nt.memoizedState !== null) {
                    var Dn = nt.alternate;
                    (Dn === null || Dn.memoizedState === null) && (Bu = wr());
                  }
                  break;
                case 22:
                  var Qn = nt.memoizedState !== null,
                    Xn = nt.alternate,
                    cr = Xn !== null && Xn.memoizedState !== null;
                  if (((ht = nt), pn)) {
                    e: if (((dt = ht), (yt = Qn), (At = null), pn))
                      for (var Vn = dt; ; ) {
                        if (Vn.tag === 5) {
                          if (At === null) {
                            At = Vn;
                            var Nr = Vn.stateNode;
                            yt ? Ut(Nr) : an(Vn.stateNode, Vn.memoizedProps);
                          }
                        } else if (Vn.tag === 6) {
                          if (At === null) {
                            var ts = Vn.stateNode;
                            yt ? dn(ts) : hn(ts, Vn.memoizedProps);
                          }
                        } else if (
                          ((Vn.tag !== 22 && Vn.tag !== 23) ||
                            Vn.memoizedState === null ||
                            Vn === dt) &&
                          Vn.child !== null
                        ) {
                          (Vn.child.return = Vn), (Vn = Vn.child);
                          continue;
                        }
                        if (Vn === dt) break;
                        for (; Vn.sibling === null; ) {
                          if (Vn.return === null || Vn.return === dt) break e;
                          At === Vn && (At = null), (Vn = Vn.return);
                        }
                        At === Vn && (At = null),
                          (Vn.sibling.return = Vn.return),
                          (Vn = Vn.sibling);
                      }
                  }
                  if (Qn && !cr && ht.mode & 1) {
                    Bn = ht;
                    for (var Yt = ht.child; Yt !== null; ) {
                      for (ht = Bn = Yt; Bn !== null; ) {
                        dt = Bn;
                        var Ht = dt.child;
                        switch (dt.tag) {
                          case 0:
                          case 11:
                          case 14:
                          case 15:
                            Ls(4, dt, dt.return);
                            break;
                          case 1:
                            xa(dt, dt.return);
                            var tn = dt.stateNode;
                            if (typeof tn.componentWillUnmount == "function") {
                              var Ln = dt.return;
                              try {
                                (tn.props = dt.memoizedProps),
                                  (tn.state = dt.memoizedState),
                                  tn.componentWillUnmount();
                              } catch (Un) {
                                zr(dt, Ln, Un);
                              }
                            }
                            break;
                          case 5:
                            xa(dt, dt.return);
                            break;
                          case 22:
                            if (dt.memoizedState !== null) {
                              tm(ht);
                              continue;
                            }
                        }
                        Ht !== null ? ((Ht.return = dt), (Bn = Ht)) : tm(ht);
                      }
                      Yt = Yt.sibling;
                    }
                  }
              }
            switch (jt & 4102) {
              case 2:
                qp(nt), (nt.flags &= -3);
                break;
              case 6:
                qp(nt), (nt.flags &= -3), Mu(nt.alternate, nt);
                break;
              case 4096:
                nt.flags &= -4097;
                break;
              case 4100:
                (nt.flags &= -4097), Mu(nt.alternate, nt);
                break;
              case 4:
                Mu(nt.alternate, nt);
            }
          } catch (Un) {
            zr(nt, nt.return, Un);
          }
          if (((ht = nt.sibling), ht !== null)) {
            (ht.return = nt.return), (Bn = ht);
            break;
          }
          Bn = nt.return;
        }
    }
  }
  function Jm(tt, nt, ht) {
    (Bn = tt), Zp(tt);
  }
  function Zp(tt, nt, ht) {
    for (var dt = (tt.mode & 1) !== 0; Bn !== null; ) {
      var yt = Bn,
        At = yt.child;
      if (yt.tag === 22 && dt) {
        var Nt = yt.memoizedState !== null || ga;
        if (!Nt) {
          var jt = yt.alternate,
            rn = (jt !== null && jt.memoizedState !== null) || Is;
          jt = ga;
          var Sn = Is;
          if (((ga = Nt), (Is = rn) && !Sn))
            for (Bn = yt; Bn !== null; )
              (Nt = Bn),
                (rn = Nt.child),
                Nt.tag === 22 && Nt.memoizedState !== null
                  ? rm(yt)
                  : rn !== null
                  ? ((rn.return = Nt), (Bn = rn))
                  : rm(yt);
          for (; At !== null; ) (Bn = At), Zp(At), (At = At.sibling);
          (Bn = yt), (ga = jt), (Is = Sn);
        }
        em(tt);
      } else
        yt.subtreeFlags & 8772 && At !== null
          ? ((At.return = yt), (Bn = At))
          : em(tt);
    }
  }
  function em(tt) {
    for (; Bn !== null; ) {
      var nt = Bn;
      if (nt.flags & 8772) {
        var ht = nt.alternate;
        try {
          if (nt.flags & 8772)
            switch (nt.tag) {
              case 0:
              case 11:
              case 15:
                Is || yo(5, nt);
                break;
              case 1:
                var dt = nt.stateNode;
                if (nt.flags & 4 && !Is)
                  if (ht === null) dt.componentDidMount();
                  else {
                    var yt =
                      nt.elementType === nt.type
                        ? ht.memoizedProps
                        : rs(nt.type, ht.memoizedProps);
                    dt.componentDidUpdate(
                      yt,
                      ht.memoizedState,
                      dt.__reactInternalSnapshotBeforeUpdate
                    );
                  }
                var At = nt.updateQueue;
                At !== null && Ju(nt, At, dt);
                break;
              case 3:
                var Nt = nt.updateQueue;
                if (Nt !== null) {
                  if (((ht = null), nt.child !== null))
                    switch (nt.child.tag) {
                      case 5:
                        ht = Et(nt.child.stateNode);
                        break;
                      case 1:
                        ht = nt.child.stateNode;
                    }
                  Ju(nt, Nt, ht);
                }
                break;
              case 5:
                var jt = nt.stateNode;
                ht === null &&
                  nt.flags & 4 &&
                  Rn(jt, nt.type, nt.memoizedProps, nt);
                break;
              case 6:
                break;
              case 4:
                break;
              case 12:
                break;
              case 13:
                if (qt && nt.memoizedState === null) {
                  var rn = nt.alternate;
                  if (rn !== null) {
                    var Sn = rn.memoizedState;
                    if (Sn !== null) {
                      var Dn = Sn.dehydrated;
                      Dn !== null && Qt(Dn);
                    }
                  }
                }
                break;
              case 19:
              case 17:
              case 21:
              case 22:
              case 23:
                break;
              default:
                throw Error(g(163));
            }
          Is || (nt.flags & 512 && Su(nt));
        } catch (Qn) {
          zr(nt, nt.return, Qn);
        }
      }
      if (nt === tt) {
        Bn = null;
        break;
      }
      if (((ht = nt.sibling), ht !== null)) {
        (ht.return = nt.return), (Bn = ht);
        break;
      }
      Bn = nt.return;
    }
  }
  function tm(tt) {
    for (; Bn !== null; ) {
      var nt = Bn;
      if (nt === tt) {
        Bn = null;
        break;
      }
      var ht = nt.sibling;
      if (ht !== null) {
        (ht.return = nt.return), (Bn = ht);
        break;
      }
      Bn = nt.return;
    }
  }
  function rm(tt) {
    for (; Bn !== null; ) {
      var nt = Bn;
      try {
        switch (nt.tag) {
          case 0:
          case 11:
          case 15:
            var ht = nt.return;
            try {
              yo(4, nt);
            } catch (rn) {
              zr(nt, ht, rn);
            }
            break;
          case 1:
            var dt = nt.stateNode;
            if (typeof dt.componentDidMount == "function") {
              var yt = nt.return;
              try {
                dt.componentDidMount();
              } catch (rn) {
                zr(nt, yt, rn);
              }
            }
            var At = nt.return;
            try {
              Su(nt);
            } catch (rn) {
              zr(nt, At, rn);
            }
            break;
          case 5:
            var Nt = nt.return;
            try {
              Su(nt);
            } catch (rn) {
              zr(nt, Nt, rn);
            }
        }
      } catch (rn) {
        zr(nt, nt.return, rn);
      }
      if (nt === tt) {
        Bn = null;
        break;
      }
      var jt = nt.sibling;
      if (jt !== null) {
        (jt.return = nt.return), (Bn = jt);
        break;
      }
      Bn = nt.return;
    }
  }
  var $a = 0,
    yl = 1,
    xl = 2,
    _l = 3,
    Sl = 4;
  if (typeof Symbol == "function" && Symbol.for) {
    var xo = Symbol.for;
    ($a = xo("selector.component")),
      (yl = xo("selector.has_pseudo_class")),
      (xl = xo("selector.role")),
      (_l = xo("selector.test_id")),
      (Sl = xo("selector.text"));
  }
  function Cu(tt) {
    var nt = $t(tt);
    if (nt != null) {
      if (typeof nt.memoizedProps["data-testname"] != "string")
        throw Error(g(364));
      return nt;
    }
    if (((tt = wt(tt)), tt === null)) throw Error(g(362));
    return tt.stateNode.current;
  }
  function Tu(tt, nt) {
    switch (nt.$$typeof) {
      case $a:
        if (tt.type === nt.value) return !0;
        break;
      case yl:
        e: {
          (nt = nt.value), (tt = [tt, 0]);
          for (var ht = 0; ht < tt.length; ) {
            var dt = tt[ht++],
              yt = tt[ht++],
              At = nt[yt];
            if (dt.tag !== 5 || !sn(dt)) {
              for (; At != null && Tu(dt, At); ) yt++, (At = nt[yt]);
              if (yt === nt.length) {
                nt = !0;
                break e;
              } else
                for (dt = dt.child; dt !== null; )
                  tt.push(dt, yt), (dt = dt.sibling);
            }
          }
          nt = !1;
        }
        return nt;
      case xl:
        if (tt.tag === 5 && cn(tt.stateNode, nt.value)) return !0;
        break;
      case Sl:
        if (
          (tt.tag === 5 || tt.tag === 6) &&
          ((tt = on(tt)), tt !== null && 0 <= tt.indexOf(nt.value))
        )
          return !0;
        break;
      case _l:
        if (
          tt.tag === 5 &&
          ((tt = tt.memoizedProps["data-testname"]),
          typeof tt == "string" && tt.toLowerCase() === nt.value.toLowerCase())
        )
          return !0;
        break;
      default:
        throw Error(g(365));
    }
    return !1;
  }
  function bu(tt) {
    switch (tt.$$typeof) {
      case $a:
        return "<" + (gt(tt.value) || "Unknown") + ">";
      case yl:
        return ":has(" + (bu(tt) || "") + ")";
      case xl:
        return '[role="' + tt.value + '"]';
      case Sl:
        return '"' + tt.value + '"';
      case _l:
        return '[data-testname="' + tt.value + '"]';
      default:
        throw Error(g(365));
    }
  }
  function im(tt, nt) {
    var ht = [];
    tt = [tt, 0];
    for (var dt = 0; dt < tt.length; ) {
      var yt = tt[dt++],
        At = tt[dt++],
        Nt = nt[At];
      if (yt.tag !== 5 || !sn(yt)) {
        for (; Nt != null && Tu(yt, Nt); ) At++, (Nt = nt[At]);
        if (At === nt.length) ht.push(yt);
        else
          for (yt = yt.child; yt !== null; ) tt.push(yt, At), (yt = yt.sibling);
      }
    }
    return ht;
  }
  function wu(tt, nt) {
    if (!kt) throw Error(g(363));
    (tt = Cu(tt)), (tt = im(tt, nt)), (nt = []), (tt = Array.from(tt));
    for (var ht = 0; ht < tt.length; ) {
      var dt = tt[ht++];
      if (dt.tag === 5) sn(dt) || nt.push(dt.stateNode);
      else for (dt = dt.child; dt !== null; ) tt.push(dt), (dt = dt.sibling);
    }
    return nt;
  }
  var Ym = Math.ceil,
    El = _.ReactCurrentDispatcher,
    Pu = _.ReactCurrentOwner,
    _r = _.ReactCurrentBatchConfig,
    nr = 0,
    Er = null,
    Ar = null,
    Ir = 0,
    Kr = 0,
    Qs = yr(0),
    Mr = 0,
    _o = null,
    Zs = 0,
    Al = 0,
    Ru = 0,
    So = null,
    Gr = null,
    Bu = 0,
    Iu = 1 / 0;
  function eo() {
    Iu = wr() + 500;
  }
  var Ml = !1,
    Lu = null,
    As = null,
    Cl = !1,
    Ms = null,
    Tl = 0,
    Eo = 0,
    Fu = null,
    wl = -1,
    Pl = 0;
  function Ur() {
    return nr & 6 ? wr() : wl !== -1 ? wl : (wl = wr());
  }
  function Cs(tt) {
    return tt.mode & 1
      ? nr & 2 && Ir !== 0
        ? Ir & -Ir
        : Im.transition !== null
        ? (Pl === 0 &&
            ((tt = wo), (wo <<= 1), !(wo & 4194240) && (wo = 64), (Pl = tt)),
          Pl)
        : ((tt = sr), tt !== 0 ? tt : nn())
      : 1;
  }
  function _i(tt, nt, ht) {
    if (50 < Eo) throw ((Eo = 0), (Fu = null), Error(g(185)));
    var dt = Rl(tt, nt);
    return dt === null
      ? null
      : (io(dt, nt, ht),
        (!(nr & 2) || dt !== Er) &&
          (dt === Er && (!(nr & 2) && (Al |= nt), Mr === 4 && Ts(dt, Ir)),
          jr(dt, ht),
          nt === 1 && nr === 0 && !(tt.mode & 1) && (eo(), Io && ls())),
        dt);
  }
  function Rl(tt, nt) {
    tt.lanes |= nt;
    var ht = tt.alternate;
    for (
      ht !== null && (ht.lanes |= nt), ht = tt, tt = tt.return;
      tt !== null;

    )
      (tt.childLanes |= nt),
        (ht = tt.alternate),
        ht !== null && (ht.childLanes |= nt),
        (ht = tt),
        (tt = tt.return);
    return ht.tag === 3 ? ht.stateNode : null;
  }
  function jr(tt, nt) {
    var ht = tt.callbackNode;
    Am(tt, nt);
    var dt = Ro(tt, tt === Er ? Ir : 0);
    if (dt === 0)
      ht !== null && Hu(ht),
        (tt.callbackNode = null),
        (tt.callbackPriority = 0);
    else if (((nt = dt & -dt), tt.callbackPriority !== nt)) {
      if ((ht != null && Hu(ht), nt === 1))
        tt.tag === 0 ? Bm(om.bind(null, tt)) : Wu(om.bind(null, tt)),
          xn
            ? An(function () {
                nr === 0 && ls();
              })
            : Gl(zl, ls),
          (ht = null);
      else {
        switch (zu(dt)) {
          case 1:
            ht = zl;
            break;
          case 4:
            ht = bm;
            break;
          case 16:
            ht = Hl;
            break;
          case 536870912:
            ht = wm;
            break;
          default:
            ht = Hl;
        }
        ht = mm(ht, sm.bind(null, tt));
      }
      (tt.callbackPriority = nt), (tt.callbackNode = ht);
    }
  }
  function sm(tt, nt) {
    if (((wl = -1), (Pl = 0), nr & 6)) throw Error(g(327));
    var ht = tt.callbackNode;
    if (Ds() && tt.callbackNode !== ht) return null;
    var dt = Ro(tt, tt === Er ? Ir : 0);
    if (dt === 0) return null;
    if (dt & 30 || dt & tt.expiredLanes || nt) nt = Bl(tt, dt);
    else {
      nt = dt;
      var yt = nr;
      nr |= 2;
      var At = cm();
      (Er !== tt || Ir !== nt) && (eo(), Fs(tt, nt));
      do
        try {
          Zm();
          break;
        } catch (jt) {
          lm(tt, jt);
        }
      while (!0);
      Xl(),
        (El.current = At),
        (nr = yt),
        Ar !== null ? (nt = 0) : ((Er = null), (Ir = 0), (nt = Mr));
    }
    if (nt !== 0) {
      if (
        (nt === 2 &&
          ((yt = Ol(tt)), yt !== 0 && ((dt = yt), (nt = ku(tt, yt)))),
        nt === 1)
      )
        throw ((ht = _o), Fs(tt, 0), Ts(tt, dt), jr(tt, wr()), ht);
      if (nt === 6) Ts(tt, dt);
      else {
        if (
          ((yt = tt.current.alternate),
          !(dt & 30) &&
            !qm(yt) &&
            ((nt = Bl(tt, dt)),
            nt === 2 &&
              ((At = Ol(tt)), At !== 0 && ((dt = At), (nt = ku(tt, At)))),
            nt === 1))
        )
          throw ((ht = _o), Fs(tt, 0), Ts(tt, dt), jr(tt, wr()), ht);
        switch (((tt.finishedWork = yt), (tt.finishedLanes = dt), nt)) {
          case 0:
          case 1:
            throw Error(g(345));
          case 2:
            ks(tt, Gr);
            break;
          case 3:
            if (
              (Ts(tt, dt),
              (dt & 130023424) === dt && ((nt = Bu + 500 - wr()), 10 < nt))
            ) {
              if (Ro(tt, 0) !== 0) break;
              if (((yt = tt.suspendedLanes), (yt & dt) !== dt)) {
                Ur(), (tt.pingedLanes |= tt.suspendedLanes & yt);
                break;
              }
              tt.timeoutHandle = en(ks.bind(null, tt, Gr), nt);
              break;
            }
            ks(tt, Gr);
            break;
          case 4:
            if ((Ts(tt, dt), (dt & 4194240) === dt)) break;
            for (nt = tt.eventTimes, yt = -1; 0 < dt; ) {
              var Nt = 31 - Hr(dt);
              (At = 1 << Nt), (Nt = nt[Nt]), Nt > yt && (yt = Nt), (dt &= ~At);
            }
            if (
              ((dt = yt),
              (dt = wr() - dt),
              (dt =
                (120 > dt
                  ? 120
                  : 480 > dt
                  ? 480
                  : 1080 > dt
                  ? 1080
                  : 1920 > dt
                  ? 1920
                  : 3e3 > dt
                  ? 3e3
                  : 4320 > dt
                  ? 4320
                  : 1960 * Ym(dt / 1960)) - dt),
              10 < dt)
            ) {
              tt.timeoutHandle = en(ks.bind(null, tt, Gr), dt);
              break;
            }
            ks(tt, Gr);
            break;
          case 5:
            ks(tt, Gr);
            break;
          default:
            throw Error(g(329));
        }
      }
    }
    return jr(tt, wr()), tt.callbackNode === ht ? sm.bind(null, tt) : null;
  }
  function ku(tt, nt) {
    var ht = So;
    return (
      tt.current.memoizedState.isDehydrated && (Fs(tt, nt).flags |= 256),
      (tt = Bl(tt, nt)),
      tt !== 2 && ((nt = Gr), (Gr = ht), nt !== null && Du(nt)),
      tt
    );
  }
  function Du(tt) {
    Gr === null ? (Gr = tt) : Gr.push.apply(Gr, tt);
  }
  function qm(tt) {
    for (var nt = tt; ; ) {
      if (nt.flags & 16384) {
        var ht = nt.updateQueue;
        if (ht !== null && ((ht = ht.stores), ht !== null))
          for (var dt = 0; dt < ht.length; dt++) {
            var yt = ht[dt],
              At = yt.getSnapshot;
            yt = yt.value;
            try {
              if (!as(At(), yt)) return !1;
            } catch {
              return !1;
            }
          }
      }
      if (((ht = nt.child), nt.subtreeFlags & 16384 && ht !== null))
        (ht.return = nt), (nt = ht);
      else {
        if (nt === tt) break;
        for (; nt.sibling === null; ) {
          if (nt.return === null || nt.return === tt) return !0;
          nt = nt.return;
        }
        (nt.sibling.return = nt.return), (nt = nt.sibling);
      }
    }
    return !0;
  }
  function Ts(tt, nt) {
    for (
      nt &= ~Ru,
        nt &= ~Al,
        tt.suspendedLanes |= nt,
        tt.pingedLanes &= ~nt,
        tt = tt.expirationTimes;
      0 < nt;

    ) {
      var ht = 31 - Hr(nt),
        dt = 1 << ht;
      (tt[ht] = -1), (nt &= ~dt);
    }
  }
  function om(tt) {
    if (nr & 6) throw Error(g(327));
    Ds();
    var nt = Ro(tt, 0);
    if (!(nt & 1)) return jr(tt, wr()), null;
    var ht = Bl(tt, nt);
    if (tt.tag !== 0 && ht === 2) {
      var dt = Ol(tt);
      dt !== 0 && ((nt = dt), (ht = ku(tt, dt)));
    }
    if (ht === 1) throw ((ht = _o), Fs(tt, 0), Ts(tt, nt), jr(tt, wr()), ht);
    if (ht === 6) throw Error(g(345));
    return (
      (tt.finishedWork = tt.current.alternate),
      (tt.finishedLanes = nt),
      ks(tt, Gr),
      jr(tt, wr()),
      null
    );
  }
  function am(tt) {
    Ms !== null && Ms.tag === 0 && !(nr & 6) && Ds();
    var nt = nr;
    nr |= 1;
    var ht = _r.transition,
      dt = sr;
    try {
      if (((_r.transition = null), (sr = 1), tt)) return tt();
    } finally {
      (sr = dt), (_r.transition = ht), (nr = nt), !(nr & 6) && ls();
    }
  }
  function Nu() {
    (Kr = Qs.current), Gn(Qs);
  }
  function Fs(tt, nt) {
    (tt.finishedWork = null), (tt.finishedLanes = 0);
    var ht = tt.timeoutHandle;
    if ((ht !== Tn && ((tt.timeoutHandle = Tn), _n(ht)), Ar !== null))
      for (ht = Ar.return; ht !== null; ) {
        var dt = ht;
        switch ((eu(dt), dt.tag)) {
          case 1:
            (dt = dt.type.childContextTypes), dt != null && mr();
            break;
          case 3:
            Ys(), Gn(dr), Gn(Jn), au();
            break;
          case 5:
            su(dt);
            break;
          case 4:
            Ys();
            break;
          case 13:
            Gn(vr);
            break;
          case 19:
            Gn(vr);
            break;
          case 10:
            Kl(dt.type._context);
            break;
          case 22:
          case 23:
            Nu();
        }
        ht = ht.return;
      }
    if (
      ((Er = tt),
      (Ar = tt = bs(tt.current, null)),
      (Ir = Kr = nt),
      (Mr = 0),
      (_o = null),
      (Ru = Al = Zs = 0),
      (Gr = So = null),
      cs !== null)
    ) {
      for (nt = 0; nt < cs.length; nt++)
        if (((ht = cs[nt]), (dt = ht.interleaved), dt !== null)) {
          ht.interleaved = null;
          var yt = dt.next,
            At = ht.pending;
          if (At !== null) {
            var Nt = At.next;
            (At.next = yt), (dt.next = Nt);
          }
          ht.pending = dt;
        }
      cs = null;
    }
    return tt;
  }
  function lm(tt, nt) {
    do {
      var ht = Ar;
      try {
        if ((Xl(), (zo.current = Jo), Ho)) {
          for (var dt = xr.memoizedState; dt !== null; ) {
            var yt = dt.queue;
            yt !== null && (yt.pending = null), (dt = dt.next);
          }
          Ho = !1;
        }
        if (
          ((qs = 0),
          (Pr = Lr = xr = null),
          (uo = !1),
          (ho = 0),
          (Pu.current = null),
          ht === null || ht.return === null)
        ) {
          (Mr = 1), (_o = nt), (Ar = null);
          break;
        }
        e: {
          var At = tt,
            Nt = ht.return,
            jt = ht,
            rn = nt;
          if (
            ((nt = Ir),
            (jt.flags |= 32768),
            rn !== null &&
              typeof rn == "object" &&
              typeof rn.then == "function")
          ) {
            var Sn = rn,
              Dn = jt,
              Qn = Dn.tag;
            if (!(Dn.mode & 1) && (Qn === 0 || Qn === 11 || Qn === 15)) {
              var Xn = Dn.alternate;
              Xn
                ? ((Dn.updateQueue = Xn.updateQueue),
                  (Dn.memoizedState = Xn.memoizedState),
                  (Dn.lanes = Xn.lanes))
                : ((Dn.updateQueue = null), (Dn.memoizedState = null));
            }
            var cr = wp(Nt);
            if (cr !== null) {
              (cr.flags &= -257),
                Pp(cr, Nt, jt, At, nt),
                cr.mode & 1 && bp(At, Sn, nt),
                (nt = cr),
                (rn = Sn);
              var Vn = nt.updateQueue;
              if (Vn === null) {
                var Nr = new Set();
                Nr.add(rn), (nt.updateQueue = Nr);
              } else Vn.add(rn);
              break e;
            } else {
              if (!(nt & 1)) {
                bp(At, Sn, nt), Ou();
                break e;
              }
              rn = Error(g(426));
            }
          } else if (gr && jt.mode & 1) {
            var ts = wp(Nt);
            if (ts !== null) {
              !(ts.flags & 65536) && (ts.flags |= 256),
                Pp(ts, Nt, jt, At, nt),
                ru(rn);
              break e;
            }
          }
          (At = rn),
            Mr !== 4 && (Mr = 2),
            So === null ? (So = [At]) : So.push(At),
            (rn = pu(rn, jt)),
            (jt = Nt);
          do {
            switch (jt.tag) {
              case 3:
                (jt.flags |= 65536), (nt &= -nt), (jt.lanes |= nt);
                var Yt = Cp(jt, rn, nt);
                Ku(jt, Yt);
                break e;
              case 1:
                At = rn;
                var Ht = jt.type,
                  tn = jt.stateNode;
                if (
                  !(jt.flags & 128) &&
                  (typeof Ht.getDerivedStateFromError == "function" ||
                    (tn !== null &&
                      typeof tn.componentDidCatch == "function" &&
                      (As === null || !As.has(tn))))
                ) {
                  (jt.flags |= 65536), (nt &= -nt), (jt.lanes |= nt);
                  var Ln = Tp(jt, At, nt);
                  Ku(jt, Ln);
                  break e;
                }
            }
            jt = jt.return;
          } while (jt !== null);
        }
        hm(ht);
      } catch (Un) {
        (nt = Un), Ar === ht && ht !== null && (Ar = ht = ht.return);
        continue;
      }
      break;
    } while (!0);
  }
  function cm() {
    var tt = El.current;
    return (El.current = Jo), tt === null ? Jo : tt;
  }
  function Ou() {
    (Mr === 0 || Mr === 3 || Mr === 2) && (Mr = 4),
      Er === null || (!(Zs & 268435455) && !(Al & 268435455)) || Ts(Er, Ir);
  }
  function Bl(tt, nt) {
    var ht = nr;
    nr |= 2;
    var dt = cm();
    (Er === tt && Ir === nt) || Fs(tt, nt);
    do
      try {
        Qm();
        break;
      } catch (yt) {
        lm(tt, yt);
      }
    while (!0);
    if ((Xl(), (nr = ht), (El.current = dt), Ar !== null)) throw Error(g(261));
    return (Er = null), (Ir = 0), Mr;
  }
  function Qm() {
    for (; Ar !== null; ) um(Ar);
  }
  function Zm() {
    for (; Ar !== null && !Cm(); ) um(Ar);
  }
  function um(tt) {
    var nt = pm(tt.alternate, tt, Kr);
    (tt.memoizedProps = tt.pendingProps),
      nt === null ? hm(tt) : (Ar = nt),
      (Pu.current = null);
  }
  function hm(tt) {
    var nt = tt;
    do {
      var ht = nt.alternate;
      if (((tt = nt.return), nt.flags & 32768)) {
        if (((ht = Wm(ht, nt)), ht !== null)) {
          (ht.flags &= 32767), (Ar = ht);
          return;
        }
        if (tt !== null)
          (tt.flags |= 32768), (tt.subtreeFlags = 0), (tt.deletions = null);
        else {
          (Mr = 6), (Ar = null);
          return;
        }
      } else if (((ht = jm(ht, nt, Kr)), ht !== null)) {
        Ar = ht;
        return;
      }
      if (((nt = nt.sibling), nt !== null)) {
        Ar = nt;
        return;
      }
      Ar = nt = tt;
    } while (nt !== null);
    Mr === 0 && (Mr = 5);
  }
  function ks(tt, nt) {
    var ht = sr,
      dt = _r.transition;
    try {
      (_r.transition = null), (sr = 1), e0(tt, nt, ht);
    } finally {
      (_r.transition = dt), (sr = ht);
    }
    return null;
  }
  function e0(tt, nt, ht) {
    do Ds();
    while (Ms !== null);
    if (nr & 6) throw Error(g(327));
    var dt = tt.finishedWork,
      yt = tt.finishedLanes;
    if (dt === null) return null;
    if (((tt.finishedWork = null), (tt.finishedLanes = 0), dt === tt.current))
      throw Error(g(177));
    (tt.callbackNode = null), (tt.callbackPriority = 0);
    var At = dt.lanes | dt.childLanes;
    if (
      (Mm(tt, At),
      tt === Er && ((Ar = Er = null), (Ir = 0)),
      (!(dt.subtreeFlags & 2064) && !(dt.flags & 2064)) ||
        Cl ||
        ((Cl = !0),
        mm(Hl, function () {
          return Ds(), null;
        })),
      (At = (dt.flags & 15990) !== 0),
      dt.subtreeFlags & 15990 || At)
    ) {
      (At = _r.transition), (_r.transition = null);
      var Nt = sr;
      sr = 1;
      var jt = nr;
      (nr |= 4),
        (Pu.current = null),
        Xm(tt, dt),
        Km(tt, dt),
        Ct(tt.containerInfo),
        (tt.current = dt),
        Jm(dt),
        Tm(),
        (nr = jt),
        (sr = Nt),
        (_r.transition = At);
    } else tt.current = dt;
    if (
      (Cl && ((Cl = !1), (Ms = tt), (Tl = yt)),
      (At = tt.pendingLanes),
      At === 0 && (As = null),
      Pm(dt.stateNode),
      jr(tt, wr()),
      nt !== null)
    )
      for (ht = tt.onRecoverableError, dt = 0; dt < nt.length; dt++) ht(nt[dt]);
    if (Ml) throw ((Ml = !1), (tt = Lu), (Lu = null), tt);
    return (
      Tl & 1 && tt.tag !== 0 && Ds(),
      (At = tt.pendingLanes),
      At & 1 ? (tt === Fu ? Eo++ : ((Eo = 0), (Fu = tt))) : (Eo = 0),
      ls(),
      null
    );
  }
  function Ds() {
    if (Ms !== null) {
      var tt = zu(Tl),
        nt = _r.transition,
        ht = sr;
      try {
        if (((_r.transition = null), (sr = 16 > tt ? 16 : tt), Ms === null))
          var dt = !1;
        else {
          if (((tt = Ms), (Ms = null), (Tl = 0), nr & 6)) throw Error(g(331));
          var yt = nr;
          for (nr |= 4, Bn = tt.current; Bn !== null; ) {
            var At = Bn,
              Nt = At.child;
            if (Bn.flags & 16) {
              var jt = At.deletions;
              if (jt !== null) {
                for (var rn = 0; rn < jt.length; rn++) {
                  var Sn = jt[rn];
                  for (Bn = Sn; Bn !== null; ) {
                    var Dn = Bn;
                    switch (Dn.tag) {
                      case 0:
                      case 11:
                      case 15:
                        Ls(8, Dn, At);
                    }
                    var Qn = Dn.child;
                    if (Qn !== null) (Qn.return = Dn), (Bn = Qn);
                    else
                      for (; Bn !== null; ) {
                        Dn = Bn;
                        var Xn = Dn.sibling,
                          cr = Dn.return;
                        if ((Kp(Dn), Dn === Sn)) {
                          Bn = null;
                          break;
                        }
                        if (Xn !== null) {
                          (Xn.return = cr), (Bn = Xn);
                          break;
                        }
                        Bn = cr;
                      }
                  }
                }
                var Vn = At.alternate;
                if (Vn !== null) {
                  var Nr = Vn.child;
                  if (Nr !== null) {
                    Vn.child = null;
                    do {
                      var ts = Nr.sibling;
                      (Nr.sibling = null), (Nr = ts);
                    } while (Nr !== null);
                  }
                }
                Bn = At;
              }
            }
            if (At.subtreeFlags & 2064 && Nt !== null)
              (Nt.return = At), (Bn = Nt);
            else
              e: for (; Bn !== null; ) {
                if (((At = Bn), At.flags & 2048))
                  switch (At.tag) {
                    case 0:
                    case 11:
                    case 15:
                      Ls(9, At, At.return);
                  }
                var Yt = At.sibling;
                if (Yt !== null) {
                  (Yt.return = At.return), (Bn = Yt);
                  break e;
                }
                Bn = At.return;
              }
          }
          var Ht = tt.current;
          for (Bn = Ht; Bn !== null; ) {
            Nt = Bn;
            var tn = Nt.child;
            if (Nt.subtreeFlags & 2064 && tn !== null)
              (tn.return = Nt), (Bn = tn);
            else
              e: for (Nt = Ht; Bn !== null; ) {
                if (((jt = Bn), jt.flags & 2048))
                  try {
                    switch (jt.tag) {
                      case 0:
                      case 11:
                      case 15:
                        yo(9, jt);
                    }
                  } catch (Un) {
                    zr(jt, jt.return, Un);
                  }
                if (jt === Nt) {
                  Bn = null;
                  break e;
                }
                var Ln = jt.sibling;
                if (Ln !== null) {
                  (Ln.return = jt.return), (Bn = Ln);
                  break e;
                }
                Bn = jt.return;
              }
          }
          if (
            ((nr = yt),
            ls(),
            os && typeof os.onPostCommitFiberRoot == "function")
          )
            try {
              os.onPostCommitFiberRoot(Bo, tt);
            } catch {}
          dt = !0;
        }
        return dt;
      } finally {
        (sr = ht), (_r.transition = nt);
      }
    }
    return !1;
  }
  function fm(tt, nt, ht) {
    (nt = pu(ht, nt)),
      (nt = Cp(tt, nt, 1)),
      Es(tt, nt),
      (nt = Ur()),
      (tt = Rl(tt, 1)),
      tt !== null && (io(tt, 1, nt), jr(tt, nt));
  }
  function zr(tt, nt, ht) {
    if (tt.tag === 3) fm(tt, tt, ht);
    else
      for (; nt !== null; ) {
        if (nt.tag === 3) {
          fm(nt, tt, ht);
          break;
        } else if (nt.tag === 1) {
          var dt = nt.stateNode;
          if (
            typeof nt.type.getDerivedStateFromError == "function" ||
            (typeof dt.componentDidCatch == "function" &&
              (As === null || !As.has(dt)))
          ) {
            (tt = pu(ht, tt)),
              (tt = Tp(nt, tt, 1)),
              Es(nt, tt),
              (tt = Ur()),
              (nt = Rl(nt, 1)),
              nt !== null && (io(nt, 1, tt), jr(nt, tt));
            break;
          }
        }
        nt = nt.return;
      }
  }
  function t0(tt, nt, ht) {
    var dt = tt.pingCache;
    dt !== null && dt.delete(nt),
      (nt = Ur()),
      (tt.pingedLanes |= tt.suspendedLanes & ht),
      Er === tt &&
        (Ir & ht) === ht &&
        (Mr === 4 || (Mr === 3 && (Ir & 130023424) === Ir && 500 > wr() - Bu)
          ? Fs(tt, 0)
          : (Ru |= ht)),
      jr(tt, nt);
  }
  function dm(tt, nt) {
    nt === 0 &&
      (tt.mode & 1
        ? ((nt = Po), (Po <<= 1), !(Po & 130023424) && (Po = 4194304))
        : (nt = 1));
    var ht = Ur();
    (tt = Rl(tt, nt)), tt !== null && (io(tt, nt, ht), jr(tt, ht));
  }
  function n0(tt) {
    var nt = tt.memoizedState,
      ht = 0;
    nt !== null && (ht = nt.retryLane), dm(tt, ht);
  }
  function r0(tt, nt) {
    var ht = 0;
    switch (tt.tag) {
      case 13:
        var dt = tt.stateNode,
          yt = tt.memoizedState;
        yt !== null && (ht = yt.retryLane);
        break;
      case 19:
        dt = tt.stateNode;
        break;
      default:
        throw Error(g(314));
    }
    dt !== null && dt.delete(nt), dm(tt, ht);
  }
  var pm;
  pm = function (tt, nt, ht) {
    if (tt !== null)
      if (tt.memoizedProps !== nt.pendingProps || dr.current) Xr = !0;
      else {
        if (!(tt.lanes & ht) && !(nt.flags & 128))
          return (Xr = !1), Hm(tt, nt, ht);
        Xr = !!(tt.flags & 131072);
      }
    else (Xr = !1), gr && nt.flags & 1048576 && _h(nt, Vo, nt.index);
    switch (((nt.lanes = 0), nt.tag)) {
      case 2:
        var dt = nt.type;
        tt !== null &&
          ((tt.alternate = null), (nt.alternate = null), (nt.flags |= 2)),
          (tt = nt.pendingProps);
        var yt = Sr(nt, Jn.current);
        Hs(nt, ht), (yt = cu(null, nt, dt, tt, yt, ht));
        var At = uu();
        return (
          (nt.flags |= 1),
          typeof yt == "object" &&
          yt !== null &&
          typeof yt.render == "function" &&
          yt.$$typeof === void 0
            ? ((nt.tag = 1),
              (nt.memoizedState = null),
              (nt.updateQueue = null),
              br(dt) ? ((At = !0), Br(nt)) : (At = !1),
              (nt.memoizedState =
                yt.state !== null && yt.state !== void 0 ? yt.state : null),
              Yl(nt),
              (yt.updater = Oo),
              (nt.stateNode = yt),
              (yt._reactInternals = nt),
              Zl(nt, dt, tt, ht),
              (nt = vu(null, nt, dt, !0, At, ht)))
            : ((nt.tag = 0),
              gr && At && _c(nt),
              Or(null, nt, yt, ht),
              (nt = nt.child)),
          nt
        );
      case 16:
        dt = nt.elementType;
        e: {
          switch (
            (tt !== null &&
              ((tt.alternate = null), (nt.alternate = null), (nt.flags |= 2)),
            (tt = nt.pendingProps),
            (yt = dt._init),
            (dt = yt(dt._payload)),
            (nt.type = dt),
            (yt = nt.tag = s0(dt)),
            (tt = rs(dt, tt)),
            yt)
          ) {
            case 0:
              nt = gu(null, nt, dt, tt, ht);
              break e;
            case 1:
              nt = Np(null, nt, dt, tt, ht);
              break e;
            case 11:
              nt = Ip(null, nt, dt, tt, ht);
              break e;
            case 14:
              nt = Lp(null, nt, dt, rs(dt.type, tt), ht);
              break e;
          }
          throw Error(g(306, dt, ""));
        }
        return nt;
      case 0:
        return (
          (dt = nt.type),
          (yt = nt.pendingProps),
          (yt = nt.elementType === dt ? yt : rs(dt, yt)),
          gu(tt, nt, dt, yt, ht)
        );
      case 1:
        return (
          (dt = nt.type),
          (yt = nt.pendingProps),
          (yt = nt.elementType === dt ? yt : rs(dt, yt)),
          Np(tt, nt, dt, yt, ht)
        );
      case 3:
        e: {
          if ((Op(nt), tt === null)) throw Error(g(387));
          (dt = nt.pendingProps),
            (At = nt.memoizedState),
            (yt = At.element),
            Xu(tt, nt),
            No(nt, dt, null, ht);
          var Nt = nt.memoizedState;
          if (((dt = Nt.element), qt && At.isDehydrated))
            if (
              ((At = {
                element: dt,
                isDehydrated: !1,
                cache: Nt.cache,
                transitions: Nt.transitions,
              }),
              (nt.updateQueue.baseState = At),
              (nt.memoizedState = At),
              nt.flags & 256)
            ) {
              (yt = Error(g(423))), (nt = Up(tt, nt, dt, ht, yt));
              break e;
            } else if (dt !== yt) {
              (yt = Error(g(424))), (nt = Up(tt, nt, dt, ht, yt));
              break e;
            } else
              for (
                qt &&
                  (($r = Mo(nt.stateNode.containerInfo)),
                  (Wr = nt),
                  (gr = !0),
                  (ss = null),
                  (so = !1)),
                  ht = rp(nt, null, dt, ht),
                  nt.child = ht;
                ht;

              )
                (ht.flags = (ht.flags & -3) | 4096), (ht = ht.sibling);
          else {
            if ((Xs(), dt === yt)) {
              nt = xs(tt, nt, ht);
              break e;
            }
            Or(tt, nt, dt, ht);
          }
          nt = nt.child;
        }
        return nt;
      case 5:
        return (
          sp(nt),
          tt === null && nu(nt),
          (dt = nt.type),
          (yt = nt.pendingProps),
          (At = tt !== null ? tt.memoizedProps : null),
          (Nt = yt.children),
          Jt(dt, yt)
            ? (Nt = null)
            : At !== null && Jt(dt, At) && (nt.flags |= 32),
          Dp(tt, nt),
          Or(tt, nt, Nt, ht),
          nt.child
        );
      case 6:
        return tt === null && nu(nt), null;
      case 13:
        return Vp(tt, nt, ht);
      case 4:
        return (
          iu(nt, nt.stateNode.containerInfo),
          (dt = nt.pendingProps),
          tt === null ? (nt.child = Ks(nt, null, dt, ht)) : Or(tt, nt, dt, ht),
          nt.child
        );
      case 11:
        return (
          (dt = nt.type),
          (yt = nt.pendingProps),
          (yt = nt.elementType === dt ? yt : rs(dt, yt)),
          Ip(tt, nt, dt, yt, ht)
        );
      case 7:
        return Or(tt, nt, nt.pendingProps, ht), nt.child;
      case 8:
        return Or(tt, nt, nt.pendingProps.children, ht), nt.child;
      case 12:
        return Or(tt, nt, nt.pendingProps.children, ht), nt.child;
      case 10:
        e: {
          if (
            ((dt = nt.type._context),
            (yt = nt.pendingProps),
            (At = nt.memoizedProps),
            (Nt = yt.value),
            $u(nt, dt, Nt),
            At !== null)
          )
            if (as(At.value, Nt)) {
              if (At.children === yt.children && !dr.current) {
                nt = xs(tt, nt, ht);
                break e;
              }
            } else
              for (
                At = nt.child, At !== null && (At.return = nt);
                At !== null;

              ) {
                var jt = At.dependencies;
                if (jt !== null) {
                  Nt = At.child;
                  for (var rn = jt.firstContext; rn !== null; ) {
                    if (rn.context === dt) {
                      if (At.tag === 1) {
                        (rn = ms(-1, ht & -ht)), (rn.tag = 2);
                        var Sn = At.updateQueue;
                        if (Sn !== null) {
                          Sn = Sn.shared;
                          var Dn = Sn.pending;
                          Dn === null
                            ? (rn.next = rn)
                            : ((rn.next = Dn.next), (Dn.next = rn)),
                            (Sn.pending = rn);
                        }
                      }
                      (At.lanes |= ht),
                        (rn = At.alternate),
                        rn !== null && (rn.lanes |= ht),
                        Jl(At.return, ht, nt),
                        (jt.lanes |= ht);
                      break;
                    }
                    rn = rn.next;
                  }
                } else if (At.tag === 10)
                  Nt = At.type === nt.type ? null : At.child;
                else if (At.tag === 18) {
                  if (((Nt = At.return), Nt === null)) throw Error(g(341));
                  (Nt.lanes |= ht),
                    (jt = Nt.alternate),
                    jt !== null && (jt.lanes |= ht),
                    Jl(Nt, ht, nt),
                    (Nt = At.sibling);
                } else Nt = At.child;
                if (Nt !== null) Nt.return = At;
                else
                  for (Nt = At; Nt !== null; ) {
                    if (Nt === nt) {
                      Nt = null;
                      break;
                    }
                    if (((At = Nt.sibling), At !== null)) {
                      (At.return = Nt.return), (Nt = At);
                      break;
                    }
                    Nt = Nt.return;
                  }
                At = Nt;
              }
          Or(tt, nt, yt.children, ht), (nt = nt.child);
        }
        return nt;
      case 9:
        return (
          (yt = nt.type),
          (dt = nt.pendingProps.children),
          Hs(nt, ht),
          (yt = Jr(yt)),
          (dt = dt(yt)),
          (nt.flags |= 1),
          Or(tt, nt, dt, ht),
          nt.child
        );
      case 14:
        return (
          (dt = nt.type),
          (yt = rs(dt, nt.pendingProps)),
          (yt = rs(dt.type, yt)),
          Lp(tt, nt, dt, yt, ht)
        );
      case 15:
        return Fp(tt, nt, nt.type, nt.pendingProps, ht);
      case 17:
        return (
          (dt = nt.type),
          (yt = nt.pendingProps),
          (yt = nt.elementType === dt ? yt : rs(dt, yt)),
          tt !== null &&
            ((tt.alternate = null), (nt.alternate = null), (nt.flags |= 2)),
          (nt.tag = 1),
          br(dt) ? ((tt = !0), Br(nt)) : (tt = !1),
          Hs(nt, ht),
          Qu(nt, dt, yt),
          Zl(nt, dt, yt, ht),
          vu(null, nt, dt, !0, tt, ht)
        );
      case 19:
        return Hp(tt, nt, ht);
      case 22:
        return kp(tt, nt, ht);
    }
    throw Error(g(156, nt.tag));
  };
  function mm(tt, nt) {
    return Gl(tt, nt);
  }
  function i0(tt, nt, ht, dt) {
    (this.tag = tt),
      (this.key = ht),
      (this.sibling =
        this.child =
        this.return =
        this.stateNode =
        this.type =
        this.elementType =
          null),
      (this.index = 0),
      (this.ref = null),
      (this.pendingProps = nt),
      (this.dependencies =
        this.memoizedState =
        this.updateQueue =
        this.memoizedProps =
          null),
      (this.mode = dt),
      (this.subtreeFlags = this.flags = 0),
      (this.deletions = null),
      (this.childLanes = this.lanes = 0),
      (this.alternate = null);
  }
  function es(tt, nt, ht, dt) {
    return new i0(tt, nt, ht, dt);
  }
  function Uu(tt) {
    return (tt = tt.prototype), !(!tt || !tt.isReactComponent);
  }
  function s0(tt) {
    if (typeof tt == "function") return Uu(tt) ? 1 : 0;
    if (tt != null) {
      if (((tt = tt.$$typeof), tt === at)) return 11;
      if (tt === lt) return 14;
    }
    return 2;
  }
  function bs(tt, nt) {
    var ht = tt.alternate;
    return (
      ht === null
        ? ((ht = es(tt.tag, nt, tt.key, tt.mode)),
          (ht.elementType = tt.elementType),
          (ht.type = tt.type),
          (ht.stateNode = tt.stateNode),
          (ht.alternate = tt),
          (tt.alternate = ht))
        : ((ht.pendingProps = nt),
          (ht.type = tt.type),
          (ht.flags = 0),
          (ht.subtreeFlags = 0),
          (ht.deletions = null)),
      (ht.flags = tt.flags & 14680064),
      (ht.childLanes = tt.childLanes),
      (ht.lanes = tt.lanes),
      (ht.child = tt.child),
      (ht.memoizedProps = tt.memoizedProps),
      (ht.memoizedState = tt.memoizedState),
      (ht.updateQueue = tt.updateQueue),
      (nt = tt.dependencies),
      (ht.dependencies =
        nt === null
          ? null
          : { lanes: nt.lanes, firstContext: nt.firstContext }),
      (ht.sibling = tt.sibling),
      (ht.index = tt.index),
      (ht.ref = tt.ref),
      ht
    );
  }
  function Il(tt, nt, ht, dt, yt, At) {
    var Nt = 2;
    if (((dt = tt), typeof tt == "function")) Uu(tt) && (Nt = 1);
    else if (typeof tt == "string") Nt = 5;
    else
      e: switch (tt) {
        case $:
          return Ns(ht.children, yt, At, nt);
        case _e:
          (Nt = 8), (yt |= 8);
          break;
        case et:
          return (
            (tt = es(12, ht, nt, yt | 2)),
            (tt.elementType = et),
            (tt.lanes = At),
            tt
          );
        case ct:
          return (
            (tt = es(13, ht, nt, yt)),
            (tt.elementType = ct),
            (tt.lanes = At),
            tt
          );
        case it:
          return (
            (tt = es(19, ht, nt, yt)),
            (tt.elementType = it),
            (tt.lanes = At),
            tt
          );
        case ut:
          return Ll(ht, yt, At, nt);
        default:
          if (typeof tt == "object" && tt !== null)
            switch (tt.$$typeof) {
              case rt:
                Nt = 10;
                break e;
              case st:
                Nt = 9;
                break e;
              case at:
                Nt = 11;
                break e;
              case lt:
                Nt = 14;
                break e;
              case ot:
                (Nt = 16), (dt = null);
                break e;
            }
          throw Error(g(130, tt == null ? tt : typeof tt, ""));
      }
    return (
      (nt = es(Nt, ht, nt, yt)),
      (nt.elementType = tt),
      (nt.type = dt),
      (nt.lanes = At),
      nt
    );
  }
  function Ns(tt, nt, ht, dt) {
    return (tt = es(7, tt, dt, nt)), (tt.lanes = ht), tt;
  }
  function Ll(tt, nt, ht, dt) {
    return (
      (tt = es(22, tt, dt, nt)),
      (tt.elementType = ut),
      (tt.lanes = ht),
      (tt.stateNode = {}),
      tt
    );
  }
  function Vu(tt, nt, ht) {
    return (tt = es(6, tt, null, nt)), (tt.lanes = ht), tt;
  }
  function Gu(tt, nt, ht) {
    return (
      (nt = es(4, tt.children !== null ? tt.children : [], tt.key, nt)),
      (nt.lanes = ht),
      (nt.stateNode = {
        containerInfo: tt.containerInfo,
        pendingChildren: null,
        implementation: tt.implementation,
      }),
      nt
    );
  }
  function o0(tt, nt, ht, dt, yt) {
    (this.tag = nt),
      (this.containerInfo = tt),
      (this.finishedWork =
        this.pingCache =
        this.current =
        this.pendingChildren =
          null),
      (this.timeoutHandle = Tn),
      (this.callbackNode = this.pendingContext = this.context = null),
      (this.callbackPriority = 0),
      (this.eventTimes = Ul(0)),
      (this.expirationTimes = Ul(-1)),
      (this.entangledLanes =
        this.finishedLanes =
        this.mutableReadLanes =
        this.expiredLanes =
        this.pingedLanes =
        this.suspendedLanes =
        this.pendingLanes =
          0),
      (this.entanglements = Ul(0)),
      (this.identifierPrefix = dt),
      (this.onRecoverableError = yt),
      qt && (this.mutableSourceEagerHydrationData = null);
  }
  function gm(tt, nt, ht, dt, yt, At, Nt, jt, rn) {
    return (
      (tt = new o0(tt, nt, ht, jt, rn)),
      nt === 1 ? ((nt = 1), At === !0 && (nt |= 8)) : (nt = 0),
      (At = es(3, null, null, nt)),
      (tt.current = At),
      (At.stateNode = tt),
      (At.memoizedState = {
        element: dt,
        isDehydrated: ht,
        cache: null,
        transitions: null,
      }),
      Yl(At),
      tt
    );
  }
  function vm(tt) {
    if (!tt) return hr;
    tt = tt._reactInternals;
    e: {
      if (_t(tt) !== tt || tt.tag !== 1) throw Error(g(170));
      var nt = tt;
      do {
        switch (nt.tag) {
          case 3:
            nt = nt.stateNode.context;
            break e;
          case 1:
            if (br(nt.type)) {
              nt = nt.stateNode.__reactInternalMemoizedMergedChildContext;
              break e;
            }
        }
        nt = nt.return;
      } while (nt !== null);
      throw Error(g(171));
    }
    if (tt.tag === 1) {
      var ht = tt.type;
      if (br(ht)) return Gs(tt, ht, nt);
    }
    return nt;
  }
  function ym(tt) {
    var nt = tt._reactInternals;
    if (nt === void 0)
      throw typeof tt.render == "function"
        ? Error(g(188))
        : ((tt = Object.keys(tt).join(",")), Error(g(268, tt)));
    return (tt = Rt(nt)), tt === null ? null : tt.stateNode;
  }
  function xm(tt, nt) {
    if (((tt = tt.memoizedState), tt !== null && tt.dehydrated !== null)) {
      var ht = tt.retryLane;
      tt.retryLane = ht !== 0 && ht < nt ? ht : nt;
    }
  }
  function ju(tt, nt) {
    xm(tt, nt), (tt = tt.alternate) && xm(tt, nt);
  }
  function a0(tt) {
    return (tt = Rt(tt)), tt === null ? null : tt.stateNode;
  }
  function l0() {
    return null;
  }
  return (
    (o.attemptContinuousHydration = function (tt) {
      if (tt.tag === 13) {
        var nt = Ur();
        _i(tt, 134217728, nt), ju(tt, 134217728);
      }
    }),
    (o.attemptHydrationAtCurrentPriority = function (tt) {
      if (tt.tag === 13) {
        var nt = Ur(),
          ht = Cs(tt);
        _i(tt, ht, nt), ju(tt, ht);
      }
    }),
    (o.attemptSynchronousHydration = function (tt) {
      switch (tt.tag) {
        case 3:
          var nt = tt.stateNode;
          if (nt.current.memoizedState.isDehydrated) {
            var ht = ro(nt.pendingLanes);
            ht !== 0 &&
              (Vl(nt, ht | 1), jr(nt, wr()), !(nr & 6) && (eo(), ls()));
          }
          break;
        case 13:
          var dt = Ur();
          am(function () {
            return _i(tt, 1, dt);
          }),
            ju(tt, 1);
      }
    }),
    (o.batchedUpdates = function (tt, nt) {
      var ht = nr;
      nr |= 1;
      try {
        return tt(nt);
      } finally {
        (nr = ht), nr === 0 && (eo(), Io && ls());
      }
    }),
    (o.createComponentSelector = function (tt) {
      return { $$typeof: $a, value: tt };
    }),
    (o.createContainer = function (tt, nt, ht, dt, yt, At, Nt) {
      return gm(tt, nt, !1, null, ht, dt, yt, At, Nt);
    }),
    (o.createHasPseudoClassSelector = function (tt) {
      return { $$typeof: yl, value: tt };
    }),
    (o.createHydrationContainer = function (
      tt,
      nt,
      ht,
      dt,
      yt,
      At,
      Nt,
      jt,
      rn
    ) {
      return (
        (tt = gm(ht, dt, !0, tt, yt, At, Nt, jt, rn)),
        (tt.context = vm(null)),
        (ht = tt.current),
        (dt = Ur()),
        (yt = Cs(ht)),
        (At = ms(dt, yt)),
        (At.callback = nt ?? null),
        Es(ht, At),
        (tt.current.lanes = yt),
        io(tt, yt, dt),
        jr(tt, dt),
        tt
      );
    }),
    (o.createPortal = function (tt, nt, ht) {
      var dt =
        3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null;
      return {
        $$typeof: j,
        key: dt == null ? null : "" + dt,
        children: tt,
        containerInfo: nt,
        implementation: ht,
      };
    }),
    (o.createRoleSelector = function (tt) {
      return { $$typeof: xl, value: tt };
    }),
    (o.createTestNameSelector = function (tt) {
      return { $$typeof: _l, value: tt };
    }),
    (o.createTextSelector = function (tt) {
      return { $$typeof: Sl, value: tt };
    }),
    (o.deferredUpdates = function (tt) {
      var nt = sr,
        ht = _r.transition;
      try {
        return (_r.transition = null), (sr = 16), tt();
      } finally {
        (sr = nt), (_r.transition = ht);
      }
    }),
    (o.discreteUpdates = function (tt, nt, ht, dt, yt) {
      var At = sr,
        Nt = _r.transition;
      try {
        return (_r.transition = null), (sr = 1), tt(nt, ht, dt, yt);
      } finally {
        (sr = At), (_r.transition = Nt), nr === 0 && eo();
      }
    }),
    (o.findAllNodes = wu),
    (o.findBoundingRects = function (tt, nt) {
      if (!kt) throw Error(g(363));
      (nt = wu(tt, nt)), (tt = []);
      for (var ht = 0; ht < nt.length; ht++) tt.push(Kt(nt[ht]));
      for (nt = tt.length - 1; 0 < nt; nt--) {
        ht = tt[nt];
        for (
          var dt = ht.x,
            yt = dt + ht.width,
            At = ht.y,
            Nt = At + ht.height,
            jt = nt - 1;
          0 <= jt;
          jt--
        )
          if (nt !== jt) {
            var rn = tt[jt],
              Sn = rn.x,
              Dn = Sn + rn.width,
              Qn = rn.y,
              Xn = Qn + rn.height;
            if (dt >= Sn && At >= Qn && yt <= Dn && Nt <= Xn) {
              tt.splice(nt, 1);
              break;
            } else if (
              dt !== Sn ||
              ht.width !== rn.width ||
              Xn < At ||
              Qn > Nt
            ) {
              if (
                !(At !== Qn || ht.height !== rn.height || Dn < dt || Sn > yt)
              ) {
                Sn > dt && ((rn.width += Sn - dt), (rn.x = dt)),
                  Dn < yt && (rn.width = yt - Sn),
                  tt.splice(nt, 1);
                break;
              }
            } else {
              Qn > At && ((rn.height += Qn - At), (rn.y = At)),
                Xn < Nt && (rn.height = Nt - Qn),
                tt.splice(nt, 1);
              break;
            }
          }
      }
      return tt;
    }),
    (o.findHostInstance = ym),
    (o.findHostInstanceWithNoPortals = function (tt) {
      return (
        (tt = Mt(tt)),
        (tt = tt !== null ? Ot(tt) : null),
        tt === null ? null : tt.stateNode
      );
    }),
    (o.findHostInstanceWithWarning = function (tt) {
      return ym(tt);
    }),
    (o.flushControlled = function (tt) {
      var nt = nr;
      nr |= 1;
      var ht = _r.transition,
        dt = sr;
      try {
        (_r.transition = null), (sr = 1), tt();
      } finally {
        (sr = dt), (_r.transition = ht), (nr = nt), nr === 0 && (eo(), ls());
      }
    }),
    (o.flushPassiveEffects = Ds),
    (o.flushSync = am),
    (o.focusWithin = function (tt, nt) {
      if (!kt) throw Error(g(363));
      for (
        tt = Cu(tt), nt = im(tt, nt), nt = Array.from(nt), tt = 0;
        tt < nt.length;

      ) {
        var ht = nt[tt++];
        if (!sn(ht)) {
          if (ht.tag === 5 && bn(ht.stateNode)) return !0;
          for (ht = ht.child; ht !== null; ) nt.push(ht), (ht = ht.sibling);
        }
      }
      return !1;
    }),
    (o.getCurrentUpdatePriority = function () {
      return sr;
    }),
    (o.getFindAllNodesFailureDescription = function (tt, nt) {
      if (!kt) throw Error(g(363));
      var ht = 0,
        dt = [];
      tt = [Cu(tt), 0];
      for (var yt = 0; yt < tt.length; ) {
        var At = tt[yt++],
          Nt = tt[yt++],
          jt = nt[Nt];
        if (
          (At.tag !== 5 || !sn(At)) &&
          (Tu(At, jt) && (dt.push(bu(jt)), Nt++, Nt > ht && (ht = Nt)),
          Nt < nt.length)
        )
          for (At = At.child; At !== null; ) tt.push(At, Nt), (At = At.sibling);
      }
      if (ht < nt.length) {
        for (tt = []; ht < nt.length; ht++) tt.push(bu(nt[ht]));
        return (
          `findAllNodes was able to match part of the selector:
  ` +
          (dt.join(" > ") +
            `

No matching component was found for:
  `) +
          tt.join(" > ")
        );
      }
      return null;
    }),
    (o.getPublicRootInstance = function (tt) {
      if (((tt = tt.current), !tt.child)) return null;
      switch (tt.child.tag) {
        case 5:
          return Et(tt.child.stateNode);
        default:
          return tt.child.stateNode;
      }
    }),
    (o.injectIntoDevTools = function (tt) {
      if (
        ((tt = {
          bundleType: tt.bundleType,
          version: tt.version,
          rendererPackageName: tt.rendererPackageName,
          rendererConfig: tt.rendererConfig,
          overrideHookState: null,
          overrideHookStateDeletePath: null,
          overrideHookStateRenamePath: null,
          overrideProps: null,
          overridePropsDeletePath: null,
          overridePropsRenamePath: null,
          setErrorHandler: null,
          setSuspenseHandler: null,
          scheduleUpdate: null,
          currentDispatcherRef: _.ReactCurrentDispatcher,
          findHostInstanceByFiber: a0,
          findFiberByHostInstance: tt.findFiberByHostInstance || l0,
          findHostInstancesForRefresh: null,
          scheduleRefresh: null,
          scheduleRoot: null,
          setRefreshHandler: null,
          getCurrentFiber: null,
          reconcilerVersion: "18.0.0-fc46dba67-20220329",
        }),
        typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u")
      )
        tt = !1;
      else {
        var nt = __REACT_DEVTOOLS_GLOBAL_HOOK__;
        if (nt.isDisabled || !nt.supportsFiber) tt = !0;
        else {
          try {
            (Bo = nt.inject(tt)), (os = nt);
          } catch {}
          tt = !!nt.checkDCE;
        }
      }
      return tt;
    }),
    (o.isAlreadyRendering = function () {
      return !1;
    }),
    (o.observeVisibleRects = function (tt, nt, ht, dt) {
      if (!kt) throw Error(g(363));
      tt = wu(tt, nt);
      var yt = vn(tt, ht, dt).disconnect;
      return {
        disconnect: function () {
          yt();
        },
      };
    }),
    (o.registerMutableSourceForHydration = function (tt, nt) {
      var ht = nt._getVersion;
      (ht = ht(nt._source)),
        tt.mutableSourceEagerHydrationData == null
          ? (tt.mutableSourceEagerHydrationData = [nt, ht])
          : tt.mutableSourceEagerHydrationData.push(nt, ht);
    }),
    (o.runWithPriority = function (tt, nt) {
      var ht = sr;
      try {
        return (sr = tt), nt();
      } finally {
        sr = ht;
      }
    }),
    (o.shouldError = function () {
      return null;
    }),
    (o.shouldSuspend = function () {
      return !1;
    }),
    (o.updateContainer = function (tt, nt, ht, dt) {
      var yt = nt.current,
        At = Ur(),
        Nt = Cs(yt);
      return (
        (ht = vm(ht)),
        nt.context === null ? (nt.context = ht) : (nt.pendingContext = ht),
        (nt = ms(At, Nt)),
        (nt.payload = { element: tt }),
        (dt = dt === void 0 ? null : dt),
        dt !== null && (nt.callback = dt),
        Es(yt, nt),
        (tt = _i(yt, Nt, At)),
        tt !== null && Do(tt, yt, Nt),
        Nt
      );
    }),
    o
  );
};
reactReconciler.exports = reactReconciler_production_min;
var reactReconcilerExports = reactReconciler.exports;
const Reconciler = getDefaultExportFromCjs(reactReconcilerExports);
var scheduler = { exports: {} },
  scheduler_production_min = {};
/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ (function (s) {
  function e(mt, vt) {
    var Ct = mt.length;
    mt.push(vt);
    e: for (; 0 < Ct; ) {
      var Tt = (Ct - 1) >>> 1,
        Dt = mt[Tt];
      if (0 < c(Dt, vt)) (mt[Tt] = vt), (mt[Ct] = Dt), (Ct = Tt);
      else break e;
    }
  }
  function o(mt) {
    return mt.length === 0 ? null : mt[0];
  }
  function a(mt) {
    if (mt.length === 0) return null;
    var vt = mt[0],
      Ct = mt.pop();
    if (Ct !== vt) {
      mt[0] = Ct;
      e: for (var Tt = 0, Dt = mt.length, Wt = Dt >>> 1; Tt < Wt; ) {
        var Pt = 2 * (Tt + 1) - 1,
          Jt = mt[Pt],
          Gt = Pt + 1,
          en = mt[Gt];
        if (0 > c(Jt, Ct))
          Gt < Dt && 0 > c(en, Jt)
            ? ((mt[Tt] = en), (mt[Gt] = Ct), (Tt = Gt))
            : ((mt[Tt] = Jt), (mt[Pt] = Ct), (Tt = Pt));
        else if (Gt < Dt && 0 > c(en, Ct))
          (mt[Tt] = en), (mt[Gt] = Ct), (Tt = Gt);
        else break e;
      }
    }
    return vt;
  }
  function c(mt, vt) {
    var Ct = mt.sortIndex - vt.sortIndex;
    return Ct !== 0 ? Ct : mt.id - vt.id;
  }
  if (typeof performance == "object" && typeof performance.now == "function") {
    var d = performance;
    s.unstable_now = function () {
      return d.now();
    };
  } else {
    var g = Date,
      _ = g.now();
    s.unstable_now = function () {
      return g.now() - _;
    };
  }
  var b = [],
    j = [],
    $ = 1,
    _e = null,
    et = 3,
    rt = !1,
    st = !1,
    at = !1,
    ct = typeof setTimeout == "function" ? setTimeout : null,
    it = typeof clearTimeout == "function" ? clearTimeout : null,
    lt = typeof setImmediate < "u" ? setImmediate : null;
  typeof navigator < "u" &&
    navigator.scheduling !== void 0 &&
    navigator.scheduling.isInputPending !== void 0 &&
    navigator.scheduling.isInputPending.bind(navigator.scheduling);
  function ot(mt) {
    for (var vt = o(j); vt !== null; ) {
      if (vt.callback === null) a(j);
      else if (vt.startTime <= mt)
        a(j), (vt.sortIndex = vt.expirationTime), e(b, vt);
      else break;
      vt = o(j);
    }
  }
  function ut(mt) {
    if (((at = !1), ot(mt), !st))
      if (o(b) !== null) (st = !0), Et(pt);
      else {
        var vt = o(j);
        vt !== null && bt(ut, vt.startTime - mt);
      }
  }
  function pt(mt, vt) {
    (st = !1), at && ((at = !1), it(xt), (xt = -1)), (rt = !0);
    var Ct = et;
    try {
      for (
        ot(vt), _e = o(b);
        _e !== null && (!(_e.expirationTime > vt) || (mt && !Mt()));

      ) {
        var Tt = _e.callback;
        if (typeof Tt == "function") {
          (_e.callback = null), (et = _e.priorityLevel);
          var Dt = Tt(_e.expirationTime <= vt);
          (vt = s.unstable_now()),
            typeof Dt == "function" ? (_e.callback = Dt) : _e === o(b) && a(b),
            ot(vt);
        } else a(b);
        _e = o(b);
      }
      if (_e !== null) var Wt = !0;
      else {
        var Pt = o(j);
        Pt !== null && bt(ut, Pt.startTime - vt), (Wt = !1);
      }
      return Wt;
    } finally {
      (_e = null), (et = Ct), (rt = !1);
    }
  }
  var ft = !1,
    gt = null,
    xt = -1,
    _t = 5,
    St = -1;
  function Mt() {
    return !(s.unstable_now() - St < _t);
  }
  function Rt() {
    if (gt !== null) {
      var mt = s.unstable_now();
      St = mt;
      var vt = !0;
      try {
        vt = gt(!0, mt);
      } finally {
        vt ? Ft() : ((ft = !1), (gt = null));
      }
    } else ft = !1;
  }
  var Ft;
  if (typeof lt == "function")
    Ft = function () {
      lt(Rt);
    };
  else if (typeof MessageChannel < "u") {
    var Ot = new MessageChannel(),
      Lt = Ot.port2;
    (Ot.port1.onmessage = Rt),
      (Ft = function () {
        Lt.postMessage(null);
      });
  } else
    Ft = function () {
      ct(Rt, 0);
    };
  function Et(mt) {
    (gt = mt), ft || ((ft = !0), Ft());
  }
  function bt(mt, vt) {
    xt = ct(function () {
      mt(s.unstable_now());
    }, vt);
  }
  (s.unstable_IdlePriority = 5),
    (s.unstable_ImmediatePriority = 1),
    (s.unstable_LowPriority = 4),
    (s.unstable_NormalPriority = 3),
    (s.unstable_Profiling = null),
    (s.unstable_UserBlockingPriority = 2),
    (s.unstable_cancelCallback = function (mt) {
      mt.callback = null;
    }),
    (s.unstable_continueExecution = function () {
      st || rt || ((st = !0), Et(pt));
    }),
    (s.unstable_forceFrameRate = function (mt) {
      0 > mt || 125 < mt
        ? console.error(
            "forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"
          )
        : (_t = 0 < mt ? Math.floor(1e3 / mt) : 5);
    }),
    (s.unstable_getCurrentPriorityLevel = function () {
      return et;
    }),
    (s.unstable_getFirstCallbackNode = function () {
      return o(b);
    }),
    (s.unstable_next = function (mt) {
      switch (et) {
        case 1:
        case 2:
        case 3:
          var vt = 3;
          break;
        default:
          vt = et;
      }
      var Ct = et;
      et = vt;
      try {
        return mt();
      } finally {
        et = Ct;
      }
    }),
    (s.unstable_pauseExecution = function () {}),
    (s.unstable_requestPaint = function () {}),
    (s.unstable_runWithPriority = function (mt, vt) {
      switch (mt) {
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
          break;
        default:
          mt = 3;
      }
      var Ct = et;
      et = mt;
      try {
        return vt();
      } finally {
        et = Ct;
      }
    }),
    (s.unstable_scheduleCallback = function (mt, vt, Ct) {
      var Tt = s.unstable_now();
      switch (
        (typeof Ct == "object" && Ct !== null
          ? ((Ct = Ct.delay),
            (Ct = typeof Ct == "number" && 0 < Ct ? Tt + Ct : Tt))
          : (Ct = Tt),
        mt)
      ) {
        case 1:
          var Dt = -1;
          break;
        case 2:
          Dt = 250;
          break;
        case 5:
          Dt = 1073741823;
          break;
        case 4:
          Dt = 1e4;
          break;
        default:
          Dt = 5e3;
      }
      return (
        (Dt = Ct + Dt),
        (mt = {
          id: $++,
          callback: vt,
          priorityLevel: mt,
          startTime: Ct,
          expirationTime: Dt,
          sortIndex: -1,
        }),
        Ct > Tt
          ? ((mt.sortIndex = Ct),
            e(j, mt),
            o(b) === null &&
              mt === o(j) &&
              (at ? (it(xt), (xt = -1)) : (at = !0), bt(ut, Ct - Tt)))
          : ((mt.sortIndex = Dt), e(b, mt), st || rt || ((st = !0), Et(pt))),
        mt
      );
    }),
    (s.unstable_shouldYield = Mt),
    (s.unstable_wrapCallback = function (mt) {
      var vt = et;
      return function () {
        var Ct = et;
        et = vt;
        try {
          return mt.apply(this, arguments);
        } finally {
          et = Ct;
        }
      };
    });
})(scheduler_production_min);
scheduler.exports = scheduler_production_min;
var schedulerExports = scheduler.exports;
const isPromise = (s) => typeof s == "object" && typeof s.then == "function",
  globalCache = [];
function shallowEqualArrays(s, e, o = (a, c) => a === c) {
  if (s === e) return !0;
  if (!s || !e) return !1;
  const a = s.length;
  if (e.length !== a) return !1;
  for (let c = 0; c < a; c++) if (!o(s[c], e[c])) return !1;
  return !0;
}
function query(s, e = null, o = !1, a = {}) {
  e === null && (e = [s]);
  for (const d of globalCache)
    if (shallowEqualArrays(e, d.keys, d.equal)) {
      if (o) return;
      if (Object.prototype.hasOwnProperty.call(d, "error")) throw d.error;
      if (Object.prototype.hasOwnProperty.call(d, "response"))
        return (
          a.lifespan &&
            a.lifespan > 0 &&
            (d.timeout && clearTimeout(d.timeout),
            (d.timeout = setTimeout(d.remove, a.lifespan))),
          d.response
        );
      if (!o) throw d.promise;
    }
  const c = {
    keys: e,
    equal: a.equal,
    remove: () => {
      const d = globalCache.indexOf(c);
      d !== -1 && globalCache.splice(d, 1);
    },
    promise: (isPromise(s) ? s : s(...e))
      .then((d) => {
        (c.response = d),
          a.lifespan &&
            a.lifespan > 0 &&
            (c.timeout = setTimeout(c.remove, a.lifespan));
      })
      .catch((d) => (c.error = d)),
  };
  if ((globalCache.push(c), !o)) throw c.promise;
}
const suspend = (s, e, o) => query(s, e, !1, o),
  preload = (s, e, o) => void query(s, e, !0, o),
  clear = (s) => {
    if (s === void 0 || s.length === 0)
      globalCache.splice(0, globalCache.length);
    else {
      const e = globalCache.find((o) => shallowEqualArrays(s, o.keys, o.equal));
      e && e.remove();
    }
  },
  catalogue = {},
  extend = (s) => void Object.assign(catalogue, s);
function createRenderer(s, e) {
  function o($, { args: _e = [], attach: et, ...rt }, st) {
    let at = `${$[0].toUpperCase()}${$.slice(1)}`,
      ct;
    if ($ === "primitive") {
      if (rt.object === void 0)
        throw new Error("R3F: Primitives without 'object' are invalid!");
      const it = rt.object;
      ct = prepare(it, { type: $, root: st, attach: et, primitive: !0 });
    } else {
      const it = catalogue[at];
      if (!it)
        throw new Error(
          `R3F: ${at} is not part of the THREE namespace! Did you forget to extend? See: https://docs.pmnd.rs/react-three-fiber/api/objects#using-3rd-party-objects-declaratively`
        );
      if (!Array.isArray(_e))
        throw new Error("R3F: The args prop must be an array!");
      ct = prepare(new it(..._e), {
        type: $,
        root: st,
        attach: et,
        memoizedProps: { args: _e },
      });
    }
    return (
      ct.__r3f.attach === void 0 &&
        (ct instanceof BufferGeometry
          ? (ct.__r3f.attach = "geometry")
          : ct instanceof Material && (ct.__r3f.attach = "material")),
      at !== "inject" && applyProps$1(ct, rt),
      ct
    );
  }
  function a($, _e) {
    let et = !1;
    if (_e) {
      var rt, st;
      (rt = _e.__r3f) != null && rt.attach
        ? attach($, _e, _e.__r3f.attach)
        : _e.isObject3D && $.isObject3D && ($.add(_e), (et = !0)),
        et || (st = $.__r3f) == null || st.objects.push(_e),
        _e.__r3f || prepare(_e, {}),
        (_e.__r3f.parent = $),
        updateInstance(_e),
        invalidateInstance(_e);
    }
  }
  function c($, _e, et) {
    let rt = !1;
    if (_e) {
      var st, at;
      if ((st = _e.__r3f) != null && st.attach) attach($, _e, _e.__r3f.attach);
      else if (_e.isObject3D && $.isObject3D) {
        (_e.parent = $),
          _e.dispatchEvent({ type: "added" }),
          $.dispatchEvent({ type: "childadded", child: _e });
        const ct = $.children.filter((lt) => lt !== _e),
          it = ct.indexOf(et);
        ($.children = [...ct.slice(0, it), _e, ...ct.slice(it)]), (rt = !0);
      }
      rt || (at = $.__r3f) == null || at.objects.push(_e),
        _e.__r3f || prepare(_e, {}),
        (_e.__r3f.parent = $),
        updateInstance(_e),
        invalidateInstance(_e);
    }
  }
  function d($, _e, et = !1) {
    $ && [...$].forEach((rt) => g(_e, rt, et));
  }
  function g($, _e, et) {
    if (_e) {
      var rt, st, at;
      if (
        (_e.__r3f && (_e.__r3f.parent = null),
        (rt = $.__r3f) != null &&
          rt.objects &&
          ($.__r3f.objects = $.__r3f.objects.filter((ut) => ut !== _e)),
        (st = _e.__r3f) != null && st.attach)
      )
        detach($, _e, _e.__r3f.attach);
      else if (_e.isObject3D && $.isObject3D) {
        var ct;
        $.remove(_e),
          (ct = _e.__r3f) != null &&
            ct.root &&
            removeInteractivity(findInitialRoot(_e), _e);
      }
      const lt = (at = _e.__r3f) == null ? void 0 : at.primitive,
        ot = !lt && (et === void 0 ? _e.dispose !== null : et);
      if (!lt) {
        var it;
        d((it = _e.__r3f) == null ? void 0 : it.objects, _e, ot),
          d(_e.children, _e, ot);
      }
      if ((delete _e.__r3f, ot && _e.dispose && _e.type !== "Scene")) {
        const ut = () => {
          try {
            _e.dispose();
          } catch {}
        };
        typeof IS_REACT_ACT_ENVIRONMENT > "u"
          ? schedulerExports.unstable_scheduleCallback(
              schedulerExports.unstable_IdlePriority,
              ut
            )
          : ut();
      }
      invalidateInstance($);
    }
  }
  function _($, _e, et, rt) {
    var st;
    const at = (st = $.__r3f) == null ? void 0 : st.parent;
    if (!at) return;
    const ct = o(_e, et, $.__r3f.root);
    if ($.children) {
      for (const it of $.children) it.__r3f && a(ct, it);
      $.children = $.children.filter((it) => !it.__r3f);
    }
    $.__r3f.objects.forEach((it) => a(ct, it)),
      ($.__r3f.objects = []),
      $.__r3f.autoRemovedBeforeAppend || g(at, $),
      ct.parent && (ct.__r3f.autoRemovedBeforeAppend = !0),
      a(at, ct),
      ct.raycast &&
        ct.__r3f.eventCount &&
        findInitialRoot(ct).getState().internal.interaction.push(ct),
      [rt, rt.alternate].forEach((it) => {
        it !== null &&
          ((it.stateNode = ct),
          it.ref &&
            (typeof it.ref == "function" ? it.ref(ct) : (it.ref.current = ct)));
      });
  }
  const b = () =>
    console.warn(
      "Text is not allowed in the R3F tree! This could be stray whitespace or characters."
    );
  return {
    reconciler: Reconciler({
      createInstance: o,
      removeChild: g,
      appendChild: a,
      appendInitialChild: a,
      insertBefore: c,
      supportsMutation: !0,
      isPrimaryRenderer: !1,
      supportsPersistence: !1,
      supportsHydration: !1,
      noTimeout: -1,
      appendChildToContainer: ($, _e) => {
        if (!_e) return;
        const et = $.getState().scene;
        et.__r3f && ((et.__r3f.root = $), a(et, _e));
      },
      removeChildFromContainer: ($, _e) => {
        _e && g($.getState().scene, _e);
      },
      insertInContainerBefore: ($, _e, et) => {
        if (!_e || !et) return;
        const rt = $.getState().scene;
        rt.__r3f && c(rt, _e, et);
      },
      getRootHostContext: () => null,
      getChildHostContext: ($) => $,
      finalizeInitialChildren($) {
        var _e;
        return !!((_e = $ == null ? void 0 : $.__r3f) != null ? _e : {})
          .handlers;
      },
      prepareUpdate($, _e, et, rt) {
        var st;
        if (
          ((st = $ == null ? void 0 : $.__r3f) != null ? st : {}).primitive &&
          rt.object &&
          rt.object !== $
        )
          return [!0];
        {
          const { args: ct = [], children: it, ...lt } = rt,
            { args: ot = [], children: ut, ...pt } = et;
          if (!Array.isArray(ct))
            throw new Error("R3F: the args prop must be an array!");
          if (ct.some((gt, xt) => gt !== ot[xt])) return [!0];
          const ft = diffProps($, lt, pt, !0);
          return ft.changes.length ? [!1, ft] : null;
        }
      },
      commitUpdate($, [_e, et], rt, st, at, ct) {
        _e ? _($, rt, at, ct) : applyProps$1($, et);
      },
      commitMount($, _e, et, rt) {
        var st;
        const at = (st = $.__r3f) != null ? st : {};
        $.raycast &&
          at.handlers &&
          at.eventCount &&
          findInitialRoot($).getState().internal.interaction.push($);
      },
      getPublicInstance: ($) => $,
      prepareForCommit: () => null,
      preparePortalMount: ($) => prepare($.getState().scene),
      resetAfterCommit: () => {},
      shouldSetTextContent: () => !1,
      clearContainer: () => !1,
      hideInstance($) {
        var _e;
        const { attach: et, parent: rt } = (_e = $.__r3f) != null ? _e : {};
        et && rt && detach(rt, $, et),
          $.isObject3D && ($.visible = !1),
          invalidateInstance($);
      },
      unhideInstance($, _e) {
        var et;
        const { attach: rt, parent: st } = (et = $.__r3f) != null ? et : {};
        rt && st && attach(st, $, rt),
          (($.isObject3D && _e.visible == null) || _e.visible) &&
            ($.visible = !0),
          invalidateInstance($);
      },
      createTextInstance: b,
      hideTextInstance: b,
      unhideTextInstance: b,
      getCurrentEventPriority: () =>
        e ? e() : constantsExports.DefaultEventPriority,
      beforeActiveInstanceBlur: () => {},
      afterActiveInstanceBlur: () => {},
      detachDeletedInstance: () => {},
      now:
        typeof performance < "u" && is.fun(performance.now)
          ? performance.now
          : is.fun(Date.now)
          ? Date.now
          : () => 0,
      scheduleTimeout: is.fun(setTimeout) ? setTimeout : void 0,
      cancelTimeout: is.fun(clearTimeout) ? clearTimeout : void 0,
    }),
    applyProps: applyProps$1,
  };
}
var _window$document, _window$navigator;
const hasColorSpace = (s) => "colorSpace" in s || "outputColorSpace" in s,
  getColorManagement = () => {
    var s;
    return (s = catalogue.ColorManagement) != null ? s : null;
  },
  isOrthographicCamera = (s) => s && s.isOrthographicCamera,
  isRef = (s) => s && s.hasOwnProperty("current"),
  useIsomorphicLayoutEffect =
    typeof window < "u" &&
    (((_window$document = window.document) != null &&
      _window$document.createElement) ||
      ((_window$navigator = window.navigator) == null
        ? void 0
        : _window$navigator.product) === "ReactNative")
      ? reactExports$1.useLayoutEffect
      : reactExports$1.useEffect;
function useMutableCallback(s) {
  const e = reactExports$1.useRef(s);
  return useIsomorphicLayoutEffect(() => void (e.current = s), [s]), e;
}
function Block({ set: s }) {
  return (
    useIsomorphicLayoutEffect(
      () => (s(new Promise(() => null)), () => s(!1)),
      [s]
    ),
    null
  );
}
class ErrorBoundary extends reactExports$1.Component {
  constructor(...e) {
    super(...e), (this.state = { error: !1 });
  }
  componentDidCatch(e) {
    this.props.set(e);
  }
  render() {
    return this.state.error ? null : this.props.children;
  }
}
ErrorBoundary.getDerivedStateFromError = () => ({ error: !0 });
const DEFAULT = "__default",
  DEFAULTS = new Map(),
  isDiffSet = (s) => s && !!s.memoized && !!s.changes;
function calculateDpr(s) {
  var e;
  const o =
    typeof window < "u" ? ((e = window.devicePixelRatio) != null ? e : 2) : 1;
  return Array.isArray(s) ? Math.min(Math.max(s[0], o), s[1]) : s;
}
const getRootState = (s) => {
  var e;
  return (e = s.__r3f) == null ? void 0 : e.root.getState();
};
function findInitialRoot(s) {
  let e = s.__r3f.root;
  for (; e.getState().previousRoot; ) e = e.getState().previousRoot;
  return e;
}
const is = {
  obj: (s) => s === Object(s) && !is.arr(s) && typeof s != "function",
  fun: (s) => typeof s == "function",
  str: (s) => typeof s == "string",
  num: (s) => typeof s == "number",
  boo: (s) => typeof s == "boolean",
  und: (s) => s === void 0,
  arr: (s) => Array.isArray(s),
  equ(
    s,
    e,
    { arrays: o = "shallow", objects: a = "reference", strict: c = !0 } = {}
  ) {
    if (typeof s != typeof e || !!s != !!e) return !1;
    if (is.str(s) || is.num(s) || is.boo(s)) return s === e;
    const d = is.obj(s);
    if (d && a === "reference") return s === e;
    const g = is.arr(s);
    if (g && o === "reference") return s === e;
    if ((g || d) && s === e) return !0;
    let _;
    for (_ in s) if (!(_ in e)) return !1;
    if (d && o === "shallow" && a === "shallow") {
      for (_ in c ? e : s)
        if (!is.equ(s[_], e[_], { strict: c, objects: "reference" })) return !1;
    } else for (_ in c ? e : s) if (s[_] !== e[_]) return !1;
    if (is.und(_)) {
      if (
        (g && s.length === 0 && e.length === 0) ||
        (d && Object.keys(s).length === 0 && Object.keys(e).length === 0)
      )
        return !0;
      if (s !== e) return !1;
    }
    return !0;
  },
};
function buildGraph(s) {
  const e = { nodes: {}, materials: {} };
  return (
    s &&
      s.traverse((o) => {
        o.name && (e.nodes[o.name] = o),
          o.material &&
            !e.materials[o.material.name] &&
            (e.materials[o.material.name] = o.material);
      }),
    e
  );
}
function dispose(s) {
  s.dispose && s.type !== "Scene" && s.dispose();
  for (const e in s) e.dispose == null || e.dispose(), delete s[e];
}
function prepare(s, e) {
  const o = s;
  return (
    (o.__r3f = {
      type: "",
      root: null,
      previousAttach: null,
      memoizedProps: {},
      eventCount: 0,
      handlers: {},
      objects: [],
      parent: null,
      ...e,
    }),
    s
  );
}
function resolve(s, e) {
  let o = s;
  if (e.includes("-")) {
    const a = e.split("-"),
      c = a.pop();
    return (o = a.reduce((d, g) => d[g], s)), { target: o, key: c };
  } else return { target: o, key: e };
}
const INDEX_REGEX = /-\d+$/;
function attach(s, e, o) {
  if (is.str(o)) {
    if (INDEX_REGEX.test(o)) {
      const d = o.replace(INDEX_REGEX, ""),
        { target: g, key: _ } = resolve(s, d);
      Array.isArray(g[_]) || (g[_] = []);
    }
    const { target: a, key: c } = resolve(s, o);
    (e.__r3f.previousAttach = a[c]), (a[c] = e);
  } else e.__r3f.previousAttach = o(s, e);
}
function detach(s, e, o) {
  var a, c;
  if (is.str(o)) {
    const { target: d, key: g } = resolve(s, o),
      _ = e.__r3f.previousAttach;
    _ === void 0 ? delete d[g] : (d[g] = _);
  } else
    (a = e.__r3f) == null || a.previousAttach == null || a.previousAttach(s, e);
  (c = e.__r3f) == null || delete c.previousAttach;
}
function diffProps(
  s,
  { children: e, key: o, ref: a, ...c },
  { children: d, key: g, ref: _, ...b } = {},
  j = !1
) {
  const $ = s.__r3f,
    _e = Object.entries(c),
    et = [];
  if (j) {
    const st = Object.keys(b);
    for (let at = 0; at < st.length; at++)
      c.hasOwnProperty(st[at]) || _e.unshift([st[at], DEFAULT + "remove"]);
  }
  _e.forEach(([st, at]) => {
    var ct;
    if (
      ((ct = s.__r3f) != null && ct.primitive && st === "object") ||
      is.equ(at, b[st])
    )
      return;
    if (/^on(Pointer|Click|DoubleClick|ContextMenu|Wheel)/.test(st))
      return et.push([st, at, !0, []]);
    let it = [];
    st.includes("-") && (it = st.split("-")), et.push([st, at, !1, it]);
    for (const lt in c) {
      const ot = c[lt];
      lt.startsWith(`${st}-`) && et.push([lt, ot, !1, lt.split("-")]);
    }
  });
  const rt = { ...c };
  return (
    $ != null &&
      $.memoizedProps &&
      $ != null &&
      $.memoizedProps.args &&
      (rt.args = $.memoizedProps.args),
    $ != null &&
      $.memoizedProps &&
      $ != null &&
      $.memoizedProps.attach &&
      (rt.attach = $.memoizedProps.attach),
    { memoized: rt, changes: et }
  );
}
const __DEV__ = typeof process < "u" && !1;
function applyProps$1(s, e) {
  var o;
  const a = s.__r3f,
    c = a == null ? void 0 : a.root,
    d = c == null || c.getState == null ? void 0 : c.getState(),
    { memoized: g, changes: _ } = isDiffSet(e) ? e : diffProps(s, e),
    b = a == null ? void 0 : a.eventCount;
  s.__r3f && (s.__r3f.memoizedProps = g);
  for (let $ = 0; $ < _.length; $++) {
    let [_e, et, rt, st] = _[$];
    if (hasColorSpace(s)) {
      const lt = "srgb",
        ot = "srgb-linear";
      _e === "encoding"
        ? ((_e = "colorSpace"), (et = et === 3001 ? lt : ot))
        : _e === "outputEncoding" &&
          ((_e = "outputColorSpace"), (et = et === 3001 ? lt : ot));
    }
    let at = s,
      ct = at[_e];
    if (
      st.length &&
      ((ct = st.reduce((it, lt) => it[lt], s)), !(ct && ct.set))
    ) {
      const [it, ...lt] = st.reverse();
      (at = lt.reverse().reduce((ot, ut) => ot[ut], s)), (_e = it);
    }
    if (et === DEFAULT + "remove")
      if (at.constructor) {
        let it = DEFAULTS.get(at.constructor);
        it || ((it = new at.constructor()), DEFAULTS.set(at.constructor, it)),
          (et = it[_e]);
      } else et = 0;
    if (rt && a)
      et ? (a.handlers[_e] = et) : delete a.handlers[_e],
        (a.eventCount = Object.keys(a.handlers).length);
    else if (ct && ct.set && (ct.copy || ct instanceof Layers)) {
      if (Array.isArray(et)) ct.fromArray ? ct.fromArray(et) : ct.set(...et);
      else if (
        ct.copy &&
        et &&
        et.constructor &&
        (__DEV__
          ? ct.constructor.name === et.constructor.name
          : ct.constructor === et.constructor)
      )
        ct.copy(et);
      else if (et !== void 0) {
        const it = ct instanceof Color;
        !it && ct.setScalar
          ? ct.setScalar(et)
          : ct instanceof Layers && et instanceof Layers
          ? (ct.mask = et.mask)
          : ct.set(et),
          !getColorManagement() &&
            d &&
            !d.linear &&
            it &&
            ct.convertSRGBToLinear();
      }
    } else if (
      ((at[_e] = et),
      at[_e] instanceof Texture &&
        at[_e].format === RGBAFormat &&
        at[_e].type === UnsignedByteType &&
        d)
    ) {
      const it = at[_e];
      hasColorSpace(it) && hasColorSpace(d.gl)
        ? (it.colorSpace = d.gl.outputColorSpace)
        : (it.encoding = d.gl.outputEncoding);
    }
    invalidateInstance(s);
  }
  if (a && a.parent && s.raycast && b !== a.eventCount) {
    const $ = findInitialRoot(s).getState().internal,
      _e = $.interaction.indexOf(s);
    _e > -1 && $.interaction.splice(_e, 1),
      a.eventCount && $.interaction.push(s);
  }
  return (
    !(_.length === 1 && _[0][0] === "onUpdate") &&
      _.length &&
      (o = s.__r3f) != null &&
      o.parent &&
      updateInstance(s),
    s
  );
}
function invalidateInstance(s) {
  var e, o;
  const a =
    (e = s.__r3f) == null || (o = e.root) == null || o.getState == null
      ? void 0
      : o.getState();
  a && a.internal.frames === 0 && a.invalidate();
}
function updateInstance(s) {
  s.onUpdate == null || s.onUpdate(s);
}
function updateCamera(s, e) {
  s.manual ||
    (isOrthographicCamera(s)
      ? ((s.left = e.width / -2),
        (s.right = e.width / 2),
        (s.top = e.height / 2),
        (s.bottom = e.height / -2))
      : (s.aspect = e.width / e.height),
    s.updateProjectionMatrix(),
    s.updateMatrixWorld());
}
function makeId(s) {
  return (s.eventObject || s.object).uuid + "/" + s.index + s.instanceId;
}
function getEventPriority() {
  var s;
  const e = (typeof self < "u" && self) || (typeof window < "u" && window);
  if (!e) return constantsExports.DefaultEventPriority;
  switch ((s = e.event) == null ? void 0 : s.type) {
    case "click":
    case "contextmenu":
    case "dblclick":
    case "pointercancel":
    case "pointerdown":
    case "pointerup":
      return constantsExports.DiscreteEventPriority;
    case "pointermove":
    case "pointerout":
    case "pointerover":
    case "pointerenter":
    case "pointerleave":
    case "wheel":
      return constantsExports.ContinuousEventPriority;
    default:
      return constantsExports.DefaultEventPriority;
  }
}
function releaseInternalPointerCapture(s, e, o, a) {
  const c = o.get(e);
  c &&
    (o.delete(e),
    o.size === 0 && (s.delete(a), c.target.releasePointerCapture(a)));
}
function removeInteractivity(s, e) {
  const { internal: o } = s.getState();
  (o.interaction = o.interaction.filter((a) => a !== e)),
    (o.initialHits = o.initialHits.filter((a) => a !== e)),
    o.hovered.forEach((a, c) => {
      (a.eventObject === e || a.object === e) && o.hovered.delete(c);
    }),
    o.capturedMap.forEach((a, c) => {
      releaseInternalPointerCapture(o.capturedMap, e, a, c);
    });
}
function createEvents(s) {
  function e(b) {
    const { internal: j } = s.getState(),
      $ = b.offsetX - j.initialClick[0],
      _e = b.offsetY - j.initialClick[1];
    return Math.round(Math.sqrt($ * $ + _e * _e));
  }
  function o(b) {
    return b.filter((j) =>
      ["Move", "Over", "Enter", "Out", "Leave"].some(($) => {
        var _e;
        return (_e = j.__r3f) == null ? void 0 : _e.handlers["onPointer" + $];
      })
    );
  }
  function a(b, j) {
    const $ = s.getState(),
      _e = new Set(),
      et = [],
      rt = j ? j($.internal.interaction) : $.internal.interaction;
    for (let it = 0; it < rt.length; it++) {
      const lt = getRootState(rt[it]);
      lt && (lt.raycaster.camera = void 0);
    }
    $.previousRoot || $.events.compute == null || $.events.compute(b, $);
    function st(it) {
      const lt = getRootState(it);
      if (!lt || !lt.events.enabled || lt.raycaster.camera === null) return [];
      if (lt.raycaster.camera === void 0) {
        var ot;
        lt.events.compute == null ||
          lt.events.compute(
            b,
            lt,
            (ot = lt.previousRoot) == null ? void 0 : ot.getState()
          ),
          lt.raycaster.camera === void 0 && (lt.raycaster.camera = null);
      }
      return lt.raycaster.camera ? lt.raycaster.intersectObject(it, !0) : [];
    }
    let at = rt
      .flatMap(st)
      .sort((it, lt) => {
        const ot = getRootState(it.object),
          ut = getRootState(lt.object);
        return !ot || !ut
          ? it.distance - lt.distance
          : ut.events.priority - ot.events.priority ||
              it.distance - lt.distance;
      })
      .filter((it) => {
        const lt = makeId(it);
        return _e.has(lt) ? !1 : (_e.add(lt), !0);
      });
    $.events.filter && (at = $.events.filter(at, $));
    for (const it of at) {
      let lt = it.object;
      for (; lt; ) {
        var ct;
        (ct = lt.__r3f) != null &&
          ct.eventCount &&
          et.push({ ...it, eventObject: lt }),
          (lt = lt.parent);
      }
    }
    if ("pointerId" in b && $.internal.capturedMap.has(b.pointerId))
      for (let it of $.internal.capturedMap.get(b.pointerId).values())
        _e.has(makeId(it.intersection)) || et.push(it.intersection);
    return et;
  }
  function c(b, j, $, _e) {
    const et = s.getState();
    if (b.length) {
      const rt = { stopped: !1 };
      for (const st of b) {
        const at = getRootState(st.object) || et,
          { raycaster: ct, pointer: it, camera: lt, internal: ot } = at,
          ut = new Vector3(it.x, it.y, 0).unproject(lt),
          pt = (St) => {
            var Mt, Rt;
            return (Mt =
              (Rt = ot.capturedMap.get(St)) == null
                ? void 0
                : Rt.has(st.eventObject)) != null
              ? Mt
              : !1;
          },
          ft = (St) => {
            const Mt = { intersection: st, target: j.target };
            ot.capturedMap.has(St)
              ? ot.capturedMap.get(St).set(st.eventObject, Mt)
              : ot.capturedMap.set(St, new Map([[st.eventObject, Mt]])),
              j.target.setPointerCapture(St);
          },
          gt = (St) => {
            const Mt = ot.capturedMap.get(St);
            Mt &&
              releaseInternalPointerCapture(
                ot.capturedMap,
                st.eventObject,
                Mt,
                St
              );
          };
        let xt = {};
        for (let St in j) {
          let Mt = j[St];
          typeof Mt != "function" && (xt[St] = Mt);
        }
        let _t = {
          ...st,
          ...xt,
          pointer: it,
          intersections: b,
          stopped: rt.stopped,
          delta: $,
          unprojectedPoint: ut,
          ray: ct.ray,
          camera: lt,
          stopPropagation() {
            const St = "pointerId" in j && ot.capturedMap.get(j.pointerId);
            if (
              (!St || St.has(st.eventObject)) &&
              ((_t.stopped = rt.stopped = !0),
              ot.hovered.size &&
                Array.from(ot.hovered.values()).find(
                  (Mt) => Mt.eventObject === st.eventObject
                ))
            ) {
              const Mt = b.slice(0, b.indexOf(st));
              d([...Mt, st]);
            }
          },
          target: {
            hasPointerCapture: pt,
            setPointerCapture: ft,
            releasePointerCapture: gt,
          },
          currentTarget: {
            hasPointerCapture: pt,
            setPointerCapture: ft,
            releasePointerCapture: gt,
          },
          nativeEvent: j,
        };
        if ((_e(_t), rt.stopped === !0)) break;
      }
    }
    return b;
  }
  function d(b) {
    const { internal: j } = s.getState();
    for (const $ of j.hovered.values())
      if (
        !b.length ||
        !b.find(
          (_e) =>
            _e.object === $.object &&
            _e.index === $.index &&
            _e.instanceId === $.instanceId
        )
      ) {
        const et = $.eventObject.__r3f,
          rt = et == null ? void 0 : et.handlers;
        if ((j.hovered.delete(makeId($)), et != null && et.eventCount)) {
          const st = { ...$, intersections: b };
          rt.onPointerOut == null || rt.onPointerOut(st),
            rt.onPointerLeave == null || rt.onPointerLeave(st);
        }
      }
  }
  function g(b, j) {
    for (let $ = 0; $ < j.length; $++) {
      const _e = j[$].__r3f;
      _e == null ||
        _e.handlers.onPointerMissed == null ||
        _e.handlers.onPointerMissed(b);
    }
  }
  function _(b) {
    switch (b) {
      case "onPointerLeave":
      case "onPointerCancel":
        return () => d([]);
      case "onLostPointerCapture":
        return (j) => {
          const { internal: $ } = s.getState();
          "pointerId" in j &&
            $.capturedMap.has(j.pointerId) &&
            requestAnimationFrame(() => {
              $.capturedMap.has(j.pointerId) &&
                ($.capturedMap.delete(j.pointerId), d([]));
            });
        };
    }
    return function ($) {
      const { onPointerMissed: _e, internal: et } = s.getState();
      et.lastEvent.current = $;
      const rt = b === "onPointerMove",
        st = b === "onClick" || b === "onContextMenu" || b === "onDoubleClick",
        ct = a($, rt ? o : void 0),
        it = st ? e($) : 0;
      b === "onPointerDown" &&
        ((et.initialClick = [$.offsetX, $.offsetY]),
        (et.initialHits = ct.map((ot) => ot.eventObject))),
        st && !ct.length && it <= 2 && (g($, et.interaction), _e && _e($)),
        rt && d(ct);
      function lt(ot) {
        const ut = ot.eventObject,
          pt = ut.__r3f,
          ft = pt == null ? void 0 : pt.handlers;
        if (pt != null && pt.eventCount)
          if (rt) {
            if (
              ft.onPointerOver ||
              ft.onPointerEnter ||
              ft.onPointerOut ||
              ft.onPointerLeave
            ) {
              const gt = makeId(ot),
                xt = et.hovered.get(gt);
              xt
                ? xt.stopped && ot.stopPropagation()
                : (et.hovered.set(gt, ot),
                  ft.onPointerOver == null || ft.onPointerOver(ot),
                  ft.onPointerEnter == null || ft.onPointerEnter(ot));
            }
            ft.onPointerMove == null || ft.onPointerMove(ot);
          } else {
            const gt = ft[b];
            gt
              ? (!st || et.initialHits.includes(ut)) &&
                (g(
                  $,
                  et.interaction.filter((xt) => !et.initialHits.includes(xt))
                ),
                gt(ot))
              : st &&
                et.initialHits.includes(ut) &&
                g(
                  $,
                  et.interaction.filter((xt) => !et.initialHits.includes(xt))
                );
          }
      }
      c(ct, $, it, lt);
    };
  }
  return { handlePointer: _ };
}
const isRenderer = (s) => !!(s != null && s.render),
  context = reactExports$1.createContext(null),
  createStore = (s, e) => {
    const o = create((_, b) => {
        const j = new Vector3(),
          $ = new Vector3(),
          _e = new Vector3();
        function et(it = b().camera, lt = $, ot = b().size) {
          const { width: ut, height: pt, top: ft, left: gt } = ot,
            xt = ut / pt;
          lt instanceof Vector3 ? _e.copy(lt) : _e.set(...lt);
          const _t = it.getWorldPosition(j).distanceTo(_e);
          if (isOrthographicCamera(it))
            return {
              width: ut / it.zoom,
              height: pt / it.zoom,
              top: ft,
              left: gt,
              factor: 1,
              distance: _t,
              aspect: xt,
            };
          {
            const St = (it.fov * Math.PI) / 180,
              Mt = 2 * Math.tan(St / 2) * _t,
              Rt = Mt * (ut / pt);
            return {
              width: Rt,
              height: Mt,
              top: ft,
              left: gt,
              factor: ut / Rt,
              distance: _t,
              aspect: xt,
            };
          }
        }
        let rt;
        const st = (it) =>
            _((lt) => ({ performance: { ...lt.performance, current: it } })),
          at = new Vector2();
        return {
          set: _,
          get: b,
          gl: null,
          camera: null,
          raycaster: null,
          events: { priority: 1, enabled: !0, connected: !1 },
          xr: null,
          scene: null,
          invalidate: (it = 1) => s(b(), it),
          advance: (it, lt) => e(it, lt, b()),
          legacy: !1,
          linear: !1,
          flat: !1,
          controls: null,
          clock: new Clock(),
          pointer: at,
          mouse: at,
          frameloop: "always",
          onPointerMissed: void 0,
          performance: {
            current: 1,
            min: 0.5,
            max: 1,
            debounce: 200,
            regress: () => {
              const it = b();
              rt && clearTimeout(rt),
                it.performance.current !== it.performance.min &&
                  st(it.performance.min),
                (rt = setTimeout(
                  () => st(b().performance.max),
                  it.performance.debounce
                ));
            },
          },
          size: { width: 0, height: 0, top: 0, left: 0, updateStyle: !1 },
          viewport: {
            initialDpr: 0,
            dpr: 0,
            width: 0,
            height: 0,
            top: 0,
            left: 0,
            aspect: 0,
            distance: 0,
            factor: 0,
            getCurrentViewport: et,
          },
          setEvents: (it) =>
            _((lt) => ({ ...lt, events: { ...lt.events, ...it } })),
          setSize: (it, lt, ot, ut, pt) => {
            const ft = b().camera,
              gt = {
                width: it,
                height: lt,
                top: ut || 0,
                left: pt || 0,
                updateStyle: ot,
              };
            _((xt) => ({
              size: gt,
              viewport: { ...xt.viewport, ...et(ft, $, gt) },
            }));
          },
          setDpr: (it) =>
            _((lt) => {
              const ot = calculateDpr(it);
              return {
                viewport: {
                  ...lt.viewport,
                  dpr: ot,
                  initialDpr: lt.viewport.initialDpr || ot,
                },
              };
            }),
          setFrameloop: (it = "always") => {
            const lt = b().clock;
            lt.stop(),
              (lt.elapsedTime = 0),
              it !== "never" && (lt.start(), (lt.elapsedTime = 0)),
              _(() => ({ frameloop: it }));
          },
          previousRoot: void 0,
          internal: {
            active: !1,
            priority: 0,
            frames: 0,
            lastEvent: reactExports$1.createRef(),
            interaction: [],
            hovered: new Map(),
            subscribers: [],
            initialClick: [0, 0],
            initialHits: [],
            capturedMap: new Map(),
            subscribe: (it, lt, ot) => {
              const ut = b().internal;
              return (
                (ut.priority = ut.priority + (lt > 0 ? 1 : 0)),
                ut.subscribers.push({ ref: it, priority: lt, store: ot }),
                (ut.subscribers = ut.subscribers.sort(
                  (pt, ft) => pt.priority - ft.priority
                )),
                () => {
                  const pt = b().internal;
                  pt != null &&
                    pt.subscribers &&
                    ((pt.priority = pt.priority - (lt > 0 ? 1 : 0)),
                    (pt.subscribers = pt.subscribers.filter(
                      (ft) => ft.ref !== it
                    )));
                }
              );
            },
          },
        };
      }),
      a = o.getState();
    let c = a.size,
      d = a.viewport.dpr,
      g = a.camera;
    return (
      o.subscribe(() => {
        const {
          camera: _,
          size: b,
          viewport: j,
          gl: $,
          set: _e,
        } = o.getState();
        if (b.width !== c.width || b.height !== c.height || j.dpr !== d) {
          var et;
          (c = b), (d = j.dpr), updateCamera(_, b), $.setPixelRatio(j.dpr);
          const rt =
            (et = b.updateStyle) != null
              ? et
              : typeof HTMLCanvasElement < "u" &&
                $.domElement instanceof HTMLCanvasElement;
          $.setSize(b.width, b.height, rt);
        }
        _ !== g &&
          ((g = _),
          _e((rt) => ({
            viewport: { ...rt.viewport, ...rt.viewport.getCurrentViewport(_) },
          })));
      }),
      o.subscribe((_) => s(_)),
      o
    );
  };
let i,
  globalEffects = new Set(),
  globalAfterEffects = new Set(),
  globalTailEffects = new Set();
function run(s, e) {
  if (s.size) for (const { callback: o } of s.values()) o(e);
}
function flushGlobalEffects(s, e) {
  switch (s) {
    case "before":
      return run(globalEffects, e);
    case "after":
      return run(globalAfterEffects, e);
    case "tail":
      return run(globalTailEffects, e);
  }
}
let subscribers, subscription;
function render$1(s, e, o) {
  let a = e.clock.getDelta();
  for (
    e.frameloop === "never" &&
      typeof s == "number" &&
      ((a = s - e.clock.elapsedTime),
      (e.clock.oldTime = e.clock.elapsedTime),
      (e.clock.elapsedTime = s)),
      subscribers = e.internal.subscribers,
      i = 0;
    i < subscribers.length;
    i++
  )
    (subscription = subscribers[i]),
      subscription.ref.current(subscription.store.getState(), a, o);
  return (
    !e.internal.priority && e.gl.render && e.gl.render(e.scene, e.camera),
    (e.internal.frames = Math.max(0, e.internal.frames - 1)),
    e.frameloop === "always" ? 1 : e.internal.frames
  );
}
function createLoop(s) {
  let e = !1,
    o = !1,
    a,
    c,
    d;
  function g(j) {
    (c = requestAnimationFrame(g)),
      (e = !0),
      (a = 0),
      flushGlobalEffects("before", j),
      (o = !0);
    for (const _e of s.values()) {
      var $;
      (d = _e.store.getState()),
        d.internal.active &&
          (d.frameloop === "always" || d.internal.frames > 0) &&
          !(($ = d.gl.xr) != null && $.isPresenting) &&
          (a += render$1(j, d));
    }
    if (((o = !1), flushGlobalEffects("after", j), a === 0))
      return flushGlobalEffects("tail", j), (e = !1), cancelAnimationFrame(c);
  }
  function _(j, $ = 1) {
    var _e;
    if (!j) return s.forEach((et) => _(et.store.getState(), $));
    ((_e = j.gl.xr) != null && _e.isPresenting) ||
      !j.internal.active ||
      j.frameloop === "never" ||
      ($ > 1
        ? (j.internal.frames = Math.min(60, j.internal.frames + $))
        : o
        ? (j.internal.frames = 2)
        : (j.internal.frames = 1),
      e || ((e = !0), requestAnimationFrame(g)));
  }
  function b(j, $ = !0, _e, et) {
    if (($ && flushGlobalEffects("before", j), _e)) render$1(j, _e, et);
    else for (const rt of s.values()) render$1(j, rt.store.getState());
    $ && flushGlobalEffects("after", j);
  }
  return { loop: g, invalidate: _, advance: b };
}
function useStore() {
  const s = reactExports$1.useContext(context);
  if (!s)
    throw new Error("R3F: Hooks can only be used within the Canvas component!");
  return s;
}
function useThree(s = (o) => o, e) {
  return useStore()(s, e);
}
function useFrame(s, e = 0) {
  const o = useStore(),
    a = o.getState().internal.subscribe,
    c = useMutableCallback(s);
  return useIsomorphicLayoutEffect(() => a(c, e, o), [e, a, o]), null;
}
const memoizedLoaders = new WeakMap();
function loadingFn(s, e) {
  return function (o, ...a) {
    let c = memoizedLoaders.get(o);
    return (
      c || ((c = new o()), memoizedLoaders.set(o, c)),
      s && s(c),
      Promise.all(
        a.map(
          (d) =>
            new Promise((g, _) =>
              c.load(
                d,
                (b) => {
                  b.scene && Object.assign(b, buildGraph(b.scene)), g(b);
                },
                e,
                (b) =>
                  _(
                    new Error(
                      `Could not load ${d}: ${b == null ? void 0 : b.message}`
                    )
                  )
              )
            )
        )
      )
    );
  };
}
function useLoader(s, e, o, a) {
  const c = Array.isArray(e) ? e : [e],
    d = suspend(loadingFn(o, a), [s, ...c], { equal: is.equ });
  return Array.isArray(e) ? d : d[0];
}
useLoader.preload = function (s, e, o) {
  const a = Array.isArray(e) ? e : [e];
  return preload(loadingFn(o), [s, ...a]);
};
useLoader.clear = function (s, e) {
  const o = Array.isArray(e) ? e : [e];
  return clear([s, ...o]);
};
const roots = new Map(),
  { invalidate, advance } = createLoop(roots),
  { reconciler, applyProps } = createRenderer(roots, getEventPriority),
  shallowLoose = { objects: "shallow", strict: !1 },
  createRendererInstance = (s, e) => {
    const o = typeof s == "function" ? s(e) : s;
    return isRenderer(o)
      ? o
      : new WebGLRenderer({
          powerPreference: "high-performance",
          canvas: e,
          antialias: !0,
          alpha: !0,
          ...s,
        });
  };
function computeInitialSize(s, e) {
  const o = typeof HTMLCanvasElement < "u" && s instanceof HTMLCanvasElement;
  if (e) {
    const { width: a, height: c, top: d, left: g, updateStyle: _ = o } = e;
    return { width: a, height: c, top: d, left: g, updateStyle: _ };
  } else if (
    typeof HTMLCanvasElement < "u" &&
    s instanceof HTMLCanvasElement &&
    s.parentElement
  ) {
    const {
      width: a,
      height: c,
      top: d,
      left: g,
    } = s.parentElement.getBoundingClientRect();
    return { width: a, height: c, top: d, left: g, updateStyle: o };
  } else if (typeof OffscreenCanvas < "u" && s instanceof OffscreenCanvas)
    return {
      width: s.width,
      height: s.height,
      top: 0,
      left: 0,
      updateStyle: o,
    };
  return { width: 0, height: 0, top: 0, left: 0 };
}
function createRoot(s) {
  const e = roots.get(s),
    o = e == null ? void 0 : e.fiber,
    a = e == null ? void 0 : e.store;
  e && console.warn("R3F.createRoot should only be called once!");
  const c = typeof reportError == "function" ? reportError : console.error,
    d = a || createStore(invalidate, advance),
    g =
      o ||
      reconciler.createContainer(
        d,
        constantsExports.ConcurrentRoot,
        null,
        !1,
        null,
        "",
        c,
        null
      );
  e || roots.set(s, { fiber: g, store: d });
  let _,
    b = !1,
    j;
  return {
    configure($ = {}) {
      let {
          gl: _e,
          size: et,
          scene: rt,
          events: st,
          onCreated: at,
          shadows: ct = !1,
          linear: it = !1,
          flat: lt = !1,
          legacy: ot = !1,
          orthographic: ut = !1,
          frameloop: pt = "always",
          dpr: ft = [1, 2],
          performance: gt,
          raycaster: xt,
          camera: _t,
          onPointerMissed: St,
        } = $,
        Mt = d.getState(),
        Rt = Mt.gl;
      Mt.gl || Mt.set({ gl: (Rt = createRendererInstance(_e, s)) });
      let Ft = Mt.raycaster;
      Ft || Mt.set({ raycaster: (Ft = new Raycaster()) });
      const { params: Ot, ...Lt } = xt || {};
      if (
        (is.equ(Lt, Ft, shallowLoose) || applyProps(Ft, { ...Lt }),
        is.equ(Ot, Ft.params, shallowLoose) ||
          applyProps(Ft, { params: { ...Ft.params, ...Ot } }),
        !Mt.camera || (Mt.camera === j && !is.equ(j, _t, shallowLoose)))
      ) {
        j = _t;
        const Ct = _t instanceof Camera,
          Tt = Ct
            ? _t
            : ut
            ? new OrthographicCamera(0, 0, 0, 0, 0.1, 1e3)
            : new PerspectiveCamera(75, 0, 0.1, 1e3);
        Ct ||
          ((Tt.position.z = 5),
          _t &&
            (applyProps(Tt, _t),
            ("aspect" in _t ||
              "left" in _t ||
              "right" in _t ||
              "bottom" in _t ||
              "top" in _t) &&
              ((Tt.manual = !0), Tt.updateProjectionMatrix())),
          !Mt.camera && !(_t != null && _t.rotation) && Tt.lookAt(0, 0, 0)),
          Mt.set({ camera: Tt }),
          (Ft.camera = Tt);
      }
      if (!Mt.scene) {
        let Ct;
        rt instanceof Scene
          ? (Ct = rt)
          : ((Ct = new Scene()), rt && applyProps(Ct, rt)),
          Mt.set({ scene: prepare(Ct) });
      }
      if (!Mt.xr) {
        var Et;
        const Ct = (Wt, Pt) => {
            const Jt = d.getState();
            Jt.frameloop !== "never" && advance(Wt, !0, Jt, Pt);
          },
          Tt = () => {
            const Wt = d.getState();
            (Wt.gl.xr.enabled = Wt.gl.xr.isPresenting),
              Wt.gl.xr.setAnimationLoop(Wt.gl.xr.isPresenting ? Ct : null),
              Wt.gl.xr.isPresenting || invalidate(Wt);
          },
          Dt = {
            connect() {
              const Wt = d.getState().gl;
              Wt.xr.addEventListener("sessionstart", Tt),
                Wt.xr.addEventListener("sessionend", Tt);
            },
            disconnect() {
              const Wt = d.getState().gl;
              Wt.xr.removeEventListener("sessionstart", Tt),
                Wt.xr.removeEventListener("sessionend", Tt);
            },
          };
        typeof ((Et = Rt.xr) == null ? void 0 : Et.addEventListener) ==
          "function" && Dt.connect(),
          Mt.set({ xr: Dt });
      }
      if (Rt.shadowMap) {
        const Ct = Rt.shadowMap.enabled,
          Tt = Rt.shadowMap.type;
        if (((Rt.shadowMap.enabled = !!ct), is.boo(ct)))
          Rt.shadowMap.type = PCFSoftShadowMap;
        else if (is.str(ct)) {
          var bt;
          const Dt = {
            basic: BasicShadowMap,
            percentage: PCFShadowMap,
            soft: PCFSoftShadowMap,
            variance: VSMShadowMap,
          };
          Rt.shadowMap.type = (bt = Dt[ct]) != null ? bt : PCFSoftShadowMap;
        } else is.obj(ct) && Object.assign(Rt.shadowMap, ct);
        (Ct !== Rt.shadowMap.enabled || Tt !== Rt.shadowMap.type) &&
          (Rt.shadowMap.needsUpdate = !0);
      }
      const mt = getColorManagement();
      mt &&
        ("enabled" in mt
          ? (mt.enabled = !ot)
          : "legacyMode" in mt && (mt.legacyMode = ot)),
        b ||
          applyProps(Rt, {
            outputEncoding: it ? 3e3 : 3001,
            toneMapping: lt ? NoToneMapping : ACESFilmicToneMapping,
          }),
        Mt.legacy !== ot && Mt.set(() => ({ legacy: ot })),
        Mt.linear !== it && Mt.set(() => ({ linear: it })),
        Mt.flat !== lt && Mt.set(() => ({ flat: lt })),
        _e &&
          !is.fun(_e) &&
          !isRenderer(_e) &&
          !is.equ(_e, Rt, shallowLoose) &&
          applyProps(Rt, _e),
        st && !Mt.events.handlers && Mt.set({ events: st(d) });
      const vt = computeInitialSize(s, et);
      return (
        is.equ(vt, Mt.size, shallowLoose) ||
          Mt.setSize(vt.width, vt.height, vt.updateStyle, vt.top, vt.left),
        ft && Mt.viewport.dpr !== calculateDpr(ft) && Mt.setDpr(ft),
        Mt.frameloop !== pt && Mt.setFrameloop(pt),
        Mt.onPointerMissed || Mt.set({ onPointerMissed: St }),
        gt &&
          !is.equ(gt, Mt.performance, shallowLoose) &&
          Mt.set((Ct) => ({ performance: { ...Ct.performance, ...gt } })),
        (_ = at),
        (b = !0),
        this
      );
    },
    render($) {
      return (
        b || this.configure(),
        reconciler.updateContainer(
          jsxRuntimeExports.jsx(Provider, {
            store: d,
            children: $,
            onCreated: _,
            rootElement: s,
          }),
          g,
          null,
          () => {}
        ),
        d
      );
    },
    unmount() {
      unmountComponentAtNode(s);
    },
  };
}
function Provider({ store: s, children: e, onCreated: o, rootElement: a }) {
  return (
    useIsomorphicLayoutEffect(() => {
      const c = s.getState();
      c.set((d) => ({ internal: { ...d.internal, active: !0 } })),
        o && o(c),
        s.getState().events.connected ||
          c.events.connect == null ||
          c.events.connect(a);
    }, []),
    jsxRuntimeExports.jsx(context.Provider, { value: s, children: e })
  );
}
function unmountComponentAtNode(s, e) {
  const o = roots.get(s),
    a = o == null ? void 0 : o.fiber;
  if (a) {
    const c = o == null ? void 0 : o.store.getState();
    c && (c.internal.active = !1),
      reconciler.updateContainer(null, a, null, () => {
        c &&
          setTimeout(() => {
            try {
              var d, g, _, b;
              c.events.disconnect == null || c.events.disconnect(),
                (d = c.gl) == null ||
                  (g = d.renderLists) == null ||
                  g.dispose == null ||
                  g.dispose(),
                (_ = c.gl) == null ||
                  _.forceContextLoss == null ||
                  _.forceContextLoss(),
                (b = c.gl) != null && b.xr && c.xr.disconnect(),
                dispose(c),
                roots.delete(s);
            } catch {}
          }, 500);
      });
  }
}
reconciler.injectIntoDevTools({
  bundleType: 0,
  rendererPackageName: "@react-three/fiber",
  version: reactExports$1.version,
});
function debounce(s, e, o) {
  var a, c, d, g, _;
  e == null && (e = 100);
  function b() {
    var $ = Date.now() - g;
    $ < e && $ >= 0
      ? (a = setTimeout(b, e - $))
      : ((a = null), o || ((_ = s.apply(d, c)), (d = c = null)));
  }
  var j = function () {
    (d = this), (c = arguments), (g = Date.now());
    var $ = o && !a;
    return (
      a || (a = setTimeout(b, e)), $ && ((_ = s.apply(d, c)), (d = c = null)), _
    );
  };
  return (
    (j.clear = function () {
      a && (clearTimeout(a), (a = null));
    }),
    (j.flush = function () {
      a && ((_ = s.apply(d, c)), (d = c = null), clearTimeout(a), (a = null));
    }),
    j
  );
}
debounce.debounce = debounce;
var debounce_1 = debounce;
const createDebounce = getDefaultExportFromCjs(debounce_1);
function useMeasure(s) {
  let {
    debounce: e,
    scroll: o,
    polyfill: a,
    offsetSize: c,
  } = s === void 0 ? { debounce: 0, scroll: !1, offsetSize: !1 } : s;
  const d = a || (typeof window > "u" ? class {} : window.ResizeObserver);
  if (!d)
    throw new Error(
      "This browser does not support ResizeObserver out of the box. See: https://github.com/react-spring/react-use-measure/#resize-observer-polyfills"
    );
  const [g, _] = reactExports$1.useState({
      left: 0,
      top: 0,
      width: 0,
      height: 0,
      bottom: 0,
      right: 0,
      x: 0,
      y: 0,
    }),
    b = reactExports$1.useRef({
      element: null,
      scrollContainers: null,
      resizeObserver: null,
      lastBounds: g,
    }),
    j = e ? (typeof e == "number" ? e : e.scroll) : null,
    $ = e ? (typeof e == "number" ? e : e.resize) : null,
    _e = reactExports$1.useRef(!1);
  reactExports$1.useEffect(
    () => ((_e.current = !0), () => void (_e.current = !1))
  );
  const [et, rt, st] = reactExports$1.useMemo(() => {
    const lt = () => {
      if (!b.current.element) return;
      const {
          left: ot,
          top: ut,
          width: pt,
          height: ft,
          bottom: gt,
          right: xt,
          x: _t,
          y: St,
        } = b.current.element.getBoundingClientRect(),
        Mt = {
          left: ot,
          top: ut,
          width: pt,
          height: ft,
          bottom: gt,
          right: xt,
          x: _t,
          y: St,
        };
      b.current.element instanceof HTMLElement &&
        c &&
        ((Mt.height = b.current.element.offsetHeight),
        (Mt.width = b.current.element.offsetWidth)),
        Object.freeze(Mt),
        _e.current &&
          !areBoundsEqual(b.current.lastBounds, Mt) &&
          _((b.current.lastBounds = Mt));
    };
    return [lt, $ ? createDebounce(lt, $) : lt, j ? createDebounce(lt, j) : lt];
  }, [_, c, j, $]);
  function at() {
    b.current.scrollContainers &&
      (b.current.scrollContainers.forEach((lt) =>
        lt.removeEventListener("scroll", st, !0)
      ),
      (b.current.scrollContainers = null)),
      b.current.resizeObserver &&
        (b.current.resizeObserver.disconnect(),
        (b.current.resizeObserver = null));
  }
  function ct() {
    b.current.element &&
      ((b.current.resizeObserver = new d(st)),
      b.current.resizeObserver.observe(b.current.element),
      o &&
        b.current.scrollContainers &&
        b.current.scrollContainers.forEach((lt) =>
          lt.addEventListener("scroll", st, { capture: !0, passive: !0 })
        ));
  }
  const it = (lt) => {
    !lt ||
      lt === b.current.element ||
      (at(),
      (b.current.element = lt),
      (b.current.scrollContainers = findScrollContainers(lt)),
      ct());
  };
  return (
    useOnWindowScroll(st, !!o),
    useOnWindowResize(rt),
    reactExports$1.useEffect(() => {
      at(), ct();
    }, [o, st, rt]),
    reactExports$1.useEffect(() => at, []),
    [it, g, et]
  );
}
function useOnWindowResize(s) {
  reactExports$1.useEffect(() => {
    const e = s;
    return (
      window.addEventListener("resize", e),
      () => void window.removeEventListener("resize", e)
    );
  }, [s]);
}
function useOnWindowScroll(s, e) {
  reactExports$1.useEffect(() => {
    if (e) {
      const o = s;
      return (
        window.addEventListener("scroll", o, { capture: !0, passive: !0 }),
        () => void window.removeEventListener("scroll", o, !0)
      );
    }
  }, [s, e]);
}
function findScrollContainers(s) {
  const e = [];
  if (!s || s === document.body) return e;
  const {
    overflow: o,
    overflowX: a,
    overflowY: c,
  } = window.getComputedStyle(s);
  return (
    [o, a, c].some((d) => d === "auto" || d === "scroll") && e.push(s),
    [...e, ...findScrollContainers(s.parentElement)]
  );
}
const keys = ["x", "y", "top", "bottom", "left", "right", "width", "height"],
  areBoundsEqual = (s, e) => keys.every((o) => s[o] === e[o]);
var __defProp$1 = Object.defineProperty,
  __defProps = Object.defineProperties,
  __getOwnPropDescs = Object.getOwnPropertyDescriptors,
  __getOwnPropSymbols = Object.getOwnPropertySymbols,
  __hasOwnProp = Object.prototype.hasOwnProperty,
  __propIsEnum = Object.prototype.propertyIsEnumerable,
  __defNormalProp$1 = (s, e, o) =>
    e in s
      ? __defProp$1(s, e, {
          enumerable: !0,
          configurable: !0,
          writable: !0,
          value: o,
        })
      : (s[e] = o),
  __spreadValues = (s, e) => {
    for (var o in e || (e = {}))
      __hasOwnProp.call(e, o) && __defNormalProp$1(s, o, e[o]);
    if (__getOwnPropSymbols)
      for (var o of __getOwnPropSymbols(e))
        __propIsEnum.call(e, o) && __defNormalProp$1(s, o, e[o]);
    return s;
  },
  __spreadProps = (s, e) => __defProps(s, __getOwnPropDescs(e)),
  _a,
  _b;
typeof window < "u" &&
(((_a = window.document) != null && _a.createElement) ||
  ((_b = window.navigator) == null ? void 0 : _b.product) === "ReactNative")
  ? reactExports$1.useLayoutEffect
  : reactExports$1.useEffect;
function traverseFiber(s, e, o) {
  if (!s) return;
  if (o(s) === !0) return s;
  let a = s.child;
  for (; a; ) {
    const c = traverseFiber(a, e, o);
    if (c) return c;
    a = a.sibling;
  }
}
function wrapContext(s) {
  try {
    return Object.defineProperties(s, {
      _currentRenderer: {
        get() {
          return null;
        },
        set() {},
      },
      _currentRenderer2: {
        get() {
          return null;
        },
        set() {},
      },
    });
  } catch {
    return s;
  }
}
const error = console.error;
console.error = function () {
  const s = [...arguments].join("");
  if (s != null && s.startsWith("Warning:") && s.includes("useContext")) {
    console.error = error;
    return;
  }
  return error.apply(this, arguments);
};
const FiberContext = wrapContext(reactExports$1.createContext(null));
class FiberProvider extends reactExports$1.Component {
  render() {
    return reactExports$1.createElement(
      FiberContext.Provider,
      { value: this._reactInternals },
      this.props.children
    );
  }
}
function useFiber() {
  const s = reactExports$1.useContext(FiberContext);
  if (s === null)
    throw new Error(
      "its-fine: useFiber must be called within a <FiberProvider />!"
    );
  const e = reactExports$1.useId();
  return reactExports$1.useMemo(() => {
    for (const a of [s, s == null ? void 0 : s.alternate]) {
      if (!a) continue;
      const c = traverseFiber(a, !1, (d) => {
        let g = d.memoizedState;
        for (; g; ) {
          if (g.memoizedState === e) return !0;
          g = g.next;
        }
      });
      if (c) return c;
    }
  }, [s, e]);
}
function useContextMap() {
  const s = useFiber(),
    [e] = reactExports$1.useState(() => new Map());
  e.clear();
  let o = s;
  for (; o; ) {
    if (o.type && typeof o.type == "object") {
      const c =
        o.type._context === void 0 && o.type.Provider === o.type
          ? o.type
          : o.type._context;
      c &&
        c !== FiberContext &&
        !e.has(c) &&
        e.set(c, reactExports$1.useContext(wrapContext(c)));
    }
    o = o.return;
  }
  return e;
}
function useContextBridge() {
  const s = useContextMap();
  return reactExports$1.useMemo(
    () =>
      Array.from(s.keys()).reduce(
        (e, o) => (a) =>
          reactExports$1.createElement(
            e,
            null,
            reactExports$1.createElement(
              o.Provider,
              __spreadProps(__spreadValues({}, a), { value: s.get(o) })
            )
          ),
        (e) =>
          reactExports$1.createElement(FiberProvider, __spreadValues({}, e))
      ),
    [s]
  );
}
const DOM_EVENTS = {
  onClick: ["click", !1],
  onContextMenu: ["contextmenu", !1],
  onDoubleClick: ["dblclick", !1],
  onWheel: ["wheel", !0],
  onPointerDown: ["pointerdown", !0],
  onPointerUp: ["pointerup", !0],
  onPointerLeave: ["pointerleave", !0],
  onPointerMove: ["pointermove", !0],
  onPointerCancel: ["pointercancel", !0],
  onLostPointerCapture: ["lostpointercapture", !0],
};
function createPointerEvents(s) {
  const { handlePointer: e } = createEvents(s);
  return {
    priority: 1,
    enabled: !0,
    compute(o, a, c) {
      a.pointer.set(
        (o.offsetX / a.size.width) * 2 - 1,
        -(o.offsetY / a.size.height) * 2 + 1
      ),
        a.raycaster.setFromCamera(a.pointer, a.camera);
    },
    connected: void 0,
    handlers: Object.keys(DOM_EVENTS).reduce(
      (o, a) => ({ ...o, [a]: e(a) }),
      {}
    ),
    update: () => {
      var o;
      const { events: a, internal: c } = s.getState();
      (o = c.lastEvent) != null &&
        o.current &&
        a.handlers &&
        a.handlers.onPointerMove(c.lastEvent.current);
    },
    connect: (o) => {
      var a;
      const { set: c, events: d } = s.getState();
      d.disconnect == null || d.disconnect(),
        c((g) => ({ events: { ...g.events, connected: o } })),
        Object.entries((a = d.handlers) != null ? a : []).forEach(([g, _]) => {
          const [b, j] = DOM_EVENTS[g];
          o.addEventListener(b, _, { passive: j });
        });
    },
    disconnect: () => {
      const { set: o, events: a } = s.getState();
      if (a.connected) {
        var c;
        Object.entries((c = a.handlers) != null ? c : []).forEach(([d, g]) => {
          if (a && a.connected instanceof HTMLElement) {
            const [_] = DOM_EVENTS[d];
            a.connected.removeEventListener(_, g);
          }
        }),
          o((d) => ({ events: { ...d.events, connected: void 0 } }));
      }
    },
  };
}
const CanvasImpl = reactExports$1.forwardRef(function s(
    {
      children: e,
      fallback: o,
      resize: a,
      style: c,
      gl: d,
      events: g = createPointerEvents,
      eventSource: _,
      eventPrefix: b,
      shadows: j,
      linear: $,
      flat: _e,
      legacy: et,
      orthographic: rt,
      frameloop: st,
      dpr: at,
      performance: ct,
      raycaster: it,
      camera: lt,
      scene: ot,
      onPointerMissed: ut,
      onCreated: pt,
      ...ft
    },
    gt
  ) {
    reactExports$1.useMemo(() => extend(THREE), []);
    const xt = useContextBridge(),
      [_t, St] = useMeasure({
        scroll: !0,
        debounce: { scroll: 50, resize: 0 },
        ...a,
      }),
      Mt = reactExports$1.useRef(null),
      Rt = reactExports$1.useRef(null);
    reactExports$1.useImperativeHandle(gt, () => Mt.current);
    const Ft = useMutableCallback(ut),
      [Ot, Lt] = reactExports$1.useState(!1),
      [Et, bt] = reactExports$1.useState(!1);
    if (Ot) throw Ot;
    if (Et) throw Et;
    const mt = reactExports$1.useRef(null);
    useIsomorphicLayoutEffect(() => {
      const Ct = Mt.current;
      St.width > 0 &&
        St.height > 0 &&
        Ct &&
        (mt.current || (mt.current = createRoot(Ct)),
        mt.current.configure({
          gl: d,
          events: g,
          shadows: j,
          linear: $,
          flat: _e,
          legacy: et,
          orthographic: rt,
          frameloop: st,
          dpr: at,
          performance: ct,
          raycaster: it,
          camera: lt,
          scene: ot,
          size: St,
          onPointerMissed: (...Tt) =>
            Ft.current == null ? void 0 : Ft.current(...Tt),
          onCreated: (Tt) => {
            Tt.events.connect == null ||
              Tt.events.connect(_ ? (isRef(_) ? _.current : _) : Rt.current),
              b &&
                Tt.setEvents({
                  compute: (Dt, Wt) => {
                    const Pt = Dt[b + "X"],
                      Jt = Dt[b + "Y"];
                    Wt.pointer.set(
                      (Pt / Wt.size.width) * 2 - 1,
                      -(Jt / Wt.size.height) * 2 + 1
                    ),
                      Wt.raycaster.setFromCamera(Wt.pointer, Wt.camera);
                  },
                }),
              pt == null || pt(Tt);
          },
        }),
        mt.current.render(
          jsxRuntimeExports.jsx(xt, {
            children: jsxRuntimeExports.jsx(ErrorBoundary, {
              set: bt,
              children: jsxRuntimeExports.jsx(reactExports$1.Suspense, {
                fallback: jsxRuntimeExports.jsx(Block, { set: Lt }),
                children: e,
              }),
            }),
          })
        ));
    }),
      reactExports$1.useEffect(() => {
        const Ct = Mt.current;
        if (Ct) return () => unmountComponentAtNode(Ct);
      }, []);
    const vt = _ ? "none" : "auto";
    return jsxRuntimeExports.jsx("div", {
      ref: Rt,
      style: {
        position: "relative",
        width: "100%",
        height: "100%",
        overflow: "hidden",
        pointerEvents: vt,
        ...c,
      },
      ...ft,
      children: jsxRuntimeExports.jsx("div", {
        ref: _t,
        style: { width: "100%", height: "100%" },
        children: jsxRuntimeExports.jsx("canvas", {
          ref: Mt,
          style: { display: "block" },
          children: o,
        }),
      }),
    });
  }),
  Canvas = reactExports$1.forwardRef(function s(e, o) {
    return jsxRuntimeExports.jsx(FiberProvider, {
      children: jsxRuntimeExports.jsx(CanvasImpl, { ...e, ref: o }),
    });
  });
function _extends() {
  return (
    (_extends = Object.assign
      ? Object.assign.bind()
      : function (s) {
          for (var e = 1; e < arguments.length; e++) {
            var o = arguments[e];
            for (var a in o) ({}).hasOwnProperty.call(o, a) && (s[a] = o[a]);
          }
          return s;
        }),
    _extends.apply(null, arguments)
  );
}
const v1 = new Vector3(),
  v2 = new Vector3(),
  v3 = new Vector3(),
  v4 = new Vector2();
function defaultCalculatePosition(s, e, o) {
  const a = v1.setFromMatrixPosition(s.matrixWorld);
  a.project(e);
  const c = o.width / 2,
    d = o.height / 2;
  return [a.x * c + c, -(a.y * d) + d];
}
function isObjectBehindCamera(s, e) {
  const o = v1.setFromMatrixPosition(s.matrixWorld),
    a = v2.setFromMatrixPosition(e.matrixWorld),
    c = o.sub(a),
    d = e.getWorldDirection(v3);
  return c.angleTo(d) > Math.PI / 2;
}
function isObjectVisible(s, e, o, a) {
  const c = v1.setFromMatrixPosition(s.matrixWorld),
    d = c.clone();
  d.project(e), v4.set(d.x, d.y), o.setFromCamera(v4, e);
  const g = o.intersectObjects(a, !0);
  if (g.length) {
    const _ = g[0].distance;
    return c.distanceTo(o.ray.origin) < _;
  }
  return !0;
}
function objectScale(s, e) {
  if (e instanceof OrthographicCamera) return e.zoom;
  if (e instanceof PerspectiveCamera) {
    const o = v1.setFromMatrixPosition(s.matrixWorld),
      a = v2.setFromMatrixPosition(e.matrixWorld),
      c = (e.fov * Math.PI) / 180,
      d = o.distanceTo(a);
    return 1 / (2 * Math.tan(c / 2) * d);
  } else return 1;
}
function objectZIndex(s, e, o) {
  if (e instanceof PerspectiveCamera || e instanceof OrthographicCamera) {
    const a = v1.setFromMatrixPosition(s.matrixWorld),
      c = v2.setFromMatrixPosition(e.matrixWorld),
      d = a.distanceTo(c),
      g = (o[1] - o[0]) / (e.far - e.near),
      _ = o[1] - g * e.far;
    return Math.round(g * d + _);
  }
}
const epsilon = (s) => (Math.abs(s) < 1e-10 ? 0 : s);
function getCSSMatrix(s, e, o = "") {
  let a = "matrix3d(";
  for (let c = 0; c !== 16; c++)
    a += epsilon(e[c] * s.elements[c]) + (c !== 15 ? "," : ")");
  return o + a;
}
const getCameraCSSMatrix = (
    (s) => (e) =>
      getCSSMatrix(e, s)
  )([1, -1, 1, 1, 1, -1, 1, 1, 1, -1, 1, 1, 1, -1, 1, 1]),
  getObjectCSSMatrix = (
    (s) => (e, o) =>
      getCSSMatrix(e, s(o), "translate(-50%,-50%)")
  )((s) => [
    1 / s,
    1 / s,
    1 / s,
    1,
    -1 / s,
    -1 / s,
    -1 / s,
    -1,
    1 / s,
    1 / s,
    1 / s,
    1,
    1,
    1,
    1,
    1,
  ]);
function isRefObject(s) {
  return s && typeof s == "object" && "current" in s;
}
const Html = reactExports$1.forwardRef(
  (
    {
      children: s,
      eps: e = 0.001,
      style: o,
      className: a,
      prepend: c,
      center: d,
      fullscreen: g,
      portal: _,
      distanceFactor: b,
      sprite: j = !1,
      transform: $ = !1,
      occlude: _e,
      onOcclude: et,
      castShadow: rt,
      receiveShadow: st,
      material: at,
      geometry: ct,
      zIndexRange: it = [16777271, 0],
      calculatePosition: lt = defaultCalculatePosition,
      as: ot = "div",
      wrapperClass: ut,
      pointerEvents: pt = "auto",
      ...ft
    },
    gt
  ) => {
    const {
        gl: xt,
        camera: _t,
        scene: St,
        size: Mt,
        raycaster: Rt,
        events: Ft,
        viewport: Ot,
      } = useThree(),
      [Lt] = reactExports$1.useState(() => document.createElement(ot)),
      Et = reactExports$1.useRef(),
      bt = reactExports$1.useRef(null),
      mt = reactExports$1.useRef(0),
      vt = reactExports$1.useRef([0, 0]),
      Ct = reactExports$1.useRef(null),
      Tt = reactExports$1.useRef(null),
      Dt =
        (_ == null ? void 0 : _.current) ||
        Ft.connected ||
        xt.domElement.parentNode,
      Wt = reactExports$1.useRef(null),
      Pt = reactExports$1.useRef(!1),
      Jt = reactExports$1.useMemo(
        () =>
          (_e && _e !== "blending") ||
          (Array.isArray(_e) && _e.length && isRefObject(_e[0])),
        [_e]
      );
    reactExports$1.useLayoutEffect(() => {
      const fn = xt.domElement;
      _e && _e === "blending"
        ? ((fn.style.zIndex = `${Math.floor(it[0] / 2)}`),
          (fn.style.position = "absolute"),
          (fn.style.pointerEvents = "none"))
        : ((fn.style.zIndex = null),
          (fn.style.position = null),
          (fn.style.pointerEvents = null));
    }, [_e]),
      reactExports$1.useLayoutEffect(() => {
        if (bt.current) {
          const fn = (Et.current = createRoot$1(Lt));
          if ((St.updateMatrixWorld(), $))
            Lt.style.cssText =
              "position:absolute;top:0;left:0;pointer-events:none;overflow:hidden;";
          else {
            const pn = lt(bt.current, _t, Mt);
            Lt.style.cssText = `position:absolute;top:0;left:0;transform:translate3d(${pn[0]}px,${pn[1]}px,0);transform-origin:0 0;`;
          }
          return (
            Dt && (c ? Dt.prepend(Lt) : Dt.appendChild(Lt)),
            () => {
              Dt && Dt.removeChild(Lt), fn.unmount();
            }
          );
        }
      }, [Dt, $]),
      reactExports$1.useLayoutEffect(() => {
        ut && (Lt.className = ut);
      }, [ut]);
    const Gt = reactExports$1.useMemo(
        () =>
          $
            ? {
                position: "absolute",
                top: 0,
                left: 0,
                width: Mt.width,
                height: Mt.height,
                transformStyle: "preserve-3d",
                pointerEvents: "none",
              }
            : {
                position: "absolute",
                transform: d ? "translate3d(-50%,-50%,0)" : "none",
                ...(g && {
                  top: -Mt.height / 2,
                  left: -Mt.width / 2,
                  width: Mt.width,
                  height: Mt.height,
                }),
                ...o,
              },
        [o, d, g, Mt, $]
      ),
      en = reactExports$1.useMemo(
        () => ({ position: "absolute", pointerEvents: pt }),
        [pt]
      );
    reactExports$1.useLayoutEffect(() => {
      if (((Pt.current = !1), $)) {
        var fn;
        (fn = Et.current) == null ||
          fn.render(
            reactExports$1.createElement(
              "div",
              { ref: Ct, style: Gt },
              reactExports$1.createElement(
                "div",
                { ref: Tt, style: en },
                reactExports$1.createElement("div", {
                  ref: gt,
                  className: a,
                  style: o,
                  children: s,
                })
              )
            )
          );
      } else {
        var pn;
        (pn = Et.current) == null ||
          pn.render(
            reactExports$1.createElement("div", {
              ref: gt,
              style: Gt,
              className: a,
              children: s,
            })
          );
      }
    });
    const _n = reactExports$1.useRef(!0);
    useFrame((fn) => {
      if (bt.current) {
        _t.updateMatrixWorld(), bt.current.updateWorldMatrix(!0, !1);
        const pn = $ ? vt.current : lt(bt.current, _t, Mt);
        if (
          $ ||
          Math.abs(mt.current - _t.zoom) > e ||
          Math.abs(vt.current[0] - pn[0]) > e ||
          Math.abs(vt.current[1] - pn[1]) > e
        ) {
          const Bt = isObjectBehindCamera(bt.current, _t);
          let qt = !1;
          Jt &&
            (Array.isArray(_e)
              ? (qt = _e.map((Pn) => Pn.current))
              : _e !== "blending" && (qt = [St]));
          const $t = _n.current;
          if (qt) {
            const Pn = isObjectVisible(bt.current, _t, Rt, qt);
            _n.current = Pn && !Bt;
          } else _n.current = !Bt;
          $t !== _n.current &&
            (et
              ? et(!_n.current)
              : (Lt.style.display = _n.current ? "block" : "none"));
          const yn = Math.floor(it[0] / 2),
            nn = _e ? (Jt ? [it[0], yn] : [yn - 1, 0]) : it;
          if (((Lt.style.zIndex = `${objectZIndex(bt.current, _t, nn)}`), $)) {
            const [Pn, xn] = [Mt.width / 2, Mt.height / 2],
              An = _t.projectionMatrix.elements[5] * xn,
              {
                isOrthographicCamera: kt,
                top: wt,
                left: Kt,
                bottom: on,
                right: sn,
              } = _t,
              cn = getCameraCSSMatrix(_t.matrixWorldInverse),
              bn = kt
                ? `scale(${An})translate(${epsilon(-(sn + Kt) / 2)}px,${epsilon(
                    (wt + on) / 2
                  )}px)`
                : `translateZ(${An}px)`;
            let vn = bt.current.matrixWorld;
            j &&
              ((vn = _t.matrixWorldInverse
                .clone()
                .transpose()
                .copyPosition(vn)
                .scale(bt.current.scale)),
              (vn.elements[3] = vn.elements[7] = vn.elements[11] = 0),
              (vn.elements[15] = 1)),
              (Lt.style.width = Mt.width + "px"),
              (Lt.style.height = Mt.height + "px"),
              (Lt.style.perspective = kt ? "" : `${An}px`),
              Ct.current &&
                Tt.current &&
                ((Ct.current.style.transform = `${bn}${cn}translate(${Pn}px,${xn}px)`),
                (Tt.current.style.transform = getObjectCSSMatrix(
                  vn,
                  1 / ((b || 10) / 400)
                )));
          } else {
            const Pn = b === void 0 ? 1 : objectScale(bt.current, _t) * b;
            Lt.style.transform = `translate3d(${pn[0]}px,${pn[1]}px,0) scale(${Pn})`;
          }
          (vt.current = pn), (mt.current = _t.zoom);
        }
      }
      if (!Jt && Wt.current && !Pt.current)
        if ($) {
          if (Ct.current) {
            const pn = Ct.current.children[0];
            if (pn != null && pn.clientWidth && pn != null && pn.clientHeight) {
              const { isOrthographicCamera: Bt } = _t;
              if (Bt || ct)
                ft.scale &&
                  (Array.isArray(ft.scale)
                    ? ft.scale instanceof Vector3
                      ? Wt.current.scale.copy(ft.scale.clone().divideScalar(1))
                      : Wt.current.scale.set(
                          1 / ft.scale[0],
                          1 / ft.scale[1],
                          1 / ft.scale[2]
                        )
                    : Wt.current.scale.setScalar(1 / ft.scale));
              else {
                const qt = (b || 10) / 400,
                  $t = pn.clientWidth * qt,
                  yn = pn.clientHeight * qt;
                Wt.current.scale.set($t, yn, 1);
              }
              Pt.current = !0;
            }
          }
        } else {
          const pn = Lt.children[0];
          if (pn != null && pn.clientWidth && pn != null && pn.clientHeight) {
            const Bt = 1 / Ot.factor,
              qt = pn.clientWidth * Bt,
              $t = pn.clientHeight * Bt;
            Wt.current.scale.set(qt, $t, 1), (Pt.current = !0);
          }
          Wt.current.lookAt(fn.camera.position);
        }
    });
    const Tn = reactExports$1.useMemo(
      () => ({
        vertexShader: $
          ? void 0
          : `
          /*
            This shader is from the THREE's SpriteMaterial.
            We need to turn the backing plane into a Sprite
            (make it always face the camera) if "transfrom"
            is false.
          */
          #include <common>

          void main() {
            vec2 center = vec2(0., 1.);
            float rotation = 0.0;

            // This is somewhat arbitrary, but it seems to work well
            // Need to figure out how to derive this dynamically if it even matters
            float size = 0.03;

            vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );
            vec2 scale;
            scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
            scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );

            bool isPerspective = isPerspectiveMatrix( projectionMatrix );
            if ( isPerspective ) scale *= - mvPosition.z;

            vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale * size;
            vec2 rotatedPosition;
            rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
            rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
            mvPosition.xy += rotatedPosition;

            gl_Position = projectionMatrix * mvPosition;
          }
      `,
        fragmentShader: `
        void main() {
          gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);
        }
      `,
      }),
      [$]
    );
    return reactExports$1.createElement(
      "group",
      _extends({}, ft, { ref: bt }),
      _e &&
        !Jt &&
        reactExports$1.createElement(
          "mesh",
          { castShadow: rt, receiveShadow: st, ref: Wt },
          ct || reactExports$1.createElement("planeGeometry", null),
          at ||
            reactExports$1.createElement("shaderMaterial", {
              side: DoubleSide,
              vertexShader: Tn.vertexShader,
              fragmentShader: Tn.fragmentShader,
            })
        )
    );
  }
);
let saveLastTotalLoaded = 0;
const useProgress = create(
  (s) => (
    (DefaultLoadingManager.onStart = (e, o, a) => {
      s({
        active: !0,
        item: e,
        loaded: o,
        total: a,
        progress: ((o - saveLastTotalLoaded) / (a - saveLastTotalLoaded)) * 100,
      });
    }),
    (DefaultLoadingManager.onLoad = () => {
      s({ active: !1 });
    }),
    (DefaultLoadingManager.onError = (e) =>
      s((o) => ({ errors: [...o.errors, e] }))),
    (DefaultLoadingManager.onProgress = (e, o, a) => {
      o === a && (saveLastTotalLoaded = a),
        s({
          active: !0,
          item: e,
          loaded: o,
          total: a,
          progress:
            ((o - saveLastTotalLoaded) / (a - saveLastTotalLoaded)) * 100 ||
            100,
        });
    }),
    { errors: [], active: !1, progress: 0, item: "", loaded: 0, total: 0 }
  )
);
function toTrianglesDrawMode(s, e) {
  if (e === TrianglesDrawMode)
    return (
      console.warn(
        "THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles."
      ),
      s
    );
  if (e === TriangleFanDrawMode || e === TriangleStripDrawMode) {
    let o = s.getIndex();
    if (o === null) {
      const g = [],
        _ = s.getAttribute("position");
      if (_ !== void 0) {
        for (let b = 0; b < _.count; b++) g.push(b);
        s.setIndex(g), (o = s.getIndex());
      } else
        return (
          console.error(
            "THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."
          ),
          s
        );
    }
    const a = o.count - 2,
      c = [];
    if (o)
      if (e === TriangleFanDrawMode)
        for (let g = 1; g <= a; g++)
          c.push(o.getX(0)), c.push(o.getX(g)), c.push(o.getX(g + 1));
      else
        for (let g = 0; g < a; g++)
          g % 2 === 0
            ? (c.push(o.getX(g)), c.push(o.getX(g + 1)), c.push(o.getX(g + 2)))
            : (c.push(o.getX(g + 2)), c.push(o.getX(g + 1)), c.push(o.getX(g)));
    c.length / 3 !== a &&
      console.error(
        "THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles."
      );
    const d = s.clone();
    return d.setIndex(c), d.clearGroups(), d;
  } else
    return (
      console.error(
        "THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:",
        e
      ),
      s
    );
}
const version = parseInt(REVISION.replace(/\D+/g, ""));
var __defProp = Object.defineProperty,
  __defNormalProp = (s, e, o) =>
    e in s
      ? __defProp(s, e, {
          enumerable: !0,
          configurable: !0,
          writable: !0,
          value: o,
        })
      : (s[e] = o),
  __publicField = (s, e, o) => (
    __defNormalProp(s, typeof e != "symbol" ? e + "" : e, o), o
  );
const _ray = new Ray(),
  _plane = new Plane(),
  TILT_LIMIT = Math.cos(70 * (Math.PI / 180)),
  moduloWrapAround = (s, e) => ((s % e) + e) % e;
let OrbitControls$1 = class extends EventDispatcher {
  constructor(e, o) {
    super(),
      __publicField(this, "object"),
      __publicField(this, "domElement"),
      __publicField(this, "enabled", !0),
      __publicField(this, "target", new Vector3()),
      __publicField(this, "minDistance", 0),
      __publicField(this, "maxDistance", 1 / 0),
      __publicField(this, "minZoom", 0),
      __publicField(this, "maxZoom", 1 / 0),
      __publicField(this, "minPolarAngle", 0),
      __publicField(this, "maxPolarAngle", Math.PI),
      __publicField(this, "minAzimuthAngle", -1 / 0),
      __publicField(this, "maxAzimuthAngle", 1 / 0),
      __publicField(this, "enableDamping", !1),
      __publicField(this, "dampingFactor", 0.05),
      __publicField(this, "enableZoom", !0),
      __publicField(this, "zoomSpeed", 1),
      __publicField(this, "enableRotate", !0),
      __publicField(this, "rotateSpeed", 1),
      __publicField(this, "enablePan", !0),
      __publicField(this, "panSpeed", 1),
      __publicField(this, "screenSpacePanning", !0),
      __publicField(this, "keyPanSpeed", 7),
      __publicField(this, "zoomToCursor", !1),
      __publicField(this, "autoRotate", !1),
      __publicField(this, "autoRotateSpeed", 2),
      __publicField(this, "reverseOrbit", !1),
      __publicField(this, "reverseHorizontalOrbit", !1),
      __publicField(this, "reverseVerticalOrbit", !1),
      __publicField(this, "keys", {
        LEFT: "ArrowLeft",
        UP: "ArrowUp",
        RIGHT: "ArrowRight",
        BOTTOM: "ArrowDown",
      }),
      __publicField(this, "mouseButtons", {
        LEFT: MOUSE.ROTATE,
        MIDDLE: MOUSE.DOLLY,
        RIGHT: MOUSE.PAN,
      }),
      __publicField(this, "touches", {
        ONE: TOUCH.ROTATE,
        TWO: TOUCH.DOLLY_PAN,
      }),
      __publicField(this, "target0"),
      __publicField(this, "position0"),
      __publicField(this, "zoom0"),
      __publicField(this, "_domElementKeyEvents", null),
      __publicField(this, "getPolarAngle"),
      __publicField(this, "getAzimuthalAngle"),
      __publicField(this, "setPolarAngle"),
      __publicField(this, "setAzimuthalAngle"),
      __publicField(this, "getDistance"),
      __publicField(this, "listenToKeyEvents"),
      __publicField(this, "stopListenToKeyEvents"),
      __publicField(this, "saveState"),
      __publicField(this, "reset"),
      __publicField(this, "update"),
      __publicField(this, "connect"),
      __publicField(this, "dispose"),
      (this.object = e),
      (this.domElement = o),
      (this.target0 = this.target.clone()),
      (this.position0 = this.object.position.clone()),
      (this.zoom0 = this.object.zoom),
      (this.getPolarAngle = () => $.phi),
      (this.getAzimuthalAngle = () => $.theta),
      (this.setPolarAngle = (Vt) => {
        let un = moduloWrapAround(Vt, 2 * Math.PI),
          In = $.phi;
        In < 0 && (In += 2 * Math.PI), un < 0 && (un += 2 * Math.PI);
        let Ut = Math.abs(un - In);
        2 * Math.PI - Ut < Ut &&
          (un < In ? (un += 2 * Math.PI) : (In += 2 * Math.PI)),
          (_e.phi = un - In),
          a.update();
      }),
      (this.setAzimuthalAngle = (Vt) => {
        let un = moduloWrapAround(Vt, 2 * Math.PI),
          In = $.theta;
        In < 0 && (In += 2 * Math.PI), un < 0 && (un += 2 * Math.PI);
        let Ut = Math.abs(un - In);
        2 * Math.PI - Ut < Ut &&
          (un < In ? (un += 2 * Math.PI) : (In += 2 * Math.PI)),
          (_e.theta = un - In),
          a.update();
      }),
      (this.getDistance = () => a.object.position.distanceTo(a.target)),
      (this.listenToKeyEvents = (Vt) => {
        Vt.addEventListener("keydown", vn), (this._domElementKeyEvents = Vt);
      }),
      (this.stopListenToKeyEvents = () => {
        this._domElementKeyEvents.removeEventListener("keydown", vn),
          (this._domElementKeyEvents = null);
      }),
      (this.saveState = () => {
        a.target0.copy(a.target),
          a.position0.copy(a.object.position),
          (a.zoom0 = a.object.zoom);
      }),
      (this.reset = () => {
        a.target.copy(a.target0),
          a.object.position.copy(a.position0),
          (a.object.zoom = a.zoom0),
          a.object.updateProjectionMatrix(),
          a.dispatchEvent(c),
          a.update(),
          (b = _.NONE);
      }),
      (this.update = (() => {
        const Vt = new Vector3(),
          un = new Vector3(0, 1, 0),
          In = new Quaternion().setFromUnitVectors(e.up, un),
          Ut = In.clone().invert(),
          dn = new Vector3(),
          an = new Quaternion(),
          hn = 2 * Math.PI;
        return function () {
          const $n = a.object.position;
          In.setFromUnitVectors(e.up, un),
            Ut.copy(In).invert(),
            Vt.copy($n).sub(a.target),
            Vt.applyQuaternion(In),
            $.setFromVector3(Vt),
            a.autoRotate && b === _.NONE && Ot(Rt()),
            a.enableDamping
              ? (($.theta += _e.theta * a.dampingFactor),
                ($.phi += _e.phi * a.dampingFactor))
              : (($.theta += _e.theta), ($.phi += _e.phi));
          let Yn = a.minAzimuthAngle,
            rr = a.maxAzimuthAngle;
          isFinite(Yn) &&
            isFinite(rr) &&
            (Yn < -Math.PI ? (Yn += hn) : Yn > Math.PI && (Yn -= hn),
            rr < -Math.PI ? (rr += hn) : rr > Math.PI && (rr -= hn),
            Yn <= rr
              ? ($.theta = Math.max(Yn, Math.min(rr, $.theta)))
              : ($.theta =
                  $.theta > (Yn + rr) / 2
                    ? Math.max(Yn, $.theta)
                    : Math.min(rr, $.theta))),
            ($.phi = Math.max(
              a.minPolarAngle,
              Math.min(a.maxPolarAngle, $.phi)
            )),
            $.makeSafe(),
            a.enableDamping === !0
              ? a.target.addScaledVector(rt, a.dampingFactor)
              : a.target.add(rt),
            (a.zoomToCursor && _t) || a.object.isOrthographicCamera
              ? ($.radius = Dt($.radius))
              : ($.radius = Dt($.radius * et)),
            Vt.setFromSpherical($),
            Vt.applyQuaternion(Ut),
            $n.copy(a.target).add(Vt),
            a.object.matrixAutoUpdate || a.object.updateMatrix(),
            a.object.lookAt(a.target),
            a.enableDamping === !0
              ? ((_e.theta *= 1 - a.dampingFactor),
                (_e.phi *= 1 - a.dampingFactor),
                rt.multiplyScalar(1 - a.dampingFactor))
              : (_e.set(0, 0, 0), rt.set(0, 0, 0));
          let pr = !1;
          if (a.zoomToCursor && _t) {
            let tr = null;
            if (
              a.object instanceof PerspectiveCamera &&
              a.object.isPerspectiveCamera
            ) {
              const Cr = Vt.length();
              tr = Dt(Cr * et);
              const Tr = Cr - tr;
              a.object.position.addScaledVector(gt, Tr),
                a.object.updateMatrixWorld();
            } else if (a.object.isOrthographicCamera) {
              const Cr = new Vector3(xt.x, xt.y, 0);
              Cr.unproject(a.object),
                (a.object.zoom = Math.max(
                  a.minZoom,
                  Math.min(a.maxZoom, a.object.zoom / et)
                )),
                a.object.updateProjectionMatrix(),
                (pr = !0);
              const Tr = new Vector3(xt.x, xt.y, 0);
              Tr.unproject(a.object),
                a.object.position.sub(Tr).add(Cr),
                a.object.updateMatrixWorld(),
                (tr = Vt.length());
            } else
              console.warn(
                "WARNING: OrbitControls.js encountered an unknown camera type - zoom to cursor disabled."
              ),
                (a.zoomToCursor = !1);
            tr !== null &&
              (a.screenSpacePanning
                ? a.target
                    .set(0, 0, -1)
                    .transformDirection(a.object.matrix)
                    .multiplyScalar(tr)
                    .add(a.object.position)
                : (_ray.origin.copy(a.object.position),
                  _ray.direction
                    .set(0, 0, -1)
                    .transformDirection(a.object.matrix),
                  Math.abs(a.object.up.dot(_ray.direction)) < TILT_LIMIT
                    ? e.lookAt(a.target)
                    : (_plane.setFromNormalAndCoplanarPoint(
                        a.object.up,
                        a.target
                      ),
                      _ray.intersectPlane(_plane, a.target))));
          } else
            a.object instanceof OrthographicCamera &&
              a.object.isOrthographicCamera &&
              ((pr = et !== 1),
              pr &&
                ((a.object.zoom = Math.max(
                  a.minZoom,
                  Math.min(a.maxZoom, a.object.zoom / et)
                )),
                a.object.updateProjectionMatrix()));
          return (
            (et = 1),
            (_t = !1),
            pr ||
            dn.distanceToSquared(a.object.position) > j ||
            8 * (1 - an.dot(a.object.quaternion)) > j
              ? (a.dispatchEvent(c),
                dn.copy(a.object.position),
                an.copy(a.object.quaternion),
                (pr = !1),
                !0)
              : !1
          );
        };
      })()),
      (this.connect = (Vt) => {
        Vt === document &&
          console.error(
            'THREE.OrbitControls: "document" should not be used as the target "domElement". Please use "renderer.domElement" instead.'
          ),
          (a.domElement = Vt),
          (a.domElement.style.touchAction = "none"),
          a.domElement.addEventListener("contextmenu", gn),
          a.domElement.addEventListener("pointerdown", wt),
          a.domElement.addEventListener("pointercancel", on),
          a.domElement.addEventListener("wheel", bn);
      }),
      (this.dispose = () => {
        var Vt, un, In, Ut, dn, an;
        a.domElement && (a.domElement.style.touchAction = "auto"),
          (Vt = a.domElement) == null ||
            Vt.removeEventListener("contextmenu", gn),
          (un = a.domElement) == null ||
            un.removeEventListener("pointerdown", wt),
          (In = a.domElement) == null ||
            In.removeEventListener("pointercancel", on),
          (Ut = a.domElement) == null || Ut.removeEventListener("wheel", bn),
          (dn = a.domElement) == null ||
            dn.ownerDocument.removeEventListener("pointermove", Kt),
          (an = a.domElement) == null ||
            an.ownerDocument.removeEventListener("pointerup", on),
          a._domElementKeyEvents !== null &&
            a._domElementKeyEvents.removeEventListener("keydown", vn);
      });
    const a = this,
      c = { type: "change" },
      d = { type: "start" },
      g = { type: "end" },
      _ = {
        NONE: -1,
        ROTATE: 0,
        DOLLY: 1,
        PAN: 2,
        TOUCH_ROTATE: 3,
        TOUCH_PAN: 4,
        TOUCH_DOLLY_PAN: 5,
        TOUCH_DOLLY_ROTATE: 6,
      };
    let b = _.NONE;
    const j = 1e-6,
      $ = new Spherical(),
      _e = new Spherical();
    let et = 1;
    const rt = new Vector3(),
      st = new Vector2(),
      at = new Vector2(),
      ct = new Vector2(),
      it = new Vector2(),
      lt = new Vector2(),
      ot = new Vector2(),
      ut = new Vector2(),
      pt = new Vector2(),
      ft = new Vector2(),
      gt = new Vector3(),
      xt = new Vector2();
    let _t = !1;
    const St = [],
      Mt = {};
    function Rt() {
      return ((2 * Math.PI) / 60 / 60) * a.autoRotateSpeed;
    }
    function Ft() {
      return Math.pow(0.95, a.zoomSpeed);
    }
    function Ot(Vt) {
      a.reverseOrbit || a.reverseHorizontalOrbit
        ? (_e.theta += Vt)
        : (_e.theta -= Vt);
    }
    function Lt(Vt) {
      a.reverseOrbit || a.reverseVerticalOrbit
        ? (_e.phi += Vt)
        : (_e.phi -= Vt);
    }
    const Et = (() => {
        const Vt = new Vector3();
        return function (In, Ut) {
          Vt.setFromMatrixColumn(Ut, 0), Vt.multiplyScalar(-In), rt.add(Vt);
        };
      })(),
      bt = (() => {
        const Vt = new Vector3();
        return function (In, Ut) {
          a.screenSpacePanning === !0
            ? Vt.setFromMatrixColumn(Ut, 1)
            : (Vt.setFromMatrixColumn(Ut, 0), Vt.crossVectors(a.object.up, Vt)),
            Vt.multiplyScalar(In),
            rt.add(Vt);
        };
      })(),
      mt = (() => {
        const Vt = new Vector3();
        return function (In, Ut) {
          const dn = a.domElement;
          if (
            dn &&
            a.object instanceof PerspectiveCamera &&
            a.object.isPerspectiveCamera
          ) {
            const an = a.object.position;
            Vt.copy(an).sub(a.target);
            let hn = Vt.length();
            (hn *= Math.tan(((a.object.fov / 2) * Math.PI) / 180)),
              Et((2 * In * hn) / dn.clientHeight, a.object.matrix),
              bt((2 * Ut * hn) / dn.clientHeight, a.object.matrix);
          } else
            dn &&
            a.object instanceof OrthographicCamera &&
            a.object.isOrthographicCamera
              ? (Et(
                  (In * (a.object.right - a.object.left)) /
                    a.object.zoom /
                    dn.clientWidth,
                  a.object.matrix
                ),
                bt(
                  (Ut * (a.object.top - a.object.bottom)) /
                    a.object.zoom /
                    dn.clientHeight,
                  a.object.matrix
                ))
              : (console.warn(
                  "WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."
                ),
                (a.enablePan = !1));
        };
      })();
    function vt(Vt) {
      (a.object instanceof PerspectiveCamera && a.object.isPerspectiveCamera) ||
      (a.object instanceof OrthographicCamera && a.object.isOrthographicCamera)
        ? (et /= Vt)
        : (console.warn(
            "WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."
          ),
          (a.enableZoom = !1));
    }
    function Ct(Vt) {
      (a.object instanceof PerspectiveCamera && a.object.isPerspectiveCamera) ||
      (a.object instanceof OrthographicCamera && a.object.isOrthographicCamera)
        ? (et *= Vt)
        : (console.warn(
            "WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."
          ),
          (a.enableZoom = !1));
    }
    function Tt(Vt) {
      if (!a.zoomToCursor || !a.domElement) return;
      _t = !0;
      const un = a.domElement.getBoundingClientRect(),
        In = Vt.clientX - un.left,
        Ut = Vt.clientY - un.top,
        dn = un.width,
        an = un.height;
      (xt.x = (In / dn) * 2 - 1),
        (xt.y = -(Ut / an) * 2 + 1),
        gt
          .set(xt.x, xt.y, 1)
          .unproject(a.object)
          .sub(a.object.position)
          .normalize();
    }
    function Dt(Vt) {
      return Math.max(a.minDistance, Math.min(a.maxDistance, Vt));
    }
    function Wt(Vt) {
      st.set(Vt.clientX, Vt.clientY);
    }
    function Pt(Vt) {
      Tt(Vt), ut.set(Vt.clientX, Vt.clientY);
    }
    function Jt(Vt) {
      it.set(Vt.clientX, Vt.clientY);
    }
    function Gt(Vt) {
      at.set(Vt.clientX, Vt.clientY),
        ct.subVectors(at, st).multiplyScalar(a.rotateSpeed);
      const un = a.domElement;
      un &&
        (Ot((2 * Math.PI * ct.x) / un.clientHeight),
        Lt((2 * Math.PI * ct.y) / un.clientHeight)),
        st.copy(at),
        a.update();
    }
    function en(Vt) {
      pt.set(Vt.clientX, Vt.clientY),
        ft.subVectors(pt, ut),
        ft.y > 0 ? vt(Ft()) : ft.y < 0 && Ct(Ft()),
        ut.copy(pt),
        a.update();
    }
    function _n(Vt) {
      lt.set(Vt.clientX, Vt.clientY),
        ot.subVectors(lt, it).multiplyScalar(a.panSpeed),
        mt(ot.x, ot.y),
        it.copy(lt),
        a.update();
    }
    function Tn(Vt) {
      Tt(Vt), Vt.deltaY < 0 ? Ct(Ft()) : Vt.deltaY > 0 && vt(Ft()), a.update();
    }
    function fn(Vt) {
      let un = !1;
      switch (Vt.code) {
        case a.keys.UP:
          mt(0, a.keyPanSpeed), (un = !0);
          break;
        case a.keys.BOTTOM:
          mt(0, -a.keyPanSpeed), (un = !0);
          break;
        case a.keys.LEFT:
          mt(a.keyPanSpeed, 0), (un = !0);
          break;
        case a.keys.RIGHT:
          mt(-a.keyPanSpeed, 0), (un = !0);
          break;
      }
      un && (Vt.preventDefault(), a.update());
    }
    function pn() {
      if (St.length == 1) st.set(St[0].pageX, St[0].pageY);
      else {
        const Vt = 0.5 * (St[0].pageX + St[1].pageX),
          un = 0.5 * (St[0].pageY + St[1].pageY);
        st.set(Vt, un);
      }
    }
    function Bt() {
      if (St.length == 1) it.set(St[0].pageX, St[0].pageY);
      else {
        const Vt = 0.5 * (St[0].pageX + St[1].pageX),
          un = 0.5 * (St[0].pageY + St[1].pageY);
        it.set(Vt, un);
      }
    }
    function qt() {
      const Vt = St[0].pageX - St[1].pageX,
        un = St[0].pageY - St[1].pageY,
        In = Math.sqrt(Vt * Vt + un * un);
      ut.set(0, In);
    }
    function $t() {
      a.enableZoom && qt(), a.enablePan && Bt();
    }
    function yn() {
      a.enableZoom && qt(), a.enableRotate && pn();
    }
    function nn(Vt) {
      if (St.length == 1) at.set(Vt.pageX, Vt.pageY);
      else {
        const In = kn(Vt),
          Ut = 0.5 * (Vt.pageX + In.x),
          dn = 0.5 * (Vt.pageY + In.y);
        at.set(Ut, dn);
      }
      ct.subVectors(at, st).multiplyScalar(a.rotateSpeed);
      const un = a.domElement;
      un &&
        (Ot((2 * Math.PI * ct.x) / un.clientHeight),
        Lt((2 * Math.PI * ct.y) / un.clientHeight)),
        st.copy(at);
    }
    function Pn(Vt) {
      if (St.length == 1) lt.set(Vt.pageX, Vt.pageY);
      else {
        const un = kn(Vt),
          In = 0.5 * (Vt.pageX + un.x),
          Ut = 0.5 * (Vt.pageY + un.y);
        lt.set(In, Ut);
      }
      ot.subVectors(lt, it).multiplyScalar(a.panSpeed),
        mt(ot.x, ot.y),
        it.copy(lt);
    }
    function xn(Vt) {
      const un = kn(Vt),
        In = Vt.pageX - un.x,
        Ut = Vt.pageY - un.y,
        dn = Math.sqrt(In * In + Ut * Ut);
      pt.set(0, dn),
        ft.set(0, Math.pow(pt.y / ut.y, a.zoomSpeed)),
        vt(ft.y),
        ut.copy(pt);
    }
    function An(Vt) {
      a.enableZoom && xn(Vt), a.enablePan && Pn(Vt);
    }
    function kt(Vt) {
      a.enableZoom && xn(Vt), a.enableRotate && nn(Vt);
    }
    function wt(Vt) {
      var un, In;
      a.enabled !== !1 &&
        (St.length === 0 &&
          ((un = a.domElement) == null ||
            un.ownerDocument.addEventListener("pointermove", Kt),
          (In = a.domElement) == null ||
            In.ownerDocument.addEventListener("pointerup", on)),
        Rn(Vt),
        Vt.pointerType === "touch" ? wn(Vt) : sn(Vt));
    }
    function Kt(Vt) {
      a.enabled !== !1 && (Vt.pointerType === "touch" ? zn(Vt) : cn(Vt));
    }
    function on(Vt) {
      var un, In, Ut;
      qn(Vt),
        St.length === 0 &&
          ((un = a.domElement) == null ||
            un.releasePointerCapture(Vt.pointerId),
          (In = a.domElement) == null ||
            In.ownerDocument.removeEventListener("pointermove", Kt),
          (Ut = a.domElement) == null ||
            Ut.ownerDocument.removeEventListener("pointerup", on)),
        a.dispatchEvent(g),
        (b = _.NONE);
    }
    function sn(Vt) {
      let un;
      switch (Vt.button) {
        case 0:
          un = a.mouseButtons.LEFT;
          break;
        case 1:
          un = a.mouseButtons.MIDDLE;
          break;
        case 2:
          un = a.mouseButtons.RIGHT;
          break;
        default:
          un = -1;
      }
      switch (un) {
        case MOUSE.DOLLY:
          if (a.enableZoom === !1) return;
          Pt(Vt), (b = _.DOLLY);
          break;
        case MOUSE.ROTATE:
          if (Vt.ctrlKey || Vt.metaKey || Vt.shiftKey) {
            if (a.enablePan === !1) return;
            Jt(Vt), (b = _.PAN);
          } else {
            if (a.enableRotate === !1) return;
            Wt(Vt), (b = _.ROTATE);
          }
          break;
        case MOUSE.PAN:
          if (Vt.ctrlKey || Vt.metaKey || Vt.shiftKey) {
            if (a.enableRotate === !1) return;
            Wt(Vt), (b = _.ROTATE);
          } else {
            if (a.enablePan === !1) return;
            Jt(Vt), (b = _.PAN);
          }
          break;
        default:
          b = _.NONE;
      }
      b !== _.NONE && a.dispatchEvent(d);
    }
    function cn(Vt) {
      if (a.enabled !== !1)
        switch (b) {
          case _.ROTATE:
            if (a.enableRotate === !1) return;
            Gt(Vt);
            break;
          case _.DOLLY:
            if (a.enableZoom === !1) return;
            en(Vt);
            break;
          case _.PAN:
            if (a.enablePan === !1) return;
            _n(Vt);
            break;
        }
    }
    function bn(Vt) {
      a.enabled === !1 ||
        a.enableZoom === !1 ||
        (b !== _.NONE && b !== _.ROTATE) ||
        (Vt.preventDefault(), a.dispatchEvent(d), Tn(Vt), a.dispatchEvent(g));
    }
    function vn(Vt) {
      a.enabled === !1 || a.enablePan === !1 || fn(Vt);
    }
    function wn(Vt) {
      switch ((Wn(Vt), St.length)) {
        case 1:
          switch (a.touches.ONE) {
            case TOUCH.ROTATE:
              if (a.enableRotate === !1) return;
              pn(), (b = _.TOUCH_ROTATE);
              break;
            case TOUCH.PAN:
              if (a.enablePan === !1) return;
              Bt(), (b = _.TOUCH_PAN);
              break;
            default:
              b = _.NONE;
          }
          break;
        case 2:
          switch (a.touches.TWO) {
            case TOUCH.DOLLY_PAN:
              if (a.enableZoom === !1 && a.enablePan === !1) return;
              $t(), (b = _.TOUCH_DOLLY_PAN);
              break;
            case TOUCH.DOLLY_ROTATE:
              if (a.enableZoom === !1 && a.enableRotate === !1) return;
              yn(), (b = _.TOUCH_DOLLY_ROTATE);
              break;
            default:
              b = _.NONE;
          }
          break;
        default:
          b = _.NONE;
      }
      b !== _.NONE && a.dispatchEvent(d);
    }
    function zn(Vt) {
      switch ((Wn(Vt), b)) {
        case _.TOUCH_ROTATE:
          if (a.enableRotate === !1) return;
          nn(Vt), a.update();
          break;
        case _.TOUCH_PAN:
          if (a.enablePan === !1) return;
          Pn(Vt), a.update();
          break;
        case _.TOUCH_DOLLY_PAN:
          if (a.enableZoom === !1 && a.enablePan === !1) return;
          An(Vt), a.update();
          break;
        case _.TOUCH_DOLLY_ROTATE:
          if (a.enableZoom === !1 && a.enableRotate === !1) return;
          kt(Vt), a.update();
          break;
        default:
          b = _.NONE;
      }
    }
    function gn(Vt) {
      a.enabled !== !1 && Vt.preventDefault();
    }
    function Rn(Vt) {
      St.push(Vt);
    }
    function qn(Vt) {
      delete Mt[Vt.pointerId];
      for (let un = 0; un < St.length; un++)
        if (St[un].pointerId == Vt.pointerId) {
          St.splice(un, 1);
          return;
        }
    }
    function Wn(Vt) {
      let un = Mt[Vt.pointerId];
      un === void 0 && ((un = new Vector2()), (Mt[Vt.pointerId] = un)),
        un.set(Vt.pageX, Vt.pageY);
    }
    function kn(Vt) {
      const un = Vt.pointerId === St[0].pointerId ? St[1] : St[0];
      return Mt[un.pointerId];
    }
    o !== void 0 && this.connect(o), this.update();
  }
};
function decodeText(s) {
  if (typeof TextDecoder < "u") return new TextDecoder().decode(s);
  let e = "";
  for (let o = 0, a = s.length; o < a; o++) e += String.fromCharCode(s[o]);
  try {
    return decodeURIComponent(escape(e));
  } catch {
    return e;
  }
}
const SRGBColorSpace = "srgb",
  LinearSRGBColorSpace = "srgb-linear",
  sRGBEncoding = 3001,
  LinearEncoding = 3e3;
class GLTFLoader extends Loader$2 {
  constructor(e) {
    super(e),
      (this.dracoLoader = null),
      (this.ktx2Loader = null),
      (this.meshoptDecoder = null),
      (this.pluginCallbacks = []),
      this.register(function (o) {
        return new GLTFMaterialsClearcoatExtension(o);
      }),
      this.register(function (o) {
        return new GLTFMaterialsDispersionExtension(o);
      }),
      this.register(function (o) {
        return new GLTFTextureBasisUExtension(o);
      }),
      this.register(function (o) {
        return new GLTFTextureWebPExtension(o);
      }),
      this.register(function (o) {
        return new GLTFTextureAVIFExtension(o);
      }),
      this.register(function (o) {
        return new GLTFMaterialsSheenExtension(o);
      }),
      this.register(function (o) {
        return new GLTFMaterialsTransmissionExtension(o);
      }),
      this.register(function (o) {
        return new GLTFMaterialsVolumeExtension(o);
      }),
      this.register(function (o) {
        return new GLTFMaterialsIorExtension(o);
      }),
      this.register(function (o) {
        return new GLTFMaterialsEmissiveStrengthExtension(o);
      }),
      this.register(function (o) {
        return new GLTFMaterialsSpecularExtension(o);
      }),
      this.register(function (o) {
        return new GLTFMaterialsIridescenceExtension(o);
      }),
      this.register(function (o) {
        return new GLTFMaterialsAnisotropyExtension(o);
      }),
      this.register(function (o) {
        return new GLTFMaterialsBumpExtension(o);
      }),
      this.register(function (o) {
        return new GLTFLightsExtension(o);
      }),
      this.register(function (o) {
        return new GLTFMeshoptCompression(o);
      }),
      this.register(function (o) {
        return new GLTFMeshGpuInstancing(o);
      });
  }
  load(e, o, a, c) {
    const d = this;
    let g;
    if (this.resourcePath !== "") g = this.resourcePath;
    else if (this.path !== "") {
      const j = LoaderUtils.extractUrlBase(e);
      g = LoaderUtils.resolveURL(j, this.path);
    } else g = LoaderUtils.extractUrlBase(e);
    this.manager.itemStart(e);
    const _ = function (j) {
        c ? c(j) : console.error(j),
          d.manager.itemError(e),
          d.manager.itemEnd(e);
      },
      b = new FileLoader(this.manager);
    b.setPath(this.path),
      b.setResponseType("arraybuffer"),
      b.setRequestHeader(this.requestHeader),
      b.setWithCredentials(this.withCredentials),
      b.load(
        e,
        function (j) {
          try {
            d.parse(
              j,
              g,
              function ($) {
                o($), d.manager.itemEnd(e);
              },
              _
            );
          } catch ($) {
            _($);
          }
        },
        a,
        _
      );
  }
  setDRACOLoader(e) {
    return (this.dracoLoader = e), this;
  }
  setDDSLoader() {
    throw new Error(
      'THREE.GLTFLoader: "MSFT_texture_dds" no longer supported. Please update to "KHR_texture_basisu".'
    );
  }
  setKTX2Loader(e) {
    return (this.ktx2Loader = e), this;
  }
  setMeshoptDecoder(e) {
    return (this.meshoptDecoder = e), this;
  }
  register(e) {
    return (
      this.pluginCallbacks.indexOf(e) === -1 && this.pluginCallbacks.push(e),
      this
    );
  }
  unregister(e) {
    return (
      this.pluginCallbacks.indexOf(e) !== -1 &&
        this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(e), 1),
      this
    );
  }
  parse(e, o, a, c) {
    let d;
    const g = {},
      _ = {};
    if (typeof e == "string") d = JSON.parse(e);
    else if (e instanceof ArrayBuffer)
      if (
        decodeText(new Uint8Array(e.slice(0, 4))) ===
        BINARY_EXTENSION_HEADER_MAGIC
      ) {
        try {
          g[EXTENSIONS.KHR_BINARY_GLTF] = new GLTFBinaryExtension(e);
        } catch ($) {
          c && c($);
          return;
        }
        d = JSON.parse(g[EXTENSIONS.KHR_BINARY_GLTF].content);
      } else d = JSON.parse(decodeText(new Uint8Array(e)));
    else d = e;
    if (d.asset === void 0 || d.asset.version[0] < 2) {
      c &&
        c(
          new Error(
            "THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported."
          )
        );
      return;
    }
    const b = new GLTFParser(d, {
      path: o || this.resourcePath || "",
      crossOrigin: this.crossOrigin,
      requestHeader: this.requestHeader,
      manager: this.manager,
      ktx2Loader: this.ktx2Loader,
      meshoptDecoder: this.meshoptDecoder,
    });
    b.fileLoader.setRequestHeader(this.requestHeader);
    for (let j = 0; j < this.pluginCallbacks.length; j++) {
      const $ = this.pluginCallbacks[j](b);
      $.name ||
        console.error("THREE.GLTFLoader: Invalid plugin found: missing name"),
        (_[$.name] = $),
        (g[$.name] = !0);
    }
    if (d.extensionsUsed)
      for (let j = 0; j < d.extensionsUsed.length; ++j) {
        const $ = d.extensionsUsed[j],
          _e = d.extensionsRequired || [];
        switch ($) {
          case EXTENSIONS.KHR_MATERIALS_UNLIT:
            g[$] = new GLTFMaterialsUnlitExtension();
            break;
          case EXTENSIONS.KHR_DRACO_MESH_COMPRESSION:
            g[$] = new GLTFDracoMeshCompressionExtension(d, this.dracoLoader);
            break;
          case EXTENSIONS.KHR_TEXTURE_TRANSFORM:
            g[$] = new GLTFTextureTransformExtension();
            break;
          case EXTENSIONS.KHR_MESH_QUANTIZATION:
            g[$] = new GLTFMeshQuantizationExtension();
            break;
          default:
            _e.indexOf($) >= 0 &&
              _[$] === void 0 &&
              console.warn('THREE.GLTFLoader: Unknown extension "' + $ + '".');
        }
      }
    b.setExtensions(g), b.setPlugins(_), b.parse(a, c);
  }
  parseAsync(e, o) {
    const a = this;
    return new Promise(function (c, d) {
      a.parse(e, o, c, d);
    });
  }
}
function GLTFRegistry() {
  let s = {};
  return {
    get: function (e) {
      return s[e];
    },
    add: function (e, o) {
      s[e] = o;
    },
    remove: function (e) {
      delete s[e];
    },
    removeAll: function () {
      s = {};
    },
  };
}
const EXTENSIONS = {
  KHR_BINARY_GLTF: "KHR_binary_glTF",
  KHR_DRACO_MESH_COMPRESSION: "KHR_draco_mesh_compression",
  KHR_LIGHTS_PUNCTUAL: "KHR_lights_punctual",
  KHR_MATERIALS_CLEARCOAT: "KHR_materials_clearcoat",
  KHR_MATERIALS_DISPERSION: "KHR_materials_dispersion",
  KHR_MATERIALS_IOR: "KHR_materials_ior",
  KHR_MATERIALS_SHEEN: "KHR_materials_sheen",
  KHR_MATERIALS_SPECULAR: "KHR_materials_specular",
  KHR_MATERIALS_TRANSMISSION: "KHR_materials_transmission",
  KHR_MATERIALS_IRIDESCENCE: "KHR_materials_iridescence",
  KHR_MATERIALS_ANISOTROPY: "KHR_materials_anisotropy",
  KHR_MATERIALS_UNLIT: "KHR_materials_unlit",
  KHR_MATERIALS_VOLUME: "KHR_materials_volume",
  KHR_TEXTURE_BASISU: "KHR_texture_basisu",
  KHR_TEXTURE_TRANSFORM: "KHR_texture_transform",
  KHR_MESH_QUANTIZATION: "KHR_mesh_quantization",
  KHR_MATERIALS_EMISSIVE_STRENGTH: "KHR_materials_emissive_strength",
  EXT_MATERIALS_BUMP: "EXT_materials_bump",
  EXT_TEXTURE_WEBP: "EXT_texture_webp",
  EXT_TEXTURE_AVIF: "EXT_texture_avif",
  EXT_MESHOPT_COMPRESSION: "EXT_meshopt_compression",
  EXT_MESH_GPU_INSTANCING: "EXT_mesh_gpu_instancing",
};
class GLTFLightsExtension {
  constructor(e) {
    (this.parser = e),
      (this.name = EXTENSIONS.KHR_LIGHTS_PUNCTUAL),
      (this.cache = { refs: {}, uses: {} });
  }
  _markDefs() {
    const e = this.parser,
      o = this.parser.json.nodes || [];
    for (let a = 0, c = o.length; a < c; a++) {
      const d = o[a];
      d.extensions &&
        d.extensions[this.name] &&
        d.extensions[this.name].light !== void 0 &&
        e._addNodeRef(this.cache, d.extensions[this.name].light);
    }
  }
  _loadLight(e) {
    const o = this.parser,
      a = "light:" + e;
    let c = o.cache.get(a);
    if (c) return c;
    const d = o.json,
      b = (((d.extensions && d.extensions[this.name]) || {}).lights || [])[e];
    let j;
    const $ = new Color(16777215);
    b.color !== void 0 &&
      $.setRGB(b.color[0], b.color[1], b.color[2], LinearSRGBColorSpace);
    const _e = b.range !== void 0 ? b.range : 0;
    switch (b.type) {
      case "directional":
        (j = new DirectionalLight($)),
          j.target.position.set(0, 0, -1),
          j.add(j.target);
        break;
      case "point":
        (j = new PointLight($)), (j.distance = _e);
        break;
      case "spot":
        (j = new SpotLight($)),
          (j.distance = _e),
          (b.spot = b.spot || {}),
          (b.spot.innerConeAngle =
            b.spot.innerConeAngle !== void 0 ? b.spot.innerConeAngle : 0),
          (b.spot.outerConeAngle =
            b.spot.outerConeAngle !== void 0
              ? b.spot.outerConeAngle
              : Math.PI / 4),
          (j.angle = b.spot.outerConeAngle),
          (j.penumbra = 1 - b.spot.innerConeAngle / b.spot.outerConeAngle),
          j.target.position.set(0, 0, -1),
          j.add(j.target);
        break;
      default:
        throw new Error("THREE.GLTFLoader: Unexpected light type: " + b.type);
    }
    return (
      j.position.set(0, 0, 0),
      (j.decay = 2),
      assignExtrasToUserData(j, b),
      b.intensity !== void 0 && (j.intensity = b.intensity),
      (j.name = o.createUniqueName(b.name || "light_" + e)),
      (c = Promise.resolve(j)),
      o.cache.add(a, c),
      c
    );
  }
  getDependency(e, o) {
    if (e === "light") return this._loadLight(o);
  }
  createNodeAttachment(e) {
    const o = this,
      a = this.parser,
      d = a.json.nodes[e],
      _ = ((d.extensions && d.extensions[this.name]) || {}).light;
    return _ === void 0
      ? null
      : this._loadLight(_).then(function (b) {
          return a._getNodeRef(o.cache, _, b);
        });
  }
}
class GLTFMaterialsUnlitExtension {
  constructor() {
    this.name = EXTENSIONS.KHR_MATERIALS_UNLIT;
  }
  getMaterialType() {
    return MeshBasicMaterial;
  }
  extendParams(e, o, a) {
    const c = [];
    (e.color = new Color(1, 1, 1)), (e.opacity = 1);
    const d = o.pbrMetallicRoughness;
    if (d) {
      if (Array.isArray(d.baseColorFactor)) {
        const g = d.baseColorFactor;
        e.color.setRGB(g[0], g[1], g[2], LinearSRGBColorSpace),
          (e.opacity = g[3]);
      }
      d.baseColorTexture !== void 0 &&
        c.push(a.assignTexture(e, "map", d.baseColorTexture, SRGBColorSpace));
    }
    return Promise.all(c);
  }
}
class GLTFMaterialsEmissiveStrengthExtension {
  constructor(e) {
    (this.parser = e), (this.name = EXTENSIONS.KHR_MATERIALS_EMISSIVE_STRENGTH);
  }
  extendMaterialParams(e, o) {
    const c = this.parser.json.materials[e];
    if (!c.extensions || !c.extensions[this.name]) return Promise.resolve();
    const d = c.extensions[this.name].emissiveStrength;
    return d !== void 0 && (o.emissiveIntensity = d), Promise.resolve();
  }
}
class GLTFMaterialsClearcoatExtension {
  constructor(e) {
    (this.parser = e), (this.name = EXTENSIONS.KHR_MATERIALS_CLEARCOAT);
  }
  getMaterialType(e) {
    const a = this.parser.json.materials[e];
    return !a.extensions || !a.extensions[this.name]
      ? null
      : MeshPhysicalMaterial;
  }
  extendMaterialParams(e, o) {
    const a = this.parser,
      c = a.json.materials[e];
    if (!c.extensions || !c.extensions[this.name]) return Promise.resolve();
    const d = [],
      g = c.extensions[this.name];
    if (
      (g.clearcoatFactor !== void 0 && (o.clearcoat = g.clearcoatFactor),
      g.clearcoatTexture !== void 0 &&
        d.push(a.assignTexture(o, "clearcoatMap", g.clearcoatTexture)),
      g.clearcoatRoughnessFactor !== void 0 &&
        (o.clearcoatRoughness = g.clearcoatRoughnessFactor),
      g.clearcoatRoughnessTexture !== void 0 &&
        d.push(
          a.assignTexture(
            o,
            "clearcoatRoughnessMap",
            g.clearcoatRoughnessTexture
          )
        ),
      g.clearcoatNormalTexture !== void 0 &&
        (d.push(
          a.assignTexture(o, "clearcoatNormalMap", g.clearcoatNormalTexture)
        ),
        g.clearcoatNormalTexture.scale !== void 0))
    ) {
      const _ = g.clearcoatNormalTexture.scale;
      o.clearcoatNormalScale = new Vector2(_, _);
    }
    return Promise.all(d);
  }
}
class GLTFMaterialsDispersionExtension {
  constructor(e) {
    (this.parser = e), (this.name = EXTENSIONS.KHR_MATERIALS_DISPERSION);
  }
  getMaterialType(e) {
    const a = this.parser.json.materials[e];
    return !a.extensions || !a.extensions[this.name]
      ? null
      : MeshPhysicalMaterial;
  }
  extendMaterialParams(e, o) {
    const c = this.parser.json.materials[e];
    if (!c.extensions || !c.extensions[this.name]) return Promise.resolve();
    const d = c.extensions[this.name];
    return (
      (o.dispersion = d.dispersion !== void 0 ? d.dispersion : 0),
      Promise.resolve()
    );
  }
}
class GLTFMaterialsIridescenceExtension {
  constructor(e) {
    (this.parser = e), (this.name = EXTENSIONS.KHR_MATERIALS_IRIDESCENCE);
  }
  getMaterialType(e) {
    const a = this.parser.json.materials[e];
    return !a.extensions || !a.extensions[this.name]
      ? null
      : MeshPhysicalMaterial;
  }
  extendMaterialParams(e, o) {
    const a = this.parser,
      c = a.json.materials[e];
    if (!c.extensions || !c.extensions[this.name]) return Promise.resolve();
    const d = [],
      g = c.extensions[this.name];
    return (
      g.iridescenceFactor !== void 0 && (o.iridescence = g.iridescenceFactor),
      g.iridescenceTexture !== void 0 &&
        d.push(a.assignTexture(o, "iridescenceMap", g.iridescenceTexture)),
      g.iridescenceIor !== void 0 && (o.iridescenceIOR = g.iridescenceIor),
      o.iridescenceThicknessRange === void 0 &&
        (o.iridescenceThicknessRange = [100, 400]),
      g.iridescenceThicknessMinimum !== void 0 &&
        (o.iridescenceThicknessRange[0] = g.iridescenceThicknessMinimum),
      g.iridescenceThicknessMaximum !== void 0 &&
        (o.iridescenceThicknessRange[1] = g.iridescenceThicknessMaximum),
      g.iridescenceThicknessTexture !== void 0 &&
        d.push(
          a.assignTexture(
            o,
            "iridescenceThicknessMap",
            g.iridescenceThicknessTexture
          )
        ),
      Promise.all(d)
    );
  }
}
class GLTFMaterialsSheenExtension {
  constructor(e) {
    (this.parser = e), (this.name = EXTENSIONS.KHR_MATERIALS_SHEEN);
  }
  getMaterialType(e) {
    const a = this.parser.json.materials[e];
    return !a.extensions || !a.extensions[this.name]
      ? null
      : MeshPhysicalMaterial;
  }
  extendMaterialParams(e, o) {
    const a = this.parser,
      c = a.json.materials[e];
    if (!c.extensions || !c.extensions[this.name]) return Promise.resolve();
    const d = [];
    (o.sheenColor = new Color(0, 0, 0)), (o.sheenRoughness = 0), (o.sheen = 1);
    const g = c.extensions[this.name];
    if (g.sheenColorFactor !== void 0) {
      const _ = g.sheenColorFactor;
      o.sheenColor.setRGB(_[0], _[1], _[2], LinearSRGBColorSpace);
    }
    return (
      g.sheenRoughnessFactor !== void 0 &&
        (o.sheenRoughness = g.sheenRoughnessFactor),
      g.sheenColorTexture !== void 0 &&
        d.push(
          a.assignTexture(
            o,
            "sheenColorMap",
            g.sheenColorTexture,
            SRGBColorSpace
          )
        ),
      g.sheenRoughnessTexture !== void 0 &&
        d.push(
          a.assignTexture(o, "sheenRoughnessMap", g.sheenRoughnessTexture)
        ),
      Promise.all(d)
    );
  }
}
class GLTFMaterialsTransmissionExtension {
  constructor(e) {
    (this.parser = e), (this.name = EXTENSIONS.KHR_MATERIALS_TRANSMISSION);
  }
  getMaterialType(e) {
    const a = this.parser.json.materials[e];
    return !a.extensions || !a.extensions[this.name]
      ? null
      : MeshPhysicalMaterial;
  }
  extendMaterialParams(e, o) {
    const a = this.parser,
      c = a.json.materials[e];
    if (!c.extensions || !c.extensions[this.name]) return Promise.resolve();
    const d = [],
      g = c.extensions[this.name];
    return (
      g.transmissionFactor !== void 0 &&
        (o.transmission = g.transmissionFactor),
      g.transmissionTexture !== void 0 &&
        d.push(a.assignTexture(o, "transmissionMap", g.transmissionTexture)),
      Promise.all(d)
    );
  }
}
class GLTFMaterialsVolumeExtension {
  constructor(e) {
    (this.parser = e), (this.name = EXTENSIONS.KHR_MATERIALS_VOLUME);
  }
  getMaterialType(e) {
    const a = this.parser.json.materials[e];
    return !a.extensions || !a.extensions[this.name]
      ? null
      : MeshPhysicalMaterial;
  }
  extendMaterialParams(e, o) {
    const a = this.parser,
      c = a.json.materials[e];
    if (!c.extensions || !c.extensions[this.name]) return Promise.resolve();
    const d = [],
      g = c.extensions[this.name];
    (o.thickness = g.thicknessFactor !== void 0 ? g.thicknessFactor : 0),
      g.thicknessTexture !== void 0 &&
        d.push(a.assignTexture(o, "thicknessMap", g.thicknessTexture)),
      (o.attenuationDistance = g.attenuationDistance || 1 / 0);
    const _ = g.attenuationColor || [1, 1, 1];
    return (
      (o.attenuationColor = new Color().setRGB(
        _[0],
        _[1],
        _[2],
        LinearSRGBColorSpace
      )),
      Promise.all(d)
    );
  }
}
class GLTFMaterialsIorExtension {
  constructor(e) {
    (this.parser = e), (this.name = EXTENSIONS.KHR_MATERIALS_IOR);
  }
  getMaterialType(e) {
    const a = this.parser.json.materials[e];
    return !a.extensions || !a.extensions[this.name]
      ? null
      : MeshPhysicalMaterial;
  }
  extendMaterialParams(e, o) {
    const c = this.parser.json.materials[e];
    if (!c.extensions || !c.extensions[this.name]) return Promise.resolve();
    const d = c.extensions[this.name];
    return (o.ior = d.ior !== void 0 ? d.ior : 1.5), Promise.resolve();
  }
}
class GLTFMaterialsSpecularExtension {
  constructor(e) {
    (this.parser = e), (this.name = EXTENSIONS.KHR_MATERIALS_SPECULAR);
  }
  getMaterialType(e) {
    const a = this.parser.json.materials[e];
    return !a.extensions || !a.extensions[this.name]
      ? null
      : MeshPhysicalMaterial;
  }
  extendMaterialParams(e, o) {
    const a = this.parser,
      c = a.json.materials[e];
    if (!c.extensions || !c.extensions[this.name]) return Promise.resolve();
    const d = [],
      g = c.extensions[this.name];
    (o.specularIntensity = g.specularFactor !== void 0 ? g.specularFactor : 1),
      g.specularTexture !== void 0 &&
        d.push(a.assignTexture(o, "specularIntensityMap", g.specularTexture));
    const _ = g.specularColorFactor || [1, 1, 1];
    return (
      (o.specularColor = new Color().setRGB(
        _[0],
        _[1],
        _[2],
        LinearSRGBColorSpace
      )),
      g.specularColorTexture !== void 0 &&
        d.push(
          a.assignTexture(
            o,
            "specularColorMap",
            g.specularColorTexture,
            SRGBColorSpace
          )
        ),
      Promise.all(d)
    );
  }
}
class GLTFMaterialsBumpExtension {
  constructor(e) {
    (this.parser = e), (this.name = EXTENSIONS.EXT_MATERIALS_BUMP);
  }
  getMaterialType(e) {
    const a = this.parser.json.materials[e];
    return !a.extensions || !a.extensions[this.name]
      ? null
      : MeshPhysicalMaterial;
  }
  extendMaterialParams(e, o) {
    const a = this.parser,
      c = a.json.materials[e];
    if (!c.extensions || !c.extensions[this.name]) return Promise.resolve();
    const d = [],
      g = c.extensions[this.name];
    return (
      (o.bumpScale = g.bumpFactor !== void 0 ? g.bumpFactor : 1),
      g.bumpTexture !== void 0 &&
        d.push(a.assignTexture(o, "bumpMap", g.bumpTexture)),
      Promise.all(d)
    );
  }
}
class GLTFMaterialsAnisotropyExtension {
  constructor(e) {
    (this.parser = e), (this.name = EXTENSIONS.KHR_MATERIALS_ANISOTROPY);
  }
  getMaterialType(e) {
    const a = this.parser.json.materials[e];
    return !a.extensions || !a.extensions[this.name]
      ? null
      : MeshPhysicalMaterial;
  }
  extendMaterialParams(e, o) {
    const a = this.parser,
      c = a.json.materials[e];
    if (!c.extensions || !c.extensions[this.name]) return Promise.resolve();
    const d = [],
      g = c.extensions[this.name];
    return (
      g.anisotropyStrength !== void 0 && (o.anisotropy = g.anisotropyStrength),
      g.anisotropyRotation !== void 0 &&
        (o.anisotropyRotation = g.anisotropyRotation),
      g.anisotropyTexture !== void 0 &&
        d.push(a.assignTexture(o, "anisotropyMap", g.anisotropyTexture)),
      Promise.all(d)
    );
  }
}
class GLTFTextureBasisUExtension {
  constructor(e) {
    (this.parser = e), (this.name = EXTENSIONS.KHR_TEXTURE_BASISU);
  }
  loadTexture(e) {
    const o = this.parser,
      a = o.json,
      c = a.textures[e];
    if (!c.extensions || !c.extensions[this.name]) return null;
    const d = c.extensions[this.name],
      g = o.options.ktx2Loader;
    if (!g) {
      if (a.extensionsRequired && a.extensionsRequired.indexOf(this.name) >= 0)
        throw new Error(
          "THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures"
        );
      return null;
    }
    return o.loadTextureImage(e, d.source, g);
  }
}
class GLTFTextureWebPExtension {
  constructor(e) {
    (this.parser = e),
      (this.name = EXTENSIONS.EXT_TEXTURE_WEBP),
      (this.isSupported = null);
  }
  loadTexture(e) {
    const o = this.name,
      a = this.parser,
      c = a.json,
      d = c.textures[e];
    if (!d.extensions || !d.extensions[o]) return null;
    const g = d.extensions[o],
      _ = c.images[g.source];
    let b = a.textureLoader;
    if (_.uri) {
      const j = a.options.manager.getHandler(_.uri);
      j !== null && (b = j);
    }
    return this.detectSupport().then(function (j) {
      if (j) return a.loadTextureImage(e, g.source, b);
      if (c.extensionsRequired && c.extensionsRequired.indexOf(o) >= 0)
        throw new Error(
          "THREE.GLTFLoader: WebP required by asset but unsupported."
        );
      return a.loadTexture(e);
    });
  }
  detectSupport() {
    return (
      this.isSupported ||
        (this.isSupported = new Promise(function (e) {
          const o = new Image();
          (o.src =
            "data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA"),
            (o.onload = o.onerror =
              function () {
                e(o.height === 1);
              });
        })),
      this.isSupported
    );
  }
}
class GLTFTextureAVIFExtension {
  constructor(e) {
    (this.parser = e),
      (this.name = EXTENSIONS.EXT_TEXTURE_AVIF),
      (this.isSupported = null);
  }
  loadTexture(e) {
    const o = this.name,
      a = this.parser,
      c = a.json,
      d = c.textures[e];
    if (!d.extensions || !d.extensions[o]) return null;
    const g = d.extensions[o],
      _ = c.images[g.source];
    let b = a.textureLoader;
    if (_.uri) {
      const j = a.options.manager.getHandler(_.uri);
      j !== null && (b = j);
    }
    return this.detectSupport().then(function (j) {
      if (j) return a.loadTextureImage(e, g.source, b);
      if (c.extensionsRequired && c.extensionsRequired.indexOf(o) >= 0)
        throw new Error(
          "THREE.GLTFLoader: AVIF required by asset but unsupported."
        );
      return a.loadTexture(e);
    });
  }
  detectSupport() {
    return (
      this.isSupported ||
        (this.isSupported = new Promise(function (e) {
          const o = new Image();
          (o.src =
            "data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAABcAAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAEAAAABAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQAMAAAAABNjb2xybmNseAACAAIABoAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAAB9tZGF0EgAKCBgABogQEDQgMgkQAAAAB8dSLfI="),
            (o.onload = o.onerror =
              function () {
                e(o.height === 1);
              });
        })),
      this.isSupported
    );
  }
}
class GLTFMeshoptCompression {
  constructor(e) {
    (this.name = EXTENSIONS.EXT_MESHOPT_COMPRESSION), (this.parser = e);
  }
  loadBufferView(e) {
    const o = this.parser.json,
      a = o.bufferViews[e];
    if (a.extensions && a.extensions[this.name]) {
      const c = a.extensions[this.name],
        d = this.parser.getDependency("buffer", c.buffer),
        g = this.parser.options.meshoptDecoder;
      if (!g || !g.supported) {
        if (
          o.extensionsRequired &&
          o.extensionsRequired.indexOf(this.name) >= 0
        )
          throw new Error(
            "THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files"
          );
        return null;
      }
      return d.then(function (_) {
        const b = c.byteOffset || 0,
          j = c.byteLength || 0,
          $ = c.count,
          _e = c.byteStride,
          et = new Uint8Array(_, b, j);
        return g.decodeGltfBufferAsync
          ? g
              .decodeGltfBufferAsync($, _e, et, c.mode, c.filter)
              .then(function (rt) {
                return rt.buffer;
              })
          : g.ready.then(function () {
              const rt = new ArrayBuffer($ * _e);
              return (
                g.decodeGltfBuffer(
                  new Uint8Array(rt),
                  $,
                  _e,
                  et,
                  c.mode,
                  c.filter
                ),
                rt
              );
            });
      });
    } else return null;
  }
}
class GLTFMeshGpuInstancing {
  constructor(e) {
    (this.name = EXTENSIONS.EXT_MESH_GPU_INSTANCING), (this.parser = e);
  }
  createNodeMesh(e) {
    const o = this.parser.json,
      a = o.nodes[e];
    if (!a.extensions || !a.extensions[this.name] || a.mesh === void 0)
      return null;
    const c = o.meshes[a.mesh];
    for (const j of c.primitives)
      if (
        j.mode !== WEBGL_CONSTANTS.TRIANGLES &&
        j.mode !== WEBGL_CONSTANTS.TRIANGLE_STRIP &&
        j.mode !== WEBGL_CONSTANTS.TRIANGLE_FAN &&
        j.mode !== void 0
      )
        return null;
    const g = a.extensions[this.name].attributes,
      _ = [],
      b = {};
    for (const j in g)
      _.push(
        this.parser
          .getDependency("accessor", g[j])
          .then(($) => ((b[j] = $), b[j]))
      );
    return _.length < 1
      ? null
      : (_.push(this.parser.createNodeMesh(e)),
        Promise.all(_).then((j) => {
          const $ = j.pop(),
            _e = $.isGroup ? $.children : [$],
            et = j[0].count,
            rt = [];
          for (const st of _e) {
            const at = new Matrix4(),
              ct = new Vector3(),
              it = new Quaternion(),
              lt = new Vector3(1, 1, 1),
              ot = new InstancedMesh(st.geometry, st.material, et);
            for (let ut = 0; ut < et; ut++)
              b.TRANSLATION && ct.fromBufferAttribute(b.TRANSLATION, ut),
                b.ROTATION && it.fromBufferAttribute(b.ROTATION, ut),
                b.SCALE && lt.fromBufferAttribute(b.SCALE, ut),
                ot.setMatrixAt(ut, at.compose(ct, it, lt));
            for (const ut in b)
              if (ut === "_COLOR_0") {
                const pt = b[ut];
                ot.instanceColor = new InstancedBufferAttribute(
                  pt.array,
                  pt.itemSize,
                  pt.normalized
                );
              } else
                ut !== "TRANSLATION" &&
                  ut !== "ROTATION" &&
                  ut !== "SCALE" &&
                  st.geometry.setAttribute(ut, b[ut]);
            Object3D.prototype.copy.call(ot, st),
              this.parser.assignFinalMaterial(ot),
              rt.push(ot);
          }
          return $.isGroup ? ($.clear(), $.add(...rt), $) : rt[0];
        }));
  }
}
const BINARY_EXTENSION_HEADER_MAGIC = "glTF",
  BINARY_EXTENSION_HEADER_LENGTH = 12,
  BINARY_EXTENSION_CHUNK_TYPES = { JSON: 1313821514, BIN: 5130562 };
class GLTFBinaryExtension {
  constructor(e) {
    (this.name = EXTENSIONS.KHR_BINARY_GLTF),
      (this.content = null),
      (this.body = null);
    const o = new DataView(e, 0, BINARY_EXTENSION_HEADER_LENGTH);
    if (
      ((this.header = {
        magic: decodeText(new Uint8Array(e.slice(0, 4))),
        version: o.getUint32(4, !0),
        length: o.getUint32(8, !0),
      }),
      this.header.magic !== BINARY_EXTENSION_HEADER_MAGIC)
    )
      throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");
    if (this.header.version < 2)
      throw new Error("THREE.GLTFLoader: Legacy binary file detected.");
    const a = this.header.length - BINARY_EXTENSION_HEADER_LENGTH,
      c = new DataView(e, BINARY_EXTENSION_HEADER_LENGTH);
    let d = 0;
    for (; d < a; ) {
      const g = c.getUint32(d, !0);
      d += 4;
      const _ = c.getUint32(d, !0);
      if (((d += 4), _ === BINARY_EXTENSION_CHUNK_TYPES.JSON)) {
        const b = new Uint8Array(e, BINARY_EXTENSION_HEADER_LENGTH + d, g);
        this.content = decodeText(b);
      } else if (_ === BINARY_EXTENSION_CHUNK_TYPES.BIN) {
        const b = BINARY_EXTENSION_HEADER_LENGTH + d;
        this.body = e.slice(b, b + g);
      }
      d += g;
    }
    if (this.content === null)
      throw new Error("THREE.GLTFLoader: JSON content not found.");
  }
}
class GLTFDracoMeshCompressionExtension {
  constructor(e, o) {
    if (!o)
      throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided.");
    (this.name = EXTENSIONS.KHR_DRACO_MESH_COMPRESSION),
      (this.json = e),
      (this.dracoLoader = o),
      this.dracoLoader.preload();
  }
  decodePrimitive(e, o) {
    const a = this.json,
      c = this.dracoLoader,
      d = e.extensions[this.name].bufferView,
      g = e.extensions[this.name].attributes,
      _ = {},
      b = {},
      j = {};
    for (const $ in g) {
      const _e = ATTRIBUTES[$] || $.toLowerCase();
      _[_e] = g[$];
    }
    for (const $ in e.attributes) {
      const _e = ATTRIBUTES[$] || $.toLowerCase();
      if (g[$] !== void 0) {
        const et = a.accessors[e.attributes[$]],
          rt = WEBGL_COMPONENT_TYPES[et.componentType];
        (j[_e] = rt.name), (b[_e] = et.normalized === !0);
      }
    }
    return o.getDependency("bufferView", d).then(function ($) {
      return new Promise(function (_e, et) {
        c.decodeDracoFile(
          $,
          function (rt) {
            for (const st in rt.attributes) {
              const at = rt.attributes[st],
                ct = b[st];
              ct !== void 0 && (at.normalized = ct);
            }
            _e(rt);
          },
          _,
          j,
          LinearSRGBColorSpace,
          et
        );
      });
    });
  }
}
class GLTFTextureTransformExtension {
  constructor() {
    this.name = EXTENSIONS.KHR_TEXTURE_TRANSFORM;
  }
  extendTexture(e, o) {
    return (
      ((o.texCoord === void 0 || o.texCoord === e.channel) &&
        o.offset === void 0 &&
        o.rotation === void 0 &&
        o.scale === void 0) ||
        ((e = e.clone()),
        o.texCoord !== void 0 && (e.channel = o.texCoord),
        o.offset !== void 0 && e.offset.fromArray(o.offset),
        o.rotation !== void 0 && (e.rotation = o.rotation),
        o.scale !== void 0 && e.repeat.fromArray(o.scale),
        (e.needsUpdate = !0)),
      e
    );
  }
}
class GLTFMeshQuantizationExtension {
  constructor() {
    this.name = EXTENSIONS.KHR_MESH_QUANTIZATION;
  }
}
class GLTFCubicSplineInterpolant extends Interpolant {
  constructor(e, o, a, c) {
    super(e, o, a, c);
  }
  copySampleValue_(e) {
    const o = this.resultBuffer,
      a = this.sampleValues,
      c = this.valueSize,
      d = e * c * 3 + c;
    for (let g = 0; g !== c; g++) o[g] = a[d + g];
    return o;
  }
  interpolate_(e, o, a, c) {
    const d = this.resultBuffer,
      g = this.sampleValues,
      _ = this.valueSize,
      b = _ * 2,
      j = _ * 3,
      $ = c - o,
      _e = (a - o) / $,
      et = _e * _e,
      rt = et * _e,
      st = e * j,
      at = st - j,
      ct = -2 * rt + 3 * et,
      it = rt - et,
      lt = 1 - ct,
      ot = it - et + _e;
    for (let ut = 0; ut !== _; ut++) {
      const pt = g[at + ut + _],
        ft = g[at + ut + b] * $,
        gt = g[st + ut + _],
        xt = g[st + ut] * $;
      d[ut] = lt * pt + ot * ft + ct * gt + it * xt;
    }
    return d;
  }
}
const _q = new Quaternion();
class GLTFCubicSplineQuaternionInterpolant extends GLTFCubicSplineInterpolant {
  interpolate_(e, o, a, c) {
    const d = super.interpolate_(e, o, a, c);
    return _q.fromArray(d).normalize().toArray(d), d;
  }
}
const WEBGL_CONSTANTS = {
    FLOAT: 5126,
    FLOAT_MAT3: 35675,
    FLOAT_MAT4: 35676,
    FLOAT_VEC2: 35664,
    FLOAT_VEC3: 35665,
    FLOAT_VEC4: 35666,
    LINEAR: 9729,
    REPEAT: 10497,
    SAMPLER_2D: 35678,
    POINTS: 0,
    LINES: 1,
    LINE_LOOP: 2,
    LINE_STRIP: 3,
    TRIANGLES: 4,
    TRIANGLE_STRIP: 5,
    TRIANGLE_FAN: 6,
    UNSIGNED_BYTE: 5121,
    UNSIGNED_SHORT: 5123,
  },
  WEBGL_COMPONENT_TYPES = {
    5120: Int8Array,
    5121: Uint8Array,
    5122: Int16Array,
    5123: Uint16Array,
    5125: Uint32Array,
    5126: Float32Array,
  },
  WEBGL_FILTERS = {
    9728: NearestFilter,
    9729: LinearFilter,
    9984: NearestMipmapNearestFilter,
    9985: LinearMipmapNearestFilter,
    9986: NearestMipmapLinearFilter,
    9987: LinearMipmapLinearFilter,
  },
  WEBGL_WRAPPINGS = {
    33071: ClampToEdgeWrapping,
    33648: MirroredRepeatWrapping,
    10497: RepeatWrapping,
  },
  WEBGL_TYPE_SIZES = {
    SCALAR: 1,
    VEC2: 2,
    VEC3: 3,
    VEC4: 4,
    MAT2: 4,
    MAT3: 9,
    MAT4: 16,
  },
  ATTRIBUTES = {
    POSITION: "position",
    NORMAL: "normal",
    TANGENT: "tangent",
    ...(version >= 152
      ? {
          TEXCOORD_0: "uv",
          TEXCOORD_1: "uv1",
          TEXCOORD_2: "uv2",
          TEXCOORD_3: "uv3",
        }
      : { TEXCOORD_0: "uv", TEXCOORD_1: "uv2" }),
    COLOR_0: "color",
    WEIGHTS_0: "skinWeight",
    JOINTS_0: "skinIndex",
  },
  PATH_PROPERTIES = {
    scale: "scale",
    translation: "position",
    rotation: "quaternion",
    weights: "morphTargetInfluences",
  },
  INTERPOLATION = {
    CUBICSPLINE: void 0,
    LINEAR: InterpolateLinear,
    STEP: InterpolateDiscrete,
  },
  ALPHA_MODES = { OPAQUE: "OPAQUE", MASK: "MASK", BLEND: "BLEND" };
function createDefaultMaterial(s) {
  return (
    s.DefaultMaterial === void 0 &&
      (s.DefaultMaterial = new MeshStandardMaterial({
        color: 16777215,
        emissive: 0,
        metalness: 1,
        roughness: 1,
        transparent: !1,
        depthTest: !0,
        side: FrontSide,
      })),
    s.DefaultMaterial
  );
}
function addUnknownExtensionsToUserData(s, e, o) {
  for (const a in o.extensions)
    s[a] === void 0 &&
      ((e.userData.gltfExtensions = e.userData.gltfExtensions || {}),
      (e.userData.gltfExtensions[a] = o.extensions[a]));
}
function assignExtrasToUserData(s, e) {
  e.extras !== void 0 &&
    (typeof e.extras == "object"
      ? Object.assign(s.userData, e.extras)
      : console.warn(
          "THREE.GLTFLoader: Ignoring primitive type .extras, " + e.extras
        ));
}
function addMorphTargets(s, e, o) {
  let a = !1,
    c = !1,
    d = !1;
  for (let j = 0, $ = e.length; j < $; j++) {
    const _e = e[j];
    if (
      (_e.POSITION !== void 0 && (a = !0),
      _e.NORMAL !== void 0 && (c = !0),
      _e.COLOR_0 !== void 0 && (d = !0),
      a && c && d)
    )
      break;
  }
  if (!a && !c && !d) return Promise.resolve(s);
  const g = [],
    _ = [],
    b = [];
  for (let j = 0, $ = e.length; j < $; j++) {
    const _e = e[j];
    if (a) {
      const et =
        _e.POSITION !== void 0
          ? o.getDependency("accessor", _e.POSITION)
          : s.attributes.position;
      g.push(et);
    }
    if (c) {
      const et =
        _e.NORMAL !== void 0
          ? o.getDependency("accessor", _e.NORMAL)
          : s.attributes.normal;
      _.push(et);
    }
    if (d) {
      const et =
        _e.COLOR_0 !== void 0
          ? o.getDependency("accessor", _e.COLOR_0)
          : s.attributes.color;
      b.push(et);
    }
  }
  return Promise.all([Promise.all(g), Promise.all(_), Promise.all(b)]).then(
    function (j) {
      const $ = j[0],
        _e = j[1],
        et = j[2];
      return (
        a && (s.morphAttributes.position = $),
        c && (s.morphAttributes.normal = _e),
        d && (s.morphAttributes.color = et),
        (s.morphTargetsRelative = !0),
        s
      );
    }
  );
}
function updateMorphTargets(s, e) {
  if ((s.updateMorphTargets(), e.weights !== void 0))
    for (let o = 0, a = e.weights.length; o < a; o++)
      s.morphTargetInfluences[o] = e.weights[o];
  if (e.extras && Array.isArray(e.extras.targetNames)) {
    const o = e.extras.targetNames;
    if (s.morphTargetInfluences.length === o.length) {
      s.morphTargetDictionary = {};
      for (let a = 0, c = o.length; a < c; a++)
        s.morphTargetDictionary[o[a]] = a;
    } else
      console.warn(
        "THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names."
      );
  }
}
function createPrimitiveKey(s) {
  let e;
  const o = s.extensions && s.extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION];
  if (
    (o
      ? (e =
          "draco:" +
          o.bufferView +
          ":" +
          o.indices +
          ":" +
          createAttributesKey(o.attributes))
      : (e =
          s.indices + ":" + createAttributesKey(s.attributes) + ":" + s.mode),
    s.targets !== void 0)
  )
    for (let a = 0, c = s.targets.length; a < c; a++)
      e += ":" + createAttributesKey(s.targets[a]);
  return e;
}
function createAttributesKey(s) {
  let e = "";
  const o = Object.keys(s).sort();
  for (let a = 0, c = o.length; a < c; a++) e += o[a] + ":" + s[o[a]] + ";";
  return e;
}
function getNormalizedComponentScale(s) {
  switch (s) {
    case Int8Array:
      return 1 / 127;
    case Uint8Array:
      return 1 / 255;
    case Int16Array:
      return 1 / 32767;
    case Uint16Array:
      return 1 / 65535;
    default:
      throw new Error(
        "THREE.GLTFLoader: Unsupported normalized accessor component type."
      );
  }
}
function getImageURIMimeType(s) {
  return s.search(/\.jpe?g($|\?)/i) > 0 || s.search(/^data\:image\/jpeg/) === 0
    ? "image/jpeg"
    : s.search(/\.webp($|\?)/i) > 0 || s.search(/^data\:image\/webp/) === 0
    ? "image/webp"
    : "image/png";
}
const _identityMatrix = new Matrix4();
class GLTFParser {
  constructor(e = {}, o = {}) {
    (this.json = e),
      (this.extensions = {}),
      (this.plugins = {}),
      (this.options = o),
      (this.cache = new GLTFRegistry()),
      (this.associations = new Map()),
      (this.primitiveCache = {}),
      (this.nodeCache = {}),
      (this.meshCache = { refs: {}, uses: {} }),
      (this.cameraCache = { refs: {}, uses: {} }),
      (this.lightCache = { refs: {}, uses: {} }),
      (this.sourceCache = {}),
      (this.textureCache = {}),
      (this.nodeNamesUsed = {});
    let a = !1,
      c = !1,
      d = -1;
    typeof navigator < "u" &&
      typeof navigator.userAgent < "u" &&
      ((a = /^((?!chrome|android).)*safari/i.test(navigator.userAgent) === !0),
      (c = navigator.userAgent.indexOf("Firefox") > -1),
      (d = c ? navigator.userAgent.match(/Firefox\/([0-9]+)\./)[1] : -1)),
      typeof createImageBitmap > "u" || a || (c && d < 98)
        ? (this.textureLoader = new TextureLoader(this.options.manager))
        : (this.textureLoader = new ImageBitmapLoader(this.options.manager)),
      this.textureLoader.setCrossOrigin(this.options.crossOrigin),
      this.textureLoader.setRequestHeader(this.options.requestHeader),
      (this.fileLoader = new FileLoader(this.options.manager)),
      this.fileLoader.setResponseType("arraybuffer"),
      this.options.crossOrigin === "use-credentials" &&
        this.fileLoader.setWithCredentials(!0);
  }
  setExtensions(e) {
    this.extensions = e;
  }
  setPlugins(e) {
    this.plugins = e;
  }
  parse(e, o) {
    const a = this,
      c = this.json,
      d = this.extensions;
    this.cache.removeAll(),
      (this.nodeCache = {}),
      this._invokeAll(function (g) {
        return g._markDefs && g._markDefs();
      }),
      Promise.all(
        this._invokeAll(function (g) {
          return g.beforeRoot && g.beforeRoot();
        })
      )
        .then(function () {
          return Promise.all([
            a.getDependencies("scene"),
            a.getDependencies("animation"),
            a.getDependencies("camera"),
          ]);
        })
        .then(function (g) {
          const _ = {
            scene: g[0][c.scene || 0],
            scenes: g[0],
            animations: g[1],
            cameras: g[2],
            asset: c.asset,
            parser: a,
            userData: {},
          };
          return (
            addUnknownExtensionsToUserData(d, _, c),
            assignExtrasToUserData(_, c),
            Promise.all(
              a._invokeAll(function (b) {
                return b.afterRoot && b.afterRoot(_);
              })
            ).then(function () {
              for (const b of _.scenes) b.updateMatrixWorld();
              e(_);
            })
          );
        })
        .catch(o);
  }
  _markDefs() {
    const e = this.json.nodes || [],
      o = this.json.skins || [],
      a = this.json.meshes || [];
    for (let c = 0, d = o.length; c < d; c++) {
      const g = o[c].joints;
      for (let _ = 0, b = g.length; _ < b; _++) e[g[_]].isBone = !0;
    }
    for (let c = 0, d = e.length; c < d; c++) {
      const g = e[c];
      g.mesh !== void 0 &&
        (this._addNodeRef(this.meshCache, g.mesh),
        g.skin !== void 0 && (a[g.mesh].isSkinnedMesh = !0)),
        g.camera !== void 0 && this._addNodeRef(this.cameraCache, g.camera);
    }
  }
  _addNodeRef(e, o) {
    o !== void 0 &&
      (e.refs[o] === void 0 && (e.refs[o] = e.uses[o] = 0), e.refs[o]++);
  }
  _getNodeRef(e, o, a) {
    if (e.refs[o] <= 1) return a;
    const c = a.clone(),
      d = (g, _) => {
        const b = this.associations.get(g);
        b != null && this.associations.set(_, b);
        for (const [j, $] of g.children.entries()) d($, _.children[j]);
      };
    return d(a, c), (c.name += "_instance_" + e.uses[o]++), c;
  }
  _invokeOne(e) {
    const o = Object.values(this.plugins);
    o.push(this);
    for (let a = 0; a < o.length; a++) {
      const c = e(o[a]);
      if (c) return c;
    }
    return null;
  }
  _invokeAll(e) {
    const o = Object.values(this.plugins);
    o.unshift(this);
    const a = [];
    for (let c = 0; c < o.length; c++) {
      const d = e(o[c]);
      d && a.push(d);
    }
    return a;
  }
  getDependency(e, o) {
    const a = e + ":" + o;
    let c = this.cache.get(a);
    if (!c) {
      switch (e) {
        case "scene":
          c = this.loadScene(o);
          break;
        case "node":
          c = this._invokeOne(function (d) {
            return d.loadNode && d.loadNode(o);
          });
          break;
        case "mesh":
          c = this._invokeOne(function (d) {
            return d.loadMesh && d.loadMesh(o);
          });
          break;
        case "accessor":
          c = this.loadAccessor(o);
          break;
        case "bufferView":
          c = this._invokeOne(function (d) {
            return d.loadBufferView && d.loadBufferView(o);
          });
          break;
        case "buffer":
          c = this.loadBuffer(o);
          break;
        case "material":
          c = this._invokeOne(function (d) {
            return d.loadMaterial && d.loadMaterial(o);
          });
          break;
        case "texture":
          c = this._invokeOne(function (d) {
            return d.loadTexture && d.loadTexture(o);
          });
          break;
        case "skin":
          c = this.loadSkin(o);
          break;
        case "animation":
          c = this._invokeOne(function (d) {
            return d.loadAnimation && d.loadAnimation(o);
          });
          break;
        case "camera":
          c = this.loadCamera(o);
          break;
        default:
          if (
            ((c = this._invokeOne(function (d) {
              return d != this && d.getDependency && d.getDependency(e, o);
            })),
            !c)
          )
            throw new Error("Unknown type: " + e);
          break;
      }
      this.cache.add(a, c);
    }
    return c;
  }
  getDependencies(e) {
    let o = this.cache.get(e);
    if (!o) {
      const a = this,
        c = this.json[e + (e === "mesh" ? "es" : "s")] || [];
      (o = Promise.all(
        c.map(function (d, g) {
          return a.getDependency(e, g);
        })
      )),
        this.cache.add(e, o);
    }
    return o;
  }
  loadBuffer(e) {
    const o = this.json.buffers[e],
      a = this.fileLoader;
    if (o.type && o.type !== "arraybuffer")
      throw new Error(
        "THREE.GLTFLoader: " + o.type + " buffer type is not supported."
      );
    if (o.uri === void 0 && e === 0)
      return Promise.resolve(this.extensions[EXTENSIONS.KHR_BINARY_GLTF].body);
    const c = this.options;
    return new Promise(function (d, g) {
      a.load(LoaderUtils.resolveURL(o.uri, c.path), d, void 0, function () {
        g(
          new Error('THREE.GLTFLoader: Failed to load buffer "' + o.uri + '".')
        );
      });
    });
  }
  loadBufferView(e) {
    const o = this.json.bufferViews[e];
    return this.getDependency("buffer", o.buffer).then(function (a) {
      const c = o.byteLength || 0,
        d = o.byteOffset || 0;
      return a.slice(d, d + c);
    });
  }
  loadAccessor(e) {
    const o = this,
      a = this.json,
      c = this.json.accessors[e];
    if (c.bufferView === void 0 && c.sparse === void 0) {
      const g = WEBGL_TYPE_SIZES[c.type],
        _ = WEBGL_COMPONENT_TYPES[c.componentType],
        b = c.normalized === !0,
        j = new _(c.count * g);
      return Promise.resolve(new BufferAttribute(j, g, b));
    }
    const d = [];
    return (
      c.bufferView !== void 0
        ? d.push(this.getDependency("bufferView", c.bufferView))
        : d.push(null),
      c.sparse !== void 0 &&
        (d.push(this.getDependency("bufferView", c.sparse.indices.bufferView)),
        d.push(this.getDependency("bufferView", c.sparse.values.bufferView))),
      Promise.all(d).then(function (g) {
        const _ = g[0],
          b = WEBGL_TYPE_SIZES[c.type],
          j = WEBGL_COMPONENT_TYPES[c.componentType],
          $ = j.BYTES_PER_ELEMENT,
          _e = $ * b,
          et = c.byteOffset || 0,
          rt =
            c.bufferView !== void 0
              ? a.bufferViews[c.bufferView].byteStride
              : void 0,
          st = c.normalized === !0;
        let at, ct;
        if (rt && rt !== _e) {
          const it = Math.floor(et / rt),
            lt =
              "InterleavedBuffer:" +
              c.bufferView +
              ":" +
              c.componentType +
              ":" +
              it +
              ":" +
              c.count;
          let ot = o.cache.get(lt);
          ot ||
            ((at = new j(_, it * rt, (c.count * rt) / $)),
            (ot = new InterleavedBuffer(at, rt / $)),
            o.cache.add(lt, ot)),
            (ct = new InterleavedBufferAttribute(ot, b, (et % rt) / $, st));
        } else _ === null ? (at = new j(c.count * b)) : (at = new j(_, et, c.count * b)), (ct = new BufferAttribute(at, b, st));
        if (c.sparse !== void 0) {
          const it = WEBGL_TYPE_SIZES.SCALAR,
            lt = WEBGL_COMPONENT_TYPES[c.sparse.indices.componentType],
            ot = c.sparse.indices.byteOffset || 0,
            ut = c.sparse.values.byteOffset || 0,
            pt = new lt(g[1], ot, c.sparse.count * it),
            ft = new j(g[2], ut, c.sparse.count * b);
          _ !== null &&
            (ct = new BufferAttribute(
              ct.array.slice(),
              ct.itemSize,
              ct.normalized
            ));
          for (let gt = 0, xt = pt.length; gt < xt; gt++) {
            const _t = pt[gt];
            if (
              (ct.setX(_t, ft[gt * b]),
              b >= 2 && ct.setY(_t, ft[gt * b + 1]),
              b >= 3 && ct.setZ(_t, ft[gt * b + 2]),
              b >= 4 && ct.setW(_t, ft[gt * b + 3]),
              b >= 5)
            )
              throw new Error(
                "THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute."
              );
          }
        }
        return ct;
      })
    );
  }
  loadTexture(e) {
    const o = this.json,
      a = this.options,
      d = o.textures[e].source,
      g = o.images[d];
    let _ = this.textureLoader;
    if (g.uri) {
      const b = a.manager.getHandler(g.uri);
      b !== null && (_ = b);
    }
    return this.loadTextureImage(e, d, _);
  }
  loadTextureImage(e, o, a) {
    const c = this,
      d = this.json,
      g = d.textures[e],
      _ = d.images[o],
      b = (_.uri || _.bufferView) + ":" + g.sampler;
    if (this.textureCache[b]) return this.textureCache[b];
    const j = this.loadImageSource(o, a)
      .then(function ($) {
        ($.flipY = !1),
          ($.name = g.name || _.name || ""),
          $.name === "" &&
            typeof _.uri == "string" &&
            _.uri.startsWith("data:image/") === !1 &&
            ($.name = _.uri);
        const et = (d.samplers || {})[g.sampler] || {};
        return (
          ($.magFilter = WEBGL_FILTERS[et.magFilter] || LinearFilter),
          ($.minFilter =
            WEBGL_FILTERS[et.minFilter] || LinearMipmapLinearFilter),
          ($.wrapS = WEBGL_WRAPPINGS[et.wrapS] || RepeatWrapping),
          ($.wrapT = WEBGL_WRAPPINGS[et.wrapT] || RepeatWrapping),
          c.associations.set($, { textures: e }),
          $
        );
      })
      .catch(function () {
        return null;
      });
    return (this.textureCache[b] = j), j;
  }
  loadImageSource(e, o) {
    const a = this,
      c = this.json,
      d = this.options;
    if (this.sourceCache[e] !== void 0)
      return this.sourceCache[e].then((_e) => _e.clone());
    const g = c.images[e],
      _ = self.URL || self.webkitURL;
    let b = g.uri || "",
      j = !1;
    if (g.bufferView !== void 0)
      b = a.getDependency("bufferView", g.bufferView).then(function (_e) {
        j = !0;
        const et = new Blob([_e], { type: g.mimeType });
        return (b = _.createObjectURL(et)), b;
      });
    else if (g.uri === void 0)
      throw new Error(
        "THREE.GLTFLoader: Image " + e + " is missing URI and bufferView"
      );
    const $ = Promise.resolve(b)
      .then(function (_e) {
        return new Promise(function (et, rt) {
          let st = et;
          o.isImageBitmapLoader === !0 &&
            (st = function (at) {
              const ct = new Texture(at);
              (ct.needsUpdate = !0), et(ct);
            }),
            o.load(LoaderUtils.resolveURL(_e, d.path), st, void 0, rt);
        });
      })
      .then(function (_e) {
        return (
          j === !0 && _.revokeObjectURL(b),
          assignExtrasToUserData(_e, g),
          (_e.userData.mimeType = g.mimeType || getImageURIMimeType(g.uri)),
          _e
        );
      })
      .catch(function (_e) {
        throw (console.error("THREE.GLTFLoader: Couldn't load texture", b), _e);
      });
    return (this.sourceCache[e] = $), $;
  }
  assignTexture(e, o, a, c) {
    const d = this;
    return this.getDependency("texture", a.index).then(function (g) {
      if (!g) return null;
      if (
        (a.texCoord !== void 0 &&
          a.texCoord > 0 &&
          ((g = g.clone()), (g.channel = a.texCoord)),
        d.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM])
      ) {
        const _ =
          a.extensions !== void 0
            ? a.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM]
            : void 0;
        if (_) {
          const b = d.associations.get(g);
          (g = d.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM].extendTexture(
            g,
            _
          )),
            d.associations.set(g, b);
        }
      }
      return (
        c !== void 0 &&
          (typeof c == "number" &&
            (c = c === sRGBEncoding ? SRGBColorSpace : LinearSRGBColorSpace),
          "colorSpace" in g
            ? (g.colorSpace = c)
            : (g.encoding =
                c === SRGBColorSpace ? sRGBEncoding : LinearEncoding)),
        (e[o] = g),
        g
      );
    });
  }
  assignFinalMaterial(e) {
    const o = e.geometry;
    let a = e.material;
    const c = o.attributes.tangent === void 0,
      d = o.attributes.color !== void 0,
      g = o.attributes.normal === void 0;
    if (e.isPoints) {
      const _ = "PointsMaterial:" + a.uuid;
      let b = this.cache.get(_);
      b ||
        ((b = new PointsMaterial()),
        Material.prototype.copy.call(b, a),
        b.color.copy(a.color),
        (b.map = a.map),
        (b.sizeAttenuation = !1),
        this.cache.add(_, b)),
        (a = b);
    } else if (e.isLine) {
      const _ = "LineBasicMaterial:" + a.uuid;
      let b = this.cache.get(_);
      b ||
        ((b = new LineBasicMaterial()),
        Material.prototype.copy.call(b, a),
        b.color.copy(a.color),
        (b.map = a.map),
        this.cache.add(_, b)),
        (a = b);
    }
    if (c || d || g) {
      let _ = "ClonedMaterial:" + a.uuid + ":";
      c && (_ += "derivative-tangents:"),
        d && (_ += "vertex-colors:"),
        g && (_ += "flat-shading:");
      let b = this.cache.get(_);
      b ||
        ((b = a.clone()),
        d && (b.vertexColors = !0),
        g && (b.flatShading = !0),
        c &&
          (b.normalScale && (b.normalScale.y *= -1),
          b.clearcoatNormalScale && (b.clearcoatNormalScale.y *= -1)),
        this.cache.add(_, b),
        this.associations.set(b, this.associations.get(a))),
        (a = b);
    }
    e.material = a;
  }
  getMaterialType() {
    return MeshStandardMaterial;
  }
  loadMaterial(e) {
    const o = this,
      a = this.json,
      c = this.extensions,
      d = a.materials[e];
    let g;
    const _ = {},
      b = d.extensions || {},
      j = [];
    if (b[EXTENSIONS.KHR_MATERIALS_UNLIT]) {
      const _e = c[EXTENSIONS.KHR_MATERIALS_UNLIT];
      (g = _e.getMaterialType()), j.push(_e.extendParams(_, d, o));
    } else {
      const _e = d.pbrMetallicRoughness || {};
      if (
        ((_.color = new Color(1, 1, 1)),
        (_.opacity = 1),
        Array.isArray(_e.baseColorFactor))
      ) {
        const et = _e.baseColorFactor;
        _.color.setRGB(et[0], et[1], et[2], LinearSRGBColorSpace),
          (_.opacity = et[3]);
      }
      _e.baseColorTexture !== void 0 &&
        j.push(o.assignTexture(_, "map", _e.baseColorTexture, SRGBColorSpace)),
        (_.metalness = _e.metallicFactor !== void 0 ? _e.metallicFactor : 1),
        (_.roughness = _e.roughnessFactor !== void 0 ? _e.roughnessFactor : 1),
        _e.metallicRoughnessTexture !== void 0 &&
          (j.push(
            o.assignTexture(_, "metalnessMap", _e.metallicRoughnessTexture)
          ),
          j.push(
            o.assignTexture(_, "roughnessMap", _e.metallicRoughnessTexture)
          )),
        (g = this._invokeOne(function (et) {
          return et.getMaterialType && et.getMaterialType(e);
        })),
        j.push(
          Promise.all(
            this._invokeAll(function (et) {
              return et.extendMaterialParams && et.extendMaterialParams(e, _);
            })
          )
        );
    }
    d.doubleSided === !0 && (_.side = DoubleSide);
    const $ = d.alphaMode || ALPHA_MODES.OPAQUE;
    if (
      ($ === ALPHA_MODES.BLEND
        ? ((_.transparent = !0), (_.depthWrite = !1))
        : ((_.transparent = !1),
          $ === ALPHA_MODES.MASK &&
            (_.alphaTest = d.alphaCutoff !== void 0 ? d.alphaCutoff : 0.5)),
      d.normalTexture !== void 0 &&
        g !== MeshBasicMaterial &&
        (j.push(o.assignTexture(_, "normalMap", d.normalTexture)),
        (_.normalScale = new Vector2(1, 1)),
        d.normalTexture.scale !== void 0))
    ) {
      const _e = d.normalTexture.scale;
      _.normalScale.set(_e, _e);
    }
    if (
      (d.occlusionTexture !== void 0 &&
        g !== MeshBasicMaterial &&
        (j.push(o.assignTexture(_, "aoMap", d.occlusionTexture)),
        d.occlusionTexture.strength !== void 0 &&
          (_.aoMapIntensity = d.occlusionTexture.strength)),
      d.emissiveFactor !== void 0 && g !== MeshBasicMaterial)
    ) {
      const _e = d.emissiveFactor;
      _.emissive = new Color().setRGB(
        _e[0],
        _e[1],
        _e[2],
        LinearSRGBColorSpace
      );
    }
    return (
      d.emissiveTexture !== void 0 &&
        g !== MeshBasicMaterial &&
        j.push(
          o.assignTexture(_, "emissiveMap", d.emissiveTexture, SRGBColorSpace)
        ),
      Promise.all(j).then(function () {
        const _e = new g(_);
        return (
          d.name && (_e.name = d.name),
          assignExtrasToUserData(_e, d),
          o.associations.set(_e, { materials: e }),
          d.extensions && addUnknownExtensionsToUserData(c, _e, d),
          _e
        );
      })
    );
  }
  createUniqueName(e) {
    const o = PropertyBinding.sanitizeNodeName(e || "");
    return o in this.nodeNamesUsed
      ? o + "_" + ++this.nodeNamesUsed[o]
      : ((this.nodeNamesUsed[o] = 0), o);
  }
  loadGeometries(e) {
    const o = this,
      a = this.extensions,
      c = this.primitiveCache;
    function d(_) {
      return a[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION]
        .decodePrimitive(_, o)
        .then(function (b) {
          return addPrimitiveAttributes(b, _, o);
        });
    }
    const g = [];
    for (let _ = 0, b = e.length; _ < b; _++) {
      const j = e[_],
        $ = createPrimitiveKey(j),
        _e = c[$];
      if (_e) g.push(_e.promise);
      else {
        let et;
        j.extensions && j.extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION]
          ? (et = d(j))
          : (et = addPrimitiveAttributes(new BufferGeometry(), j, o)),
          (c[$] = { primitive: j, promise: et }),
          g.push(et);
      }
    }
    return Promise.all(g);
  }
  loadMesh(e) {
    const o = this,
      a = this.json,
      c = this.extensions,
      d = a.meshes[e],
      g = d.primitives,
      _ = [];
    for (let b = 0, j = g.length; b < j; b++) {
      const $ =
        g[b].material === void 0
          ? createDefaultMaterial(this.cache)
          : this.getDependency("material", g[b].material);
      _.push($);
    }
    return (
      _.push(o.loadGeometries(g)),
      Promise.all(_).then(function (b) {
        const j = b.slice(0, b.length - 1),
          $ = b[b.length - 1],
          _e = [];
        for (let rt = 0, st = $.length; rt < st; rt++) {
          const at = $[rt],
            ct = g[rt];
          let it;
          const lt = j[rt];
          if (
            ct.mode === WEBGL_CONSTANTS.TRIANGLES ||
            ct.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP ||
            ct.mode === WEBGL_CONSTANTS.TRIANGLE_FAN ||
            ct.mode === void 0
          )
            (it =
              d.isSkinnedMesh === !0
                ? new SkinnedMesh(at, lt)
                : new Mesh(at, lt)),
              it.isSkinnedMesh === !0 && it.normalizeSkinWeights(),
              ct.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP
                ? (it.geometry = toTrianglesDrawMode(
                    it.geometry,
                    TriangleStripDrawMode
                  ))
                : ct.mode === WEBGL_CONSTANTS.TRIANGLE_FAN &&
                  (it.geometry = toTrianglesDrawMode(
                    it.geometry,
                    TriangleFanDrawMode
                  ));
          else if (ct.mode === WEBGL_CONSTANTS.LINES)
            it = new LineSegments(at, lt);
          else if (ct.mode === WEBGL_CONSTANTS.LINE_STRIP)
            it = new Line(at, lt);
          else if (ct.mode === WEBGL_CONSTANTS.LINE_LOOP)
            it = new LineLoop(at, lt);
          else if (ct.mode === WEBGL_CONSTANTS.POINTS) it = new Points(at, lt);
          else
            throw new Error(
              "THREE.GLTFLoader: Primitive mode unsupported: " + ct.mode
            );
          Object.keys(it.geometry.morphAttributes).length > 0 &&
            updateMorphTargets(it, d),
            (it.name = o.createUniqueName(d.name || "mesh_" + e)),
            assignExtrasToUserData(it, d),
            ct.extensions && addUnknownExtensionsToUserData(c, it, ct),
            o.assignFinalMaterial(it),
            _e.push(it);
        }
        for (let rt = 0, st = _e.length; rt < st; rt++)
          o.associations.set(_e[rt], { meshes: e, primitives: rt });
        if (_e.length === 1)
          return (
            d.extensions && addUnknownExtensionsToUserData(c, _e[0], d), _e[0]
          );
        const et = new Group();
        d.extensions && addUnknownExtensionsToUserData(c, et, d),
          o.associations.set(et, { meshes: e });
        for (let rt = 0, st = _e.length; rt < st; rt++) et.add(_e[rt]);
        return et;
      })
    );
  }
  loadCamera(e) {
    let o;
    const a = this.json.cameras[e],
      c = a[a.type];
    if (!c) {
      console.warn("THREE.GLTFLoader: Missing camera parameters.");
      return;
    }
    return (
      a.type === "perspective"
        ? (o = new PerspectiveCamera(
            MathUtils.radToDeg(c.yfov),
            c.aspectRatio || 1,
            c.znear || 1,
            c.zfar || 2e6
          ))
        : a.type === "orthographic" &&
          (o = new OrthographicCamera(
            -c.xmag,
            c.xmag,
            c.ymag,
            -c.ymag,
            c.znear,
            c.zfar
          )),
      a.name && (o.name = this.createUniqueName(a.name)),
      assignExtrasToUserData(o, a),
      Promise.resolve(o)
    );
  }
  loadSkin(e) {
    const o = this.json.skins[e],
      a = [];
    for (let c = 0, d = o.joints.length; c < d; c++)
      a.push(this._loadNodeShallow(o.joints[c]));
    return (
      o.inverseBindMatrices !== void 0
        ? a.push(this.getDependency("accessor", o.inverseBindMatrices))
        : a.push(null),
      Promise.all(a).then(function (c) {
        const d = c.pop(),
          g = c,
          _ = [],
          b = [];
        for (let j = 0, $ = g.length; j < $; j++) {
          const _e = g[j];
          if (_e) {
            _.push(_e);
            const et = new Matrix4();
            d !== null && et.fromArray(d.array, j * 16), b.push(et);
          } else
            console.warn(
              'THREE.GLTFLoader: Joint "%s" could not be found.',
              o.joints[j]
            );
        }
        return new Skeleton(_, b);
      })
    );
  }
  loadAnimation(e) {
    const o = this.json,
      a = this,
      c = o.animations[e],
      d = c.name ? c.name : "animation_" + e,
      g = [],
      _ = [],
      b = [],
      j = [],
      $ = [];
    for (let _e = 0, et = c.channels.length; _e < et; _e++) {
      const rt = c.channels[_e],
        st = c.samplers[rt.sampler],
        at = rt.target,
        ct = at.node,
        it = c.parameters !== void 0 ? c.parameters[st.input] : st.input,
        lt = c.parameters !== void 0 ? c.parameters[st.output] : st.output;
      at.node !== void 0 &&
        (g.push(this.getDependency("node", ct)),
        _.push(this.getDependency("accessor", it)),
        b.push(this.getDependency("accessor", lt)),
        j.push(st),
        $.push(at));
    }
    return Promise.all([
      Promise.all(g),
      Promise.all(_),
      Promise.all(b),
      Promise.all(j),
      Promise.all($),
    ]).then(function (_e) {
      const et = _e[0],
        rt = _e[1],
        st = _e[2],
        at = _e[3],
        ct = _e[4],
        it = [];
      for (let lt = 0, ot = et.length; lt < ot; lt++) {
        const ut = et[lt],
          pt = rt[lt],
          ft = st[lt],
          gt = at[lt],
          xt = ct[lt];
        if (ut === void 0) continue;
        ut.updateMatrix && ut.updateMatrix();
        const _t = a._createAnimationTracks(ut, pt, ft, gt, xt);
        if (_t) for (let St = 0; St < _t.length; St++) it.push(_t[St]);
      }
      return new AnimationClip(d, void 0, it);
    });
  }
  createNodeMesh(e) {
    const o = this.json,
      a = this,
      c = o.nodes[e];
    return c.mesh === void 0
      ? null
      : a.getDependency("mesh", c.mesh).then(function (d) {
          const g = a._getNodeRef(a.meshCache, c.mesh, d);
          return (
            c.weights !== void 0 &&
              g.traverse(function (_) {
                if (_.isMesh)
                  for (let b = 0, j = c.weights.length; b < j; b++)
                    _.morphTargetInfluences[b] = c.weights[b];
              }),
            g
          );
        });
  }
  loadNode(e) {
    const o = this.json,
      a = this,
      c = o.nodes[e],
      d = a._loadNodeShallow(e),
      g = [],
      _ = c.children || [];
    for (let j = 0, $ = _.length; j < $; j++)
      g.push(a.getDependency("node", _[j]));
    const b =
      c.skin === void 0
        ? Promise.resolve(null)
        : a.getDependency("skin", c.skin);
    return Promise.all([d, Promise.all(g), b]).then(function (j) {
      const $ = j[0],
        _e = j[1],
        et = j[2];
      et !== null &&
        $.traverse(function (rt) {
          rt.isSkinnedMesh && rt.bind(et, _identityMatrix);
        });
      for (let rt = 0, st = _e.length; rt < st; rt++) $.add(_e[rt]);
      return $;
    });
  }
  _loadNodeShallow(e) {
    const o = this.json,
      a = this.extensions,
      c = this;
    if (this.nodeCache[e] !== void 0) return this.nodeCache[e];
    const d = o.nodes[e],
      g = d.name ? c.createUniqueName(d.name) : "",
      _ = [],
      b = c._invokeOne(function (j) {
        return j.createNodeMesh && j.createNodeMesh(e);
      });
    return (
      b && _.push(b),
      d.camera !== void 0 &&
        _.push(
          c.getDependency("camera", d.camera).then(function (j) {
            return c._getNodeRef(c.cameraCache, d.camera, j);
          })
        ),
      c
        ._invokeAll(function (j) {
          return j.createNodeAttachment && j.createNodeAttachment(e);
        })
        .forEach(function (j) {
          _.push(j);
        }),
      (this.nodeCache[e] = Promise.all(_).then(function (j) {
        let $;
        if (
          (d.isBone === !0
            ? ($ = new Bone())
            : j.length > 1
            ? ($ = new Group())
            : j.length === 1
            ? ($ = j[0])
            : ($ = new Object3D()),
          $ !== j[0])
        )
          for (let _e = 0, et = j.length; _e < et; _e++) $.add(j[_e]);
        if (
          (d.name && (($.userData.name = d.name), ($.name = g)),
          assignExtrasToUserData($, d),
          d.extensions && addUnknownExtensionsToUserData(a, $, d),
          d.matrix !== void 0)
        ) {
          const _e = new Matrix4();
          _e.fromArray(d.matrix), $.applyMatrix4(_e);
        } else d.translation !== void 0 && $.position.fromArray(d.translation), d.rotation !== void 0 && $.quaternion.fromArray(d.rotation), d.scale !== void 0 && $.scale.fromArray(d.scale);
        return (
          c.associations.has($) || c.associations.set($, {}),
          (c.associations.get($).nodes = e),
          $
        );
      })),
      this.nodeCache[e]
    );
  }
  loadScene(e) {
    const o = this.extensions,
      a = this.json.scenes[e],
      c = this,
      d = new Group();
    a.name && (d.name = c.createUniqueName(a.name)),
      assignExtrasToUserData(d, a),
      a.extensions && addUnknownExtensionsToUserData(o, d, a);
    const g = a.nodes || [],
      _ = [];
    for (let b = 0, j = g.length; b < j; b++)
      _.push(c.getDependency("node", g[b]));
    return Promise.all(_).then(function (b) {
      for (let $ = 0, _e = b.length; $ < _e; $++) d.add(b[$]);
      const j = ($) => {
        const _e = new Map();
        for (const [et, rt] of c.associations)
          (et instanceof Material || et instanceof Texture) && _e.set(et, rt);
        return (
          $.traverse((et) => {
            const rt = c.associations.get(et);
            rt != null && _e.set(et, rt);
          }),
          _e
        );
      };
      return (c.associations = j(d)), d;
    });
  }
  _createAnimationTracks(e, o, a, c, d) {
    const g = [],
      _ = e.name ? e.name : e.uuid,
      b = [];
    PATH_PROPERTIES[d.path] === PATH_PROPERTIES.weights
      ? e.traverse(function (et) {
          et.morphTargetInfluences && b.push(et.name ? et.name : et.uuid);
        })
      : b.push(_);
    let j;
    switch (PATH_PROPERTIES[d.path]) {
      case PATH_PROPERTIES.weights:
        j = NumberKeyframeTrack;
        break;
      case PATH_PROPERTIES.rotation:
        j = QuaternionKeyframeTrack;
        break;
      case PATH_PROPERTIES.position:
      case PATH_PROPERTIES.scale:
        j = VectorKeyframeTrack;
        break;
      default:
        switch (a.itemSize) {
          case 1:
            j = NumberKeyframeTrack;
            break;
          case 2:
          case 3:
          default:
            j = VectorKeyframeTrack;
            break;
        }
        break;
    }
    const $ =
        c.interpolation !== void 0
          ? INTERPOLATION[c.interpolation]
          : InterpolateLinear,
      _e = this._getArrayFromAccessor(a);
    for (let et = 0, rt = b.length; et < rt; et++) {
      const st = new j(b[et] + "." + PATH_PROPERTIES[d.path], o.array, _e, $);
      c.interpolation === "CUBICSPLINE" &&
        this._createCubicSplineTrackInterpolant(st),
        g.push(st);
    }
    return g;
  }
  _getArrayFromAccessor(e) {
    let o = e.array;
    if (e.normalized) {
      const a = getNormalizedComponentScale(o.constructor),
        c = new Float32Array(o.length);
      for (let d = 0, g = o.length; d < g; d++) c[d] = o[d] * a;
      o = c;
    }
    return o;
  }
  _createCubicSplineTrackInterpolant(e) {
    (e.createInterpolant = function (a) {
      const c =
        this instanceof QuaternionKeyframeTrack
          ? GLTFCubicSplineQuaternionInterpolant
          : GLTFCubicSplineInterpolant;
      return new c(this.times, this.values, this.getValueSize() / 3, a);
    }),
      (e.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = !0);
  }
}
function computeBounds(s, e, o) {
  const a = e.attributes,
    c = new Box3();
  if (a.POSITION !== void 0) {
    const _ = o.json.accessors[a.POSITION],
      b = _.min,
      j = _.max;
    if (b !== void 0 && j !== void 0) {
      if (
        (c.set(new Vector3(b[0], b[1], b[2]), new Vector3(j[0], j[1], j[2])),
        _.normalized)
      ) {
        const $ = getNormalizedComponentScale(
          WEBGL_COMPONENT_TYPES[_.componentType]
        );
        c.min.multiplyScalar($), c.max.multiplyScalar($);
      }
    } else {
      console.warn(
        "THREE.GLTFLoader: Missing min/max properties for accessor POSITION."
      );
      return;
    }
  } else return;
  const d = e.targets;
  if (d !== void 0) {
    const _ = new Vector3(),
      b = new Vector3();
    for (let j = 0, $ = d.length; j < $; j++) {
      const _e = d[j];
      if (_e.POSITION !== void 0) {
        const et = o.json.accessors[_e.POSITION],
          rt = et.min,
          st = et.max;
        if (rt !== void 0 && st !== void 0) {
          if (
            (b.setX(Math.max(Math.abs(rt[0]), Math.abs(st[0]))),
            b.setY(Math.max(Math.abs(rt[1]), Math.abs(st[1]))),
            b.setZ(Math.max(Math.abs(rt[2]), Math.abs(st[2]))),
            et.normalized)
          ) {
            const at = getNormalizedComponentScale(
              WEBGL_COMPONENT_TYPES[et.componentType]
            );
            b.multiplyScalar(at);
          }
          _.max(b);
        } else
          console.warn(
            "THREE.GLTFLoader: Missing min/max properties for accessor POSITION."
          );
      }
    }
    c.expandByVector(_);
  }
  s.boundingBox = c;
  const g = new Sphere();
  c.getCenter(g.center),
    (g.radius = c.min.distanceTo(c.max) / 2),
    (s.boundingSphere = g);
}
function addPrimitiveAttributes(s, e, o) {
  const a = e.attributes,
    c = [];
  function d(g, _) {
    return o.getDependency("accessor", g).then(function (b) {
      s.setAttribute(_, b);
    });
  }
  for (const g in a) {
    const _ = ATTRIBUTES[g] || g.toLowerCase();
    _ in s.attributes || c.push(d(a[g], _));
  }
  if (e.indices !== void 0 && !s.index) {
    const g = o.getDependency("accessor", e.indices).then(function (_) {
      s.setIndex(_);
    });
    c.push(g);
  }
  return (
    assignExtrasToUserData(s, e),
    computeBounds(s, e, o),
    Promise.all(c).then(function () {
      return e.targets !== void 0 ? addMorphTargets(s, e.targets, o) : s;
    })
  );
}
const HorizontalBlurShader = {
    uniforms: { tDiffuse: { value: null }, h: { value: 1 / 512 } },
    vertexShader: `
      varying vec2 vUv;

      void main() {

        vUv = uv;
        gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

      }
  `,
    fragmentShader: `
    uniform sampler2D tDiffuse;
    uniform float h;

    varying vec2 vUv;

    void main() {

    	vec4 sum = vec4( 0.0 );

    	sum += texture2D( tDiffuse, vec2( vUv.x - 4.0 * h, vUv.y ) ) * 0.051;
    	sum += texture2D( tDiffuse, vec2( vUv.x - 3.0 * h, vUv.y ) ) * 0.0918;
    	sum += texture2D( tDiffuse, vec2( vUv.x - 2.0 * h, vUv.y ) ) * 0.12245;
    	sum += texture2D( tDiffuse, vec2( vUv.x - 1.0 * h, vUv.y ) ) * 0.1531;
    	sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y ) ) * 0.1633;
    	sum += texture2D( tDiffuse, vec2( vUv.x + 1.0 * h, vUv.y ) ) * 0.1531;
    	sum += texture2D( tDiffuse, vec2( vUv.x + 2.0 * h, vUv.y ) ) * 0.12245;
    	sum += texture2D( tDiffuse, vec2( vUv.x + 3.0 * h, vUv.y ) ) * 0.0918;
    	sum += texture2D( tDiffuse, vec2( vUv.x + 4.0 * h, vUv.y ) ) * 0.051;

    	gl_FragColor = sum;

    }
  `,
  },
  VerticalBlurShader = {
    uniforms: { tDiffuse: { value: null }, v: { value: 1 / 512 } },
    vertexShader: `
    varying vec2 vUv;

    void main() {

      vUv = uv;
      gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

    }
  `,
    fragmentShader: `

  uniform sampler2D tDiffuse;
  uniform float v;

  varying vec2 vUv;

  void main() {

    vec4 sum = vec4( 0.0 );

    sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 4.0 * v ) ) * 0.051;
    sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 3.0 * v ) ) * 0.0918;
    sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 2.0 * v ) ) * 0.12245;
    sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 1.0 * v ) ) * 0.1531;
    sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y ) ) * 0.1633;
    sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 1.0 * v ) ) * 0.1531;
    sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 2.0 * v ) ) * 0.12245;
    sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 3.0 * v ) ) * 0.0918;
    sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 4.0 * v ) ) * 0.051;

    gl_FragColor = sum;

  }
  `,
  },
  _taskCache = new WeakMap();
class DRACOLoader extends Loader$2 {
  constructor(e) {
    super(e),
      (this.decoderPath = ""),
      (this.decoderConfig = {}),
      (this.decoderBinary = null),
      (this.decoderPending = null),
      (this.workerLimit = 4),
      (this.workerPool = []),
      (this.workerNextTaskID = 1),
      (this.workerSourceURL = ""),
      (this.defaultAttributeIDs = {
        position: "POSITION",
        normal: "NORMAL",
        color: "COLOR",
        uv: "TEX_COORD",
      }),
      (this.defaultAttributeTypes = {
        position: "Float32Array",
        normal: "Float32Array",
        color: "Float32Array",
        uv: "Float32Array",
      });
  }
  setDecoderPath(e) {
    return (this.decoderPath = e), this;
  }
  setDecoderConfig(e) {
    return (this.decoderConfig = e), this;
  }
  setWorkerLimit(e) {
    return (this.workerLimit = e), this;
  }
  load(e, o, a, c) {
    const d = new FileLoader(this.manager);
    d.setPath(this.path),
      d.setResponseType("arraybuffer"),
      d.setRequestHeader(this.requestHeader),
      d.setWithCredentials(this.withCredentials),
      d.load(
        e,
        (g) => {
          const _ = {
            attributeIDs: this.defaultAttributeIDs,
            attributeTypes: this.defaultAttributeTypes,
            useUniqueIDs: !1,
          };
          this.decodeGeometry(g, _).then(o).catch(c);
        },
        a,
        c
      );
  }
  decodeDracoFile(e, o, a, c) {
    const d = {
      attributeIDs: a || this.defaultAttributeIDs,
      attributeTypes: c || this.defaultAttributeTypes,
      useUniqueIDs: !!a,
    };
    this.decodeGeometry(e, d).then(o);
  }
  decodeGeometry(e, o) {
    for (const b in o.attributeTypes) {
      const j = o.attributeTypes[b];
      j.BYTES_PER_ELEMENT !== void 0 && (o.attributeTypes[b] = j.name);
    }
    const a = JSON.stringify(o);
    if (_taskCache.has(e)) {
      const b = _taskCache.get(e);
      if (b.key === a) return b.promise;
      if (e.byteLength === 0)
        throw new Error(
          "THREE.DRACOLoader: Unable to re-decode a buffer with different settings. Buffer has already been transferred."
        );
    }
    let c;
    const d = this.workerNextTaskID++,
      g = e.byteLength,
      _ = this._getWorker(d, g)
        .then(
          (b) => (
            (c = b),
            new Promise((j, $) => {
              (c._callbacks[d] = { resolve: j, reject: $ }),
                c.postMessage(
                  { type: "decode", id: d, taskConfig: o, buffer: e },
                  [e]
                );
            })
          )
        )
        .then((b) => this._createGeometry(b.geometry));
    return (
      _.catch(() => !0).then(() => {
        c && d && this._releaseTask(c, d);
      }),
      _taskCache.set(e, { key: a, promise: _ }),
      _
    );
  }
  _createGeometry(e) {
    const o = new BufferGeometry();
    e.index && o.setIndex(new BufferAttribute(e.index.array, 1));
    for (let a = 0; a < e.attributes.length; a++) {
      const c = e.attributes[a],
        d = c.name,
        g = c.array,
        _ = c.itemSize;
      o.setAttribute(d, new BufferAttribute(g, _));
    }
    return o;
  }
  _loadLibrary(e, o) {
    const a = new FileLoader(this.manager);
    return (
      a.setPath(this.decoderPath),
      a.setResponseType(o),
      a.setWithCredentials(this.withCredentials),
      new Promise((c, d) => {
        a.load(e, c, void 0, d);
      })
    );
  }
  preload() {
    return this._initDecoder(), this;
  }
  _initDecoder() {
    if (this.decoderPending) return this.decoderPending;
    const e =
        typeof WebAssembly != "object" || this.decoderConfig.type === "js",
      o = [];
    return (
      e
        ? o.push(this._loadLibrary("draco_decoder.js", "text"))
        : (o.push(this._loadLibrary("draco_wasm_wrapper.js", "text")),
          o.push(this._loadLibrary("draco_decoder.wasm", "arraybuffer"))),
      (this.decoderPending = Promise.all(o).then((a) => {
        const c = a[0];
        e || (this.decoderConfig.wasmBinary = a[1]);
        const d = DRACOWorker.toString(),
          g = [
            "/* draco decoder */",
            c,
            "",
            "/* worker */",
            d.substring(d.indexOf("{") + 1, d.lastIndexOf("}")),
          ].join(`
`);
        this.workerSourceURL = URL.createObjectURL(new Blob([g]));
      })),
      this.decoderPending
    );
  }
  _getWorker(e, o) {
    return this._initDecoder().then(() => {
      if (this.workerPool.length < this.workerLimit) {
        const c = new Worker(this.workerSourceURL);
        (c._callbacks = {}),
          (c._taskCosts = {}),
          (c._taskLoad = 0),
          c.postMessage({ type: "init", decoderConfig: this.decoderConfig }),
          (c.onmessage = function (d) {
            const g = d.data;
            switch (g.type) {
              case "decode":
                c._callbacks[g.id].resolve(g);
                break;
              case "error":
                c._callbacks[g.id].reject(g);
                break;
              default:
                console.error(
                  'THREE.DRACOLoader: Unexpected message, "' + g.type + '"'
                );
            }
          }),
          this.workerPool.push(c);
      } else
        this.workerPool.sort(function (c, d) {
          return c._taskLoad > d._taskLoad ? -1 : 1;
        });
      const a = this.workerPool[this.workerPool.length - 1];
      return (a._taskCosts[e] = o), (a._taskLoad += o), a;
    });
  }
  _releaseTask(e, o) {
    (e._taskLoad -= e._taskCosts[o]),
      delete e._callbacks[o],
      delete e._taskCosts[o];
  }
  debug() {
    console.log(
      "Task load: ",
      this.workerPool.map((e) => e._taskLoad)
    );
  }
  dispose() {
    for (let e = 0; e < this.workerPool.length; ++e)
      this.workerPool[e].terminate();
    return (this.workerPool.length = 0), this;
  }
}
function DRACOWorker() {
  let s, e;
  onmessage = function (g) {
    const _ = g.data;
    switch (_.type) {
      case "init":
        (s = _.decoderConfig),
          (e = new Promise(function ($) {
            (s.onModuleLoaded = function (_e) {
              $({ draco: _e });
            }),
              DracoDecoderModule(s);
          }));
        break;
      case "decode":
        const b = _.buffer,
          j = _.taskConfig;
        e.then(($) => {
          const _e = $.draco,
            et = new _e.Decoder(),
            rt = new _e.DecoderBuffer();
          rt.Init(new Int8Array(b), b.byteLength);
          try {
            const st = o(_e, et, rt, j),
              at = st.attributes.map((ct) => ct.array.buffer);
            st.index && at.push(st.index.array.buffer),
              self.postMessage({ type: "decode", id: _.id, geometry: st }, at);
          } catch (st) {
            console.error(st),
              self.postMessage({ type: "error", id: _.id, error: st.message });
          } finally {
            _e.destroy(rt), _e.destroy(et);
          }
        });
        break;
    }
  };
  function o(g, _, b, j) {
    const $ = j.attributeIDs,
      _e = j.attributeTypes;
    let et, rt;
    const st = _.GetEncodedGeometryType(b);
    if (st === g.TRIANGULAR_MESH)
      (et = new g.Mesh()), (rt = _.DecodeBufferToMesh(b, et));
    else if (st === g.POINT_CLOUD)
      (et = new g.PointCloud()), (rt = _.DecodeBufferToPointCloud(b, et));
    else throw new Error("THREE.DRACOLoader: Unexpected geometry type.");
    if (!rt.ok() || et.ptr === 0)
      throw new Error("THREE.DRACOLoader: Decoding failed: " + rt.error_msg());
    const at = { index: null, attributes: [] };
    for (const ct in $) {
      const it = self[_e[ct]];
      let lt, ot;
      if (j.useUniqueIDs) (ot = $[ct]), (lt = _.GetAttributeByUniqueId(et, ot));
      else {
        if (((ot = _.GetAttributeId(et, g[$[ct]])), ot === -1)) continue;
        lt = _.GetAttribute(et, ot);
      }
      at.attributes.push(c(g, _, et, ct, it, lt));
    }
    return (
      st === g.TRIANGULAR_MESH && (at.index = a(g, _, et)), g.destroy(et), at
    );
  }
  function a(g, _, b) {
    const $ = b.num_faces() * 3,
      _e = $ * 4,
      et = g._malloc(_e);
    _.GetTrianglesUInt32Array(b, _e, et);
    const rt = new Uint32Array(g.HEAPF32.buffer, et, $).slice();
    return g._free(et), { array: rt, itemSize: 1 };
  }
  function c(g, _, b, j, $, _e) {
    const et = _e.num_components(),
      st = b.num_points() * et,
      at = st * $.BYTES_PER_ELEMENT,
      ct = d(g, $),
      it = g._malloc(at);
    _.GetAttributeDataArrayForAllPoints(b, _e, ct, at, it);
    const lt = new $(g.HEAPF32.buffer, it, st).slice();
    return g._free(it), { name: j, array: lt, itemSize: et };
  }
  function d(g, _) {
    switch (_) {
      case Float32Array:
        return g.DT_FLOAT32;
      case Int8Array:
        return g.DT_INT8;
      case Int16Array:
        return g.DT_INT16;
      case Int32Array:
        return g.DT_INT32;
      case Uint8Array:
        return g.DT_UINT8;
      case Uint16Array:
        return g.DT_UINT16;
      case Uint32Array:
        return g.DT_UINT32;
    }
  }
}
let generated;
const MeshoptDecoder = () => {
  if (generated) return generated;
  const s =
      "B9h9z9tFBBBF8fL9gBB9gLaaaaaFa9gEaaaB9gFaFa9gEaaaFaEMcBFFFGGGEIIILF9wFFFLEFBFKNFaFCx/IFMO/LFVK9tv9t9vq95GBt9f9f939h9z9t9f9j9h9s9s9f9jW9vq9zBBp9tv9z9o9v9wW9f9kv9j9v9kv9WvqWv94h919m9mvqBF8Z9tv9z9o9v9wW9f9kv9j9v9kv9J9u9kv94h919m9mvqBGy9tv9z9o9v9wW9f9kv9j9v9kv9J9u9kv949TvZ91v9u9jvBEn9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9P9jWBIi9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9R919hWBLn9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9F949wBKI9z9iqlBOc+x8ycGBM/qQFTa8jUUUUBCU/EBlHL8kUUUUBC9+RKGXAGCFJAI9LQBCaRKAE2BBC+gF9HQBALAEAIJHOAGlAGTkUUUBRNCUoBAG9uC/wgBZHKCUGAKCUG9JyRVAECFJRICBRcGXEXAcAF9PQFAVAFAclAcAVJAF9JyRMGXGXAG9FQBAMCbJHKC9wZRSAKCIrCEJCGrRQANCUGJRfCBRbAIRTEXGXAOATlAQ9PQBCBRISEMATAQJRIGXAS9FQBCBRtCBREEXGXAOAIlCi9PQBCBRISLMANCU/CBJAEJRKGXGXGXGXGXATAECKrJ2BBAtCKZrCEZfIBFGEBMAKhB83EBAKCNJhB83EBSEMAKAI2BIAI2BBHmCKrHYAYCE6HYy86BBAKCFJAICIJAYJHY2BBAmCIrCEZHPAPCE6HPy86BBAKCGJAYAPJHY2BBAmCGrCEZHPAPCE6HPy86BBAKCEJAYAPJHY2BBAmCEZHmAmCE6Hmy86BBAKCIJAYAmJHY2BBAI2BFHmCKrHPAPCE6HPy86BBAKCLJAYAPJHY2BBAmCIrCEZHPAPCE6HPy86BBAKCKJAYAPJHY2BBAmCGrCEZHPAPCE6HPy86BBAKCOJAYAPJHY2BBAmCEZHmAmCE6Hmy86BBAKCNJAYAmJHY2BBAI2BGHmCKrHPAPCE6HPy86BBAKCVJAYAPJHY2BBAmCIrCEZHPAPCE6HPy86BBAKCcJAYAPJHY2BBAmCGrCEZHPAPCE6HPy86BBAKCMJAYAPJHY2BBAmCEZHmAmCE6Hmy86BBAKCSJAYAmJHm2BBAI2BEHICKrHYAYCE6HYy86BBAKCQJAmAYJHm2BBAICIrCEZHYAYCE6HYy86BBAKCfJAmAYJHm2BBAICGrCEZHYAYCE6HYy86BBAKCbJAmAYJHK2BBAICEZHIAICE6HIy86BBAKAIJRISGMAKAI2BNAI2BBHmCIrHYAYCb6HYy86BBAKCFJAICNJAYJHY2BBAmCbZHmAmCb6Hmy86BBAKCGJAYAmJHm2BBAI2BFHYCIrHPAPCb6HPy86BBAKCEJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCIJAmAYJHm2BBAI2BGHYCIrHPAPCb6HPy86BBAKCLJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCKJAmAYJHm2BBAI2BEHYCIrHPAPCb6HPy86BBAKCOJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCNJAmAYJHm2BBAI2BIHYCIrHPAPCb6HPy86BBAKCVJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCcJAmAYJHm2BBAI2BLHYCIrHPAPCb6HPy86BBAKCMJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCSJAmAYJHm2BBAI2BKHYCIrHPAPCb6HPy86BBAKCQJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCfJAmAYJHm2BBAI2BOHICIrHYAYCb6HYy86BBAKCbJAmAYJHK2BBAICbZHIAICb6HIy86BBAKAIJRISFMAKAI8pBB83BBAKCNJAICNJ8pBB83BBAICTJRIMAtCGJRtAECTJHEAS9JQBMMGXAIQBCBRISEMGXAM9FQBANAbJ2BBRtCBRKAfREEXAEANCU/CBJAKJ2BBHTCFrCBATCFZl9zAtJHt86BBAEAGJREAKCFJHKAM9HQBMMAfCFJRfAIRTAbCFJHbAG9HQBMMABAcAG9sJANCUGJAMAG9sTkUUUBpANANCUGJAMCaJAG9sJAGTkUUUBpMAMCBAIyAcJRcAIQBMC9+RKSFMCBC99AOAIlAGCAAGCA9Ly6yRKMALCU/EBJ8kUUUUBAKM+OmFTa8jUUUUBCoFlHL8kUUUUBC9+RKGXAFCE9uHOCtJAI9LQBCaRKAE2BBHNC/wFZC/gF9HQBANCbZHVCF9LQBALCoBJCgFCUFT+JUUUBpALC84Jha83EBALC8wJha83EBALC8oJha83EBALCAJha83EBALCiJha83EBALCTJha83EBALha83ENALha83EBAEAIJC9wJRcAECFJHNAOJRMGXAF9FQBCQCbAVCF6yRSABRECBRVCBRQCBRfCBRICBRKEXGXAMAcuQBC9+RKSEMGXGXAN2BBHOC/vF9LQBALCoBJAOCIrCa9zAKJCbZCEWJHb8oGIRTAb8oGBRtGXAOCbZHbAS9PQBALAOCa9zAIJCbZCGWJ8oGBAVAbyROAb9FRbGXGXAGCG9HQBABAt87FBABCIJAO87FBABCGJAT87FBSFMAEAtjGBAECNJAOjGBAECIJATjGBMAVAbJRVALCoBJAKCEWJHmAOjGBAmATjGIALAICGWJAOjGBALCoBJAKCFJCbZHKCEWJHTAtjGBATAOjGIAIAbJRIAKCFJRKSGMGXGXAbCb6QBAQAbJAbC989zJCFJRQSFMAM1BBHbCgFZROGXGXAbCa9MQBAMCFJRMSFMAM1BFHbCgBZCOWAOCgBZqROGXAbCa9MQBAMCGJRMSFMAM1BGHbCgBZCfWAOqROGXAbCa9MQBAMCEJRMSFMAM1BEHbCgBZCdWAOqROGXAbCa9MQBAMCIJRMSFMAM2BIC8cWAOqROAMCLJRMMAOCFrCBAOCFZl9zAQJRQMGXGXAGCG9HQBABAt87FBABCIJAQ87FBABCGJAT87FBSFMAEAtjGBAECNJAQjGBAECIJATjGBMALCoBJAKCEWJHOAQjGBAOATjGIALAICGWJAQjGBALCoBJAKCFJCbZHKCEWJHOAtjGBAOAQjGIAICFJRIAKCFJRKSFMGXAOCDF9LQBALAIAcAOCbZJ2BBHbCIrHTlCbZCGWJ8oGBAVCFJHtATyROALAIAblCbZCGWJ8oGBAtAT9FHmJHtAbCbZHTyRbAT9FRTGXGXAGCG9HQBABAV87FBABCIJAb87FBABCGJAO87FBSFMAEAVjGBAECNJAbjGBAECIJAOjGBMALAICGWJAVjGBALCoBJAKCEWJHYAOjGBAYAVjGIALAICFJHICbZCGWJAOjGBALCoBJAKCFJCbZCEWJHYAbjGBAYAOjGIALAIAmJCbZHICGWJAbjGBALCoBJAKCGJCbZHKCEWJHOAVjGBAOAbjGIAKCFJRKAIATJRIAtATJRVSFMAVCBAM2BBHYyHTAOC/+F6HPJROAYCbZRtGXGXAYCIrHmQBAOCFJRbSFMAORbALAIAmlCbZCGWJ8oGBROMGXGXAtQBAbCFJRVSFMAbRVALAIAYlCbZCGWJ8oGBRbMGXGXAP9FQBAMCFJRYSFMAM1BFHYCgFZRTGXGXAYCa9MQBAMCGJRYSFMAM1BGHYCgBZCOWATCgBZqRTGXAYCa9MQBAMCEJRYSFMAM1BEHYCgBZCfWATqRTGXAYCa9MQBAMCIJRYSFMAM1BIHYCgBZCdWATqRTGXAYCa9MQBAMCLJRYSFMAMCKJRYAM2BLC8cWATqRTMATCFrCBATCFZl9zAQJHQRTMGXGXAmCb6QBAYRPSFMAY1BBHMCgFZROGXGXAMCa9MQBAYCFJRPSFMAY1BFHMCgBZCOWAOCgBZqROGXAMCa9MQBAYCGJRPSFMAY1BGHMCgBZCfWAOqROGXAMCa9MQBAYCEJRPSFMAY1BEHMCgBZCdWAOqROGXAMCa9MQBAYCIJRPSFMAYCLJRPAY2BIC8cWAOqROMAOCFrCBAOCFZl9zAQJHQROMGXGXAtCb6QBAPRMSFMAP1BBHMCgFZRbGXGXAMCa9MQBAPCFJRMSFMAP1BFHMCgBZCOWAbCgBZqRbGXAMCa9MQBAPCGJRMSFMAP1BGHMCgBZCfWAbqRbGXAMCa9MQBAPCEJRMSFMAP1BEHMCgBZCdWAbqRbGXAMCa9MQBAPCIJRMSFMAPCLJRMAP2BIC8cWAbqRbMAbCFrCBAbCFZl9zAQJHQRbMGXGXAGCG9HQBABAT87FBABCIJAb87FBABCGJAO87FBSFMAEATjGBAECNJAbjGBAECIJAOjGBMALCoBJAKCEWJHYAOjGBAYATjGIALAICGWJATjGBALCoBJAKCFJCbZCEWJHYAbjGBAYAOjGIALAICFJHICbZCGWJAOjGBALCoBJAKCGJCbZCEWJHOATjGBAOAbjGIALAIAm9FAmCb6qJHICbZCGWJAbjGBAIAt9FAtCb6qJRIAKCEJRKMANCFJRNABCKJRBAECSJREAKCbZRKAICbZRIAfCEJHfAF9JQBMMCBC99AMAc6yRKMALCoFJ8kUUUUBAKM/tIFGa8jUUUUBCTlRLC9+RKGXAFCLJAI9LQBCaRKAE2BBC/+FZC/QF9HQBALhB83ENAECFJRKAEAIJC98JREGXAF9FQBGXAGCG6QBEXGXAKAE9JQBC9+bMAK1BBHGCgFZRIGXGXAGCa9MQBAKCFJRKSFMAK1BFHGCgBZCOWAICgBZqRIGXAGCa9MQBAKCGJRKSFMAK1BGHGCgBZCfWAIqRIGXAGCa9MQBAKCEJRKSFMAK1BEHGCgBZCdWAIqRIGXAGCa9MQBAKCIJRKSFMAK2BIC8cWAIqRIAKCLJRKMALCNJAICFZCGWqHGAICGrCBAICFrCFZl9zAG8oGBJHIjGBABAIjGBABCIJRBAFCaJHFQBSGMMEXGXAKAE9JQBC9+bMAK1BBHGCgFZRIGXGXAGCa9MQBAKCFJRKSFMAK1BFHGCgBZCOWAICgBZqRIGXAGCa9MQBAKCGJRKSFMAK1BGHGCgBZCfWAIqRIGXAGCa9MQBAKCEJRKSFMAK1BEHGCgBZCdWAIqRIGXAGCa9MQBAKCIJRKSFMAK2BIC8cWAIqRIAKCLJRKMABAICGrCBAICFrCFZl9zALCNJAICFZCGWqHI8oGBJHG87FBAIAGjGBABCGJRBAFCaJHFQBMMCBC99AKAE6yRKMAKM+lLKFaF99GaG99FaG99GXGXAGCI9HQBAF9FQFEXGXGX9DBBB8/9DBBB+/ABCGJHG1BB+yAB1BBHE+yHI+L+TABCFJHL1BBHK+yHO+L+THN9DBBBB9gHVyAN9DBB/+hANAN+U9DBBBBANAVyHcAc+MHMAECa3yAI+SHIAI+UAcAMAKCa3yAO+SHcAc+U+S+S+R+VHO+U+SHN+L9DBBB9P9d9FQBAN+oRESFMCUUUU94REMAGAE86BBGXGX9DBBB8/9DBBB+/Ac9DBBBB9gyAcAO+U+SHN+L9DBBB9P9d9FQBAN+oRGSFMCUUUU94RGMALAG86BBGXGX9DBBB8/9DBBB+/AI9DBBBB9gyAIAO+U+SHN+L9DBBB9P9d9FQBAN+oRGSFMCUUUU94RGMABAG86BBABCIJRBAFCaJHFQBSGMMAF9FQBEXGXGX9DBBB8/9DBBB+/ABCIJHG8uFB+yAB8uFBHE+yHI+L+TABCGJHL8uFBHK+yHO+L+THN9DBBBB9gHVyAN9DB/+g6ANAN+U9DBBBBANAVyHcAc+MHMAECa3yAI+SHIAI+UAcAMAKCa3yAO+SHcAc+U+S+S+R+VHO+U+SHN+L9DBBB9P9d9FQBAN+oRESFMCUUUU94REMAGAE87FBGXGX9DBBB8/9DBBB+/Ac9DBBBB9gyAcAO+U+SHN+L9DBBB9P9d9FQBAN+oRGSFMCUUUU94RGMALAG87FBGXGX9DBBB8/9DBBB+/AI9DBBBB9gyAIAO+U+SHN+L9DBBB9P9d9FQBAN+oRGSFMCUUUU94RGMABAG87FBABCNJRBAFCaJHFQBMMM/SEIEaE99EaF99GXAF9FQBCBREABRIEXGXGX9D/zI818/AICKJ8uFBHLCEq+y+VHKAI8uFB+y+UHO9DB/+g6+U9DBBB8/9DBBB+/AO9DBBBB9gy+SHN+L9DBBB9P9d9FQBAN+oRVSFMCUUUU94RVMAICIJ8uFBRcAICGJ8uFBRMABALCFJCEZAEqCFWJAV87FBGXGXAKAM+y+UHN9DB/+g6+U9DBBB8/9DBBB+/AN9DBBBB9gy+SHS+L9DBBB9P9d9FQBAS+oRMSFMCUUUU94RMMABALCGJCEZAEqCFWJAM87FBGXGXAKAc+y+UHK9DB/+g6+U9DBBB8/9DBBB+/AK9DBBBB9gy+SHS+L9DBBB9P9d9FQBAS+oRcSFMCUUUU94RcMABALCaJCEZAEqCFWJAc87FBGXGX9DBBU8/AOAO+U+TANAN+U+TAKAK+U+THO9DBBBBAO9DBBBB9gy+R9DB/+g6+U9DBBB8/+SHO+L9DBBB9P9d9FQBAO+oRcSFMCUUUU94RcMABALCEZAEqCFWJAc87FBAICNJRIAECIJREAFCaJHFQBMMM9JBGXAGCGrAF9sHF9FQBEXABAB8oGBHGCNWCN91+yAGCi91CnWCUUU/8EJ+++U84GBABCIJRBAFCaJHFQBMMM9TFEaCBCB8oGUkUUBHFABCEJC98ZJHBjGUkUUBGXGXAB8/BCTWHGuQBCaREABAGlCggEJCTrXBCa6QFMAFREMAEM/lFFFaGXGXAFABqCEZ9FQBABRESFMGXGXAGCT9PQBABRESFMABREEXAEAF8oGBjGBAECIJAFCIJ8oGBjGBAECNJAFCNJ8oGBjGBAECSJAFCSJ8oGBjGBAECTJREAFCTJRFAGC9wJHGCb9LQBMMAGCI9JQBEXAEAF8oGBjGBAFCIJRFAECIJREAGC98JHGCE9LQBMMGXAG9FQBEXAEAF2BB86BBAECFJREAFCFJRFAGCaJHGQBMMABMoFFGaGXGXABCEZ9FQBABRESFMAFCgFZC+BwsN9sRIGXGXAGCT9PQBABRESFMABREEXAEAIjGBAECSJAIjGBAECNJAIjGBAECIJAIjGBAECTJREAGC9wJHGCb9LQBMMAGCI9JQBEXAEAIjGBAECIJREAGC98JHGCE9LQBMMGXAG9FQBEXAEAF86BBAECFJREAGCaJHGQBMMABMMMFBCUNMIT9kBB",
    e =
      "B9h9z9tFBBBFiI9gBB9gLaaaaaFa9gEaaaB9gFaFaEMcBBFBFFGGGEILF9wFFFLEFBFKNFaFCx/aFMO/LFVK9tv9t9vq95GBt9f9f939h9z9t9f9j9h9s9s9f9jW9vq9zBBp9tv9z9o9v9wW9f9kv9j9v9kv9WvqWv94h919m9mvqBG8Z9tv9z9o9v9wW9f9kv9j9v9kv9J9u9kv94h919m9mvqBIy9tv9z9o9v9wW9f9kv9j9v9kv9J9u9kv949TvZ91v9u9jvBLn9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9P9jWBKi9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9R919hWBOn9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9F949wBNI9z9iqlBVc+N9IcIBTEM9+FLa8jUUUUBCTlRBCBRFEXCBRGCBREEXABCNJAGJAECUaAFAGrCFZHIy86BBAEAIJREAGCFJHGCN9HQBMAFCx+YUUBJAE86BBAFCEWCxkUUBJAB8pEN83EBAFCFJHFCUG9HQBMMk8lLbaE97F9+FaL978jUUUUBCU/KBlHL8kUUUUBC9+RKGXAGCFJAI9LQBCaRKAE2BBC+gF9HQBALAEAIJHOAGlAG/8cBBCUoBAG9uC/wgBZHKCUGAKCUG9JyRNAECFJRKCBRVGXEXAVAF9PQFANAFAVlAVANJAF9JyRcGXGXAG9FQBAcCbJHIC9wZHMCE9sRSAMCFWRQAICIrCEJCGrRfCBRbEXAKRTCBRtGXEXGXAOATlAf9PQBCBRKSLMALCU/CBJAtAM9sJRmATAfJRKCBREGXAMCoB9JQBAOAKlC/gB9JQBCBRIEXAmAIJREGXGXGXGXGXATAICKrJ2BBHYCEZfIBFGEBMAECBDtDMIBSEMAEAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIBAKCIJAeDeBJAiCx+YUUBJ2BBJRKSGMAEAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIBAKCNJAeDeBJAiCx+YUUBJ2BBJRKSFMAEAKDBBBDMIBAKCTJRKMGXGXGXGXGXAYCGrCEZfIBFGEBMAECBDtDMITSEMAEAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMITAKCIJAeDeBJAiCx+YUUBJ2BBJRKSGMAEAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMITAKCNJAeDeBJAiCx+YUUBJ2BBJRKSFMAEAKDBBBDMITAKCTJRKMGXGXGXGXGXAYCIrCEZfIBFGEBMAECBDtDMIASEMAEAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIAAKCIJAeDeBJAiCx+YUUBJ2BBJRKSGMAEAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIAAKCNJAeDeBJAiCx+YUUBJ2BBJRKSFMAEAKDBBBDMIAAKCTJRKMGXGXGXGXGXAYCKrfIBFGEBMAECBDtDMI8wSEMAEAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHYCEWCxkUUBJDBEBAYCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHYCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMI8wAKCIJAeDeBJAYCx+YUUBJ2BBJRKSGMAEAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHYCEWCxkUUBJDBEBAYCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHYCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMI8wAKCNJAeDeBJAYCx+YUUBJ2BBJRKSFMAEAKDBBBDMI8wAKCTJRKMAICoBJREAICUFJAM9LQFAERIAOAKlC/fB9LQBMMGXAEAM9PQBAECErRIEXGXAOAKlCi9PQBCBRKSOMAmAEJRYGXGXGXGXGXATAECKrJ2BBAICKZrCEZfIBFGEBMAYCBDtDMIBSEMAYAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIBAKCIJAeDeBJAiCx+YUUBJ2BBJRKSGMAYAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIBAKCNJAeDeBJAiCx+YUUBJ2BBJRKSFMAYAKDBBBDMIBAKCTJRKMAICGJRIAECTJHEAM9JQBMMGXAK9FQBAKRTAtCFJHtCI6QGSFMMCBRKSEMGXAM9FQBALCUGJAbJREALAbJDBGBReCBRYEXAEALCU/CBJAYJHIDBIBHdCFD9tAdCFDbHPD9OD9hD9RHdAIAMJDBIBH8ZCFD9tA8ZAPD9OD9hD9RH8ZDQBTFtGmEYIPLdKeOnHpAIAQJDBIBHyCFD9tAyAPD9OD9hD9RHyAIASJDBIBH8cCFD9tA8cAPD9OD9hD9RH8cDQBTFtGmEYIPLdKeOnH8dDQBFTtGEmYILPdKOenHPAPDQBFGEBFGEBFGEBFGEAeD9uHeDyBjGBAEAGJHIAeAPAPDQILKOILKOILKOILKOD9uHeDyBjGBAIAGJHIAeAPAPDQNVcMNVcMNVcMNVcMD9uHeDyBjGBAIAGJHIAeAPAPDQSQfbSQfbSQfbSQfbD9uHeDyBjGBAIAGJHIAeApA8dDQNVi8ZcMpySQ8c8dfb8e8fHPAPDQBFGEBFGEBFGEBFGED9uHeDyBjGBAIAGJHIAeAPAPDQILKOILKOILKOILKOD9uHeDyBjGBAIAGJHIAeAPAPDQNVcMNVcMNVcMNVcMD9uHeDyBjGBAIAGJHIAeAPAPDQSQfbSQfbSQfbSQfbD9uHeDyBjGBAIAGJHIAeAdA8ZDQNiV8ZcpMyS8cQ8df8eb8fHdAyA8cDQNiV8ZcpMyS8cQ8df8eb8fH8ZDQBFTtGEmYILPdKOenHPAPDQBFGEBFGEBFGEBFGED9uHeDyBjGBAIAGJHIAeAPAPDQILKOILKOILKOILKOD9uHeDyBjGBAIAGJHIAeAPAPDQNVcMNVcMNVcMNVcMD9uHeDyBjGBAIAGJHIAeAPAPDQSQfbSQfbSQfbSQfbD9uHeDyBjGBAIAGJHIAeAdA8ZDQNVi8ZcMpySQ8c8dfb8e8fHPAPDQBFGEBFGEBFGEBFGED9uHeDyBjGBAIAGJHIAeAPAPDQILKOILKOILKOILKOD9uHeDyBjGBAIAGJHIAeAPAPDQNVcMNVcMNVcMNVcMD9uHeDyBjGBAIAGJHIAeAPAPDQSQfbSQfbSQfbSQfbD9uHeDyBjGBAIAGJREAYCTJHYAM9JQBMMAbCIJHbAG9JQBMMABAVAG9sJALCUGJAcAG9s/8cBBALALCUGJAcCaJAG9sJAG/8cBBMAcCBAKyAVJRVAKQBMC9+RKSFMCBC99AOAKlAGCAAGCA9Ly6yRKMALCU/KBJ8kUUUUBAKMNBT+BUUUBM+KmFTa8jUUUUBCoFlHL8kUUUUBC9+RKGXAFCE9uHOCtJAI9LQBCaRKAE2BBHNC/wFZC/gF9HQBANCbZHVCF9LQBALCoBJCgFCUF/8MBALC84Jha83EBALC8wJha83EBALC8oJha83EBALCAJha83EBALCiJha83EBALCTJha83EBALha83ENALha83EBAEAIJC9wJRcAECFJHNAOJRMGXAF9FQBCQCbAVCF6yRSABRECBRVCBRQCBRfCBRICBRKEXGXAMAcuQBC9+RKSEMGXGXAN2BBHOC/vF9LQBALCoBJAOCIrCa9zAKJCbZCEWJHb8oGIRTAb8oGBRtGXAOCbZHbAS9PQBALAOCa9zAIJCbZCGWJ8oGBAVAbyROAb9FRbGXGXAGCG9HQBABAt87FBABCIJAO87FBABCGJAT87FBSFMAEAtjGBAECNJAOjGBAECIJATjGBMAVAbJRVALCoBJAKCEWJHmAOjGBAmATjGIALAICGWJAOjGBALCoBJAKCFJCbZHKCEWJHTAtjGBATAOjGIAIAbJRIAKCFJRKSGMGXGXAbCb6QBAQAbJAbC989zJCFJRQSFMAM1BBHbCgFZROGXGXAbCa9MQBAMCFJRMSFMAM1BFHbCgBZCOWAOCgBZqROGXAbCa9MQBAMCGJRMSFMAM1BGHbCgBZCfWAOqROGXAbCa9MQBAMCEJRMSFMAM1BEHbCgBZCdWAOqROGXAbCa9MQBAMCIJRMSFMAM2BIC8cWAOqROAMCLJRMMAOCFrCBAOCFZl9zAQJRQMGXGXAGCG9HQBABAt87FBABCIJAQ87FBABCGJAT87FBSFMAEAtjGBAECNJAQjGBAECIJATjGBMALCoBJAKCEWJHOAQjGBAOATjGIALAICGWJAQjGBALCoBJAKCFJCbZHKCEWJHOAtjGBAOAQjGIAICFJRIAKCFJRKSFMGXAOCDF9LQBALAIAcAOCbZJ2BBHbCIrHTlCbZCGWJ8oGBAVCFJHtATyROALAIAblCbZCGWJ8oGBAtAT9FHmJHtAbCbZHTyRbAT9FRTGXGXAGCG9HQBABAV87FBABCIJAb87FBABCGJAO87FBSFMAEAVjGBAECNJAbjGBAECIJAOjGBMALAICGWJAVjGBALCoBJAKCEWJHYAOjGBAYAVjGIALAICFJHICbZCGWJAOjGBALCoBJAKCFJCbZCEWJHYAbjGBAYAOjGIALAIAmJCbZHICGWJAbjGBALCoBJAKCGJCbZHKCEWJHOAVjGBAOAbjGIAKCFJRKAIATJRIAtATJRVSFMAVCBAM2BBHYyHTAOC/+F6HPJROAYCbZRtGXGXAYCIrHmQBAOCFJRbSFMAORbALAIAmlCbZCGWJ8oGBROMGXGXAtQBAbCFJRVSFMAbRVALAIAYlCbZCGWJ8oGBRbMGXGXAP9FQBAMCFJRYSFMAM1BFHYCgFZRTGXGXAYCa9MQBAMCGJRYSFMAM1BGHYCgBZCOWATCgBZqRTGXAYCa9MQBAMCEJRYSFMAM1BEHYCgBZCfWATqRTGXAYCa9MQBAMCIJRYSFMAM1BIHYCgBZCdWATqRTGXAYCa9MQBAMCLJRYSFMAMCKJRYAM2BLC8cWATqRTMATCFrCBATCFZl9zAQJHQRTMGXGXAmCb6QBAYRPSFMAY1BBHMCgFZROGXGXAMCa9MQBAYCFJRPSFMAY1BFHMCgBZCOWAOCgBZqROGXAMCa9MQBAYCGJRPSFMAY1BGHMCgBZCfWAOqROGXAMCa9MQBAYCEJRPSFMAY1BEHMCgBZCdWAOqROGXAMCa9MQBAYCIJRPSFMAYCLJRPAY2BIC8cWAOqROMAOCFrCBAOCFZl9zAQJHQROMGXGXAtCb6QBAPRMSFMAP1BBHMCgFZRbGXGXAMCa9MQBAPCFJRMSFMAP1BFHMCgBZCOWAbCgBZqRbGXAMCa9MQBAPCGJRMSFMAP1BGHMCgBZCfWAbqRbGXAMCa9MQBAPCEJRMSFMAP1BEHMCgBZCdWAbqRbGXAMCa9MQBAPCIJRMSFMAPCLJRMAP2BIC8cWAbqRbMAbCFrCBAbCFZl9zAQJHQRbMGXGXAGCG9HQBABAT87FBABCIJAb87FBABCGJAO87FBSFMAEATjGBAECNJAbjGBAECIJAOjGBMALCoBJAKCEWJHYAOjGBAYATjGIALAICGWJATjGBALCoBJAKCFJCbZCEWJHYAbjGBAYAOjGIALAICFJHICbZCGWJAOjGBALCoBJAKCGJCbZCEWJHOATjGBAOAbjGIALAIAm9FAmCb6qJHICbZCGWJAbjGBAIAt9FAtCb6qJRIAKCEJRKMANCFJRNABCKJRBAECSJREAKCbZRKAICbZRIAfCEJHfAF9JQBMMCBC99AMAc6yRKMALCoFJ8kUUUUBAKM/tIFGa8jUUUUBCTlRLC9+RKGXAFCLJAI9LQBCaRKAE2BBC/+FZC/QF9HQBALhB83ENAECFJRKAEAIJC98JREGXAF9FQBGXAGCG6QBEXGXAKAE9JQBC9+bMAK1BBHGCgFZRIGXGXAGCa9MQBAKCFJRKSFMAK1BFHGCgBZCOWAICgBZqRIGXAGCa9MQBAKCGJRKSFMAK1BGHGCgBZCfWAIqRIGXAGCa9MQBAKCEJRKSFMAK1BEHGCgBZCdWAIqRIGXAGCa9MQBAKCIJRKSFMAK2BIC8cWAIqRIAKCLJRKMALCNJAICFZCGWqHGAICGrCBAICFrCFZl9zAG8oGBJHIjGBABAIjGBABCIJRBAFCaJHFQBSGMMEXGXAKAE9JQBC9+bMAK1BBHGCgFZRIGXGXAGCa9MQBAKCFJRKSFMAK1BFHGCgBZCOWAICgBZqRIGXAGCa9MQBAKCGJRKSFMAK1BGHGCgBZCfWAIqRIGXAGCa9MQBAKCEJRKSFMAK1BEHGCgBZCdWAIqRIGXAGCa9MQBAKCIJRKSFMAK2BIC8cWAIqRIAKCLJRKMABAICGrCBAICFrCFZl9zALCNJAICFZCGWqHI8oGBJHG87FBAIAGjGBABCGJRBAFCaJHFQBMMCBC99AKAE6yRKMAKM/dLEK97FaF97GXGXAGCI9HQBAF9FQFCBRGEXABABDBBBHECiD+rFCiD+sFD/6FHIAECND+rFCiD+sFD/6FAID/gFAECTD+rFCiD+sFD/6FHLD/gFD/kFD/lFHKCBDtD+2FHOAICUUUU94DtHND9OD9RD/kFHI9DBB/+hDYAIAID/mFAKAKD/mFALAOALAND9OD9RD/kFHIAID/mFD/kFD/kFD/jFD/nFHLD/mF9DBBX9LDYHOD/kFCgFDtD9OAECUUU94DtD9OD9QAIALD/mFAOD/kFCND+rFCU/+EDtD9OD9QAKALD/mFAOD/kFCTD+rFCUU/8ODtD9OD9QDMBBABCTJRBAGCIJHGAF9JQBSGMMAF9FQBCBRGEXABCTJHVAVDBBBHECBDtHOCUU98D8cFCUU98D8cEHND9OABDBBBHKAEDQILKOSQfbPden8c8d8e8fCggFDtD9OD/6FAKAEDQBFGENVcMTtmYi8ZpyHECTD+sFD/6FHID/gFAECTD+rFCTD+sFD/6FHLD/gFD/kFD/lFHE9DB/+g6DYALAEAOD+2FHOALCUUUU94DtHcD9OD9RD/kFHLALD/mFAEAED/mFAIAOAIAcD9OD9RD/kFHEAED/mFD/kFD/kFD/jFD/nFHID/mF9DBBX9LDYHOD/kFCTD+rFALAID/mFAOD/kFCggEDtD9OD9QHLAEAID/mFAOD/kFCaDbCBDnGCBDnECBDnKCBDnOCBDncCBDnMCBDnfCBDnbD9OHEDQNVi8ZcMpySQ8c8dfb8e8fD9QDMBBABAKAND9OALAEDQBFTtGEmYILPdKOenD9QDMBBABCAJRBAGCIJHGAF9JQBMMM/hEIGaF97FaL978jUUUUBCTlREGXAF9FQBCBRIEXAEABDBBBHLABCTJHKDBBBHODQILKOSQfbPden8c8d8e8fHNCTD+sFHVCID+rFDMIBAB9DBBU8/DY9D/zI818/DYAVCEDtD9QD/6FD/nFHVALAODQBFGENVcMTtmYi8ZpyHLCTD+rFCTD+sFD/6FD/mFHOAOD/mFAVALCTD+sFD/6FD/mFHcAcD/mFAVANCTD+rFCTD+sFD/6FD/mFHNAND/mFD/kFD/kFD/lFCBDtD+4FD/jF9DB/+g6DYHVD/mF9DBBX9LDYHLD/kFCggEDtHMD9OAcAVD/mFALD/kFCTD+rFD9QHcANAVD/mFALD/kFCTD+rFAOAVD/mFALD/kFAMD9OD9QHVDQBFTtGEmYILPdKOenHLD8dBAEDBIBDyB+t+J83EBABCNJALD8dFAEDBIBDyF+t+J83EBAKAcAVDQNVi8ZcMpySQ8c8dfb8e8fHVD8dBAEDBIBDyG+t+J83EBABCiJAVD8dFAEDBIBDyE+t+J83EBABCAJRBAICIJHIAF9JQBMMM9jFF97GXAGCGrAF9sHG9FQBCBRFEXABABDBBBHECND+rFCND+sFD/6FAECiD+sFCnD+rFCUUU/8EDtD+uFD/mFDMBBABCTJRBAFCIJHFAG9JQBMMM9TFEaCBCB8oGUkUUBHFABCEJC98ZJHBjGUkUUBGXGXAB8/BCTWHGuQBCaREABAGlCggEJCTrXBCa6QFMAFREMAEMMMFBCUNMIT9tBB",
    o = new Uint8Array([
      0, 97, 115, 109, 1, 0, 0, 0, 1, 4, 1, 96, 0, 0, 3, 3, 2, 0, 0, 5, 3, 1, 0,
      1, 12, 1, 0, 10, 22, 2, 12, 0, 65, 0, 65, 0, 65, 0, 252, 10, 0, 0, 11, 7,
      0, 65, 0, 253, 15, 26, 11,
    ]),
    a = new Uint8Array([
      32, 0, 65, 253, 3, 1, 2, 34, 4, 106, 6, 5, 11, 8, 7, 20, 13, 33, 12, 16,
      128, 9, 116, 64, 19, 113, 127, 15, 10, 21, 22, 14, 255, 66, 24, 54, 136,
      107, 18, 23, 192, 26, 114, 118, 132, 17, 77, 101, 130, 144, 27, 87, 131,
      44, 45, 74, 156, 154, 70, 167,
    ]);
  if (typeof WebAssembly != "object") return { supported: !1 };
  let c = s;
  WebAssembly.validate(o) && (c = e);
  let d;
  const g = WebAssembly.instantiate(_(c), {}).then((_e) => {
    (d = _e.instance), d.exports.__wasm_call_ctors();
  });
  function _(_e) {
    const et = new Uint8Array(_e.length);
    for (let st = 0; st < _e.length; ++st) {
      const at = _e.charCodeAt(st);
      et[st] =
        at > 96
          ? at - 71
          : at > 64
          ? at - 65
          : at > 47
          ? at + 4
          : at > 46
          ? 63
          : 62;
    }
    let rt = 0;
    for (let st = 0; st < _e.length; ++st)
      et[rt++] = et[st] < 60 ? a[et[st]] : (et[st] - 60) * 64 + et[++st];
    return et.buffer.slice(0, rt);
  }
  function b(_e, et, rt, st, at, ct) {
    const it = d.exports.sbrk,
      lt = (rt + 3) & -4,
      ot = it(lt * st),
      ut = it(at.length),
      pt = new Uint8Array(d.exports.memory.buffer);
    pt.set(at, ut);
    const ft = _e(ot, rt, st, ut, at.length);
    if (
      (ft === 0 && ct && ct(ot, lt, st),
      et.set(pt.subarray(ot, ot + rt * st)),
      it(ot - it(0)),
      ft !== 0)
    )
      throw new Error(`Malformed buffer data: ${ft}`);
  }
  const j = {
      0: "",
      1: "meshopt_decodeFilterOct",
      2: "meshopt_decodeFilterQuat",
      3: "meshopt_decodeFilterExp",
      NONE: "",
      OCTAHEDRAL: "meshopt_decodeFilterOct",
      QUATERNION: "meshopt_decodeFilterQuat",
      EXPONENTIAL: "meshopt_decodeFilterExp",
    },
    $ = {
      0: "meshopt_decodeVertexBuffer",
      1: "meshopt_decodeIndexBuffer",
      2: "meshopt_decodeIndexSequence",
      ATTRIBUTES: "meshopt_decodeVertexBuffer",
      TRIANGLES: "meshopt_decodeIndexBuffer",
      INDICES: "meshopt_decodeIndexSequence",
    };
  return (
    (generated = {
      ready: g,
      supported: !0,
      decodeVertexBuffer(_e, et, rt, st, at) {
        b(
          d.exports.meshopt_decodeVertexBuffer,
          _e,
          et,
          rt,
          st,
          d.exports[j[at]]
        );
      },
      decodeIndexBuffer(_e, et, rt, st) {
        b(d.exports.meshopt_decodeIndexBuffer, _e, et, rt, st);
      },
      decodeIndexSequence(_e, et, rt, st) {
        b(d.exports.meshopt_decodeIndexSequence, _e, et, rt, st);
      },
      decodeGltfBuffer(_e, et, rt, st, at, ct) {
        b(d.exports[$[at]], _e, et, rt, st, d.exports[j[ct]]);
      },
    }),
    generated
  );
};
let dracoLoader = null,
  decoderPath = "https://www.gstatic.com/draco/versioned/decoders/1.5.5/";
function extensions(s, e, o) {
  return (a) => {
    o && o(a),
      s &&
        (dracoLoader || (dracoLoader = new DRACOLoader()),
        dracoLoader.setDecoderPath(typeof s == "string" ? s : decoderPath),
        a.setDRACOLoader(dracoLoader)),
      e &&
        a.setMeshoptDecoder(
          typeof MeshoptDecoder == "function"
            ? MeshoptDecoder()
            : MeshoptDecoder
        );
  };
}
function useGLTF(s, e = !0, o = !0, a) {
  return useLoader(GLTFLoader, s, extensions(e, o, a));
}
useGLTF.preload = (s, e = !0, o = !0, a) =>
  useLoader.preload(GLTFLoader, s, extensions(e, o, a));
useGLTF.clear = (s) => useLoader.clear(GLTFLoader, s);
useGLTF.setDecoderPath = (s) => {
  decoderPath = s;
};
const OrbitControls = reactExports$1.forwardRef(
  (
    {
      makeDefault: s,
      camera: e,
      regress: o,
      domElement: a,
      enableDamping: c = !0,
      keyEvents: d = !1,
      onChange: g,
      onStart: _,
      onEnd: b,
      ...j
    },
    $
  ) => {
    const _e = useThree((ft) => ft.invalidate),
      et = useThree((ft) => ft.camera),
      rt = useThree((ft) => ft.gl),
      st = useThree((ft) => ft.events),
      at = useThree((ft) => ft.setEvents),
      ct = useThree((ft) => ft.set),
      it = useThree((ft) => ft.get),
      lt = useThree((ft) => ft.performance),
      ot = e || et,
      ut = a || st.connected || rt.domElement,
      pt = reactExports$1.useMemo(() => new OrbitControls$1(ot), [ot]);
    return (
      useFrame(() => {
        pt.enabled && pt.update();
      }, -1),
      reactExports$1.useEffect(
        () => (
          d && pt.connect(d === !0 ? ut : d),
          pt.connect(ut),
          () => void pt.dispose()
        ),
        [d, ut, o, pt, _e]
      ),
      reactExports$1.useEffect(() => {
        const ft = (_t) => {
            _e(), o && lt.regress(), g && g(_t);
          },
          gt = (_t) => {
            _ && _(_t);
          },
          xt = (_t) => {
            b && b(_t);
          };
        return (
          pt.addEventListener("change", ft),
          pt.addEventListener("start", gt),
          pt.addEventListener("end", xt),
          () => {
            pt.removeEventListener("start", gt),
              pt.removeEventListener("end", xt),
              pt.removeEventListener("change", ft);
          }
        );
      }, [g, _, b, pt, _e, at]),
      reactExports$1.useEffect(() => {
        if (s) {
          const ft = it().controls;
          return ct({ controls: pt }), () => ct({ controls: ft });
        }
      }, [s, pt]),
      reactExports$1.createElement(
        "primitive",
        _extends({ ref: $, object: pt, enableDamping: c }, j)
      )
    );
  }
);
function useAnimations(s, e) {
  const o = reactExports$1.useRef(),
    [a] = reactExports$1.useState(() =>
      e ? (e instanceof Object3D ? { current: e } : e) : o
    ),
    [c] = reactExports$1.useState(() => new AnimationMixer(void 0));
  reactExports$1.useLayoutEffect(() => {
    e && (a.current = e instanceof Object3D ? e : e.current),
      (c._root = a.current);
  });
  const d = reactExports$1.useRef({}),
    g = reactExports$1.useMemo(() => {
      const _ = {};
      return (
        s.forEach((b) =>
          Object.defineProperty(_, b.name, {
            enumerable: !0,
            get() {
              if (a.current)
                return (
                  d.current[b.name] ||
                  (d.current[b.name] = c.clipAction(b, a.current))
                );
            },
            configurable: !0,
          })
        ),
        { ref: a, clips: s, actions: _, names: s.map((b) => b.name), mixer: c }
      );
    }, [s]);
  return (
    useFrame((_, b) => c.update(b)),
    reactExports$1.useEffect(() => {
      const _ = a.current;
      return () => {
        (d.current = {}),
          c.stopAllAction(),
          Object.values(g.actions).forEach((b) => {
            _ && c.uncacheAction(b, _);
          });
      };
    }, [s]),
    g
  );
}
const ContactShadows = reactExports$1.forwardRef(
  (
    {
      scale: s = 10,
      frames: e = 1 / 0,
      opacity: o = 1,
      width: a = 1,
      height: c = 1,
      blur: d = 1,
      near: g = 0,
      far: _ = 10,
      resolution: b = 512,
      smooth: j = !0,
      color: $ = "#000000",
      depthWrite: _e = !1,
      renderOrder: et,
      ...rt
    },
    st
  ) => {
    const at = reactExports$1.useRef(null),
      ct = useThree((Ot) => Ot.scene),
      it = useThree((Ot) => Ot.gl),
      lt = reactExports$1.useRef(null);
    (a = a * (Array.isArray(s) ? s[0] : s || 1)),
      (c = c * (Array.isArray(s) ? s[1] : s || 1));
    const [ot, ut, pt, ft, gt, xt, _t] = reactExports$1.useMemo(() => {
        const Ot = new WebGLRenderTarget(b, b),
          Lt = new WebGLRenderTarget(b, b);
        Lt.texture.generateMipmaps = Ot.texture.generateMipmaps = !1;
        const Et = new PlaneGeometry(a, c).rotateX(Math.PI / 2),
          bt = new Mesh(Et),
          mt = new MeshDepthMaterial();
        (mt.depthTest = mt.depthWrite = !1),
          (mt.onBeforeCompile = (Tt) => {
            (Tt.uniforms = { ...Tt.uniforms, ucolor: { value: new Color($) } }),
              (Tt.fragmentShader = Tt.fragmentShader.replace(
                "void main() {",
                `uniform vec3 ucolor;
           void main() {
          `
              )),
              (Tt.fragmentShader = Tt.fragmentShader.replace(
                "vec4( vec3( 1.0 - fragCoordZ ), opacity );",
                "vec4( ucolor * fragCoordZ * 2.0, ( 1.0 - fragCoordZ ) * 1.0 );"
              ));
          });
        const vt = new ShaderMaterial(HorizontalBlurShader),
          Ct = new ShaderMaterial(VerticalBlurShader);
        return (Ct.depthTest = vt.depthTest = !1), [Ot, Et, mt, bt, vt, Ct, Lt];
      }, [b, a, c, s, $]),
      St = (Ot) => {
        (ft.visible = !0),
          (ft.material = gt),
          (gt.uniforms.tDiffuse.value = ot.texture),
          (gt.uniforms.h.value = (Ot * 1) / 256),
          it.setRenderTarget(_t),
          it.render(ft, lt.current),
          (ft.material = xt),
          (xt.uniforms.tDiffuse.value = _t.texture),
          (xt.uniforms.v.value = (Ot * 1) / 256),
          it.setRenderTarget(ot),
          it.render(ft, lt.current),
          (ft.visible = !1);
      };
    let Mt = 0,
      Rt,
      Ft;
    return (
      useFrame(() => {
        lt.current &&
          (e === 1 / 0 || Mt < e) &&
          (Mt++,
          (Rt = ct.background),
          (Ft = ct.overrideMaterial),
          (at.current.visible = !1),
          (ct.background = null),
          (ct.overrideMaterial = pt),
          it.setRenderTarget(ot),
          it.render(ct, lt.current),
          St(d),
          j && St(d * 0.4),
          it.setRenderTarget(null),
          (at.current.visible = !0),
          (ct.overrideMaterial = Ft),
          (ct.background = Rt));
      }),
      reactExports$1.useImperativeHandle(st, () => at.current, []),
      reactExports$1.createElement(
        "group",
        _extends({ "rotation-x": Math.PI / 2 }, rt, { ref: at }),
        reactExports$1.createElement(
          "mesh",
          {
            renderOrder: et,
            geometry: ut,
            scale: [1, -1, 1],
            rotation: [-Math.PI / 2, 0, 0],
          },
          reactExports$1.createElement("meshBasicMaterial", {
            transparent: !0,
            map: ot.texture,
            opacity: o,
            depthWrite: _e,
          })
        ),
        reactExports$1.createElement("orthographicCamera", {
          ref: lt,
          args: [-a / 2, a / 2, c / 2, -c / 2, g, _],
        })
      )
    );
  }
);
function Robot(s) {
  const e = reactExports$1.useRef(),
    {
      nodes: o,
      materials: a,
      animations: c,
    } = useGLTF("./futuristic_flying_animated_robot_-_low_poly.glb"),
    { actions: d, names: g } = useAnimations(c, e);
  return (
    reactExports$1.useEffect(() => {
      d.Scene.reset().fadeIn(0.5).play();
    }, []),
    jsxRuntimeExports.jsx("group", {
      ref: e,
      ...s,
      dispose: null,
      scale: 5,
      children: jsxRuntimeExports.jsx("group", {
        name: "Sketchfab_Scene",
        children: jsxRuntimeExports.jsx("group", {
          name: "Sketchfab_model",
          rotation: [-Math.PI / 2, 0, 0],
          scale: 0.246,
          position: [0, -0.4, 0],
          children: jsxRuntimeExports.jsx("group", {
            name: "a45b6f53b9cc462a82863bb5898bf730fbx",
            rotation: [Math.PI / 2, 0, 0],
            scale: 0.01,
            children: jsxRuntimeExports.jsx("group", {
              name: "Object_2",
              children: jsxRuntimeExports.jsx("group", {
                name: "RootNode",
                children: jsxRuntimeExports.jsxs("group", {
                  name: "Robot_Origin",
                  position: [0, 9.763, 0],
                  rotation: [-Math.PI / 2, 0, 0],
                  scale: 100,
                  children: [
                    jsxRuntimeExports.jsxs("group", {
                      name: "Robot",
                      position: [0, 0, 0.051],
                      children: [
                        jsxRuntimeExports.jsx("mesh", {
                          name: "Robot_White_Glossy_0",
                          castShadow: !0,
                          receiveShadow: !0,
                          geometry: o.Robot_White_Glossy_0.geometry,
                          material: a.White_Glossy,
                        }),
                        jsxRuntimeExports.jsx("mesh", {
                          name: "Robot_Blue_Light_0",
                          castShadow: !0,
                          receiveShadow: !0,
                          geometry: o.Robot_Blue_Light_0.geometry,
                          material: a.Blue_Light,
                        }),
                        jsxRuntimeExports.jsx("mesh", {
                          name: "Robot_Black_Matt_0",
                          castShadow: !0,
                          receiveShadow: !0,
                          geometry: o.Robot_Black_Matt_0.geometry,
                          material: a.Black_Matt,
                        }),
                      ],
                    }),
                    jsxRuntimeExports.jsx("group", {
                      name: "Mouth",
                      position: [0, -0.504, 2.573],
                      scale: [1, 1, 2.881],
                      children: jsxRuntimeExports.jsx("mesh", {
                        name: "Mouth_Blue_Light_0",
                        castShadow: !0,
                        receiveShadow: !0,
                        geometry: o.Mouth_Blue_Light_0.geometry,
                        material: a.Blue_Light,
                      }),
                    }),
                    jsxRuntimeExports.jsx("group", {
                      name: "Wave",
                      position: [0, 0, 0.113],
                      scale: [1, 1, 0.186],
                      children: jsxRuntimeExports.jsx("mesh", {
                        name: "Wave_Blue_Light_0",
                        castShadow: !0,
                        receiveShadow: !0,
                        geometry: o.Wave_Blue_Light_0.geometry,
                        material: a.Blue_Light,
                      }),
                    }),
                    jsxRuntimeExports.jsx("group", {
                      name: "Wave002",
                      position: [0, 0, 0.879],
                      scale: [1, 1, 0.889],
                      children: jsxRuntimeExports.jsx("mesh", {
                        name: "Wave002_Blue_Light_0",
                        castShadow: !0,
                        receiveShadow: !0,
                        geometry: o.Wave002_Blue_Light_0.geometry,
                        material: a.Blue_Light,
                      }),
                    }),
                    jsxRuntimeExports.jsx("group", {
                      name: "Wave001",
                      position: [0, 0, -0.089],
                      scale: [1, 1, 0.001],
                      children: jsxRuntimeExports.jsx("mesh", {
                        name: "Wave001_Blue_Light_0",
                        castShadow: !0,
                        receiveShadow: !0,
                        geometry: o.Wave001_Blue_Light_0.geometry,
                        material: a.Blue_Light,
                      }),
                    }),
                    jsxRuntimeExports.jsx("group", {
                      name: "Wave003",
                      position: [0, 0, 0.511],
                      scale: [1, 1, 0.552],
                      children: jsxRuntimeExports.jsx("mesh", {
                        name: "Wave003_Blue_Light_0",
                        castShadow: !0,
                        receiveShadow: !0,
                        geometry: o.Wave003_Blue_Light_0.geometry,
                        material: a.Blue_Light,
                      }),
                    }),
                    jsxRuntimeExports.jsx("group", {
                      name: "Waves",
                      position: [0, 0, 1],
                      scale: [1, 1, 0.747],
                    }),
                    jsxRuntimeExports.jsx("group", {
                      name: "Ears",
                      position: [0, 0, 2.967],
                      children: jsxRuntimeExports.jsx("mesh", {
                        name: "Ears_Black_Matt_0",
                        castShadow: !0,
                        receiveShadow: !0,
                        geometry: o.Ears_Black_Matt_0.geometry,
                        material: a.Black_Matt,
                      }),
                    }),
                    jsxRuntimeExports.jsx("group", {
                      name: "Empty",
                      position: [0, -0.06, 2.786],
                      children: jsxRuntimeExports.jsx("group", {
                        name: "Eyes",
                        position: [0, -0.431, 0.076],
                        children: jsxRuntimeExports.jsx("mesh", {
                          name: "Eyes_Blue_Light_0",
                          castShadow: !0,
                          receiveShadow: !0,
                          geometry: o.Eyes_Blue_Light_0.geometry,
                          material: a.Blue_Light,
                        }),
                      }),
                    }),
                    jsxRuntimeExports.jsx("group", {
                      name: "Hand_origin",
                      position: [0.723, 0, 2.015],
                      rotation: [0, -0.064, 0],
                      children: jsxRuntimeExports.jsx("group", {
                        name: "hANDS",
                        position: [-0.723, 0, -1.963],
                        children: jsxRuntimeExports.jsx("mesh", {
                          name: "hANDS_White_Glossy_0",
                          castShadow: !0,
                          receiveShadow: !0,
                          geometry: o.hANDS_White_Glossy_0.geometry,
                          material: a.White_Glossy,
                        }),
                      }),
                    }),
                    jsxRuntimeExports.jsx("group", {
                      name: "Hand_origin002",
                      position: [-0.723, 0, 2.015],
                      rotation: [0, 0.064, -Math.PI],
                      children: jsxRuntimeExports.jsx("group", {
                        name: "hANDS002",
                        position: [-0.723, 0, -1.963],
                        children: jsxRuntimeExports.jsx("mesh", {
                          name: "hANDS002_White_Glossy_0",
                          castShadow: !0,
                          receiveShadow: !0,
                          geometry: o.hANDS002_White_Glossy_0.geometry,
                          material: a.White_Glossy,
                        }),
                      }),
                    }),
                  ],
                }),
              }),
            }),
          }),
        }),
      }),
    })
  );
}
useGLTF.preload("./futuristic_flying_animated_robot_-_low_poly.glb");
function Loader$1() {
  const { progress: s, active: e } = useProgress();
  return jsxRuntimeExports.jsxs(Html, {
    center: !0,
    style: { color: "#fff" },
    children: [s.toFixed(1), "% loaded"],
  });
}
const Robott = () =>
    jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, {
      children: jsxRuntimeExports.jsxs(Canvas, {
        gl: { antialias: !0 },
        dpr: [1, 1.5],
        className: "canvac",
        children: [
          jsxRuntimeExports.jsx("ambientLight", { intensity: 1 }),
          jsxRuntimeExports.jsx(OrbitControls, {}),
          jsxRuntimeExports.jsx(reactExports$1.Suspense, {
            fallback: jsxRuntimeExports.jsx(Loader$1, {}),
            children: jsxRuntimeExports.jsx(Robot, {}),
          }),
          jsxRuntimeExports.jsx(ContactShadows, {
            position: [0, -1.994, 0],
            opacity: 1,
            scale: 25,
            blur: 1,
            far: 10,
            resolution: 256,
            color: "#000000",
          }),
        ],
      }),
    }),
  SlideFromButtom = ({ children: s, delay: e }) => {
    const o = reactExports$1.useRef(null),
      a = useInView(o, { once: !0 }),
      c = useAnimation();
    return (
      reactExports$1.useEffect(() => {
        a && c.start("visible");
      }, [a]),
      jsxRuntimeExports.jsx("div", {
        ref: o,
        style: {
          position: "relative",
          display: "flex",
          width: "100%",
          height: "100%",
          justifyContent: "center",
          alignItems: "center",
          flexDirection: "column",
        },
        children: jsxRuntimeExports.jsx(motion.div, {
          variants: {
            hidden: { opacity: 0, y: 500 },
            visible: { opacity: 1, y: 0 },
          },
          transition: { duration: 0.5, ease: "easeOut", delay: e },
          initial: "hidden",
          animate: c,
          style: {
            minWidth: "100%",
            height: "100%",
            display: "flex",
            alignItems: "center",
            justifyContent: "center",
          },
          children: s,
        }),
      })
    );
  },
  nm$2 = "arrow animation",
  ddd$2 = 0,
  h$2 = 500,
  w$3 = 500,
  meta$1 = { g: "LottieFiles AE 0.1.20" },
  layers$2 = [
    {
      ty: 4,
      nm: "Layer 5 Outlines",
      sr: 1,
      st: 0,
      op: 35,
      ip: 0,
      hd: !1,
      ddd: 0,
      bm: 0,
      hasMask: !1,
      ao: 0,
      ks: {
        a: { a: 0, k: [72.596, 41.955, 0], ix: 1 },
        s: { a: 0, k: [100, 100, 100], ix: 6 },
        sk: { a: 0, k: 0 },
        p: {
          a: 1,
          k: [
            {
              o: { x: 0.333, y: 0 },
              i: { x: 0.667, y: 1 },
              s: [250, 178, 0],
              t: 2,
              ti: null,
              to: null,
            },
            {
              o: { x: 0.333, y: 0 },
              i: { x: 0.667, y: 1 },
              s: [250, 218.00000000000003, 0],
              t: 16,
              ti: null,
              to: null,
            },
            { s: [250, 178, 0], t: 30 },
          ],
          ix: 2,
        },
        r: { a: 0, k: 0, ix: 10 },
        sa: { a: 0, k: 0 },
        o: { a: 0, k: 50, ix: 11 },
      },
      ef: [],
      shapes: [
        {
          ty: "gr",
          bm: 0,
          hd: !1,
          mn: "ADBE Vector Group",
          nm: "Group 1",
          ix: 1,
          cix: 2,
          np: 2,
          it: [
            {
              ty: "sh",
              bm: 0,
              hd: !1,
              mn: "ADBE Vector Shape - Group",
              nm: "Path 1",
              ix: 1,
              d: 1,
              ks: {
                a: 0,
                k: {
                  c: !1,
                  i: [
                    [57.596, -26.956],
                    [-0.001, 26.956],
                    [-57.597, -26.956],
                  ],
                  o: [
                    [57.596, -26.956],
                    [-0.001, 26.956],
                    [-57.597, -26.956],
                  ],
                  v: [
                    [57.596, -26.956],
                    [-0.001, 26.956],
                    [-57.597, -26.956],
                  ],
                },
                ix: 2,
              },
              _render: !0,
            },
            {
              ty: "st",
              bm: 0,
              hd: !1,
              mn: "ADBE Vector Graphic - Stroke",
              nm: "Stroke 1",
              lc: 2,
              lj: 2,
              ml: 1,
              o: { a: 0, k: 100, ix: 4 },
              w: { a: 0, k: 30, ix: 5 },
              c: { a: 0, k: [0.6078, 0.6039, 0.6078, 1], ix: 3 },
              _render: !0,
            },
            {
              ty: "tr",
              a: { a: 0, k: [0, 0], ix: 1 },
              s: { a: 0, k: [100, 100], ix: 3 },
              sk: { a: 0, k: 0, ix: 4 },
              p: { a: 0, k: [72.596, 41.955], ix: 2 },
              r: { a: 0, k: 0, ix: 6 },
              sa: { a: 0, k: 0, ix: 5 },
              o: { a: 0, k: 100, ix: 7 },
              _render: !0,
            },
          ],
          _render: !0,
        },
      ],
      ind: 1,
      completed: !0,
    },
    {
      ty: 4,
      nm: "Layer 4 Outlines",
      sr: 1,
      st: 0,
      op: 35,
      ip: 0,
      hd: !1,
      ddd: 0,
      bm: 0,
      hasMask: !1,
      ao: 0,
      ks: {
        a: { a: 0, k: [72.596, 41.955, 0], ix: 1 },
        s: { a: 0, k: [100, 100, 100], ix: 6 },
        sk: { a: 0, k: 0 },
        p: {
          a: 1,
          k: [
            {
              o: { x: 0.333, y: 0 },
              i: { x: 0.667, y: 1 },
              s: [250, 250.99999999999997, 0],
              t: 3,
              ti: null,
              to: null,
            },
            {
              o: { x: 0.333, y: 0 },
              i: { x: 0.667, y: 1 },
              s: [250, 291, 0],
              t: 17,
              ti: null,
              to: null,
            },
            { s: [250, 250.99999999999997, 0], t: 32 },
          ],
          ix: 2,
        },
        r: { a: 0, k: 0, ix: 10 },
        sa: { a: 0, k: 0 },
        o: { a: 0, k: 80, ix: 11 },
      },
      ef: [],
      shapes: [
        {
          ty: "gr",
          bm: 0,
          hd: !1,
          mn: "ADBE Vector Group",
          nm: "Group 1",
          ix: 1,
          cix: 2,
          np: 2,
          it: [
            {
              ty: "sh",
              bm: 0,
              hd: !1,
              mn: "ADBE Vector Shape - Group",
              nm: "Path 1",
              ix: 1,
              d: 1,
              ks: {
                a: 0,
                k: {
                  c: !1,
                  i: [
                    [57.596, -26.955],
                    [-0.001, 26.955],
                    [-57.597, -26.955],
                  ],
                  o: [
                    [57.596, -26.955],
                    [-0.001, 26.955],
                    [-57.597, -26.955],
                  ],
                  v: [
                    [57.596, -26.955],
                    [-0.001, 26.955],
                    [-57.597, -26.955],
                  ],
                },
                ix: 2,
              },
              _render: !0,
            },
            {
              ty: "st",
              bm: 0,
              hd: !1,
              mn: "ADBE Vector Graphic - Stroke",
              nm: "Stroke 1",
              lc: 2,
              lj: 2,
              ml: 1,
              o: { a: 0, k: 100, ix: 4 },
              w: { a: 0, k: 30, ix: 5 },
              c: { a: 0, k: [0.6078, 0.6039, 0.6078, 1], ix: 3 },
              _render: !0,
            },
            {
              ty: "tr",
              a: { a: 0, k: [0, 0], ix: 1 },
              s: { a: 0, k: [100, 100], ix: 3 },
              sk: { a: 0, k: 0, ix: 4 },
              p: { a: 0, k: [72.596, 41.955], ix: 2 },
              r: { a: 0, k: 0, ix: 6 },
              sa: { a: 0, k: 0, ix: 5 },
              o: { a: 0, k: 100, ix: 7 },
              _render: !0,
            },
          ],
          _render: !0,
        },
      ],
      ind: 2,
      completed: !0,
    },
    {
      ty: 4,
      nm: "Layer 3 Outlines",
      sr: 1,
      st: 0,
      op: 35,
      ip: 0,
      hd: !1,
      ddd: 0,
      bm: 0,
      hasMask: !1,
      ao: 0,
      ks: {
        a: { a: 0, k: [132.596, 101.955, 0], ix: 1 },
        s: { a: 0, k: [100, 100, 100], ix: 6 },
        sk: { a: 0, k: 0 },
        p: {
          a: 1,
          k: [
            {
              o: { x: 0.333, y: 0 },
              i: { x: 0.667, y: 1 },
              s: [250, 324, 0],
              t: 4,
              ti: null,
              to: null,
            },
            {
              o: { x: 0.333, y: 0 },
              i: { x: 0.667, y: 1 },
              s: [250, 364, 0],
              t: 18,
              ti: null,
              to: null,
            },
            { s: [250, 324, 0], t: 34 },
          ],
          ix: 2,
        },
        r: { a: 0, k: 0, ix: 10 },
        sa: { a: 0, k: 0 },
        o: { a: 0, k: 100, ix: 11 },
      },
      ef: [],
      shapes: [
        {
          ty: "gr",
          bm: 0,
          hd: !1,
          mn: "ADBE Vector Group",
          nm: "Group 1",
          ix: 1,
          cix: 2,
          np: 2,
          it: [
            {
              ty: "sh",
              bm: 0,
              hd: !1,
              mn: "ADBE Vector Shape - Group",
              nm: "Path 1",
              ix: 1,
              d: 1,
              ks: {
                a: 0,
                k: {
                  c: !1,
                  i: [
                    [57.596, -26.955],
                    [-0.001, 26.955],
                    [-57.597, -26.955],
                  ],
                  o: [
                    [57.596, -26.955],
                    [-0.001, 26.955],
                    [-57.597, -26.955],
                  ],
                  v: [
                    [57.596, -26.955],
                    [-0.001, 26.955],
                    [-57.597, -26.955],
                  ],
                },
                ix: 2,
              },
              _render: !0,
            },
            {
              ty: "st",
              bm: 0,
              hd: !1,
              mn: "ADBE Vector Graphic - Stroke",
              nm: "Stroke 1",
              lc: 2,
              lj: 2,
              ml: 1,
              o: { a: 0, k: 100, ix: 4 },
              w: { a: 0, k: 30, ix: 5 },
              c: { a: 0, k: [0.6078, 0.6039, 0.6078, 1], ix: 3 },
              _render: !0,
            },
            {
              ty: "tr",
              a: { a: 0, k: [0, 0], ix: 1 },
              s: { a: 0, k: [100, 100], ix: 3 },
              sk: { a: 0, k: 0, ix: 4 },
              p: { a: 0, k: [132.596, 101.955], ix: 2 },
              r: { a: 0, k: 0, ix: 6 },
              sa: { a: 0, k: 0, ix: 5 },
              o: { a: 0, k: 100, ix: 7 },
              _render: !0,
            },
          ],
          _render: !0,
        },
      ],
      ind: 3,
      completed: !0,
    },
  ],
  v$2 = "5.5.7",
  fr$2 = 30,
  op$2 = 33,
  ip$2 = 0,
  assets$2 = [],
  __complete$1 = !0,
  ad = {
    nm: nm$2,
    ddd: ddd$2,
    h: h$2,
    w: w$3,
    meta: meta$1,
    layers: layers$2,
    v: v$2,
    fr: fr$2,
    op: op$2,
    ip: ip$2,
    assets: assets$2,
    __complete: __complete$1,
  },
  v$1 = "5.6.1",
  fr$1 = 30,
  ip$1 = 0,
  op$1 = 120,
  w$2 = 300,
  h$1 = 300,
  nm$1 = "3D Motion 2",
  ddd$1 = 0,
  assets$1 = [],
  layers$1 = [
    {
      ddd: 0,
      ind: 2,
      ty: 4,
      nm: "Layer 5 Outlines",
      sr: 1,
      ks: {
        o: { a: 0, k: 100, ix: 11 },
        r: { a: 0, k: 0, ix: 10 },
        p: { a: 0, k: [149.999, 93.046, 0], ix: 2 },
        a: { a: 0, k: [9.25, 5.711, 0], ix: 1 },
        s: { a: 0, k: [1e3, 1e3, 100], ix: 6 },
      },
      ao: 0,
      shapes: [
        {
          ty: "gr",
          it: [
            {
              ind: 0,
              ty: "sh",
              ix: 1,
              ks: {
                a: 1,
                k: [
                  {
                    i: { x: 0.33, y: 1 },
                    o: { x: 0.167, y: 0.167 },
                    t: 30,
                    s: [
                      {
                        i: [
                          [-0.20900000000000002, 5.461],
                          [-9, -0.133],
                          [-1.611, -4.835],
                          [0.6280000000000001, -5.46],
                          [9, -0.133],
                          [0.537, 5.253],
                        ],
                        o: [
                          [-0.537, 5.253],
                          [-9, -0.133],
                          [-0.628, -5.46],
                          [1.61, -4.835],
                          [9, -0.133],
                          [0.20900000000000002, 5.461],
                        ],
                        v: [
                          [-0.537, 5.253],
                          [-9, -0.133],
                          [-1.611, -4.835],
                          [1.61, -4.835],
                          [9, -0.133],
                          [0.537, 5.253],
                        ],
                        c: !0,
                      },
                    ],
                  },
                  {
                    i: { x: 0.54, y: 1 },
                    o: { x: 0.67, y: 0 },
                    t: 45,
                    s: [
                      {
                        i: [
                          [2.783, 4.6450000000000005],
                          [-8.615, 1.351],
                          [-4.348, -3.981],
                          [-3.2990000000000004, -5.053999999999999],
                          [8.499, -1.921],
                          [3.412, 4.261],
                        ],
                        o: [
                          [2.159, 4.448],
                          [-8.615, 1.351],
                          [-3.8249999999999997, -4.654],
                          [-1.693, -4.643],
                          [8.499, -1.921],
                          [3.1, 4.562],
                        ],
                        v: [
                          [2.159, 4.448],
                          [-8.615, 1.351],
                          [-4.348, -3.981],
                          [-1.693, -4.643],
                          [8.499, -1.921],
                          [3.412, 4.261],
                        ],
                        c: !0,
                      },
                    ],
                  },
                  {
                    i: { x: 0.3, y: 1 },
                    o: { x: 0.46, y: 0 },
                    t: 75,
                    s: [
                      {
                        i: [
                          [-3.3, 4.783],
                          [-8.932, -1.777],
                          [1.059, -4.479],
                          [3.575, -4.8709999999999996],
                          [8.749, 1.51],
                          [-2.385, 4.656],
                        ],
                        o: [
                          [-3.613, 4.477],
                          [-8.932, -1.777],
                          [2.689, -4.992],
                          [4.222, -4.079],
                          [8.749, 1.51],
                          [-2.912, 4.7829999999999995],
                        ],
                        v: [
                          [-3.613, 4.477],
                          [-8.932, -1.777],
                          [1.059, -4.479],
                          [4.222, -4.079],
                          [8.749, 1.51],
                          [-2.385, 4.656],
                        ],
                        c: !0,
                      },
                    ],
                  },
                  {
                    t: 100,
                    s: [
                      {
                        i: [
                          [-0.20900000000000002, 5.461],
                          [-9, -0.133],
                          [-1.611, -4.835],
                          [0.6280000000000001, -5.46],
                          [9, -0.133],
                          [0.537, 5.253],
                        ],
                        o: [
                          [-0.537, 5.253],
                          [-9, -0.133],
                          [-0.628, -5.46],
                          [1.61, -4.835],
                          [9, -0.133],
                          [0.20900000000000002, 5.461],
                        ],
                        v: [
                          [-0.537, 5.253],
                          [-9, -0.133],
                          [-1.611, -4.835],
                          [1.61, -4.835],
                          [9, -0.133],
                          [0.537, 5.253],
                        ],
                        c: !0,
                      },
                    ],
                  },
                ],
                ix: 2,
              },
              nm: "Path 1",
              mn: "ADBE Vector Shape - Group",
              hd: !1,
              _render: !0,
            },
            {
              ty: "fl",
              c: { a: 0, k: [0.6078, 0.6039, 0.6078, 1], ix: 4 },
              o: { a: 0, k: 100, ix: 5 },
              r: 1,
              bm: 0,
              nm: "Fill 1",
              mn: "ADBE Vector Graphic - Fill",
              hd: !1,
              _render: !0,
            },
            {
              ty: "tr",
              p: { a: 0, k: [9.25, 5.71], ix: 2 },
              a: { a: 0, k: [0, 0], ix: 1 },
              s: { a: 0, k: [100, 100], ix: 3 },
              r: { a: 0, k: 0, ix: 6 },
              o: { a: 0, k: 100, ix: 7 },
              sk: { a: 0, k: 0, ix: 4 },
              sa: { a: 0, k: 0, ix: 5 },
              nm: "Transform",
              _render: !0,
            },
          ],
          nm: "Group 1",
          np: 2,
          cix: 2,
          bm: 0,
          ix: 1,
          mn: "ADBE Vector Group",
          hd: !1,
          _render: !0,
        },
      ],
      ip: 0,
      op: 120,
      st: 0,
      bm: 0,
      completed: !0,
    },
    {
      ddd: 0,
      ind: 3,
      ty: 4,
      nm: "Layer 3 Outlines",
      sr: 1,
      ks: {
        o: { a: 0, k: 100, ix: 11 },
        r: { a: 0, k: 0, ix: 10 },
        p: { a: 0, k: [94.998, 188.075, 0], ix: 2 },
        a: { a: 0, k: [4.5, 7.636, 0], ix: 1 },
        s: { a: 0, k: [1e3, 1e3, 100], ix: 6 },
      },
      ao: 0,
      shapes: [
        {
          ty: "gr",
          it: [
            {
              ind: 0,
              ty: "sh",
              ix: 1,
              ks: {
                a: 1,
                k: [
                  {
                    i: { x: 0.33, y: 1 },
                    o: { x: 0.167, y: 0.167 },
                    t: 30,
                    s: [
                      {
                        i: [
                          [4.326, -2.019],
                          [-4.5, -7.637],
                          [-4.5, 0.263],
                          [-3.976, 2.242],
                          [4.5, 7.637],
                          [4.5, -1.359],
                        ],
                        o: [
                          [4.037, -2.204],
                          [-4.5, -7.637],
                          [-4.5, 1.2879999999999998],
                          [-3.11, 2.793],
                          [4.5, 7.637],
                          [4.5, -1.702],
                        ],
                        v: [
                          [4.037, -2.204],
                          [-4.5, -7.637],
                          [-4.5, 0.263],
                          [-3.11, 2.793],
                          [4.5, 7.637],
                          [4.5, -1.359],
                        ],
                        c: !0,
                      },
                    ],
                  },
                  {
                    i: { x: 0.54, y: 1 },
                    o: { x: 0.67, y: 0 },
                    t: 45,
                    s: [
                      {
                        i: [
                          [7.492, -2.645],
                          [-3.9, -6.114],
                          [-3.888, 2.238],
                          [-3.633, 4.209],
                          [7.676, 7.389],
                          [7.699, -1.868],
                        ],
                        o: [
                          [7.203, -2.83],
                          [-3.9, -6.114],
                          [-3.895, 3.576],
                          [-2.505, 4.635],
                          [7.676, 7.389],
                          [7.699, -2.2110000000000003],
                        ],
                        v: [
                          [7.203, -2.83],
                          [-3.9, -6.114],
                          [-3.888, 2.238],
                          [-2.505, 4.635],
                          [7.676, 7.389],
                          [7.699, -1.868],
                        ],
                        c: !0,
                      },
                    ],
                  },
                  {
                    i: { x: 0.3, y: 1 },
                    o: { x: 0.46, y: 0 },
                    t: 75,
                    s: [
                      {
                        i: [
                          [1.045, -3.042],
                          [-3.895, -8.732],
                          [-3.887, -1.162],
                          [-3.667, 0.5599999999999999],
                          [1.209, 6.489],
                          [1.241, -2.299],
                        ],
                        o: [
                          [0.747, -3.36],
                          [-3.895, -8.732],
                          [-3.894, 0.17600000000000016],
                          [-2.939, 1.402],
                          [1.209, 6.489],
                          [1.241, -2.642],
                        ],
                        v: [
                          [0.747, -3.36],
                          [-3.895, -8.732],
                          [-3.887, -1.162],
                          [-2.939, 1.402],
                          [1.209, 6.489],
                          [1.241, -2.299],
                        ],
                        c: !0,
                      },
                    ],
                  },
                  {
                    t: 100,
                    s: [
                      {
                        i: [
                          [4.326, -2.019],
                          [-4.5, -7.637],
                          [-4.5, 0.263],
                          [-3.976, 2.242],
                          [4.5, 7.637],
                          [4.5, -1.359],
                        ],
                        o: [
                          [4.037, -2.204],
                          [-4.5, -7.637],
                          [-4.5, 1.2879999999999998],
                          [-3.11, 2.793],
                          [4.5, 7.637],
                          [4.5, -1.702],
                        ],
                        v: [
                          [4.037, -2.204],
                          [-4.5, -7.637],
                          [-4.5, 0.263],
                          [-3.11, 2.793],
                          [4.5, 7.637],
                          [4.5, -1.359],
                        ],
                        c: !0,
                      },
                    ],
                  },
                ],
                ix: 2,
              },
              nm: "Path 1",
              mn: "ADBE Vector Shape - Group",
              hd: !1,
              _render: !0,
            },
            {
              ty: "mm",
              mm: 4,
              nm: "Merge Paths 1",
              mn: "ADBE Vector Filter - Merge",
              hd: !1,
              _render: !0,
            },
            {
              ty: "fl",
              c: { a: 0, k: [0.6078, 0.6039, 0.6078, 1], ix: 4 },
              o: { a: 0, k: 100, ix: 5 },
              r: 1,
              bm: 0,
              nm: "Fill 1",
              mn: "ADBE Vector Graphic - Fill",
              hd: !1,
              _render: !0,
            },
            {
              ty: "tr",
              p: { a: 0, k: [4.5, 7.636], ix: 2 },
              a: { a: 0, k: [0, 0], ix: 1 },
              s: { a: 0, k: [100, 100], ix: 3 },
              r: { a: 0, k: 0, ix: 6 },
              o: { a: 0, k: 100, ix: 7 },
              sk: { a: 0, k: 0, ix: 4 },
              sa: { a: 0, k: 0, ix: 5 },
              nm: "Transform",
              _render: !0,
            },
          ],
          nm: "Group 1",
          np: 3,
          cix: 2,
          bm: 0,
          ix: 1,
          mn: "ADBE Vector Group",
          hd: !1,
          _render: !0,
        },
      ],
      ip: 0,
      op: 120,
      st: 0,
      bm: 0,
      completed: !0,
    },
    {
      ddd: 0,
      ind: 4,
      ty: 4,
      nm: "Layer 4 Outlines",
      sr: 1,
      ks: {
        o: { a: 0, k: 100, ix: 11 },
        r: { a: 0, k: 0, ix: 10 },
        p: { a: 0, k: [205.001, 188.075, 0], ix: 2 },
        a: { a: 0, k: [4.5, 7.636, 0], ix: 1 },
        s: { a: 0, k: [1e3, 1e3, 100], ix: 6 },
      },
      ao: 0,
      shapes: [
        {
          ty: "gr",
          it: [
            {
              ind: 0,
              ty: "sh",
              ix: 1,
              ks: {
                a: 1,
                k: [
                  {
                    i: { x: 0.33, y: 1 },
                    o: { x: 0.167, y: 0.167 },
                    t: 30,
                    s: [
                      {
                        i: [
                          [-4.326, -2.019],
                          [4.5, -7.637],
                          [4.5, 0.263],
                          [3.977, 2.242],
                          [-4.5, 7.637],
                          [-4.5, -1.359],
                        ],
                        o: [
                          [-4.037, -2.204],
                          [4.5, -7.637],
                          [4.5, 1.2879999999999998],
                          [3.11, 2.793],
                          [-4.5, 7.637],
                          [-4.5, -1.702],
                        ],
                        v: [
                          [-4.037, -2.204],
                          [4.5, -7.637],
                          [4.5, 0.263],
                          [3.11, 2.793],
                          [-4.5, 7.637],
                          [-4.5, -1.359],
                        ],
                        c: !0,
                      },
                    ],
                  },
                  {
                    i: { x: 0.54, y: 1 },
                    o: { x: 0.67, y: 0 },
                    t: 45,
                    s: [
                      {
                        i: [
                          [-1.0659999999999998, -3.166],
                          [3.856, -9.083],
                          [3.845, -1.144],
                          [3.767, 0.47499999999999987],
                          [-1.278, 6.762],
                          [-1.289, -2.44],
                        ],
                        o: [
                          [-0.817, -3.401],
                          [3.856, -9.083],
                          [3.867, 0.04300000000000015],
                          [2.884, 1.642],
                          [-1.278, 6.762],
                          [-1.289, -2.783],
                        ],
                        v: [
                          [-0.817, -3.401],
                          [3.856, -9.083],
                          [3.845, -1.144],
                          [3.021, 1.412],
                          [-1.278, 6.762],
                          [-1.289, -2.44],
                        ],
                        c: !0,
                      },
                    ],
                  },
                  {
                    i: { x: 0.3, y: 1 },
                    o: { x: 0.46, y: 0 },
                    t: 75,
                    s: [
                      {
                        i: [
                          [-7.635, -2.587],
                          [3.873, -5.845],
                          [3.863, 1.847],
                          [3.8999999999999995, 4.242],
                          [-7.795, 7.424],
                          [-7.774, -1.868],
                        ],
                        o: [
                          [-7.386, -2.822],
                          [3.873, -5.845],
                          [3.883, 3.209],
                          [2.183, 4.742],
                          [-7.795, 7.424],
                          [-7.774, -2.2110000000000003],
                        ],
                        v: [
                          [-7.386, -2.822],
                          [3.873, -5.845],
                          [3.863, 1.847],
                          [2.647, 4.574],
                          [-7.795, 7.424],
                          [-7.774, -1.868],
                        ],
                        c: !0,
                      },
                    ],
                  },
                  {
                    t: 100,
                    s: [
                      {
                        i: [
                          [-4.326, -2.019],
                          [4.5, -7.637],
                          [4.5, 0.263],
                          [3.977, 2.242],
                          [-4.5, 7.637],
                          [-4.5, -1.359],
                        ],
                        o: [
                          [-4.037, -2.204],
                          [4.5, -7.637],
                          [4.5, 1.2879999999999998],
                          [3.11, 2.793],
                          [-4.5, 7.637],
                          [-4.5, -1.702],
                        ],
                        v: [
                          [-4.037, -2.204],
                          [4.5, -7.637],
                          [4.5, 0.263],
                          [3.11, 2.793],
                          [-4.5, 7.637],
                          [-4.5, -1.359],
                        ],
                        c: !0,
                      },
                    ],
                  },
                ],
                ix: 2,
              },
              nm: "Path 1",
              mn: "ADBE Vector Shape - Group",
              hd: !1,
              _render: !0,
            },
            {
              ty: "mm",
              mm: 4,
              nm: "Merge Paths 1",
              mn: "ADBE Vector Filter - Merge",
              hd: !1,
              _render: !0,
            },
            {
              ty: "fl",
              c: { a: 0, k: [0.6078, 0.6039, 0.6078, 1], ix: 4 },
              o: { a: 0, k: 100, ix: 5 },
              r: 1,
              bm: 0,
              nm: "Fill 1",
              mn: "ADBE Vector Graphic - Fill",
              hd: !1,
              _render: !0,
            },
            {
              ty: "tr",
              p: { a: 0, k: [4.5, 7.636], ix: 2 },
              a: { a: 0, k: [0, 0], ix: 1 },
              s: { a: 0, k: [100, 100], ix: 3 },
              r: { a: 0, k: 0, ix: 6 },
              o: { a: 0, k: 100, ix: 7 },
              sk: { a: 0, k: 0, ix: 4 },
              sa: { a: 0, k: 0, ix: 5 },
              nm: "Transform",
              _render: !0,
            },
          ],
          nm: "Group 1",
          np: 3,
          cix: 2,
          bm: 0,
          ix: 1,
          mn: "ADBE Vector Group",
          hd: !1,
          _render: !0,
        },
      ],
      ip: 0,
      op: 120,
      st: 0,
      bm: 0,
      completed: !0,
    },
  ],
  markers = [],
  __complete = !0,
  td = {
    v: v$1,
    fr: fr$1,
    ip: ip$1,
    op: op$1,
    w: w$2,
    h: h$1,
    nm: nm$1,
    ddd: ddd$1,
    assets: assets$1,
    layers: layers$1,
    markers,
    __complete,
  },
  Hero = () =>
    jsxRuntimeExports.jsxs("div", {
      className: "hero",
      children: [
        jsxRuntimeExports.jsx("div", {
          className: "hami",
          children: jsxRuntimeExports.jsx(TextAnimation, {
            children: jsxRuntimeExports.jsx("div", {
              className: "hamis",
              children: jsxRuntimeExports.jsx(Lottie, { animationData: ad }),
            }),
          }),
        }),
        jsxRuntimeExports.jsx("video", {
          className: "herovedio",
          src: bg,
          autoPlay: !0,
          loop: !0,
          muted: !0,
        }),
        jsxRuntimeExports.jsxs("div", {
          className: "herocontentcon",
          children: [
            jsxRuntimeExports.jsx("div", {
              className: "heroleft",
              children: jsxRuntimeExports.jsxs("div", {
                children: [
                  jsxRuntimeExports.jsx("div", {
                    className: "greeting",
                    children: jsxRuntimeExports.jsx(TextAnimation, {
                      children: jsxRuntimeExports.jsx("p", {
                        children: "Hi There! I'm Ibrahim Abolarin",
                      }),
                    }),
                  }),
                  jsxRuntimeExports.jsxs("div", {
                    className: "herogtwo",
                    children: [
                      jsxRuntimeExports.jsx(TextAnimation, {
                        children: jsxRuntimeExports.jsx("p", {
                          children: "I am a",
                        }),
                      }),
                      jsxRuntimeExports.jsx("p", {
                        className: "typ",
                        children: jsxRuntimeExports.jsx(TextAnimation, {
                          children: jsxRuntimeExports.jsx(Typewriter, {
                            options: {
                              strings: [
                                "Software Development",
                                "Website Development",
                                "Mobile App Dev Android, iOS",
                              ],
                              autoStart: !0,
                              loop: !0,
                            },
                          }),
                        }),
                      }),
                    ],
                  }),
                  jsxRuntimeExports.jsx(TextAnimation, {
                    children: jsxRuntimeExports.jsx("p", {
                      className: "herosubtext",
                      children:
                        "Seeking to be inspired, to envision the unlikely, to work hard for things that are worth it, and to be surrounded by those who bring out the best in me.",
                    }),
                  }),
                  jsxRuntimeExports.jsx(Link, {
                    to: "/contact",
                    style: { marginTop: "20px" },
                    children: jsxRuntimeExports.jsxs("a", {
                      className: "contactbutton OO oooo two",
                      href: "",
                      children: [
                        jsxRuntimeExports.jsx("span", {}),
                        jsxRuntimeExports.jsx("span", {}),
                        jsxRuntimeExports.jsx("span", {}),
                        jsxRuntimeExports.jsx("span", {}),
                        jsxRuntimeExports.jsx(TextAnimation, {
                          children: jsxRuntimeExports.jsx("p", {
                            className: "two",
                            children: "Contact Me",
                          }),
                        }),
                      ],
                    }),
                  }),
                ],
              }),
            }),
            jsxRuntimeExports.jsx("div", {
              className: "heroright",
              children: jsxRuntimeExports.jsx(SlideFromButtom, {
                delay: 0.1,
                children: jsxRuntimeExports.jsxs("div", {
                  className: "robot",
                  children: [
                    jsxRuntimeExports.jsx("div", {
                      className: "raia",
                      children: jsxRuntimeExports.jsx(Lottie, {
                        animationData: td,
                      }),
                    }),
                    jsxRuntimeExports.jsx(Robott, {}),
                  ],
                }),
              }),
            }),
          ],
        }),
      ],
    }),
  pro = "./assets/pro-DEJThoQ2.jpg",
  bo = "./assets/bo-BjF1Q8g4.jpg",
  ch = "./assets/ch-DO2Wv4_Q.jpg",
  kr = "./assets/kr-JDItfQDX.jpg",
  p = "./assets/p-DPg4k73e.png",
  m = "./assets/m-DP7Mu6rj.jpg",
  w$1 = "./assets/w-lJwQLhIz.jpg",
  skills = [
    { nomber: 0.1, skill: "HTML" },
    { nomber: 0.2, skill: "CSS" },
    { nomber: 0.3, skill: "JavaScript" },
    { nomber: 0.4, skill: "React" },
    { nomber: 0.5, skill: "Wordpress" },
    { nomber: 0.6, skill: "PHP" },
    { nomber: 0.7, skill: "SASS" },
    { nomber: 0.8, skill: "GIT" },
    { nomber: 0.9, skill: "Github" },
    { nomber: 1, skill: "Responsive Design" },
    { nomber: 1.1, skill: "SEO" },
    { nomber: 1.2, skill: "Terminal" },
  ],
  services = [
    {
      image: p,
      name: "Software ",
      subname: "Development",
      desc: "Experienced in both functional and OOP: Dart, Python, Java, JavaScript, TypeScript.",
    },
    {
      image: w$1,
      name: "Wedsite Dev ",
      subname: "React, NextJS",
      desc: "Passionate about UI/UX. Over 2 years of development experience in HTML, CSS, JS, React and NextJS frameworks.",
    },
    {
      image: m,
      name: "Mobile App Dev ",
      subname: "Android, iOS",
      desc: "Skilled in developing hybrid mobile apps and cross-platform solutions using the React Native framework.",
    },
  ],
  works = [
    {
      img: kr,
      name: "Crown Template",
      desc: "Crown is a web template that I created targeting the restaurant and food industry which anyone can use to present their business online.",
      like: "https://fc-rest.netlify.app/",
    },
    {
      img: ch,
      name: "chronicled",
      desc: "Accounting and tax services characterized by quality, reliability and trust.",
      like: "https://www.chronicled.com/",
    },
    {
      img: bo,
      name: "Boreal Coffee Clone",
      desc: "I re-created the frontend of Boreal Coffee's official web app because I got attracted to their beautiful UI. It was a great experience for me to build the entire frontend.",
      like: "https://bc-clone.netlify.app/",
    },
  ],
  Sssb = ({ children: s }) => {
    const e = reactExports$1.useRef(null),
      o = useInView(e, { once: !0 }),
      a = useAnimation();
    return (
      reactExports$1.useEffect(() => {
        o && a.start("visible");
      }, [o]),
      jsxRuntimeExports.jsx("div", {
        ref: e,
        style: {
          position: "relative",
          display: "flex",
          width: "fit-content",
          height: "100%",
          justifyContent: "center",
          alignItems: "center",
          flexDirection: "column",
          overflow: "hidden",
        },
        children: jsxRuntimeExports.jsx(motion.div, {
          variants: {
            hidden: { opacity: 0, y: 500 },
            visible: { opacity: 1, y: 0 },
          },
          transition: { duration: 0.5, ease: "easeOut", delay: 0.4 },
          initial: "hidden",
          animate: a,
          style: {
            minWidth: "100%",
            height: "100%",
            display: "flex",
            alignItems: "center",
            justifyContent: "center",
          },
          children: s,
        }),
      })
    );
  };
function MdHomeRepairService(s) {
  return GenIcon({
    tag: "svg",
    attr: { viewBox: "0 0 24 24" },
    child: [
      { tag: "path", attr: { fill: "none", d: "M0 0h24v24H0z" }, child: [] },
      {
        tag: "path",
        attr: {
          d: "M18 16h-2v-1H8v1H6v-1H2v5h20v-5h-4zM20 8h-3V6c0-1.1-.9-2-2-2H9c-1.1 0-2 .9-2 2v2H4c-1.1 0-2 .9-2 2v4h4v-2h2v2h8v-2h2v2h4v-4c0-1.1-.9-2-2-2zm-5 0H9V6h6v2z",
        },
        child: [],
      },
    ],
  })(s);
}
function MdOutlineAlternateEmail(s) {
  return GenIcon({
    tag: "svg",
    attr: { viewBox: "0 0 24 24" },
    child: [
      { tag: "path", attr: { fill: "none", d: "M0 0h24v24H0V0z" }, child: [] },
      {
        tag: "path",
        attr: {
          d: "M12 1.95c-5.52 0-10 4.48-10 10s4.48 10 10 10h5v-2h-5c-4.34 0-8-3.66-8-8s3.66-8 8-8 8 3.66 8 8v1.43c0 .79-.71 1.57-1.5 1.57s-1.5-.78-1.5-1.57v-1.43c0-2.76-2.24-5-5-5s-5 2.24-5 5 2.24 5 5 5c1.38 0 2.64-.56 3.54-1.47.65.89 1.77 1.47 2.96 1.47 1.97 0 3.5-1.6 3.5-3.57v-1.43c0-5.52-4.48-10-10-10zm0 13c-1.66 0-3-1.34-3-3s1.34-3 3-3 3 1.34 3 3-1.34 3-3 3z",
        },
        child: [],
      },
    ],
  })(s);
}
const About = () =>
  jsxRuntimeExports.jsx("div", {
    className: "about",
    children: jsxRuntimeExports.jsxs("div", {
      className: "afirstcon",
      children: [
        jsxRuntimeExports.jsxs("div", {
          className: "titlecon",
          children: [
            jsxRuntimeExports.jsxs("div", {
              className: "atitle",
              children: [
                jsxRuntimeExports.jsx(TextAnimation, {
                  children: jsxRuntimeExports.jsx("p", {
                    children: "ABOUT ME.",
                  }),
                }),
                jsxRuntimeExports.jsx("div", {
                  className: "subatitle",
                  children: jsxRuntimeExports.jsx(TextAnimation, {
                    children: "More About Me",
                  }),
                }),
              ],
            }),
            jsxRuntimeExports.jsx(TextAnimation, {
              children: jsxRuntimeExports.jsx("p", {
                className: "titlep one",
                children:
                  "Here you will find more information about me, what I do, and my current skills mostly in terms of programming and technology",
              }),
            }),
          ],
        }),
        jsxRuntimeExports.jsxs("div", {
          className: "aboutmecon",
          children: [
            jsxRuntimeExports.jsxs("div", {
              className: "asleft",
              children: [
                jsxRuntimeExports.jsx("div", {
                  className: "astitle",
                  children: jsxRuntimeExports.jsx(TextAnimation, {
                    children: jsxRuntimeExports.jsx("p", {
                      children: "Get to know me!",
                    }),
                  }),
                }),
                jsxRuntimeExports.jsxs("div", {
                  className: "meconone",
                  children: [
                    jsxRuntimeExports.jsx("div", {
                      className: "meprofile",
                      children: jsxRuntimeExports.jsx(TextAnimation, {
                        children: jsxRuntimeExports.jsx("img", {
                          className: "profileimg",
                          src: pro,
                        }),
                      }),
                    }),
                    jsxRuntimeExports.jsx("div", {
                      className: "metextone",
                      children: jsxRuntimeExports.jsx(TextAnimation, {
                        children: jsxRuntimeExports.jsx("p", {
                          className: "one",
                          children:
                            "Hello! I'm Ibrahim Abolarin, a Software Engineer based in Nigeria, who's experienced in taking fullstack applications from scratch to production.",
                        }),
                      }),
                    }),
                  ],
                }),
                jsxRuntimeExports.jsx(TextAnimation, {
                  children: jsxRuntimeExports.jsx("p", {
                    className: "one",
                    children:
                      "Your friendly neighborhood wedsite and mobile app (both Android & IOS) developer. I spend my days (and often nights) painting the Internet canvas with Projects and lines of code, turning zeroes and ones into immersive, interactive experiences.",
                  }),
                }),
                jsxRuntimeExports.jsx(TextAnimation, {
                  children: jsxRuntimeExports.jsx("p", {
                    className: "one",
                    children:
                      "Since beginning my journey as a freelance software developer 2 years ago, I've done remote work for agencies, consulted for startups, and collaborated with talented people to create digital products for both business and consumer use. I'm quietly confident, naturally curious, and perpetually working on improving my chops.",
                  }),
                }),
                jsxRuntimeExports.jsx(TextAnimation, {
                  children: jsxRuntimeExports.jsx("p", {
                    className: "one",
                    children:
                      "Sunlight or indoors, I've got it covered. I tread the path of minimalism, finding beauty in simplicity and order. When I'm not crafting beautiful web experiences, you can find me reading Articles or swaying to the rhythm of Afrobeat & Pop Music, losing myself in the captivating flow of melodies.",
                  }),
                }),
              ],
            }),
            jsxRuntimeExports.jsxs("div", {
              className: "asright",
              children: [
                jsxRuntimeExports.jsx("div", {
                  className: "astitle",
                  children: jsxRuntimeExports.jsx(TextAnimation, {
                    children: jsxRuntimeExports.jsx("p", {
                      children: "My skills!",
                    }),
                  }),
                }),
                jsxRuntimeExports.jsx("div", {
                  className: "skillcon",
                  children: skills.map((s) =>
                    jsxRuntimeExports.jsx(Textasbuttom, {
                      children: jsxRuntimeExports.jsx("div", {
                        className: "skillitem",
                        children: jsxRuntimeExports.jsx(TextAnimation, {
                          children: jsxRuntimeExports.jsx("p", {
                            className: "one",
                            children: s.skill,
                          }),
                        }),
                      }),
                    })
                  ),
                }),
              ],
            }),
          ],
        }),
        jsxRuntimeExports.jsxs("div", {
          className: "alastsec",
          children: [
            jsxRuntimeExports.jsx("div", {
              className: "astitle",
              children: jsxRuntimeExports.jsx(TextAnimation, {
                children: jsxRuntimeExports.jsx("p", {
                  children: "This are the services i provide!",
                }),
              }),
            }),
            jsxRuntimeExports.jsx("div", {
              className: "servicemaincon",
              children: services.map((s) =>
                jsxRuntimeExports.jsx(Sssb, {
                  children: jsxRuntimeExports.jsxs("div", {
                    className: "seviceitem",
                    children: [
                      jsxRuntimeExports.jsxs("div", {
                        style: { position: "relative" },
                        children: [
                          jsxRuntimeExports.jsx(TextAnimation, {
                            children: jsxRuntimeExports.jsx("img", {
                              src: s.image,
                              className: "siimg",
                            }),
                          }),
                          jsxRuntimeExports.jsx("div", {
                            className: "gradent",
                          }),
                        ],
                      }),
                      jsxRuntimeExports.jsxs("div", {
                        className: "scontcon",
                        children: [
                          jsxRuntimeExports.jsxs("div", {
                            className: "serviceheader",
                            children: [
                              jsxRuntimeExports.jsx(TextAnimation, {
                                children: jsxRuntimeExports.jsx("div", {
                                  className: "shicon",
                                  children: jsxRuntimeExports.jsx(
                                    MdHomeRepairService,
                                    { className: "iconnav", size: "2rem" }
                                  ),
                                }),
                              }),
                              jsxRuntimeExports.jsxs("div", {
                                children: [
                                  jsxRuntimeExports.jsx(TextAnimation, {
                                    children: jsxRuntimeExports.jsx("p", {
                                      className: "two",
                                      children: s.name,
                                    }),
                                  }),
                                  jsxRuntimeExports.jsx(TextAnimation, {
                                    children: jsxRuntimeExports.jsx("a", {
                                      className: "two",
                                      children: s.subname,
                                    }),
                                  }),
                                ],
                              }),
                            ],
                          }),
                          jsxRuntimeExports.jsx(TextAnimation, {
                            children: jsxRuntimeExports.jsx("p", {
                              className: "ship one",
                              children: s.desc,
                            }),
                          }),
                        ],
                      }),
                    ],
                  }),
                })
              ),
            }),
          ],
        }),
      ],
    }),
  });
function Cartoonrobot(s) {
  const e = reactExports$1.useRef(),
    {
      nodes: o,
      materials: a,
      animations: c,
    } = useGLTF("./robot_playground.glb"),
    { actions: d, names: g } = useAnimations(c, e);
  return (
    reactExports$1.useEffect(() => {
      d.Experiment.reset().fadeIn(0.5).play();
    }, []),
    jsxRuntimeExports.jsx("group", {
      ref: e,
      ...s,
      dispose: null,
      scale: 1.4,
      position: [0, -0.9, 0],
      children: jsxRuntimeExports.jsx("group", {
        name: "Sketchfab_Scene",
        children: jsxRuntimeExports.jsx("group", {
          name: "Sketchfab_model",
          rotation: [-Math.PI / 2, 0, 0],
          scale: 0.057,
          children: jsxRuntimeExports.jsx("group", {
            name: "000846fff9e546569ee038af7e24655afbx",
            rotation: [Math.PI / 2, 0, 0],
            children: jsxRuntimeExports.jsx("group", {
              name: "Object_2",
              children: jsxRuntimeExports.jsxs("group", {
                name: "RootNode",
                children: [
                  jsxRuntimeExports.jsxs("group", {
                    name: "holo",
                    scale: 1.877,
                    children: [
                      jsxRuntimeExports.jsxs("group", {
                        name: "ground",
                        position: [0, 0.39, 0],
                        children: [
                          jsxRuntimeExports.jsx("group", {
                            name: "pDisc1",
                            position: [0, -0.388, 0],
                            scale: 11.114,
                            children: jsxRuntimeExports.jsx("mesh", {
                              name: "pDisc1_holo1_0",
                              castShadow: !0,
                              receiveShadow: !0,
                              geometry: o.pDisc1_holo1_0.geometry,
                              material: a.holo1,
                            }),
                          }),
                          jsxRuntimeExports.jsxs("group", {
                            name: "pPipe4",
                            position: [0, -0.429, 0],
                            rotation: [0, -0.311, 0],
                            children: [
                              jsxRuntimeExports.jsx("mesh", {
                                name: "pPipe4_holo1_0",
                                castShadow: !0,
                                receiveShadow: !0,
                                geometry: o.pPipe4_holo1_0.geometry,
                                material: a.holo1,
                              }),
                              jsxRuntimeExports.jsx("group", {
                                name: "MASH1_ReproMesh2",
                                position: [0, 0.429, 0],
                                children: jsxRuntimeExports.jsx("mesh", {
                                  name: "MASH1_ReproMesh2_holo1_0",
                                  castShadow: !0,
                                  receiveShadow: !0,
                                  geometry: o.MASH1_ReproMesh2_holo1_0.geometry,
                                  material: a.holo1,
                                }),
                              }),
                            ],
                          }),
                          jsxRuntimeExports.jsxs("group", {
                            name: "pPipe2",
                            position: [0, -0.576, 0],
                            rotation: [0, 0.311, 0],
                            children: [
                              jsxRuntimeExports.jsx("mesh", {
                                name: "pPipe2_holo1_0",
                                castShadow: !0,
                                receiveShadow: !0,
                                geometry: o.pPipe2_holo1_0.geometry,
                                material: a.holo1,
                              }),
                              jsxRuntimeExports.jsx("group", {
                                name: "MASH1_ReproMesh3",
                                position: [0, 0.576, 0],
                                scale: [0.819, 0.804, 0.819],
                                children: jsxRuntimeExports.jsx("mesh", {
                                  name: "MASH1_ReproMesh3_holo1_0",
                                  castShadow: !0,
                                  receiveShadow: !0,
                                  geometry: o.MASH1_ReproMesh3_holo1_0.geometry,
                                  material: a.holo1,
                                }),
                              }),
                              jsxRuntimeExports.jsx("group", {
                                name: "pPipe3",
                                rotation: [0, 0.684, 0],
                                scale: 0.856,
                                children: jsxRuntimeExports.jsx("mesh", {
                                  name: "pPipe3_holo1_0",
                                  castShadow: !0,
                                  receiveShadow: !0,
                                  geometry: o.pPipe3_holo1_0.geometry,
                                  material: a.holo1,
                                }),
                              }),
                            ],
                          }),
                          jsxRuntimeExports.jsxs("group", {
                            name: "pPipe1",
                            rotation: [0, -0.311, 0],
                            children: [
                              jsxRuntimeExports.jsx("mesh", {
                                name: "pPipe1_holo1_0",
                                castShadow: !0,
                                receiveShadow: !0,
                                geometry: o.pPipe1_holo1_0.geometry,
                                material: a.holo1,
                              }),
                              jsxRuntimeExports.jsx("group", {
                                name: "MASH1_ReproMesh1",
                                scale: [1.033, 1, 1.033],
                                children: jsxRuntimeExports.jsx("mesh", {
                                  name: "MASH1_ReproMesh1_holo1_0",
                                  castShadow: !0,
                                  receiveShadow: !0,
                                  geometry: o.MASH1_ReproMesh1_holo1_0.geometry,
                                  material: a.holo1,
                                }),
                              }),
                            ],
                          }),
                        ],
                      }),
                      jsxRuntimeExports.jsx("group", {
                        name: "group36",
                        position: [0.33, 0, -0.099],
                        rotation: [-Math.PI, -0.142, -Math.PI],
                        scale: 0.989,
                        children: jsxRuntimeExports.jsx("group", {
                          name: "group39",
                          rotation: [0, 0.877, 0],
                          children: jsxRuntimeExports.jsx("group", {
                            name: "group37",
                            position: [-4.63, 14.294, 1.994],
                            children: jsxRuntimeExports.jsxs("group", {
                              name: "group31",
                              position: [4.63, -4.887, -1.994],
                              rotation: [0.006, 0, 0.01],
                              scale: 1.182,
                              children: [
                                jsxRuntimeExports.jsxs("group", {
                                  name: "group35",
                                  position: [0.225, 0.107, 0.003],
                                  rotation: [-Math.PI, -1.463, Math.PI],
                                  children: [
                                    jsxRuntimeExports.jsxs("group", {
                                      name: "group38",
                                      position: [0.039, 0.755, 0.248],
                                      children: [
                                        jsxRuntimeExports.jsx("group", {
                                          name: "group29",
                                          position: [-0.027, -10.245, -0.036],
                                          rotation: [0, Math.PI / 4, 0],
                                          children: jsxRuntimeExports.jsxs(
                                            "group",
                                            {
                                              name: "group21",
                                              position: [-12.687, 10.697, 0],
                                              scale: 0.245,
                                              children: [
                                                jsxRuntimeExports.jsx("group", {
                                                  name: "MASH1_ReproMesh12",
                                                  position: [0, 0.239, 0],
                                                  rotation: [
                                                    -1.132,
                                                    0,
                                                    Math.PI / 2,
                                                  ],
                                                  scale: [1.033, 1, 1.033],
                                                  children:
                                                    jsxRuntimeExports.jsx(
                                                      "mesh",
                                                      {
                                                        name: "MASH1_ReproMesh12_holo1_0",
                                                        castShadow: !0,
                                                        receiveShadow: !0,
                                                        geometry:
                                                          o
                                                            .MASH1_ReproMesh12_holo1_0
                                                            .geometry,
                                                        material: a.holo1,
                                                      }
                                                    ),
                                                }),
                                                jsxRuntimeExports.jsx("group", {
                                                  name: "group14",
                                                  rotation: [0, 1.132, 0],
                                                  children:
                                                    jsxRuntimeExports.jsxs(
                                                      "group",
                                                      {
                                                        name: "group30",
                                                        rotation: [0.492, 0, 0],
                                                        scale: 3.169,
                                                        children: [
                                                          jsxRuntimeExports.jsx(
                                                            "group",
                                                            {
                                                              name: "pSuperShape2",
                                                              scale: 2.076,
                                                              children:
                                                                jsxRuntimeExports.jsx(
                                                                  "mesh",
                                                                  {
                                                                    name: "pSuperShape2_holo1_0",
                                                                    castShadow:
                                                                      !0,
                                                                    receiveShadow:
                                                                      !0,
                                                                    geometry:
                                                                      o
                                                                        .pSuperShape2_holo1_0
                                                                        .geometry,
                                                                    material:
                                                                      a.holo1,
                                                                  }
                                                                ),
                                                            }
                                                          ),
                                                          jsxRuntimeExports.jsx(
                                                            "group",
                                                            {
                                                              name: "pSuperShape3",
                                                              scale: 2.076,
                                                              children:
                                                                jsxRuntimeExports.jsx(
                                                                  "mesh",
                                                                  {
                                                                    name: "pSuperShape3_holo1_0",
                                                                    castShadow:
                                                                      !0,
                                                                    receiveShadow:
                                                                      !0,
                                                                    geometry:
                                                                      o
                                                                        .pSuperShape3_holo1_0
                                                                        .geometry,
                                                                    material:
                                                                      a.holo1,
                                                                  }
                                                                ),
                                                            }
                                                          ),
                                                        ],
                                                      }
                                                    ),
                                                }),
                                              ],
                                            }
                                          ),
                                        }),
                                        jsxRuntimeExports.jsx("group", {
                                          name: "group28",
                                          position: [-0.027, -10.245, -0.036],
                                          rotation: [0, Math.PI / 2, 0],
                                          children: jsxRuntimeExports.jsxs(
                                            "group",
                                            {
                                              name: "group21_1",
                                              position: [-12.687, 10.697, 0],
                                              scale: 0.245,
                                              children: [
                                                jsxRuntimeExports.jsx("group", {
                                                  name: "MASH1_ReproMesh12_1",
                                                  position: [0, 0.239, 0],
                                                  rotation: [
                                                    -1.132,
                                                    0,
                                                    Math.PI / 2,
                                                  ],
                                                  scale: [1.033, 1, 1.033],
                                                  children:
                                                    jsxRuntimeExports.jsx(
                                                      "group",
                                                      {
                                                        name: "MASH1_ReproMesh19",
                                                        children:
                                                          jsxRuntimeExports.jsx(
                                                            "mesh",
                                                            {
                                                              name: "MASH1_ReproMesh19_holo1_0",
                                                              castShadow: !0,
                                                              receiveShadow: !0,
                                                              geometry:
                                                                o
                                                                  .MASH1_ReproMesh19_holo1_0
                                                                  .geometry,
                                                              material: a.holo1,
                                                            }
                                                          ),
                                                      }
                                                    ),
                                                }),
                                                jsxRuntimeExports.jsx("group", {
                                                  name: "group14_1",
                                                  rotation: [0, 1.132, 0],
                                                  children:
                                                    jsxRuntimeExports.jsxs(
                                                      "group",
                                                      {
                                                        name: "group7",
                                                        rotation: [
                                                          0.317, -0.659, 1.521,
                                                        ],
                                                        scale: 2.048,
                                                        children: [
                                                          jsxRuntimeExports.jsx(
                                                            "group",
                                                            {
                                                              name: "pGear1",
                                                              children:
                                                                jsxRuntimeExports.jsx(
                                                                  "mesh",
                                                                  {
                                                                    name: "pGear1_holo1_0",
                                                                    castShadow:
                                                                      !0,
                                                                    receiveShadow:
                                                                      !0,
                                                                    geometry:
                                                                      o
                                                                        .pGear1_holo1_0
                                                                        .geometry,
                                                                    material:
                                                                      a.holo1,
                                                                  }
                                                                ),
                                                            }
                                                          ),
                                                          jsxRuntimeExports.jsx(
                                                            "group",
                                                            {
                                                              name: "pGear2",
                                                              children:
                                                                jsxRuntimeExports.jsx(
                                                                  "mesh",
                                                                  {
                                                                    name: "pGear2_holo1_0",
                                                                    castShadow:
                                                                      !0,
                                                                    receiveShadow:
                                                                      !0,
                                                                    geometry:
                                                                      o
                                                                        .pGear2_holo1_0
                                                                        .geometry,
                                                                    material:
                                                                      a.holo1,
                                                                  }
                                                                ),
                                                            }
                                                          ),
                                                        ],
                                                      }
                                                    ),
                                                }),
                                              ],
                                            }
                                          ),
                                        }),
                                        jsxRuntimeExports.jsx("group", {
                                          name: "group27",
                                          position: [-0.027, -10.245, -0.036],
                                          rotation: [
                                            -Math.PI,
                                            Math.PI / 4,
                                            Math.PI,
                                          ],
                                          children: jsxRuntimeExports.jsxs(
                                            "group",
                                            {
                                              name: "group20",
                                              position: [-12.687, 10.697, 0],
                                              scale: 0.245,
                                              children: [
                                                jsxRuntimeExports.jsx("group", {
                                                  name: "MASH1_ReproMesh11",
                                                  position: [0, 0.239, 0],
                                                  rotation: [
                                                    -1.132,
                                                    0,
                                                    Math.PI / 2,
                                                  ],
                                                  scale: [1.033, 1, 1.033],
                                                  children:
                                                    jsxRuntimeExports.jsx(
                                                      "group",
                                                      {
                                                        name: "MASH1_ReproMesh18",
                                                        children:
                                                          jsxRuntimeExports.jsx(
                                                            "mesh",
                                                            {
                                                              name: "MASH1_ReproMesh18_holo1_0",
                                                              castShadow: !0,
                                                              receiveShadow: !0,
                                                              geometry:
                                                                o
                                                                  .MASH1_ReproMesh18_holo1_0
                                                                  .geometry,
                                                              material: a.holo1,
                                                            }
                                                          ),
                                                      }
                                                    ),
                                                }),
                                                jsxRuntimeExports.jsx("group", {
                                                  name: "group13",
                                                  rotation: [0, 1.132, 0],
                                                  children:
                                                    jsxRuntimeExports.jsxs(
                                                      "group",
                                                      {
                                                        name: "group6",
                                                        position: [0, 0.028, 0],
                                                        rotation: [
                                                          0.479, 0.1, -0.002,
                                                        ],
                                                        scale: 2.37,
                                                        children: [
                                                          jsxRuntimeExports.jsx(
                                                            "group",
                                                            {
                                                              name: "pHelix1",
                                                              children:
                                                                jsxRuntimeExports.jsx(
                                                                  "mesh",
                                                                  {
                                                                    name: "pHelix1_holo1_0",
                                                                    castShadow:
                                                                      !0,
                                                                    receiveShadow:
                                                                      !0,
                                                                    geometry:
                                                                      o
                                                                        .pHelix1_holo1_0
                                                                        .geometry,
                                                                    material:
                                                                      a.holo1,
                                                                  }
                                                                ),
                                                            }
                                                          ),
                                                          jsxRuntimeExports.jsx(
                                                            "group",
                                                            {
                                                              name: "pHelix2",
                                                              children:
                                                                jsxRuntimeExports.jsx(
                                                                  "mesh",
                                                                  {
                                                                    name: "pHelix2_holo1_0",
                                                                    castShadow:
                                                                      !0,
                                                                    receiveShadow:
                                                                      !0,
                                                                    geometry:
                                                                      o
                                                                        .pHelix2_holo1_0
                                                                        .geometry,
                                                                    material:
                                                                      a.holo1,
                                                                  }
                                                                ),
                                                            }
                                                          ),
                                                        ],
                                                      }
                                                    ),
                                                }),
                                              ],
                                            }
                                          ),
                                        }),
                                        jsxRuntimeExports.jsx("group", {
                                          name: "group26",
                                          position: [-0.027, -10.245, -0.036],
                                          rotation: [-Math.PI, 0, -Math.PI],
                                          children: jsxRuntimeExports.jsxs(
                                            "group",
                                            {
                                              name: "group19",
                                              position: [-12.687, 10.697, 0],
                                              scale: 0.245,
                                              children: [
                                                jsxRuntimeExports.jsx("group", {
                                                  name: "MASH1_ReproMesh10",
                                                  position: [0, 0.239, 0],
                                                  rotation: [
                                                    -1.132,
                                                    0,
                                                    Math.PI / 2,
                                                  ],
                                                  scale: [1.033, 1, 1.033],
                                                  children:
                                                    jsxRuntimeExports.jsx(
                                                      "group",
                                                      {
                                                        name: "MASH1_ReproMesh17",
                                                        children:
                                                          jsxRuntimeExports.jsx(
                                                            "mesh",
                                                            {
                                                              name: "MASH1_ReproMesh17_holo1_0",
                                                              castShadow: !0,
                                                              receiveShadow: !0,
                                                              geometry:
                                                                o
                                                                  .MASH1_ReproMesh17_holo1_0
                                                                  .geometry,
                                                              material: a.holo1,
                                                            }
                                                          ),
                                                      }
                                                    ),
                                                }),
                                                jsxRuntimeExports.jsx("group", {
                                                  name: "group12",
                                                  rotation: [0, 1.132, 0],
                                                  children:
                                                    jsxRuntimeExports.jsxs(
                                                      "group",
                                                      {
                                                        name: "group4",
                                                        position: [
                                                          -0.254, 1.103, -0.402,
                                                        ],
                                                        rotation: [
                                                          -0.176, -0.673, 0.273,
                                                        ],
                                                        scale: 1.554,
                                                        children: [
                                                          jsxRuntimeExports.jsx(
                                                            "group",
                                                            {
                                                              name: "pPyramid1",
                                                              scale: [
                                                                5.263, 7.637,
                                                                5.263,
                                                              ],
                                                              children:
                                                                jsxRuntimeExports.jsx(
                                                                  "mesh",
                                                                  {
                                                                    name: "pPyramid1_holo1_0",
                                                                    castShadow:
                                                                      !0,
                                                                    receiveShadow:
                                                                      !0,
                                                                    geometry:
                                                                      o
                                                                        .pPyramid1_holo1_0
                                                                        .geometry,
                                                                    material:
                                                                      a.holo1,
                                                                  }
                                                                ),
                                                            }
                                                          ),
                                                          jsxRuntimeExports.jsx(
                                                            "group",
                                                            {
                                                              name: "pPyramid2",
                                                              scale: [
                                                                5.572, 8.085,
                                                                5.572,
                                                              ],
                                                              children:
                                                                jsxRuntimeExports.jsx(
                                                                  "mesh",
                                                                  {
                                                                    name: "pPyramid2_holo1_0",
                                                                    castShadow:
                                                                      !0,
                                                                    receiveShadow:
                                                                      !0,
                                                                    geometry:
                                                                      o
                                                                        .pPyramid2_holo1_0
                                                                        .geometry,
                                                                    material:
                                                                      a.holo1,
                                                                  }
                                                                ),
                                                            }
                                                          ),
                                                        ],
                                                      }
                                                    ),
                                                }),
                                              ],
                                            }
                                          ),
                                        }),
                                        jsxRuntimeExports.jsx("group", {
                                          name: "group25",
                                          position: [-0.027, -10.245, -0.036],
                                          rotation: [
                                            -Math.PI,
                                            -Math.PI / 4,
                                            -Math.PI,
                                          ],
                                          children: jsxRuntimeExports.jsxs(
                                            "group",
                                            {
                                              name: "group18",
                                              position: [-12.692, 10.697, 0],
                                              scale: 0.245,
                                              children: [
                                                jsxRuntimeExports.jsx("group", {
                                                  name: "MASH1_ReproMesh9",
                                                  position: [0, 0.239, 0],
                                                  rotation: [
                                                    -1.132,
                                                    0,
                                                    Math.PI / 2,
                                                  ],
                                                  scale: [1.033, 1, 1.033],
                                                  children:
                                                    jsxRuntimeExports.jsx(
                                                      "group",
                                                      {
                                                        name: "MASH1_ReproMesh16",
                                                        children:
                                                          jsxRuntimeExports.jsx(
                                                            "mesh",
                                                            {
                                                              name: "MASH1_ReproMesh16_holo1_0",
                                                              castShadow: !0,
                                                              receiveShadow: !0,
                                                              geometry:
                                                                o
                                                                  .MASH1_ReproMesh16_holo1_0
                                                                  .geometry,
                                                              material: a.holo1,
                                                            }
                                                          ),
                                                      }
                                                    ),
                                                }),
                                                jsxRuntimeExports.jsx("group", {
                                                  name: "group11",
                                                  rotation: [0, 1.132, 0],
                                                  children:
                                                    jsxRuntimeExports.jsxs(
                                                      "group",
                                                      {
                                                        name: "group5",
                                                        rotation: [
                                                          0.222, 0.16, 0.928,
                                                        ],
                                                        scale: 1.89,
                                                        children: [
                                                          jsxRuntimeExports.jsx(
                                                            "group",
                                                            {
                                                              name: "pTorus2",
                                                              children:
                                                                jsxRuntimeExports.jsx(
                                                                  "mesh",
                                                                  {
                                                                    name: "pTorus2_holo1_0",
                                                                    castShadow:
                                                                      !0,
                                                                    receiveShadow:
                                                                      !0,
                                                                    geometry:
                                                                      o
                                                                        .pTorus2_holo1_0
                                                                        .geometry,
                                                                    material:
                                                                      a.holo1,
                                                                  }
                                                                ),
                                                            }
                                                          ),
                                                          jsxRuntimeExports.jsx(
                                                            "group",
                                                            {
                                                              name: "pTorus1",
                                                              children:
                                                                jsxRuntimeExports.jsx(
                                                                  "mesh",
                                                                  {
                                                                    name: "pTorus1_holo1_0",
                                                                    castShadow:
                                                                      !0,
                                                                    receiveShadow:
                                                                      !0,
                                                                    geometry:
                                                                      o
                                                                        .pTorus1_holo1_0
                                                                        .geometry,
                                                                    material:
                                                                      a.holo1,
                                                                  }
                                                                ),
                                                            }
                                                          ),
                                                        ],
                                                      }
                                                    ),
                                                }),
                                              ],
                                            }
                                          ),
                                        }),
                                        jsxRuntimeExports.jsx("group", {
                                          name: "group23",
                                          position: [-0.027, -10.245, -0.036],
                                          rotation: [0, -Math.PI / 4, 0],
                                          children: jsxRuntimeExports.jsxs(
                                            "group",
                                            {
                                              name: "group16",
                                              position: [-12.687, 10.697, 0],
                                              scale: 0.245,
                                              children: [
                                                jsxRuntimeExports.jsx("group", {
                                                  name: "MASH1_ReproMesh7",
                                                  position: [0, 0.239, 0],
                                                  rotation: [
                                                    -1.132,
                                                    0,
                                                    Math.PI / 2,
                                                  ],
                                                  scale: [1.033, 1, 1.033],
                                                  children:
                                                    jsxRuntimeExports.jsx(
                                                      "group",
                                                      {
                                                        name: "MASH1_ReproMesh14",
                                                        children:
                                                          jsxRuntimeExports.jsx(
                                                            "mesh",
                                                            {
                                                              name: "MASH1_ReproMesh14_holo1_0",
                                                              castShadow: !0,
                                                              receiveShadow: !0,
                                                              geometry:
                                                                o
                                                                  .MASH1_ReproMesh14_holo1_0
                                                                  .geometry,
                                                              material: a.holo1,
                                                            }
                                                          ),
                                                      }
                                                    ),
                                                }),
                                                jsxRuntimeExports.jsx("group", {
                                                  name: "group9",
                                                  rotation: [0, 1.132, 0],
                                                  scale: 1.303,
                                                  children:
                                                    jsxRuntimeExports.jsxs(
                                                      "group",
                                                      {
                                                        name: "group2",
                                                        rotation: [
                                                          -0.623, -0.617, 0.102,
                                                        ],
                                                        children: [
                                                          jsxRuntimeExports.jsx(
                                                            "group",
                                                            {
                                                              name: "pCube1",
                                                              scale: 4.808,
                                                              children:
                                                                jsxRuntimeExports.jsx(
                                                                  "mesh",
                                                                  {
                                                                    name: "pCube1_holo1_0",
                                                                    castShadow:
                                                                      !0,
                                                                    receiveShadow:
                                                                      !0,
                                                                    geometry:
                                                                      o
                                                                        .pCube1_holo1_0
                                                                        .geometry,
                                                                    material:
                                                                      a.holo1,
                                                                  }
                                                                ),
                                                            }
                                                          ),
                                                          jsxRuntimeExports.jsx(
                                                            "group",
                                                            {
                                                              name: "pCube2",
                                                              scale: 4.918,
                                                              children:
                                                                jsxRuntimeExports.jsx(
                                                                  "mesh",
                                                                  {
                                                                    name: "pCube2_holo1_0",
                                                                    castShadow:
                                                                      !0,
                                                                    receiveShadow:
                                                                      !0,
                                                                    geometry:
                                                                      o
                                                                        .pCube2_holo1_0
                                                                        .geometry,
                                                                    material:
                                                                      a.holo1,
                                                                  }
                                                                ),
                                                            }
                                                          ),
                                                        ],
                                                      }
                                                    ),
                                                }),
                                              ],
                                            }
                                          ),
                                        }),
                                        jsxRuntimeExports.jsx("group", {
                                          name: "group22",
                                          position: [-0.027, -10.245, -0.036],
                                          children: jsxRuntimeExports.jsxs(
                                            "group",
                                            {
                                              name: "group15",
                                              position: [-12.687, 10.697, 0],
                                              scale: 0.245,
                                              children: [
                                                jsxRuntimeExports.jsx("group", {
                                                  name: "MASH1_ReproMesh6",
                                                  position: [0, 0.239, 0],
                                                  rotation: [
                                                    -1.132,
                                                    0,
                                                    Math.PI / 2,
                                                  ],
                                                  scale: [1.033, 1, 1.033],
                                                  children:
                                                    jsxRuntimeExports.jsx(
                                                      "group",
                                                      {
                                                        name: "MASH1_ReproMesh13",
                                                        children:
                                                          jsxRuntimeExports.jsx(
                                                            "mesh",
                                                            {
                                                              name: "MASH1_ReproMesh13_holo1_0",
                                                              castShadow: !0,
                                                              receiveShadow: !0,
                                                              geometry:
                                                                o
                                                                  .MASH1_ReproMesh13_holo1_0
                                                                  .geometry,
                                                              material: a.holo1,
                                                            }
                                                          ),
                                                      }
                                                    ),
                                                }),
                                                jsxRuntimeExports.jsx("group", {
                                                  name: "group8",
                                                  rotation: [0, 1.132, 0],
                                                  children:
                                                    jsxRuntimeExports.jsxs(
                                                      "group",
                                                      {
                                                        name: "group1",
                                                        rotation: [
                                                          -0.513, 0, 0,
                                                        ],
                                                        scale: [
                                                          1.223, 0.98, 1.223,
                                                        ],
                                                        children: [
                                                          jsxRuntimeExports.jsx(
                                                            "group",
                                                            {
                                                              name: "pCylinder2",
                                                              scale: 3.569,
                                                              children:
                                                                jsxRuntimeExports.jsx(
                                                                  "mesh",
                                                                  {
                                                                    name: "pCylinder2_holo1_0",
                                                                    castShadow:
                                                                      !0,
                                                                    receiveShadow:
                                                                      !0,
                                                                    geometry:
                                                                      o
                                                                        .pCylinder2_holo1_0
                                                                        .geometry,
                                                                    material:
                                                                      a.holo1,
                                                                  }
                                                                ),
                                                            }
                                                          ),
                                                          jsxRuntimeExports.jsx(
                                                            "group",
                                                            {
                                                              name: "pCylinder3",
                                                              scale: 3.665,
                                                              children:
                                                                jsxRuntimeExports.jsx(
                                                                  "mesh",
                                                                  {
                                                                    name: "pCylinder3_holo1_0",
                                                                    castShadow:
                                                                      !0,
                                                                    receiveShadow:
                                                                      !0,
                                                                    geometry:
                                                                      o
                                                                        .pCylinder3_holo1_0
                                                                        .geometry,
                                                                    material:
                                                                      a.holo1,
                                                                  }
                                                                ),
                                                            }
                                                          ),
                                                        ],
                                                      }
                                                    ),
                                                }),
                                              ],
                                            }
                                          ),
                                        }),
                                        jsxRuntimeExports.jsx("group", {
                                          name: "pCylinder4",
                                          position: [-0.027, 0.458, -0.036],
                                          scale: [0.818, 0.439, 0.818],
                                          children: jsxRuntimeExports.jsx(
                                            "mesh",
                                            {
                                              name: "pCylinder4_holo1_0",
                                              castShadow: !0,
                                              receiveShadow: !0,
                                              geometry:
                                                o.pCylinder4_holo1_0.geometry,
                                              material: a.holo1,
                                            }
                                          ),
                                        }),
                                      ],
                                    }),
                                    jsxRuntimeExports.jsx("group", {
                                      name: "group24",
                                      position: [0.021, -10.723, 0.224],
                                      rotation: [0, -Math.PI / 2, 0],
                                      children: jsxRuntimeExports.jsxs(
                                        "group",
                                        {
                                          name: "group17",
                                          position: [-12.356, 11.797, 0.231],
                                          scale: 0.295,
                                          children: [
                                            jsxRuntimeExports.jsx("group", {
                                              name: "group10",
                                              rotation: [
                                                Math.PI,
                                                -1.163,
                                                Math.PI,
                                              ],
                                              children: jsxRuntimeExports.jsxs(
                                                "group",
                                                {
                                                  name: "group3",
                                                  scale: 1.445,
                                                  children: [
                                                    jsxRuntimeExports.jsx(
                                                      "group",
                                                      {
                                                        name: "pPlatonic1",
                                                        scale: 3.239,
                                                        children:
                                                          jsxRuntimeExports.jsx(
                                                            "mesh",
                                                            {
                                                              name: "pPlatonic1_holo1_0",
                                                              castShadow: !0,
                                                              receiveShadow: !0,
                                                              geometry:
                                                                o
                                                                  .pPlatonic1_holo1_0
                                                                  .geometry,
                                                              material: a.holo1,
                                                            }
                                                          ),
                                                      }
                                                    ),
                                                    jsxRuntimeExports.jsx(
                                                      "group",
                                                      {
                                                        name: "pPlatonic2",
                                                        scale: 3.414,
                                                        children:
                                                          jsxRuntimeExports.jsx(
                                                            "mesh",
                                                            {
                                                              name: "pPlatonic2_holo1_0",
                                                              castShadow: !0,
                                                              receiveShadow: !0,
                                                              geometry:
                                                                o
                                                                  .pPlatonic2_holo1_0
                                                                  .geometry,
                                                              material: a.holo1,
                                                            }
                                                          ),
                                                      }
                                                    ),
                                                  ],
                                                }
                                              ),
                                            }),
                                            jsxRuntimeExports.jsx("group", {
                                              name: "MASH1_ReproMesh8",
                                              position: [0.227, 0.006, -0.549],
                                              rotation: [
                                                -1.132,
                                                0,
                                                Math.PI / 2,
                                              ],
                                              scale: [0.818, 0.792, 0.818],
                                              children: jsxRuntimeExports.jsx(
                                                "group",
                                                {
                                                  name: "MASH1_ReproMesh15",
                                                  children:
                                                    jsxRuntimeExports.jsx(
                                                      "mesh",
                                                      {
                                                        name: "MASH1_ReproMesh15_holo1_0",
                                                        castShadow: !0,
                                                        receiveShadow: !0,
                                                        geometry:
                                                          o
                                                            .MASH1_ReproMesh15_holo1_0
                                                            .geometry,
                                                        material: a.holo1,
                                                      }
                                                    ),
                                                }
                                              ),
                                            }),
                                          ],
                                        }
                                      ),
                                    }),
                                  ],
                                }),
                                jsxRuntimeExports.jsx("group", {
                                  name: "pPlatonic3",
                                  position: [-0.348, -0.124, -0.324],
                                  scale: 0.001,
                                  children: jsxRuntimeExports.jsx("mesh", {
                                    name: "pPlatonic3_holo1_0",
                                    castShadow: !0,
                                    receiveShadow: !0,
                                    geometry: o.pPlatonic3_holo1_0.geometry,
                                    material: a.holo1,
                                  }),
                                }),
                              ],
                            }),
                          }),
                        }),
                      }),
                    ],
                  }),
                  jsxRuntimeExports.jsxs("group", {
                    name: "bot_geo",
                    children: [
                      jsxRuntimeExports.jsx("group", { name: "knee" }),
                      jsxRuntimeExports.jsx("group", { name: "foot" }),
                      jsxRuntimeExports.jsx("group", { name: "hand" }),
                      jsxRuntimeExports.jsx("group", { name: "upperLeg" }),
                      jsxRuntimeExports.jsx("group", { name: "body" }),
                      jsxRuntimeExports.jsx("group", { name: "index" }),
                      jsxRuntimeExports.jsx("group", { name: "pinky" }),
                      jsxRuntimeExports.jsx("group", { name: "thumb" }),
                      jsxRuntimeExports.jsx("group", { name: "earBall" }),
                      jsxRuntimeExports.jsx("group", { name: "topHeadBall" }),
                      jsxRuntimeExports.jsx("group", { name: "topHeadTube" }),
                      jsxRuntimeExports.jsx("group", { name: "shoulder" }),
                      jsxRuntimeExports.jsx("group", { name: "midfinger" }),
                      jsxRuntimeExports.jsx("group", { name: "neckTop" }),
                      jsxRuntimeExports.jsx("group", { name: "neck" }),
                      jsxRuntimeExports.jsx("group", { name: "head" }),
                      jsxRuntimeExports.jsx("group", { name: "topHead" }),
                      jsxRuntimeExports.jsx("group", { name: "hip" }),
                      jsxRuntimeExports.jsx("group", { name: "earTube" }),
                      jsxRuntimeExports.jsx("group", { name: "ear" }),
                      jsxRuntimeExports.jsx("group", { name: "neckBase" }),
                      jsxRuntimeExports.jsxs("group", {
                        name: "face",
                        children: [
                          jsxRuntimeExports.jsx("group", {
                            name: "eyeCloseKawaii",
                            position: [-13.612, -3.321, -2.904],
                            scale: 1.29,
                          }),
                          jsxRuntimeExports.jsx("group", {
                            name: "eye",
                            position: [0.412, -4.257, -1.92],
                            scale: 1.155,
                          }),
                          jsxRuntimeExports.jsx("group", {
                            name: "eyeSmile",
                            position: [-13.482, -3.211, -2.249],
                            scale: 1.155,
                          }),
                          jsxRuntimeExports.jsx("group", {
                            name: "eyeClose",
                            position: [-15.998, 1.374, -1.498],
                          }),
                          jsxRuntimeExports.jsx("group", {
                            name: "happy",
                            position: [-13.388, -0.047, -1.52],
                          }),
                          jsxRuntimeExports.jsx("group", {
                            name: "smile",
                            position: [0, 0, -1.52],
                          }),
                          jsxRuntimeExports.jsx("group", {
                            name: "o",
                            position: [-13.388, 1.374, -1.254],
                          }),
                          jsxRuntimeExports.jsx("group", {
                            name: "close",
                            position: [-13.388, -0.045, -1.52],
                          }),
                          jsxRuntimeExports.jsxs("group", {
                            name: "group34",
                            rotation: [-Math.PI, 0, 0],
                            scale: -1,
                            children: [
                              jsxRuntimeExports.jsx("group", {
                                name: "eyeCloseKawaii1",
                                position: [-13.612, -3.321, -2.904],
                                scale: 1.29,
                              }),
                              jsxRuntimeExports.jsx("group", {
                                name: "eye1",
                                position: [-5.679, -4.257, -1.92],
                                rotation: [-Math.PI, 0, 0],
                                scale: -1.155,
                              }),
                              jsxRuntimeExports.jsx("group", {
                                name: "eyeSmile1",
                                position: [-13.482, -3.211, -2.249],
                                scale: 1.155,
                              }),
                              jsxRuntimeExports.jsx("group", {
                                name: "eyeClose1",
                                position: [-15.998, 1.374, -1.498],
                              }),
                            ],
                          }),
                        ],
                      }),
                      jsxRuntimeExports.jsx("group", { name: "arm2" }),
                    ],
                  }),
                  jsxRuntimeExports.jsx("group", {
                    name: "Group",
                    children: jsxRuntimeExports.jsx("group", {
                      name: "Main",
                      children: jsxRuntimeExports.jsx("group", {
                        name: "DeformationSystem",
                        children: jsxRuntimeExports.jsxs("group", {
                          name: "Object_159",
                          children: [
                            jsxRuntimeExports.jsx("primitive", {
                              object: o._rootJoint,
                            }),
                            jsxRuntimeExports.jsx("skinnedMesh", {
                              name: "Object_162",
                              geometry: o.Object_162.geometry,
                              material: a.material,
                              skeleton: o.Object_162.skeleton,
                            }),
                            jsxRuntimeExports.jsx("skinnedMesh", {
                              name: "Object_164",
                              geometry: o.Object_164.geometry,
                              material: a.material,
                              skeleton: o.Object_164.skeleton,
                            }),
                            jsxRuntimeExports.jsx("skinnedMesh", {
                              name: "Object_166",
                              geometry: o.Object_166.geometry,
                              material: a.material,
                              skeleton: o.Object_166.skeleton,
                            }),
                            jsxRuntimeExports.jsx("skinnedMesh", {
                              name: "Object_168",
                              geometry: o.Object_168.geometry,
                              material: a.material,
                              skeleton: o.Object_168.skeleton,
                            }),
                            jsxRuntimeExports.jsx("skinnedMesh", {
                              name: "Object_170",
                              geometry: o.Object_170.geometry,
                              material: a.material,
                              skeleton: o.Object_170.skeleton,
                            }),
                            jsxRuntimeExports.jsx("skinnedMesh", {
                              name: "Object_172",
                              geometry: o.Object_172.geometry,
                              material: a.material,
                              skeleton: o.Object_172.skeleton,
                            }),
                            jsxRuntimeExports.jsx("skinnedMesh", {
                              name: "Object_174",
                              geometry: o.Object_174.geometry,
                              material: a.material,
                              skeleton: o.Object_174.skeleton,
                            }),
                            jsxRuntimeExports.jsx("skinnedMesh", {
                              name: "Object_176",
                              geometry: o.Object_176.geometry,
                              material: a.material,
                              skeleton: o.Object_176.skeleton,
                            }),
                            jsxRuntimeExports.jsx("skinnedMesh", {
                              name: "Object_178",
                              geometry: o.Object_178.geometry,
                              material: a.material,
                              skeleton: o.Object_178.skeleton,
                            }),
                            jsxRuntimeExports.jsx("skinnedMesh", {
                              name: "Object_180",
                              geometry: o.Object_180.geometry,
                              material: a.material,
                              skeleton: o.Object_180.skeleton,
                            }),
                            jsxRuntimeExports.jsx("skinnedMesh", {
                              name: "Object_182",
                              geometry: o.Object_182.geometry,
                              material: a.material,
                              skeleton: o.Object_182.skeleton,
                            }),
                            jsxRuntimeExports.jsx("skinnedMesh", {
                              name: "Object_184",
                              geometry: o.Object_184.geometry,
                              material: a.material,
                              skeleton: o.Object_184.skeleton,
                            }),
                            jsxRuntimeExports.jsx("skinnedMesh", {
                              name: "Object_186",
                              geometry: o.Object_186.geometry,
                              material: a.material,
                              skeleton: o.Object_186.skeleton,
                            }),
                            jsxRuntimeExports.jsx("skinnedMesh", {
                              name: "Object_188",
                              geometry: o.Object_188.geometry,
                              material: a.material,
                              skeleton: o.Object_188.skeleton,
                            }),
                            jsxRuntimeExports.jsx("skinnedMesh", {
                              name: "Object_190",
                              geometry: o.Object_190.geometry,
                              material: a.material,
                              skeleton: o.Object_190.skeleton,
                            }),
                            jsxRuntimeExports.jsx("skinnedMesh", {
                              name: "Object_192",
                              geometry: o.Object_192.geometry,
                              material: a.material,
                              skeleton: o.Object_192.skeleton,
                            }),
                            jsxRuntimeExports.jsx("skinnedMesh", {
                              name: "Object_194",
                              geometry: o.Object_194.geometry,
                              material: a.material,
                              skeleton: o.Object_194.skeleton,
                            }),
                            jsxRuntimeExports.jsx("skinnedMesh", {
                              name: "Object_196",
                              geometry: o.Object_196.geometry,
                              material: a.material,
                              skeleton: o.Object_196.skeleton,
                            }),
                            jsxRuntimeExports.jsx("skinnedMesh", {
                              name: "Object_198",
                              geometry: o.Object_198.geometry,
                              material: a.material,
                              skeleton: o.Object_198.skeleton,
                            }),
                            jsxRuntimeExports.jsx("skinnedMesh", {
                              name: "Object_200",
                              geometry: o.Object_200.geometry,
                              material: a.material,
                              skeleton: o.Object_200.skeleton,
                            }),
                            jsxRuntimeExports.jsx("skinnedMesh", {
                              name: "Object_202",
                              geometry: o.Object_202.geometry,
                              material: a.material,
                              skeleton: o.Object_202.skeleton,
                            }),
                            jsxRuntimeExports.jsx("skinnedMesh", {
                              name: "Object_204",
                              geometry: o.Object_204.geometry,
                              material: a.material,
                              skeleton: o.Object_204.skeleton,
                            }),
                            jsxRuntimeExports.jsx("skinnedMesh", {
                              name: "Object_206",
                              geometry: o.Object_206.geometry,
                              material: a.material,
                              skeleton: o.Object_206.skeleton,
                            }),
                            jsxRuntimeExports.jsx("skinnedMesh", {
                              name: "Object_208",
                              geometry: o.Object_208.geometry,
                              material: a.material,
                              skeleton: o.Object_208.skeleton,
                            }),
                            jsxRuntimeExports.jsx("skinnedMesh", {
                              name: "Object_210",
                              geometry: o.Object_210.geometry,
                              material: a.material,
                              skeleton: o.Object_210.skeleton,
                            }),
                            jsxRuntimeExports.jsx("skinnedMesh", {
                              name: "Object_212",
                              geometry: o.Object_212.geometry,
                              material: a.material,
                              skeleton: o.Object_212.skeleton,
                            }),
                            jsxRuntimeExports.jsx("skinnedMesh", {
                              name: "Object_214",
                              geometry: o.Object_214.geometry,
                              material: a.material,
                              skeleton: o.Object_214.skeleton,
                            }),
                            jsxRuntimeExports.jsx("skinnedMesh", {
                              name: "Object_216",
                              geometry: o.Object_216.geometry,
                              material: a.material,
                              skeleton: o.Object_216.skeleton,
                            }),
                            jsxRuntimeExports.jsx("skinnedMesh", {
                              name: "Object_218",
                              geometry: o.Object_218.geometry,
                              material: a.material,
                              skeleton: o.Object_218.skeleton,
                            }),
                            jsxRuntimeExports.jsx("skinnedMesh", {
                              name: "Object_220",
                              geometry: o.Object_220.geometry,
                              material: a.material,
                              skeleton: o.Object_220.skeleton,
                            }),
                            jsxRuntimeExports.jsx("skinnedMesh", {
                              name: "Object_222",
                              geometry: o.Object_222.geometry,
                              material: a.material,
                              skeleton: o.Object_222.skeleton,
                            }),
                            jsxRuntimeExports.jsx("skinnedMesh", {
                              name: "Object_224",
                              geometry: o.Object_224.geometry,
                              material: a.material,
                              skeleton: o.Object_224.skeleton,
                            }),
                            jsxRuntimeExports.jsx("skinnedMesh", {
                              name: "Object_226",
                              geometry: o.Object_226.geometry,
                              material: a.material,
                              skeleton: o.Object_226.skeleton,
                            }),
                            jsxRuntimeExports.jsx("skinnedMesh", {
                              name: "Object_228",
                              geometry: o.Object_228.geometry,
                              material: a.material,
                              skeleton: o.Object_228.skeleton,
                            }),
                            jsxRuntimeExports.jsx("group", {
                              name: "Object_161",
                            }),
                            jsxRuntimeExports.jsx("group", {
                              name: "Object_163",
                            }),
                            jsxRuntimeExports.jsx("group", {
                              name: "Object_165",
                            }),
                            jsxRuntimeExports.jsx("group", {
                              name: "Object_167",
                            }),
                            jsxRuntimeExports.jsx("group", {
                              name: "Object_169",
                            }),
                            jsxRuntimeExports.jsx("group", {
                              name: "Object_171",
                            }),
                            jsxRuntimeExports.jsx("group", {
                              name: "Object_173",
                            }),
                            jsxRuntimeExports.jsx("group", {
                              name: "Object_175",
                            }),
                            jsxRuntimeExports.jsx("group", {
                              name: "Object_177",
                            }),
                            jsxRuntimeExports.jsx("group", {
                              name: "Object_179",
                            }),
                            jsxRuntimeExports.jsx("group", {
                              name: "Object_181",
                            }),
                            jsxRuntimeExports.jsx("group", {
                              name: "Object_183",
                            }),
                            jsxRuntimeExports.jsx("group", {
                              name: "Object_185",
                            }),
                            jsxRuntimeExports.jsx("group", {
                              name: "Object_187",
                            }),
                            jsxRuntimeExports.jsx("group", {
                              name: "Object_189",
                            }),
                            jsxRuntimeExports.jsx("group", {
                              name: "Object_191",
                            }),
                            jsxRuntimeExports.jsx("group", {
                              name: "Object_193",
                            }),
                            jsxRuntimeExports.jsx("group", {
                              name: "Object_195",
                            }),
                            jsxRuntimeExports.jsx("group", {
                              name: "Object_197",
                            }),
                            jsxRuntimeExports.jsx("group", {
                              name: "Object_199",
                            }),
                            jsxRuntimeExports.jsx("group", {
                              name: "Object_201",
                            }),
                            jsxRuntimeExports.jsx("group", {
                              name: "Object_203",
                              position: [-13.612, -3.321, -2.904],
                              scale: 1.29,
                            }),
                            jsxRuntimeExports.jsx("group", {
                              name: "Object_205",
                              position: [0.412, -4.257, -1.92],
                              scale: 1.155,
                            }),
                            jsxRuntimeExports.jsx("group", {
                              name: "Object_207",
                              position: [-13.482, -3.211, -2.249],
                              scale: 1.155,
                            }),
                            jsxRuntimeExports.jsx("group", {
                              name: "Object_209",
                              position: [-15.998, 1.374, -1.498],
                            }),
                            jsxRuntimeExports.jsx("group", {
                              name: "Object_211",
                              position: [-13.388, -0.047, -1.52],
                            }),
                            jsxRuntimeExports.jsx("group", {
                              name: "Object_213",
                              position: [0, 0, -1.52],
                            }),
                            jsxRuntimeExports.jsx("group", {
                              name: "Object_215",
                              position: [-13.388, 1.374, -1.254],
                            }),
                            jsxRuntimeExports.jsx("group", {
                              name: "Object_217",
                              position: [-13.388, -0.045, -1.52],
                            }),
                            jsxRuntimeExports.jsx("group", {
                              name: "Object_219",
                              position: [13.612, -3.321, -2.904],
                              scale: [-1.29, 1.29, 1.29],
                            }),
                            jsxRuntimeExports.jsx("group", {
                              name: "Object_221",
                              position: [5.679, -4.257, -1.92],
                              scale: 1.155,
                            }),
                            jsxRuntimeExports.jsx("group", {
                              name: "Object_223",
                              position: [13.482, -3.211, -2.249],
                              scale: [-1.155, 1.155, 1.155],
                            }),
                            jsxRuntimeExports.jsx("group", {
                              name: "Object_225",
                              position: [15.998, 1.374, -1.498],
                              scale: [-1, 1, 1],
                            }),
                            jsxRuntimeExports.jsx("group", {
                              name: "Object_227",
                            }),
                          ],
                        }),
                      }),
                    }),
                  }),
                ],
              }),
            }),
          }),
        }),
      }),
    })
  );
}
useGLTF.preload("./robot_playground.glb");
function Loader() {
  const { progress: s, active: e } = useProgress();
  return jsxRuntimeExports.jsxs(Html, {
    center: !0,
    style: { color: "#fff" },
    children: [s.toFixed(1), "% loaded"],
  });
}
const Cartoonrobotscean = () =>
    jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, {
      children: jsxRuntimeExports.jsxs(Canvas, {
        gl: { antialias: !0 },
        dpr: [1, 1.5],
        className: "canvac",
        children: [
          jsxRuntimeExports.jsx("ambientLight", { intensity: 1 }),
          jsxRuntimeExports.jsx(OrbitControls, {}),
          jsxRuntimeExports.jsx(reactExports$1.Suspense, {
            fallback: jsxRuntimeExports.jsx(Loader, {}),
            children: jsxRuntimeExports.jsx(Cartoonrobot, {}),
          }),
          jsxRuntimeExports.jsx(ContactShadows, {
            position: [0, -1.994, 0],
            opacity: 1,
            scale: 25,
            blur: 1,
            far: 10,
            resolution: 256,
            color: "#000000",
          }),
        ],
      }),
    }),
  Animation = () =>
    jsxRuntimeExports.jsx("div", {
      className: "Animation",
      children: jsxRuntimeExports.jsxs("div", {
        className: "animasubcon",
        children: [
          jsxRuntimeExports.jsx("div", {
            className: "raia",
            children: jsxRuntimeExports.jsx(Lottie, { animationData: td }),
          }),
          jsxRuntimeExports.jsx(Cartoonrobotscean, {}),
        ],
      }),
    }),
  Work = () =>
    jsxRuntimeExports.jsxs("div", {
      className: "work",
      children: [
        jsxRuntimeExports.jsxs("div", {
          className: "titlecon nnk",
          children: [
            jsxRuntimeExports.jsxs("div", {
              className: "atitle",
              children: [
                jsxRuntimeExports.jsx(TextAnimation, {
                  children: jsxRuntimeExports.jsx("p", {
                    children: "Projects.",
                  }),
                }),
                jsxRuntimeExports.jsx("div", {
                  className: "subatitle",
                  children: jsxRuntimeExports.jsx(TextAnimation, {
                    children: "View more",
                  }),
                }),
              ],
            }),
            jsxRuntimeExports.jsx(TextAnimation, {
              children: jsxRuntimeExports.jsx("p", {
                className: "titlep one",
                children:
                  "Here you will find some of the personal and clients projects that I created",
              }),
            }),
          ],
        }),
        jsxRuntimeExports.jsx("div", {
          className: "workcontent",
          children: works.map((s) =>
            jsxRuntimeExports.jsx(Sssb, {
              children: jsxRuntimeExports.jsxs("a", {
                href: s.like,
                className: "seviceitem",
                children: [
                  jsxRuntimeExports.jsxs("div", {
                    style: {
                      position: "relative",
                      display: "flex",
                      alignItems: "center",
                      justifyContent: "center",
                    },
                    children: [
                      jsxRuntimeExports.jsx(TextAnimation, {
                        children: jsxRuntimeExports.jsx("img", {
                          src: s.img,
                          style: { maxHeight: "200px" },
                          className: "siimg",
                        }),
                      }),
                      jsxRuntimeExports.jsx("div", { className: "gradent" }),
                    ],
                  }),
                  jsxRuntimeExports.jsxs("div", {
                    className: "scontcon",
                    children: [
                      jsxRuntimeExports.jsx("div", {
                        className: "workkheader",
                        children: jsxRuntimeExports.jsx(TextAnimation, {
                          children: jsxRuntimeExports.jsx("p", {
                            children: s.name,
                          }),
                        }),
                      }),
                      jsxRuntimeExports.jsxs("div", {
                        children: [
                          jsxRuntimeExports.jsx("div", {
                            style: { marginTop: "15px" },
                            children: jsxRuntimeExports.jsx(TextAnimation, {
                              children: jsxRuntimeExports.jsx("p", {
                                className: "ship one",
                                children: s.desc,
                              }),
                            }),
                          }),
                          jsxRuntimeExports.jsx("div", {
                            className: "abs",
                            children: jsxRuntimeExports.jsx(TextAnimation, {
                              children: jsxRuntimeExports.jsx("a", {
                                href: s.like,
                                className: "shicon",
                                children: jsxRuntimeExports.jsx(
                                  RiSearchEyeLine,
                                  { className: "iconnav", size: "2rem" }
                                ),
                              }),
                            }),
                          }),
                        ],
                      }),
                    ],
                  }),
                ],
              }),
            })
          ),
        }),
      ],
    }),
  cool = "./cool.mp4",
  Cool = () =>
    jsxRuntimeExports.jsx("div", {
      className: "coll",
      children: jsxRuntimeExports.jsxs("div", {
        style: {
          height: "90%",
          width: "100%",
          maxWidth: "1000px",
          borderRadius: "30px",
          overflow: "hidden",
          position: "relative",
        },
        children: [
          jsxRuntimeExports.jsx("video", {
            className: "herovedio",
            src: cool,
            autoPlay: !0,
            loop: !0,
            muted: !0,
          }),
          jsxRuntimeExports.jsxs("div", {
            className: "coolabs",
            children: [
              jsxRuntimeExports.jsx(TextAnimation, {
                children: jsxRuntimeExports.jsx("p", {
                  children: "Have a project ",
                }),
              }),
              jsxRuntimeExports.jsx(TextAnimation, {
                children: jsxRuntimeExports.jsx("p", { children: "in mind?" }),
              }),
              jsxRuntimeExports.jsx(Link, {
                to: "/contact",
                style: { marginTop: "20px" },
                children: jsxRuntimeExports.jsxs("a", {
                  className: "contactbutton OO oooo",
                  href: "",
                  children: [
                    jsxRuntimeExports.jsx("span", {}),
                    jsxRuntimeExports.jsx("span", {}),
                    jsxRuntimeExports.jsx("span", {}),
                    jsxRuntimeExports.jsx("span", {}),
                    jsxRuntimeExports.jsx(TextAnimation, {
                      children: jsxRuntimeExports.jsx("p", {
                        className: "two",
                        children: "Contact Me",
                      }),
                    }),
                  ],
                }),
              }),
            ],
          }),
        ],
      }),
    }),
  Footer = () =>
    jsxRuntimeExports.jsxs("div", {
      className: "footer",
      children: [
        jsxRuntimeExports.jsxs("div", {
          className: "firstfooter",
          children: [
            jsxRuntimeExports.jsx(TextAnimation, {
              children: jsxRuntimeExports.jsx(motion.a, {
                href: "https://github.com/Hemo-abolarin",
                className: "ShotCostomButton",
                children: jsxRuntimeExports.jsx(Lottie, { animationData: git }),
              }),
            }),
            jsxRuntimeExports.jsx(TextAnimation, {
              children: jsxRuntimeExports.jsx(motion.a, {
                href: "https://www.linkedin.com/login",
                className: "ShotCostomButton",
                children: jsxRuntimeExports.jsx(Lottie, { animationData: ln }),
              }),
            }),
          ],
        }),
        jsxRuntimeExports.jsxs("div", {
          className: "secondfooter",
          children: [
            jsxRuntimeExports.jsx(motion.div, {
              className: "logocon",
              children: jsxRuntimeExports.jsx("img", {
                className: "logoemage",
                src: logo,
              }),
            }),
            jsxRuntimeExports.jsx(TextAnimation, {
              children: jsxRuntimeExports.jsx("p", {
                children: "Ibrahim portfolio",
              }),
            }),
          ],
        }),
        jsxRuntimeExports.jsx("div", {
          className: "lastfooter",
          children: jsxRuntimeExports.jsx(TextAnimation, {
            children: "@ Ibrahim Portfolio.2024 original",
          }),
        }),
      ],
    }),
  Home = () => {
    const [s, e] = reactExports$1.useState(1),
      o = reactExports$1.useRef(null),
      a = reactExports$1.useRef(null),
      c = reactExports$1.useRef(null),
      d = useInView(o),
      g = useInView(a),
      _ = useInView(c);
    return (
      reactExports$1.useEffect(() => {
        d && !g && !_ ? e(1) : !d && g && !_ ? e(2) : !d && !g && _ && e(3),
          console.log(d),
          console.log(g),
          console.log(_);
      }, [d, g, _]),
      jsxRuntimeExports.jsxs("div", {
        className: "home",
        style: { backgroundColor: "black" },
        children: [
          jsxRuntimeExports.jsxs(motion.div, {
            variants: {
              hidden: { opacity: 0, x: -100 },
              show: { opacity: 1, x: 0 },
            },
            transition: { duration: 0.5, ease: "easeOut", delay: 0.2 },
            initial: "hidden",
            animate: "show",
            className: "leftbar",
            children: [
              jsxRuntimeExports.jsx(motion.div, {
                variants: {
                  hidden: { opacity: 0, x: -100, y: -100 },
                  show: { opacity: 1, x: 0, y: 0 },
                },
                transition: { duration: 0.5, ease: "easeOut", delay: 0.5 },
                initial: "hidden",
                animate: "show",
                className: "logocon",
                children: jsxRuntimeExports.jsx("img", {
                  className: "logoemage",
                  src: logo,
                }),
              }),
              jsxRuntimeExports.jsxs("div", {
                className: "leftnavcon",
                children: [
                  s === 1
                    ? jsxRuntimeExports.jsx(motion.a, {
                        variants: {
                          hidden: { opacity: 0, x: -100 },
                          show: { opacity: 1, x: 0 },
                        },
                        transition: {
                          duration: 0.2,
                          ease: "easeOut",
                          delay: 0.2,
                        },
                        initial: "hidden",
                        animate: "show",
                        className: "Alncitem",
                        href: "#hero",
                        children: jsxRuntimeExports.jsx("a", {
                          href: "#hero",
                          children: "Hero",
                        }),
                      })
                    : jsxRuntimeExports.jsx(motion.a, {
                        variants: {
                          hidden: { opacity: 0, x: -100 },
                          show: { opacity: 1, x: 0 },
                        },
                        transition: {
                          duration: 0.2,
                          ease: "easeOut",
                          delay: 0.2,
                        },
                        initial: "hidden",
                        animate: "show",
                        className: "lncitem",
                        href: "#hero",
                        onClick: () => {
                          e(1);
                        },
                        children: jsxRuntimeExports.jsx("a", {
                          href: "#hero",
                          children: "Hero",
                        }),
                      }),
                  s === 3
                    ? jsxRuntimeExports.jsx(motion.a, {
                        variants: {
                          hidden: { opacity: 0, x: -100 },
                          show: { opacity: 1, x: 0 },
                        },
                        transition: {
                          duration: 0.2,
                          ease: "easeOut",
                          delay: 0.6,
                        },
                        initial: "hidden",
                        animate: "show",
                        className: "Alncitem",
                        href: "#about",
                        children: jsxRuntimeExports.jsx("a", {
                          href: "#about",
                          children: "About ",
                        }),
                      })
                    : jsxRuntimeExports.jsx(motion.a, {
                        variants: {
                          hidden: { opacity: 0, x: -100 },
                          show: { opacity: 1, x: 0 },
                        },
                        transition: {
                          duration: 0.2,
                          ease: "easeOut",
                          delay: 0.6,
                        },
                        initial: "hidden",
                        animate: "show",
                        className: "lncitem",
                        onClick: () => {
                          e(3);
                        },
                        href: "#about",
                        children: jsxRuntimeExports.jsx("a", {
                          href: "#about",
                          children: "About",
                        }),
                      }),
                  s === 2
                    ? jsxRuntimeExports.jsx(motion.a, {
                        variants: {
                          hidden: { opacity: 0, x: -100 },
                          show: { opacity: 1, x: 0 },
                        },
                        transition: {
                          duration: 0.2,
                          ease: "easeOut",
                          delay: 0.4,
                        },
                        initial: "hidden",
                        animate: "show",
                        className: "Alncitem",
                        href: "#works",
                        children: jsxRuntimeExports.jsx("a", {
                          href: "#works",
                          children: "Projects",
                        }),
                      })
                    : jsxRuntimeExports.jsx(motion.a, {
                        variants: {
                          hidden: { opacity: 0, x: -100 },
                          show: { opacity: 1, x: 0 },
                        },
                        transition: {
                          duration: 0.2,
                          ease: "easeOut",
                          delay: 0.4,
                        },
                        initial: "hidden",
                        animate: "show",
                        className: "lncitem",
                        onClick: () => {
                          e(2);
                        },
                        href: "#works",
                        children: jsxRuntimeExports.jsx("a", {
                          href: "#works",
                          children: "Projects",
                        }),
                      }),
                ],
              }),
            ],
          }),
          jsxRuntimeExports.jsxs("div", {
            className: "contentconn",
            children: [
              jsxRuntimeExports.jsx(TopNav, {}),
              jsxRuntimeExports.jsx("div", {
                ref: o,
                id: "hero",
                children: jsxRuntimeExports.jsx(Hero, {}),
              }),
              jsxRuntimeExports.jsxs("div", {
                ref: c,
                id: "about",
                children: [
                  jsxRuntimeExports.jsx(About, {}),
                  jsxRuntimeExports.jsx(Animation, {}),
                ],
              }),
              jsxRuntimeExports.jsxs("div", {
                ref: a,
                id: "works",
                children: [
                  jsxRuntimeExports.jsx(Work, {}),
                  jsxRuntimeExports.jsx(Cool, {}),
                  jsxRuntimeExports.jsx(Footer, {}),
                ],
              }),
            ],
          }),
        ],
      })
    );
  };
class EmailJSResponseStatus {
  constructor(e = 0, o = "Network Error") {
    (this.status = e), (this.text = o);
  }
}
const createWebStorage = () => {
    if (!(typeof localStorage > "u"))
      return {
        get: (s) => Promise.resolve(localStorage.getItem(s)),
        set: (s, e) => Promise.resolve(localStorage.setItem(s, e)),
        remove: (s) => Promise.resolve(localStorage.removeItem(s)),
      };
  },
  store = {
    origin: "https://api.emailjs.com",
    blockHeadless: !1,
    storageProvider: createWebStorage(),
  },
  buildOptions = (s) =>
    s
      ? typeof s == "string"
        ? { publicKey: s }
        : s.toString() === "[object Object]"
        ? s
        : {}
      : {},
  init = (s, e = "https://api.emailjs.com") => {
    if (!s) return;
    const o = buildOptions(s);
    (store.publicKey = o.publicKey),
      (store.blockHeadless = o.blockHeadless),
      (store.storageProvider = o.storageProvider),
      (store.blockList = o.blockList),
      (store.limitRate = o.limitRate),
      (store.origin = o.origin || e);
  },
  sendPost = async (s, e, o = {}) => {
    const a = await fetch(store.origin + s, {
        method: "POST",
        headers: o,
        body: e,
      }),
      c = await a.text(),
      d = new EmailJSResponseStatus(a.status, c);
    if (a.ok) return d;
    throw d;
  },
  validateParams = (s, e, o) => {
    if (!s || typeof s != "string")
      throw "The public key is required. Visit https://dashboard.emailjs.com/admin/account";
    if (!e || typeof e != "string")
      throw "The service ID is required. Visit https://dashboard.emailjs.com/admin";
    if (!o || typeof o != "string")
      throw "The template ID is required. Visit https://dashboard.emailjs.com/admin/templates";
  },
  validateTemplateParams = (s) => {
    if (s && s.toString() !== "[object Object]")
      throw "The template params have to be the object. Visit https://www.emailjs.com/docs/sdk/send/";
  },
  isHeadless = (s) => s.webdriver || !s.languages || s.languages.length === 0,
  headlessError = () =>
    new EmailJSResponseStatus(451, "Unavailable For Headless Browser"),
  validateBlockListParams = (s, e) => {
    if (!Array.isArray(s)) throw "The BlockList list has to be an array";
    if (typeof e != "string")
      throw "The BlockList watchVariable has to be a string";
  },
  isBlockListDisabled = (s) => {
    var e;
    return !((e = s.list) != null && e.length) || !s.watchVariable;
  },
  getValue = (s, e) => (s instanceof FormData ? s.get(e) : s[e]),
  isBlockedValueInParams = (s, e) => {
    if (isBlockListDisabled(s)) return !1;
    validateBlockListParams(s.list, s.watchVariable);
    const o = getValue(e, s.watchVariable);
    return typeof o != "string" ? !1 : s.list.includes(o);
  },
  blockedEmailError = () => new EmailJSResponseStatus(403, "Forbidden"),
  validateLimitRateParams = (s, e) => {
    if (typeof s != "number" || s < 0)
      throw "The LimitRate throttle has to be a positive number";
    if (e && typeof e != "string")
      throw "The LimitRate ID has to be a non-empty string";
  },
  getLeftTime = async (s, e, o) => {
    const a = Number((await o.get(s)) || 0);
    return e - Date.now() + a;
  },
  isLimitRateHit = async (s, e, o) => {
    if (!e.throttle || !o) return !1;
    validateLimitRateParams(e.throttle, e.id);
    const a = e.id || s;
    return (await getLeftTime(a, e.throttle, o)) > 0
      ? !0
      : (await o.set(a, Date.now().toString()), !1);
  },
  limitRateError = () => new EmailJSResponseStatus(429, "Too Many Requests"),
  send = async (s, e, o, a) => {
    const c = buildOptions(a),
      d = c.publicKey || store.publicKey,
      g = c.blockHeadless || store.blockHeadless,
      _ = c.storageProvider || store.storageProvider,
      b = { ...store.blockList, ...c.blockList },
      j = { ...store.limitRate, ...c.limitRate };
    return g && isHeadless(navigator)
      ? Promise.reject(headlessError())
      : (validateParams(d, s, e),
        validateTemplateParams(o),
        o && isBlockedValueInParams(b, o)
          ? Promise.reject(blockedEmailError())
          : (await isLimitRateHit(location.pathname, j, _))
          ? Promise.reject(limitRateError())
          : sendPost(
              "/api/v1.0/email/send",
              JSON.stringify({
                lib_version: "4.4.1",
                user_id: d,
                service_id: s,
                template_id: e,
                template_params: o,
              }),
              { "Content-type": "application/json" }
            ));
  },
  validateForm = (s) => {
    if (!s || s.nodeName !== "FORM")
      throw "The 3rd parameter is expected to be the HTML form element or the style selector of the form";
  },
  findHTMLForm = (s) => (typeof s == "string" ? document.querySelector(s) : s),
  sendForm = async (s, e, o, a) => {
    const c = buildOptions(a),
      d = c.publicKey || store.publicKey,
      g = c.blockHeadless || store.blockHeadless,
      _ = store.storageProvider || c.storageProvider,
      b = { ...store.blockList, ...c.blockList },
      j = { ...store.limitRate, ...c.limitRate };
    if (g && isHeadless(navigator)) return Promise.reject(headlessError());
    const $ = findHTMLForm(o);
    validateParams(d, s, e), validateForm($);
    const _e = new FormData($);
    return isBlockedValueInParams(b, _e)
      ? Promise.reject(blockedEmailError())
      : (await isLimitRateHit(location.pathname, j, _))
      ? Promise.reject(limitRateError())
      : (_e.append("lib_version", "4.4.1"),
        _e.append("service_id", s),
        _e.append("template_id", e),
        _e.append("user_id", d),
        sendPost("/api/v1.0/email/send-form", _e));
  },
  emailjs = { init, send, sendForm, EmailJSResponseStatus },
  useAlert = () => {
    const [s, e] = reactExports$1.useState({
      show: !1,
      text: "",
      type: "danger",
    });
    return {
      alert: s,
      showAlert: ({ text: c, type: d = "danger" }) =>
        e({ show: !0, text: c, type: d }),
      hideAlert: () => e({ show: !1, text: "", type: "danger" }),
    };
  },
  Alert = ({ type: s, text: e }) =>
    jsxRuntimeExports.jsx("div", {
      className: "alermaincon",
      children: jsxRuntimeExports.jsxs("div", {
        className: `${s === "danger" ? "danger" : "succeful"} alertconinnercon`,
        role: "alert",
        children: [
          jsxRuntimeExports.jsx("a", {
            className: `${
              s === "danger" ? "bg-red-500" : "bg-green-500"
            } flex uppercase px-2 py-1 text-xs font-semibold mr-3 alertcon`,
            children: s === "danger" ? "Failed" : "Success",
          }),
          jsxRuntimeExports.jsxs("a", {
            className: "mr-2 text-left",
            children: [" ", e],
          }),
        ],
      }),
    }),
  nm = "whatsappTime",
  mn = "",
  layers = [
    {
      ty: 0,
      nm: "phone-composition",
      mn: "",
      sr: 1,
      st: 0,
      op: 271,
      ip: 0,
      hd: !1,
      cl: "",
      ln: "",
      ddd: 0,
      bm: 0,
      hasMask: !1,
      ao: 0,
      ks: {
        a: { a: 0, k: [0, 0] },
        s: { a: 0, k: [100, 100] },
        sk: { a: 0, k: 0 },
        p: { a: 0, k: [0, 0] },
        r: { a: 0, k: 0 },
        sa: { a: 0, k: 0 },
        o: {
          a: 1,
          k: [
            { o: { x: 0, y: 0 }, i: { x: 1, y: 1 }, s: [0], t: 0 },
            {
              o: { x: 0, y: 0 },
              i: { x: 1, y: 1 },
              s: [0],
              t: 50.699999999999996,
            },
            { o: { x: 0.42, y: 0 }, i: { x: 0.58, y: 1 }, s: [100], t: 69.6 },
            { o: { x: 0, y: 0 }, i: { x: 1, y: 1 }, s: [100], t: 270 },
          ],
        },
      },
      ef: [],
      w: 100,
      h: 100,
      refId: "comp_phone_6ADD6E0F-BD1A-4979-955D-714C9ABAB504",
      ind: 1,
    },
    {
      ty: 0,
      nm: "Fill 1-composition",
      mn: "",
      sr: 1,
      st: 0,
      op: 271,
      ip: 0,
      hd: !1,
      cl: "",
      ln: "",
      ddd: 0,
      bm: 0,
      hasMask: !1,
      ao: 0,
      ks: {
        a: { a: 0, k: [0, 0] },
        s: { a: 0, k: [100, 100] },
        sk: { a: 0, k: 0 },
        p: { a: 0, k: [0, 0] },
        r: { a: 0, k: 0 },
        sa: { a: 0, k: 0 },
        o: { a: 0, k: 100 },
      },
      ef: [],
      w: 100,
      h: 100,
      refId: "comp_Fill 1_BA8ED0D5-D328-49CA-A278-C5A2B56A4A59",
      ind: 2,
    },
    {
      ty: 0,
      nm: "circle_1-composition",
      mn: "",
      sr: 1,
      st: 0,
      op: 271,
      ip: 0,
      hd: !1,
      cl: "",
      ln: "",
      ddd: 0,
      bm: 0,
      hasMask: !1,
      ao: 0,
      ks: {
        a: { a: 0, k: [0, 0] },
        s: { a: 0, k: [100, 100] },
        sk: { a: 0, k: 0 },
        p: { a: 0, k: [0, 0] },
        r: { a: 0, k: 0 },
        sa: { a: 0, k: 0 },
        o: {
          a: 1,
          k: [
            { o: { x: 0, y: 0 }, i: { x: 1, y: 1 }, s: [100], t: 0 },
            { o: { x: 0, y: 0 }, i: { x: 1, y: 1 }, s: [100], t: 50.4 },
            { o: { x: 0, y: 0 }, i: { x: 1, y: 1 }, s: [0], t: 90 },
            { o: { x: 0, y: 0 }, i: { x: 1, y: 1 }, s: [0], t: 129.3 },
            {
              o: { x: 0, y: 0 },
              i: { x: 1, y: 1 },
              s: [100],
              t: 129.60000000000002,
            },
            { o: { x: 0.42, y: 0 }, i: { x: 0.58, y: 1 }, s: [0], t: 169.2 },
            { o: { x: 0, y: 0 }, i: { x: 1, y: 1 }, s: [0], t: 270 },
          ],
        },
      },
      ef: [],
      w: 100,
      h: 100,
      refId: "comp_circle_1_3242EB09-ABE7-42CC-A679-7351963F39E4",
      ind: 3,
    },
    {
      ty: 0,
      nm: "circle_1_copy_copy-composition",
      mn: "",
      sr: 1,
      st: 0,
      op: 271,
      ip: 0,
      hd: !1,
      cl: "",
      ln: "",
      ddd: 0,
      bm: 0,
      hasMask: !1,
      ao: 0,
      ks: {
        a: { a: 0, k: [0, 0] },
        s: { a: 0, k: [100, 100] },
        sk: { a: 0, k: 0 },
        p: { a: 0, k: [0, 0] },
        r: { a: 0, k: 0 },
        sa: { a: 0, k: 0 },
        o: {
          a: 1,
          k: [
            { o: { x: 0, y: 0 }, i: { x: 1, y: 1 }, s: [100], t: 0 },
            { o: { x: 0.42, y: 0 }, i: { x: 1, y: 1 }, s: [100], t: 90 },
            {
              o: { x: 0, y: 0 },
              i: { x: 1, y: 1 },
              s: [0],
              t: 129.60000000000002,
            },
            { o: { x: 0, y: 0 }, i: { x: 1, y: 1 }, s: [0], t: 168.9 },
            { o: { x: 0.42, y: 0 }, i: { x: 1, y: 1 }, s: [100], t: 169.2 },
            { o: { x: 0, y: 0 }, i: { x: 1, y: 1 }, s: [100], t: 270 },
          ],
        },
      },
      ef: [],
      w: 100,
      h: 100,
      refId: "comp_circle_1_copy_copy_6856E7C8-C47F-4CFC-B65C-915DBA76F176",
      ind: 4,
    },
    {
      ty: 0,
      nm: "circle_1_copy_copy-composition",
      mn: "",
      sr: 1,
      st: 0,
      op: 271,
      ip: 0,
      hd: !1,
      cl: "",
      ln: "",
      ddd: 0,
      bm: 0,
      hasMask: !1,
      ao: 0,
      ks: {
        a: { a: 0, k: [0, 0] },
        s: { a: 0, k: [100, 100] },
        sk: { a: 0, k: 0 },
        p: { a: 0, k: [0, 0] },
        r: { a: 0, k: 0 },
        sa: { a: 0, k: 0 },
        o: { a: 0, k: 100 },
      },
      ef: [],
      w: 100,
      h: 100,
      refId: "comp_circle_1_copy_copy_DB39B229-8432-4667-8BDA-C51947FD6E80",
      ind: 5,
    },
    {
      ty: 4,
      nm: "Scene-background",
      mn: "",
      sr: 1,
      st: 0,
      op: 271,
      ip: 0,
      hd: !1,
      cl: "",
      ln: "",
      ddd: 0,
      bm: 0,
      hasMask: !1,
      ao: 0,
      ks: {
        a: { a: 0, k: [0, 0] },
        s: { a: 0, k: [100, 100] },
        sk: { a: 0, k: 0 },
        p: { a: 0, k: [0, 0] },
        r: { a: 0, k: 0 },
        sa: { a: 0, k: 0 },
        o: { a: 0, k: 100 },
      },
      ef: [],
      shapes: [
        {
          ty: "gr",
          bm: 0,
          cl: "",
          ln: "",
          hd: !1,
          mn: "",
          nm: "Scene-background",
          cix: 2,
          np: 3,
          it: [
            {
              ty: "rc",
              bm: 0,
              cl: "",
              ln: "",
              hd: !1,
              mn: "",
              nm: "Scene-background",
              d: 1,
              p: { a: 0, k: [50, 50] },
              r: { a: 0, k: 0 },
              s: { a: 0, k: [100, 100] },
            },
            {
              ty: "fl",
              bm: 0,
              cl: "",
              ln: "",
              hd: !1,
              mn: "",
              nm: "Fill 1",
              c: { a: 0, k: [1, 1, 1] },
              r: 1,
              o: { a: 0, k: 100 },
            },
            {
              ty: "tr",
              a: { a: 0, k: [0, 0] },
              s: { a: 0, k: [100, 100] },
              sk: { a: 0, k: 0 },
              p: { a: 0, k: [0, 0] },
              r: { a: 0, k: 0 },
              sa: { a: 0, k: 0 },
              o: { a: 0, k: 100 },
            },
          ],
        },
      ],
      ind: 6,
    },
  ],
  ddd = 0,
  h = 100,
  w = 100,
  meta = { a: "", k: "", d: "whatsappTime", g: "Flow 1.10.0", tc: "#000000" },
  v = "5.6.4",
  fr = 30,
  op = 271,
  ip = 0,
  assets = [
    {
      nm: "",
      mn: "",
      layers: [
        {
          ty: 3,
          nm: "circle_1_copy_copy-null",
          mn: "",
          sr: 1,
          st: 0,
          op: 271,
          ip: 0,
          hd: !1,
          cl: "",
          ln: "",
          ddd: 0,
          bm: 0,
          hasMask: !1,
          ao: 0,
          ks: {
            a: { a: 0, k: [0.005, 0.005, 0] },
            s: { a: 0, k: [100, 100] },
            sk: { a: 0, k: 0 },
            p: { s: !0, x: { a: 0, k: 50 }, y: { a: 0, k: 50 } },
            r: { a: 0, k: 0 },
            sa: { a: 0, k: 0 },
            o: { a: 0, k: 100 },
          },
          ef: [],
          ind: 1,
        },
        {
          ty: 4,
          nm: "circle_1_copy_copy-content",
          mn: "",
          sr: 1,
          st: 0,
          op: 271,
          ip: 0,
          hd: !1,
          cl: "",
          ln: "",
          ddd: 0,
          bm: 0,
          hasMask: !1,
          ao: 0,
          ks: {
            a: { a: 0, k: [0, 0] },
            s: { a: 0, k: [100, 100] },
            sk: { a: 0, k: 0 },
            p: { a: 0, k: [0, 0] },
            r: { a: 0, k: 0 },
            sa: { a: 0, k: 0 },
            o: { a: 0, k: 100 },
          },
          ef: [],
          shapes: [
            {
              ty: "gr",
              bm: 0,
              cl: "",
              ln: "",
              hd: !1,
              mn: "",
              nm: "circle_1_copy_copy-content",
              cix: 2,
              np: 3,
              it: [
                {
                  ty: "sh",
                  bm: 0,
                  cl: "",
                  ln: "",
                  hd: !1,
                  mn: "",
                  nm: "circle_1_copy_copy-path",
                  d: 1,
                  ks: {
                    a: 0,
                    k: {
                      c: !0,
                      i: [
                        [-0.00275, 0],
                        [0, 0.0027500000000000007],
                        [0.0027500000000000007, 0],
                        [0, -0.00275],
                      ],
                      o: [
                        [0.0027500000000000007, 0],
                        [0, -0.00275],
                        [-0.00275, 0],
                        [0, 0.0027500000000000007],
                      ],
                      v: [
                        [0.005, 0.01],
                        [0.01, 0.005],
                        [0.005, 0],
                        [0, 0.005],
                      ],
                    },
                  },
                },
                {
                  ty: "fl",
                  bm: 0,
                  cl: "",
                  ln: "",
                  hd: !1,
                  mn: "",
                  nm: "Fill 1",
                  c: { a: 0, k: [0.0235, 0.4863, 0.3922] },
                  r: 1,
                  o: { a: 0, k: 100 },
                },
                {
                  ty: "tr",
                  a: { a: 0, k: [0, 0] },
                  s: { a: 0, k: [100, 100] },
                  sk: { a: 0, k: 0 },
                  p: { a: 0, k: [0, 0] },
                  r: { a: 0, k: 0 },
                  sa: { a: 0, k: 0 },
                  o: { a: 0, k: 100 },
                },
              ],
            },
          ],
          ind: 2,
          parent: 1,
        },
      ],
      id: "comp_circle_1_copy_copy_DB39B229-8432-4667-8BDA-C51947FD6E80",
    },
    {
      nm: "",
      mn: "",
      layers: [
        {
          ty: 3,
          nm: "circle_1_copy_copy-null",
          mn: "",
          sr: 1,
          st: 0,
          op: 271,
          ip: 0,
          hd: !1,
          cl: "",
          ln: "",
          ddd: 0,
          bm: 0,
          hasMask: !1,
          ao: 0,
          ks: {
            a: {
              a: 1,
              k: [
                {
                  o: { x: 0, y: 0 },
                  i: { x: 1, y: 1 },
                  s: [0.005, 0.005, 0],
                  t: 0,
                },
                {
                  o: { x: 0.215, y: 0.61 },
                  i: { x: 0.355, y: 1 },
                  s: [0.005, 0.005, 0],
                  t: 69.6,
                },
                {
                  o: { x: 0, y: 0 },
                  i: { x: 1, y: 1 },
                  s: [50, 50, 0],
                  t: 129.60000000000002,
                },
                {
                  o: { x: 0, y: 0 },
                  i: { x: 1, y: 1 },
                  s: [50, 50, 0],
                  t: 148.5,
                },
                {
                  o: { x: 0.215, y: 0.61 },
                  i: { x: 0.355, y: 1 },
                  s: [0.005, 0.005, 0],
                  t: 148.8,
                },
                {
                  o: { x: 0.42, y: 0 },
                  i: { x: 0.58, y: 1 },
                  s: [50, 50, 0],
                  t: 208.8,
                },
                {
                  o: { x: 0, y: 0 },
                  i: { x: 1, y: 1 },
                  s: [50, 50, 0],
                  t: 270,
                },
              ],
            },
            s: { a: 0, k: [100, 100] },
            sk: { a: 0, k: 0 },
            p: { s: !0, x: { a: 0, k: 50 }, y: { a: 0, k: 50 } },
            r: { a: 0, k: 0 },
            sa: { a: 0, k: 0 },
            o: { a: 0, k: 100 },
          },
          ef: [],
          ind: 1,
        },
        {
          ty: 4,
          nm: "circle_1_copy_copy-content",
          mn: "",
          sr: 1,
          st: 0,
          op: 271,
          ip: 0,
          hd: !1,
          cl: "",
          ln: "",
          ddd: 0,
          bm: 0,
          hasMask: !1,
          ao: 0,
          ks: {
            a: { a: 0, k: [0, 0] },
            s: { a: 0, k: [100, 100] },
            sk: { a: 0, k: 0 },
            p: { a: 0, k: [0, 0] },
            r: { a: 0, k: 0 },
            sa: { a: 0, k: 0 },
            o: { a: 0, k: 100 },
          },
          ef: [],
          shapes: [
            {
              ty: "gr",
              bm: 0,
              cl: "",
              ln: "",
              hd: !1,
              mn: "",
              nm: "circle_1_copy_copy-content",
              cix: 2,
              np: 3,
              it: [
                {
                  ty: "sh",
                  bm: 0,
                  cl: "",
                  ln: "",
                  hd: !1,
                  mn: "",
                  nm: "circle_1_copy_copy-path",
                  d: 1,
                  ks: {
                    a: 1,
                    k: [
                      {
                        o: { x: 0, y: 0 },
                        i: { x: 1, y: 1 },
                        s: [
                          {
                            c: !0,
                            i: [
                              [-0.00275, 0],
                              [0, 0.0027500000000000007],
                              [0.0027500000000000007, 0],
                              [0, -0.00275],
                            ],
                            o: [
                              [0.0027500000000000007, 0],
                              [0, -0.00275],
                              [-0.00275, 0],
                              [0, 0.0027500000000000007],
                            ],
                            v: [
                              [0.005, 0.01],
                              [0.01, 0.005],
                              [0.005, 0],
                              [0, 0.005],
                            ],
                          },
                        ],
                        t: 0,
                      },
                      {
                        o: { x: 0.215, y: 0.61 },
                        i: { x: 0.355, y: 1 },
                        s: [
                          {
                            c: !0,
                            i: [
                              [-0.00275, 0],
                              [0, 0.0027500000000000007],
                              [0.0027500000000000007, 0],
                              [0, -0.00275],
                            ],
                            o: [
                              [0.0027500000000000007, 0],
                              [0, -0.00275],
                              [-0.00275, 0],
                              [0, 0.0027500000000000007],
                            ],
                            v: [
                              [0.005, 0.01],
                              [0.01, 0.005],
                              [0.005, 0],
                              [0, 0.005],
                            ],
                          },
                        ],
                        t: 69.6,
                      },
                      {
                        o: { x: 0, y: 0 },
                        i: { x: 1, y: 1 },
                        s: [
                          {
                            c: !0,
                            i: [
                              [-27.5, 0],
                              [0, 27.5],
                              [27.5, 0],
                              [0, -27.5],
                            ],
                            o: [
                              [27.5, 0],
                              [0, -27.5],
                              [-27.5, 0],
                              [0, 27.5],
                            ],
                            v: [
                              [50, 100],
                              [100, 50],
                              [50, 0],
                              [0, 50],
                            ],
                          },
                        ],
                        t: 129.60000000000002,
                      },
                      {
                        o: { x: 0, y: 0 },
                        i: { x: 1, y: 1 },
                        s: [
                          {
                            c: !0,
                            i: [
                              [-27.5, 0],
                              [0, 27.5],
                              [27.5, 0],
                              [0, -27.5],
                            ],
                            o: [
                              [27.5, 0],
                              [0, -27.5],
                              [-27.5, 0],
                              [0, 27.5],
                            ],
                            v: [
                              [50, 100],
                              [100, 50],
                              [50, 0],
                              [0, 50],
                            ],
                          },
                        ],
                        t: 148.5,
                      },
                      {
                        o: { x: 0.215, y: 0.61 },
                        i: { x: 0.355, y: 1 },
                        s: [
                          {
                            c: !0,
                            i: [
                              [-0.00275, 0],
                              [0, 0.0027500000000000007],
                              [0.0027500000000000007, 0],
                              [0, -0.00275],
                            ],
                            o: [
                              [0.0027500000000000007, 0],
                              [0, -0.00275],
                              [-0.00275, 0],
                              [0, 0.0027500000000000007],
                            ],
                            v: [
                              [0.005, 0.01],
                              [0.01, 0.005],
                              [0.005, 0],
                              [0, 0.005],
                            ],
                          },
                        ],
                        t: 148.8,
                      },
                      {
                        o: { x: 0.42, y: 0 },
                        i: { x: 0.58, y: 1 },
                        s: [
                          {
                            c: !0,
                            i: [
                              [-27.5, 0],
                              [0, 27.5],
                              [27.5, 0],
                              [0, -27.5],
                            ],
                            o: [
                              [27.5, 0],
                              [0, -27.5],
                              [-27.5, 0],
                              [0, 27.5],
                            ],
                            v: [
                              [50, 100],
                              [100, 50],
                              [50, 0],
                              [0, 50],
                            ],
                          },
                        ],
                        t: 208.8,
                      },
                      {
                        o: { x: 0, y: 0 },
                        i: { x: 1, y: 1 },
                        s: [
                          {
                            c: !0,
                            i: [
                              [-27.5, 0],
                              [0, 27.5],
                              [27.5, 0],
                              [0, -27.5],
                            ],
                            o: [
                              [27.5, 0],
                              [0, -27.5],
                              [-27.5, 0],
                              [0, 27.5],
                            ],
                            v: [
                              [50, 100],
                              [100, 50],
                              [50, 0],
                              [0, 50],
                            ],
                          },
                        ],
                        t: 270,
                      },
                    ],
                  },
                },
                {
                  ty: "fl",
                  bm: 0,
                  cl: "",
                  ln: "",
                  hd: !1,
                  mn: "",
                  nm: "Fill 1",
                  c: { a: 0, k: [0.0235, 0.4863, 0.3922] },
                  r: 1,
                  o: { a: 0, k: 100 },
                },
                {
                  ty: "tr",
                  a: { a: 0, k: [0, 0] },
                  s: { a: 0, k: [100, 100] },
                  sk: { a: 0, k: 0 },
                  p: { a: 0, k: [0, 0] },
                  r: { a: 0, k: 0 },
                  sa: { a: 0, k: 0 },
                  o: { a: 0, k: 100 },
                },
              ],
            },
          ],
          ind: 2,
          parent: 1,
        },
      ],
      id: "comp_circle_1_copy_copy_6856E7C8-C47F-4CFC-B65C-915DBA76F176",
    },
    {
      nm: "",
      mn: "",
      layers: [
        {
          ty: 3,
          nm: "circle_1-null",
          mn: "",
          sr: 1,
          st: 0,
          op: 271,
          ip: 0,
          hd: !1,
          cl: "",
          ln: "",
          ddd: 0,
          bm: 0,
          hasMask: !1,
          ao: 0,
          ks: {
            a: {
              a: 1,
              k: [
                {
                  o: { x: 0, y: 0 },
                  i: { x: 1, y: 1 },
                  s: [0.005, 0.005, 0],
                  t: 0,
                },
                {
                  o: { x: 0.215, y: 0.61 },
                  i: { x: 0.355, y: 1 },
                  s: [0.005, 0.005, 0],
                  t: 30,
                },
                { o: { x: 0, y: 0 }, i: { x: 1, y: 1 }, s: [50, 50, 0], t: 90 },
                {
                  o: { x: 0, y: 0 },
                  i: { x: 1, y: 1 },
                  s: [50, 50, 0],
                  t: 108.9,
                },
                {
                  o: { x: 0.215, y: 0.61 },
                  i: { x: 0.355, y: 1 },
                  s: [0.005, 0.005, 0],
                  t: 109.2,
                },
                {
                  o: { x: 0.42, y: 0 },
                  i: { x: 0.58, y: 1 },
                  s: [50, 50, 0],
                  t: 169.2,
                },
                {
                  o: { x: 0, y: 0 },
                  i: { x: 1, y: 1 },
                  s: [50, 50, 0],
                  t: 270,
                },
              ],
            },
            s: { a: 0, k: [100, 100] },
            sk: { a: 0, k: 0 },
            p: { s: !0, x: { a: 0, k: 50 }, y: { a: 0, k: 50 } },
            r: { a: 0, k: 0 },
            sa: { a: 0, k: 0 },
            o: { a: 0, k: 100 },
          },
          ef: [],
          ind: 1,
        },
        {
          ty: 4,
          nm: "circle_1-content",
          mn: "",
          sr: 1,
          st: 0,
          op: 271,
          ip: 0,
          hd: !1,
          cl: "",
          ln: "",
          ddd: 0,
          bm: 0,
          hasMask: !1,
          ao: 0,
          ks: {
            a: { a: 0, k: [0, 0] },
            s: { a: 0, k: [100, 100] },
            sk: { a: 0, k: 0 },
            p: { a: 0, k: [0, 0] },
            r: { a: 0, k: 0 },
            sa: { a: 0, k: 0 },
            o: { a: 0, k: 100 },
          },
          ef: [],
          shapes: [
            {
              ty: "gr",
              bm: 0,
              cl: "",
              ln: "",
              hd: !1,
              mn: "",
              nm: "circle_1-content",
              cix: 2,
              np: 3,
              it: [
                {
                  ty: "sh",
                  bm: 0,
                  cl: "",
                  ln: "",
                  hd: !1,
                  mn: "",
                  nm: "circle_1-path",
                  d: 1,
                  ks: {
                    a: 1,
                    k: [
                      {
                        o: { x: 0, y: 0 },
                        i: { x: 1, y: 1 },
                        s: [
                          {
                            c: !0,
                            i: [
                              [-0.00275, 0],
                              [0, 0.0027500000000000007],
                              [0.0027500000000000007, 0],
                              [0, -0.00275],
                            ],
                            o: [
                              [0.0027500000000000007, 0],
                              [0, -0.00275],
                              [-0.00275, 0],
                              [0, 0.0027500000000000007],
                            ],
                            v: [
                              [0.005, 0.01],
                              [0.01, 0.005],
                              [0.005, 0],
                              [0, 0.005],
                            ],
                          },
                        ],
                        t: 0,
                      },
                      {
                        o: { x: 0.215, y: 0.61 },
                        i: { x: 0.355, y: 1 },
                        s: [
                          {
                            c: !0,
                            i: [
                              [-0.00275, 0],
                              [0, 0.0027500000000000007],
                              [0.0027500000000000007, 0],
                              [0, -0.00275],
                            ],
                            o: [
                              [0.0027500000000000007, 0],
                              [0, -0.00275],
                              [-0.00275, 0],
                              [0, 0.0027500000000000007],
                            ],
                            v: [
                              [0.005, 0.01],
                              [0.01, 0.005],
                              [0.005, 0],
                              [0, 0.005],
                            ],
                          },
                        ],
                        t: 30,
                      },
                      {
                        o: { x: 0, y: 0 },
                        i: { x: 1, y: 1 },
                        s: [
                          {
                            c: !0,
                            i: [
                              [-27.5, 0],
                              [0, 27.5],
                              [27.5, 0],
                              [0, -27.5],
                            ],
                            o: [
                              [27.5, 0],
                              [0, -27.5],
                              [-27.5, 0],
                              [0, 27.5],
                            ],
                            v: [
                              [50, 100],
                              [100, 50],
                              [50, 0],
                              [0, 50],
                            ],
                          },
                        ],
                        t: 90,
                      },
                      {
                        o: { x: 0, y: 0 },
                        i: { x: 1, y: 1 },
                        s: [
                          {
                            c: !0,
                            i: [
                              [-27.5, 0],
                              [0, 27.5],
                              [27.5, 0],
                              [0, -27.5],
                            ],
                            o: [
                              [27.5, 0],
                              [0, -27.5],
                              [-27.5, 0],
                              [0, 27.5],
                            ],
                            v: [
                              [50, 100],
                              [100, 50],
                              [50, 0],
                              [0, 50],
                            ],
                          },
                        ],
                        t: 108.9,
                      },
                      {
                        o: { x: 0.215, y: 0.61 },
                        i: { x: 0.355, y: 1 },
                        s: [
                          {
                            c: !0,
                            i: [
                              [-0.00275, 0],
                              [0, 0.0027500000000000007],
                              [0.0027500000000000007, 0],
                              [0, -0.00275],
                            ],
                            o: [
                              [0.0027500000000000007, 0],
                              [0, -0.00275],
                              [-0.00275, 0],
                              [0, 0.0027500000000000007],
                            ],
                            v: [
                              [0.005, 0.01],
                              [0.01, 0.005],
                              [0.005, 0],
                              [0, 0.005],
                            ],
                          },
                        ],
                        t: 109.2,
                      },
                      {
                        o: { x: 0.42, y: 0 },
                        i: { x: 0.58, y: 1 },
                        s: [
                          {
                            c: !0,
                            i: [
                              [-27.5, 0],
                              [0, 27.5],
                              [27.5, 0],
                              [0, -27.5],
                            ],
                            o: [
                              [27.5, 0],
                              [0, -27.5],
                              [-27.5, 0],
                              [0, 27.5],
                            ],
                            v: [
                              [50, 100],
                              [100, 50],
                              [50, 0],
                              [0, 50],
                            ],
                          },
                        ],
                        t: 169.2,
                      },
                      {
                        o: { x: 0, y: 0 },
                        i: { x: 1, y: 1 },
                        s: [
                          {
                            c: !0,
                            i: [
                              [-27.5, 0],
                              [0, 27.5],
                              [27.5, 0],
                              [0, -27.5],
                            ],
                            o: [
                              [27.5, 0],
                              [0, -27.5],
                              [-27.5, 0],
                              [0, 27.5],
                            ],
                            v: [
                              [50, 100],
                              [100, 50],
                              [50, 0],
                              [0, 50],
                            ],
                          },
                        ],
                        t: 270,
                      },
                    ],
                  },
                },
                {
                  ty: "fl",
                  bm: 0,
                  cl: "",
                  ln: "",
                  hd: !1,
                  mn: "",
                  nm: "Fill 1",
                  c: { a: 0, k: [0.0235, 0.4863, 0.3922] },
                  r: 1,
                  o: { a: 0, k: 100 },
                },
                {
                  ty: "tr",
                  a: { a: 0, k: [0, 0] },
                  s: { a: 0, k: [100, 100] },
                  sk: { a: 0, k: 0 },
                  p: { a: 0, k: [0, 0] },
                  r: { a: 0, k: 0 },
                  sa: { a: 0, k: 0 },
                  o: { a: 0, k: 100 },
                },
              ],
            },
          ],
          ind: 2,
          parent: 1,
        },
      ],
      id: "comp_circle_1_3242EB09-ABE7-42CC-A679-7351963F39E4",
    },
    {
      nm: "",
      mn: "",
      layers: [
        {
          ty: 3,
          nm: "Fill 1-null",
          mn: "",
          sr: 1,
          st: 0,
          op: 271,
          ip: 0,
          hd: !1,
          cl: "",
          ln: "",
          ddd: 0,
          bm: 0,
          hasMask: !1,
          ao: 0,
          ks: {
            a: { a: 0, k: [30, 30, 0] },
            s: { a: 0, k: [100, 100] },
            sk: { a: 0, k: 0 },
            p: { s: !0, x: { a: 0, k: 50 }, y: { a: 0, k: 50 } },
            r: { a: 0, k: 0 },
            sa: { a: 0, k: 0 },
            o: { a: 0, k: 100 },
          },
          ef: [],
          ind: 1,
        },
        {
          ty: 4,
          nm: "Fill 1-size",
          mn: "",
          sr: 1,
          st: 0,
          op: 271,
          ip: 0,
          hd: !1,
          cl: "",
          ln: "",
          ddd: 0,
          bm: 0,
          hasMask: !1,
          ao: 0,
          ks: {
            a: { a: 0, k: [0, 0] },
            s: { a: 0, k: [100, 100] },
            sk: { a: 0, k: 0 },
            p: { a: 0, k: [0, 0] },
            r: { a: 0, k: 0 },
            sa: { a: 0, k: 0 },
            o: { a: 0, k: 100 },
          },
          ef: [],
          shapes: [
            {
              ty: "gr",
              bm: 0,
              cl: "",
              ln: "",
              hd: !1,
              mn: "",
              nm: "Fill 1-size",
              cix: 2,
              np: 3,
              it: [
                {
                  ty: "rc",
                  bm: 0,
                  cl: "",
                  ln: "",
                  hd: !1,
                  mn: "",
                  nm: "sizeElement",
                  d: 1,
                  p: { a: 0, k: [50, 50] },
                  r: { a: 0, k: 0 },
                  s: { a: 0, k: [100, 100] },
                },
                {
                  ty: "fl",
                  bm: 0,
                  cl: "",
                  ln: "",
                  hd: !1,
                  mn: "",
                  nm: "Fill 1",
                  c: { a: 0, k: [0, 0, 0, 0] },
                  r: 1,
                  o: { a: 0, k: 0 },
                },
                {
                  ty: "tr",
                  a: { a: 0, k: [0, 0] },
                  s: { a: 0, k: [100, 100] },
                  sk: { a: 0, k: 0 },
                  p: { a: 0, k: [0, 0] },
                  r: { a: 0, k: 0 },
                  sa: { a: 0, k: 0 },
                  o: { a: 0, k: 100 },
                },
              ],
            },
          ],
          ind: 2,
        },
        {
          ty: 4,
          nm: "Fill 1-stroke",
          mn: "",
          sr: 1,
          st: 0,
          op: 271,
          ip: 0,
          hd: !1,
          cl: "",
          ln: "",
          ddd: 0,
          bm: 0,
          hasMask: !1,
          ao: 0,
          ks: {
            a: { a: 0, k: [0, 0] },
            s: { a: 0, k: [100, 100] },
            sk: { a: 0, k: 0 },
            p: { a: 0, k: [0, 0] },
            r: { a: 0, k: 0 },
            sa: { a: 0, k: 0 },
            o: { a: 0, k: 100 },
          },
          ef: [],
          shapes: [
            {
              ty: "gr",
              bm: 0,
              cl: "",
              ln: "",
              hd: !1,
              mn: "",
              nm: "Fill 1-stroke",
              cix: 2,
              np: 3,
              it: [
                {
                  ty: "sh",
                  bm: 0,
                  cl: "",
                  ln: "",
                  hd: !1,
                  mn: "",
                  nm: "Fill 1-path",
                  d: 1,
                  ks: {
                    a: 0,
                    k: {
                      c: !0,
                      i: [
                        [-16.5685542, 0],
                        [0, -16.5685542],
                        [16.56855420000001, 0],
                        [4.746475199999999, 3.1489902],
                        [0, 0],
                        [0, 0],
                        [0, 6.370218000000001],
                      ],
                      o: [
                        [16.5685542, 0],
                        [0, 16.5685542],
                        [-6.122851799999996, 0],
                        [0, 0],
                        [0, 0],
                        [-3.3858414000000003, -4.857683399999999],
                        [0, -16.5685542],
                      ],
                      v: [
                        [30, 0],
                        [60, 30],
                        [30.8910894, 60],
                        [14.257425600000001, 55.8415842],
                        [1.1881188, 58.8118812],
                        [4.7524752, 46.3366338],
                        [0, 30],
                      ],
                    },
                  },
                },
                {
                  ty: "st",
                  bm: 0,
                  cl: "",
                  ln: "",
                  hd: !1,
                  mn: "",
                  nm: "Stroke 1",
                  lc: 1,
                  lj: 1,
                  ml: 10,
                  o: {
                    a: 1,
                    k: [
                      { o: { x: 0, y: 0 }, i: { x: 1, y: 1 }, s: [100], t: 0 },
                      {
                        o: { x: 0.42, y: 0 },
                        i: { x: 0.58, y: 1 },
                        s: [100],
                        t: 30,
                      },
                      {
                        o: { x: 0.42, y: 0 },
                        i: { x: 0.58, y: 1 },
                        s: [100],
                        t: 47.400000000000006,
                      },
                      {
                        o: { x: 0, y: 0 },
                        i: { x: 1, y: 1 },
                        s: [100],
                        t: 270,
                      },
                    ],
                  },
                  w: { a: 0, k: 6 },
                  d: [{ nm: "offset", mn: "", n: "o", v: { a: 0, k: 0 } }],
                  c: {
                    a: 1,
                    k: [
                      {
                        o: { x: 0, y: 0 },
                        i: { x: 1, y: 1 },
                        s: [0.0235, 0.4863, 0.3922],
                        t: 0,
                      },
                      {
                        o: { x: 0.42, y: 0 },
                        i: { x: 0.58, y: 1 },
                        s: [0.0235, 0.4863, 0.3922],
                        t: 30,
                      },
                      {
                        o: { x: 0.42, y: 0 },
                        i: { x: 0.58, y: 1 },
                        s: [1, 1, 1],
                        t: 47.400000000000006,
                      },
                      {
                        o: { x: 0, y: 0 },
                        i: { x: 1, y: 1 },
                        s: [1, 1, 1],
                        t: 270,
                      },
                    ],
                  },
                },
                {
                  ty: "tm",
                  bm: 0,
                  cl: "",
                  ln: "",
                  hd: !1,
                  mn: "",
                  nm: "Trim Paths 1",
                  e: {
                    a: 1,
                    k: [
                      {
                        o: { x: 0.645, y: 0.045 },
                        i: { x: 0.355, y: 1 },
                        s: [62],
                        t: 0,
                      },
                      {
                        o: { x: 0.42, y: 0 },
                        i: { x: 0.58, y: 1 },
                        s: [100],
                        t: 30,
                      },
                      {
                        o: { x: 0, y: 0 },
                        i: { x: 1, y: 1 },
                        s: [100],
                        t: 270,
                      },
                    ],
                  },
                  o: { a: 0, k: 0 },
                  s: {
                    a: 1,
                    k: [
                      {
                        o: { x: 0.645, y: 0.045 },
                        i: { x: 0.355, y: 1 },
                        s: [62],
                        t: 0,
                      },
                      {
                        o: { x: 0.42, y: 0 },
                        i: { x: 0.58, y: 1 },
                        s: [0],
                        t: 30,
                      },
                      { o: { x: 0, y: 0 }, i: { x: 1, y: 1 }, s: [0], t: 270 },
                    ],
                  },
                  m: 2,
                },
                {
                  ty: "tr",
                  a: { a: 0, k: [0, 0] },
                  s: { a: 0, k: [100, 100] },
                  sk: { a: 0, k: 0 },
                  p: { a: 0, k: [0, 0] },
                  r: { a: 0, k: 0 },
                  sa: { a: 0, k: 0 },
                  o: { a: 0, k: 100 },
                },
              ],
            },
          ],
          ind: 3,
          parent: 1,
        },
        {
          ty: 4,
          nm: "Fill 1-content",
          mn: "",
          sr: 1,
          st: 0,
          op: 271,
          ip: 0,
          hd: !1,
          cl: "",
          ln: "",
          ddd: 0,
          bm: 0,
          hasMask: !1,
          ao: 0,
          ks: {
            a: { a: 0, k: [0, 0] },
            s: { a: 0, k: [100, 100] },
            sk: { a: 0, k: 0 },
            p: { a: 0, k: [0, 0] },
            r: { a: 0, k: 0 },
            sa: { a: 0, k: 0 },
            o: { a: 0, k: 100 },
          },
          ef: [],
          shapes: [
            {
              ty: "gr",
              bm: 0,
              cl: "",
              ln: "",
              hd: !1,
              mn: "",
              nm: "Fill 1-content",
              cix: 2,
              np: 3,
              it: [
                {
                  ty: "sh",
                  bm: 0,
                  cl: "",
                  ln: "",
                  hd: !1,
                  mn: "",
                  nm: "Fill 1-path",
                  d: 1,
                  ks: {
                    a: 0,
                    k: {
                      c: !0,
                      i: [
                        [-16.5685542, 0],
                        [0, -16.5685542],
                        [16.56855420000001, 0],
                        [4.746475199999999, 3.1489902],
                        [0, 0],
                        [0, 0],
                        [0, 6.370218000000001],
                      ],
                      o: [
                        [16.5685542, 0],
                        [0, 16.5685542],
                        [-6.122851799999996, 0],
                        [0, 0],
                        [0, 0],
                        [-3.3858414000000003, -4.857683399999999],
                        [0, -16.5685542],
                      ],
                      v: [
                        [30, 0],
                        [60, 30],
                        [30.8910894, 60],
                        [14.257425600000001, 55.8415842],
                        [1.1881188, 58.8118812],
                        [4.7524752, 46.3366338],
                        [0, 30],
                      ],
                    },
                  },
                },
                {
                  ty: "fl",
                  bm: 0,
                  cl: "",
                  ln: "",
                  hd: !1,
                  mn: "",
                  nm: "Fill 1",
                  c: {
                    a: 1,
                    k: [
                      {
                        o: { x: 0, y: 0 },
                        i: { x: 1, y: 1 },
                        s: [0, 0, 0],
                        t: 0,
                      },
                      {
                        o: { x: 0, y: 0 },
                        i: { x: 1, y: 1 },
                        s: [0, 0, 0],
                        t: 30,
                      },
                      {
                        o: { x: 0, y: 0 },
                        i: { x: 1, y: 1 },
                        s: [0, 0, 0],
                        t: 47.1,
                      },
                      {
                        o: { x: 0.42, y: 0 },
                        i: { x: 0.58, y: 1 },
                        s: [0.0235, 0.4863, 0.3922],
                        t: 47.400000000000006,
                      },
                      {
                        o: { x: 0, y: 0 },
                        i: { x: 1, y: 1 },
                        s: [0.0235, 0.4863, 0.3922],
                        t: 270,
                      },
                    ],
                  },
                  r: 1,
                  o: {
                    a: 1,
                    k: [
                      { o: { x: 0, y: 0 }, i: { x: 1, y: 1 }, s: [0], t: 0 },
                      { o: { x: 0, y: 0 }, i: { x: 1, y: 1 }, s: [0], t: 30 },
                      { o: { x: 0, y: 0 }, i: { x: 1, y: 1 }, s: [0], t: 47.1 },
                      {
                        o: { x: 0.42, y: 0 },
                        i: { x: 0.58, y: 1 },
                        s: [100],
                        t: 47.400000000000006,
                      },
                      {
                        o: { x: 0, y: 0 },
                        i: { x: 1, y: 1 },
                        s: [100],
                        t: 270,
                      },
                    ],
                  },
                },
                {
                  ty: "tr",
                  a: { a: 0, k: [0, 0] },
                  s: { a: 0, k: [100, 100] },
                  sk: { a: 0, k: 0 },
                  p: { a: 0, k: [0, 0] },
                  r: { a: 0, k: 0 },
                  sa: { a: 0, k: 0 },
                  o: { a: 0, k: 100 },
                },
              ],
            },
          ],
          ind: 4,
          parent: 1,
        },
      ],
      id: "comp_Fill 1_BA8ED0D5-D328-49CA-A278-C5A2B56A4A59",
    },
    {
      nm: "",
      mn: "",
      layers: [
        {
          ty: 3,
          nm: "phone-null",
          mn: "",
          sr: 1,
          st: 0,
          op: 271,
          ip: 0,
          hd: !1,
          cl: "",
          ln: "",
          ddd: 0,
          bm: 0,
          hasMask: !1,
          ao: 0,
          ks: {
            a: { a: 0, k: [16.5, 15.3, 0] },
            s: { a: 0, k: [100, 100] },
            sk: { a: 0, k: 0 },
            p: {
              s: !0,
              x: {
                a: 1,
                k: [
                  { o: { x: 0.42, y: 0 }, i: { x: 0.58, y: 1 }, s: [48], t: 0 },
                  {
                    o: { x: 0.42, y: 0 },
                    i: { x: 0.58, y: 1 },
                    s: [50],
                    t: 69.6,
                  },
                  {
                    o: { x: 0.42, y: 0 },
                    i: { x: 0.58, y: 1 },
                    s: [48],
                    t: 240,
                  },
                  { o: { x: 0, y: 0 }, i: { x: 1, y: 1 }, s: [48], t: 270 },
                ],
              },
              y: { a: 0, k: 50 },
            },
            r: {
              a: 1,
              k: [
                { o: { x: 0, y: 0 }, i: { x: 1, y: 1 }, s: [0], t: 0 },
                {
                  o: { x: 0.455, y: 0.03 },
                  i: { x: 0.515, y: 0.955 },
                  s: [0],
                  t: 50.699999999999996,
                },
                {
                  o: { x: 0.455, y: 0.03 },
                  i: { x: 0.515, y: 0.955 },
                  s: [14.999999999999998],
                  t: 58.199999999999996,
                },
                {
                  o: { x: 0.455, y: 0.03 },
                  i: { x: 0.515, y: 0.955 },
                  s: [-14.999999999999998],
                  t: 65.7,
                },
                { o: { x: 0, y: 0 }, i: { x: 1, y: 1 }, s: [0], t: 73.2 },
                { o: { x: 0, y: 0 }, i: { x: 1, y: 1 }, s: [0], t: 89.7 },
                {
                  o: { x: 0.455, y: 0.03 },
                  i: { x: 0.515, y: 0.955 },
                  s: [0],
                  t: 90,
                },
                {
                  o: { x: 0.455, y: 0.03 },
                  i: { x: 0.515, y: 0.955 },
                  s: [14.999999999999998],
                  t: 97.5,
                },
                {
                  o: { x: 0.455, y: 0.03 },
                  i: { x: 0.515, y: 0.955 },
                  s: [-14.999999999999998],
                  t: 105,
                },
                { o: { x: 0, y: 0 }, i: { x: 1, y: 1 }, s: [0], t: 112.5 },
                { o: { x: 0, y: 0 }, i: { x: 1, y: 1 }, s: [0], t: 129.3 },
                {
                  o: { x: 0.455, y: 0.03 },
                  i: { x: 0.515, y: 0.955 },
                  s: [0],
                  t: 129.60000000000002,
                },
                {
                  o: { x: 0.455, y: 0.03 },
                  i: { x: 0.515, y: 0.955 },
                  s: [14.999999999999998],
                  t: 137.10000000000002,
                },
                {
                  o: { x: 0.455, y: 0.03 },
                  i: { x: 0.515, y: 0.955 },
                  s: [-14.999999999999998],
                  t: 144.60000000000002,
                },
                {
                  o: { x: 0, y: 0 },
                  i: { x: 1, y: 1 },
                  s: [0],
                  t: 152.10000000000002,
                },
                { o: { x: 0, y: 0 }, i: { x: 1, y: 1 }, s: [0], t: 168.9 },
                {
                  o: { x: 0.455, y: 0.03 },
                  i: { x: 0.515, y: 0.955 },
                  s: [0],
                  t: 169.2,
                },
                {
                  o: { x: 0.455, y: 0.03 },
                  i: { x: 0.515, y: 0.955 },
                  s: [14.999999999999998],
                  t: 176.7,
                },
                {
                  o: { x: 0.455, y: 0.03 },
                  i: { x: 0.515, y: 0.955 },
                  s: [-14.999999999999998],
                  t: 184.20000000000002,
                },
                {
                  o: { x: 0.42, y: 0 },
                  i: { x: 0.58, y: 1 },
                  s: [0],
                  t: 191.70000000000002,
                },
                { o: { x: 0, y: 0 }, i: { x: 1, y: 1 }, s: [0], t: 270 },
              ],
            },
            sa: { a: 0, k: 0 },
            o: { a: 0, k: 100 },
          },
          ef: [],
          ind: 1,
        },
        {
          ty: 4,
          nm: "phone-content",
          mn: "",
          sr: 1,
          st: 0,
          op: 271,
          ip: 0,
          hd: !1,
          cl: "",
          ln: "",
          ddd: 0,
          bm: 0,
          hasMask: !1,
          ao: 0,
          ks: {
            a: { a: 0, k: [0, 0] },
            s: { a: 0, k: [100, 100] },
            sk: { a: 0, k: 0 },
            p: { a: 0, k: [0, 0] },
            r: { a: 0, k: 0 },
            sa: { a: 0, k: 0 },
            o: { a: 0, k: 100 },
          },
          ef: [],
          shapes: [
            {
              ty: "gr",
              bm: 0,
              cl: "",
              ln: "",
              hd: !1,
              mn: "",
              nm: "phone-content",
              cix: 2,
              np: 3,
              it: [
                {
                  ty: "sh",
                  bm: 0,
                  cl: "",
                  ln: "",
                  hd: !1,
                  mn: "",
                  nm: "phone-path",
                  d: 1,
                  ks: {
                    a: 0,
                    k: {
                      c: !1,
                      i: [
                        [0, 0],
                        [-1.218327, -2.4361247519999996],
                        [-1.0514928599999998, -1.6049764260000003],
                        [0, 0],
                        [-2.56616976, -2.5882450020000007],
                        [-4.361829780000001, -1.5851347740000001],
                        [-3.3454598100000013, 2.4890361299999952],
                        [-0.20415186000000318, 2.1186567899999993],
                        [0.05487965999999744, 0.35274211199999783],
                        [1.5212620500000007, 0.7694186400000014],
                        [1.0010035200000011, -1.0604307599999991],
                        [0, 0],
                        [0.7507526400000017, 0.30864934799999943],
                        [2.1227424900000003, 2.5331288940000043],
                        [0.6827023500000013, 1.0185427259999997],
                        [-1.317110190000001, 1.294122348000002],
                        [0, 1.038384378],
                        [0.16683414000000063, 0.36596987999999975],
                        [0.16683414000000063, 0.4100626439999999],
                        [0, 0],
                        [1.6485826500000007, 0.12786883200000002],
                        [1.5388236599999998, -2.0635409879999997],
                        [0, -1.9202396579999998],
                      ],
                      o: [
                        [0, 2.6169049620000004],
                        [0.9658806300000002, 1.931262696000001],
                        [0, 0],
                        [2.2983572699999995, 2.7976854779999982],
                        [3.323507880000001, 3.3488447220000026],
                        [3.6549809999999994, 1.3249873440000037],
                        [1.584922350000003, -1.1794809780000044],
                        [0.05926997999999628, -0.6239125799999954],
                        [-0.16683380999999997, -1.0648399140000038],
                        [-1.7495613300000024, -0.8862644339999974],
                        [0, 0],
                        [-0.44342726999999726, 0.5401362059999997],
                        [-3.1061850600000014, -1.2853037339999993],
                        [-0.7836806999999997, -0.9347663519999969],
                        [-0.9307577399999989, -1.3955356440000006],
                        [0.6234320400000009, -0.6128895419999996],
                        [0, -0.4960434420000004],
                        [-0.1712241299999988, -0.3725837640000007],
                        [0, 0],
                        [-1.04710254, -2.612495808],
                        [-1.98664125, -0.156529404],
                        [-0.8363648699999999, 1.1243651760000004],
                        [0, 0],
                      ],
                      v: [
                        [0, 6.959116872],
                        [1.31711019, 12.984392124000001],
                        [3.56936844, 16.599998160000002],
                        [4.79428092, 18.308592306],
                        [8.96293464, 22.940536644],
                        [20.02665984, 29.461855338000003],
                        [30.31329048, 28.877626062000004],
                        [32.914582800000005, 24.43307643],
                        [32.9782431, 23.068405476000002],
                        [29.79961743, 20.969590338],
                        [24.052626840000002, 19.212493968],
                        [21.473286119999997, 22.497404274],
                        [19.8159225, 22.92730857],
                        [11.31178125, 17.056357992],
                        [9.24830841, 14.278514472000001],
                        [9.25489422, 11.25816075],
                        [11.120800019999999, 8.134188696],
                        [10.68615372, 6.956912142000001],
                        [10.22516517, 5.801681970000001],
                        [8.75878245, 2.278670616],
                        [6.0082176, 0.043168032],
                        [1.77590358, 2.128755402],
                        [0, 6.959116872],
                      ],
                    },
                  },
                },
                {
                  ty: "fl",
                  bm: 0,
                  cl: "",
                  ln: "",
                  hd: !1,
                  mn: "",
                  nm: "Fill 1",
                  c: { a: 0, k: [1, 1, 1] },
                  r: 1,
                  o: { a: 0, k: 100 },
                },
                {
                  ty: "tr",
                  a: { a: 0, k: [0, 0] },
                  s: { a: 0, k: [100, 100] },
                  sk: { a: 0, k: 0 },
                  p: { a: 0, k: [0, 0] },
                  r: { a: 0, k: 0 },
                  sa: { a: 0, k: 0 },
                  o: { a: 0, k: 100 },
                },
              ],
            },
          ],
          ind: 2,
          parent: 1,
        },
      ],
      id: "comp_phone_6ADD6E0F-BD1A-4979-955D-714C9ABAB504",
    },
  ],
  wa = { nm, mn, layers, ddd, h, w, meta, v, fr, op, ip, assets },
  Contact = () => {
    reactExports$1.useRef(null);
    const [s, e] = reactExports$1.useState({
        name: "",
        email: "",
        message: "",
      }),
      [o, a] = reactExports$1.useState(!1),
      { alert: c, showAlert: d, hideAlert: g } = useAlert(),
      _ = (j) => {
        e({ ...s, [j.target.name]: j.target.value });
      },
      b = (j) => {
        j.preventDefault(),
          a(!0),
          emailjs
            .send(
              "service_p4q98ea",
              "template_qlru78a",
              {
                from_name: s.name,
                to_name: "Ibrahim",
                from_email: s.email,
                to_email: "contact@ibrahim2562003@gmail.com",
                message: s.message,
              },
              "R4iRUIv20KlDQiE7u"
            )
            .then(() => {
              a(!1),
                d({
                  show: !0,
                  text: "Message sent succesfully",
                  type: "success",
                }),
                setTimeout(() => {
                  g(), e({ name: "", email: "", message: "" });
                }, [3e3]);
            })
            .catch(($) => {
              a(!1),
                console.log($),
                d({
                  show: !0,
                  text: "I didnt receive your message",
                  type: "danger",
                });
            });
      };
    return jsxRuntimeExports.jsxs("section", {
      className: "section",
      children: [
        c.show && jsxRuntimeExports.jsx(Alert, { ...c }),
        jsxRuntimeExports.jsx("div", {
          className: "back",
          children: jsxRuntimeExports.jsx(TextAnimation, {
            children: jsxRuntimeExports.jsx(Link, {
              to: "/",
              children: jsxRuntimeExports.jsx(motion.div, {
                variants: {
                  hidden: { opacity: 0, y: -100 },
                  show: { opacity: 1, y: 0 },
                },
                transition: { duration: 0.5, ease: "easeOut", delay: 0.2 },
                initial: "hidden",
                animate: "show",
                className: "logocon",
                children: jsxRuntimeExports.jsx("img", {
                  className: "logoemage",
                  src: logo,
                }),
              }),
            }),
          }),
        }),
        jsxRuntimeExports.jsx(TextAnimation, {
          children: jsxRuntimeExports.jsx("h1", {
            className: "headtext two",
            children: "Get in Touch",
          }),
        }),
        jsxRuntimeExports.jsxs("div", {
          className: "secsection",
          children: [
            jsxRuntimeExports.jsx("div", {
              className: " contentcon",
              children: jsxRuntimeExports.jsx(Textasbuttom, {
                children: jsxRuntimeExports.jsxs("div", {
                  className: "ssss",
                  children: [
                    jsxRuntimeExports.jsx(TextAnimation, {
                      children: jsxRuntimeExports.jsx("p", {
                        className: "getintouchusingtext one",
                        children: "Also contact me through E-mail",
                      }),
                    }),
                    jsxRuntimeExports.jsxs("form", {
                      className: "form",
                      onSubmit: b,
                      children: [
                        jsxRuntimeExports.jsxs("label", {
                          className: "label",
                          children: [
                            jsxRuntimeExports.jsx(TextAnimation, {
                              children: jsxRuntimeExports.jsx("p", {
                                children: "Name",
                              }),
                            }),
                            jsxRuntimeExports.jsx(TextAnimation, {
                              children: jsxRuntimeExports.jsx("input", {
                                type: "text",
                                name: "name",
                                className: "input",
                                placeholder: "john",
                                required: !0,
                                value: s.name,
                                onChange: _,
                              }),
                            }),
                          ],
                        }),
                        jsxRuntimeExports.jsxs("label", {
                          className: "label",
                          children: [
                            jsxRuntimeExports.jsx(TextAnimation, {
                              children: jsxRuntimeExports.jsx("p", {
                                children: "Email",
                              }),
                            }),
                            jsxRuntimeExports.jsx(TextAnimation, {
                              children: jsxRuntimeExports.jsx("input", {
                                type: "email",
                                name: "email",
                                className: "input",
                                placeholder: "john@gmail.com",
                                required: !0,
                                value: s.email,
                                onChange: _,
                              }),
                            }),
                          ],
                        }),
                        jsxRuntimeExports.jsxs("label", {
                          className: "label",
                          children: [
                            jsxRuntimeExports.jsx(TextAnimation, {
                              children: jsxRuntimeExports.jsx("p", {
                                children: "Your Message",
                              }),
                            }),
                            jsxRuntimeExports.jsx(TextAnimation, {
                              children: jsxRuntimeExports.jsx("textarea", {
                                name: "message",
                                rows: 4,
                                className: "textarea",
                                placeholder: "Let me know how i can help you",
                                required: !0,
                                value: s.message,
                                onChange: _,
                              }),
                            }),
                          ],
                        }),
                        jsxRuntimeExports.jsx(TextAnimation, {
                          children: jsxRuntimeExports.jsxs("button", {
                            type: "submit",
                            className: "contactbutton oooo OO",
                            disabled: o,
                            children: [
                              jsxRuntimeExports.jsx("span", {}),
                              jsxRuntimeExports.jsx("span", {}),
                              jsxRuntimeExports.jsx("span", {}),
                              jsxRuntimeExports.jsx("span", {}),
                              jsxRuntimeExports.jsx(TextAnimation, {
                                children: jsxRuntimeExports.jsx("p", {
                                  className: "two",
                                  children: o ? "Sending..." : "Send",
                                }),
                              }),
                            ],
                          }),
                        }),
                      ],
                    }),
                  ],
                }),
              }),
            }),
            jsxRuntimeExports.jsx("div", {
              className: "oterside",
              children: jsxRuntimeExports.jsxs("div", {
                className: "getintouch",
                children: [
                  jsxRuntimeExports.jsx(TextAnimation, {
                    children: jsxRuntimeExports.jsx("p", {
                      className: "getintouchusingtext one",
                      children: "Get in touch using",
                    }),
                  }),
                  jsxRuntimeExports.jsxs("div", {
                    className: "contactcon",
                    children: [
                      jsxRuntimeExports.jsxs("div", {
                        className: "contact",
                        children: [
                          jsxRuntimeExports.jsx(TextAnimation, {
                            children: jsxRuntimeExports.jsx("div", {
                              style: { height: "3rem", width: "3rem" },
                              children: jsxRuntimeExports.jsx(Lottie, {
                                animationData: wa,
                              }),
                            }),
                          }),
                          jsxRuntimeExports.jsx(TextAnimation, {
                            children: jsxRuntimeExports.jsx("p", {
                              className: "one",
                              children: "09091086733",
                            }),
                          }),
                        ],
                      }),
                      jsxRuntimeExports.jsxs("div", {
                        className: "contact",
                        children: [
                          jsxRuntimeExports.jsx(TextAnimation, {
                            children: jsxRuntimeExports.jsx(
                              MdOutlineAlternateEmail,
                              { size: "3rem" }
                            ),
                          }),
                          jsxRuntimeExports.jsx(TextAnimation, {
                            children: jsxRuntimeExports.jsx("p", {
                              className: "one",
                              children: "hemoabolarin@gmail.com",
                            }),
                          }),
                        ],
                      }),
                    ],
                  }),
                ],
              }),
            }),
          ],
        }),
      ],
    });
  },
  Intropage = () =>
    jsxRuntimeExports.jsxs("div", {
      className: "intro",
      children: [
        jsxRuntimeExports.jsx("p", { className: "p", children: "Welcome to" }),
        jsxRuntimeExports.jsxs("div", {
          className: "introtextcon",
          children: [
            jsxRuntimeExports.jsx(Textasbuttom, {
              delay: 1.5,
              children: jsxRuntimeExports.jsx(TextAnimation, {
                children: jsxRuntimeExports.jsx("img", {
                  className: "intreologo",
                  src: logo,
                }),
              }),
            }),
            jsxRuntimeExports.jsx("p", {
              children: jsxRuntimeExports.jsx(Textasbuttom, {
                delay: 1.4,
                children: jsxRuntimeExports.jsx(TextAnimation, {
                  children: "I",
                }),
              }),
            }),
            jsxRuntimeExports.jsx("p", {
              children: jsxRuntimeExports.jsx(Textasbuttom, {
                delay: 1.3,
                children: jsxRuntimeExports.jsx(TextAnimation, {
                  children: "B",
                }),
              }),
            }),
            jsxRuntimeExports.jsx("p", {
              children: jsxRuntimeExports.jsx(Textasbuttom, {
                delay: 1.2,
                children: jsxRuntimeExports.jsx(TextAnimation, {
                  children: "R",
                }),
              }),
            }),
            jsxRuntimeExports.jsx("p", {
              children: jsxRuntimeExports.jsx(Textasbuttom, {
                delay: 1.1,
                children: jsxRuntimeExports.jsx(TextAnimation, {
                  children: "A",
                }),
              }),
            }),
            jsxRuntimeExports.jsx("p", {
              children: jsxRuntimeExports.jsx(Textasbuttom, {
                delay: 1,
                children: jsxRuntimeExports.jsx(TextAnimation, {
                  children: "H",
                }),
              }),
            }),
            jsxRuntimeExports.jsx("p", {
              children: jsxRuntimeExports.jsx(Textasbuttom, {
                delay: 0.9,
                children: jsxRuntimeExports.jsx(TextAnimation, {
                  children: "I",
                }),
              }),
            }),
            jsxRuntimeExports.jsx("p", {
              children: jsxRuntimeExports.jsx(Textasbuttom, {
                delay: 0.8,
                children: jsxRuntimeExports.jsx(TextAnimation, {
                  children: "M",
                }),
              }),
            }),
            jsxRuntimeExports.jsx("p", {
              children: jsxRuntimeExports.jsx(Textasbuttom, {
                delay: 0.7,
                children: jsxRuntimeExports.jsx(TextAnimation, {
                  children: "-",
                }),
              }),
            }),
            jsxRuntimeExports.jsx("p", {
              children: jsxRuntimeExports.jsx(Textasbuttom, {
                delay: 0.6,
                children: jsxRuntimeExports.jsx(TextAnimation, {
                  children: "P",
                }),
              }),
            }),
            jsxRuntimeExports.jsx("p", {
              children: jsxRuntimeExports.jsx(Textasbuttom, {
                delay: 0.5,
                children: jsxRuntimeExports.jsx(TextAnimation, {
                  children: "O",
                }),
              }),
            }),
            jsxRuntimeExports.jsx("p", {
              children: jsxRuntimeExports.jsx(Textasbuttom, {
                delay: 0.4,
                children: jsxRuntimeExports.jsx(TextAnimation, {
                  children: "R",
                }),
              }),
            }),
            jsxRuntimeExports.jsx("p", {
              children: jsxRuntimeExports.jsx(Textasbuttom, {
                delay: 0.3,
                children: jsxRuntimeExports.jsx(TextAnimation, {
                  children: "T",
                }),
              }),
            }),
          ],
        }),
      ],
    });
function App() {
  const [s, e] = reactExports$1.useState(!0),
    [o, a] = reactExports$1.useState({ x: 0, y: 0 });
  reactExports$1.useEffect(() => {
    const d = (g) => {
      a({ x: g.clientX + 1, y: g.clientY + 1 });
    };
    return (
      window.addEventListener("mousemove", d),
      () => {
        window.removeEventListener("mousemove", d);
      }
    );
  }, []);
  const c = { default: { x: o.x, y: o.y } };
  return (
    reactExports$1.useEffect(() => {
      e(!0),
        setTimeout(() => {
          e(!1);
        }, 4e3);
    }, []),
    jsxRuntimeExports.jsxs("div", {
      style: {
        backgroundColor: "#000",
        height: "100vh",
        color: "white",
        display: "flex",
        justifyContent: "center",
      },
      children: [
        jsxRuntimeExports.jsx(motion.div, {
          className: "cusor",
          variants: c,
          animate: "default",
        }),
        jsxRuntimeExports.jsx(HashRouter, {
          children: s
            ? jsxRuntimeExports.jsx(Intropage, {})
            : jsxRuntimeExports.jsxs(Routes, {
                children: [
                  jsxRuntimeExports.jsx(Route, {
                    path: "/",
                    element: jsxRuntimeExports.jsx(Home, {}),
                  }),
                  jsxRuntimeExports.jsx(Route, {
                    path: "/contact",
                    element: jsxRuntimeExports.jsx(Contact, {}),
                  }),
                ],
              }),
        }),
      ],
    })
  );
}
client.createRoot(document.getElementById("root")).render(
  jsxRuntimeExports.jsx(React.StrictMode, {
    children: jsxRuntimeExports.jsx(App, {}),
  })
);
